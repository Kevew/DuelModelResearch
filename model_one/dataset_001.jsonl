{"declaration": "example (a b: Nat) (h1: a + b = a): a + b = a := by\n  exact h1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/test.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh1 : a + b = a\n\u22a2 a + b = a"}, {"line": "  exact h1", "tactic_state": ""}]}
{"declaration": "theorem not_irrational_rpow :\n   \u00ac \u2200 a b : \u211d, Irrational a \u2192 Irrational b \u2192 0 < a \u2192 Irrational (a ^ b) := by\n  push_neg\n  by_cases hc : Irrational (\u221a2 ^ \u221a2)\n  \u00b7 use (\u221a2 ^ \u221a2), \u221a2, hc, irrational_sqrt_two, by positivity\n    rw [\u2190 rpow_mul, mul_self_sqrt, rpow_two, sq_sqrt] <;> norm_num\n  \u00b7 use \u221a2, \u221a2, irrational_sqrt_two, irrational_sqrt_two, by positivity, hc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/IrrationalPowerOfIrrational.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00ac\u2200 (a b : \u211d), Irrational a \u2192 Irrational b \u2192 0 < a \u2192 Irrational (a ^ b)"}, {"line": "  push_neg", "tactic_state": "\u22a2 \u2203 a b, Irrational a \u2227 Irrational b \u2227 0 < a \u2227 \u00acIrrational (a ^ b)"}, {"line": "  by_cases hc : Irrational (\u221a2 ^ \u221a2)", "tactic_state": "case pos\nhc : Irrational (\u221a2 ^ \u221a2)\n\u22a2 \u2203 a b, Irrational a \u2227 Irrational b \u2227 0 < a \u2227 \u00acIrrational (a ^ b)\n---\ncase neg\nhc : \u00acIrrational (\u221a2 ^ \u221a2)\n\u22a2 \u2203 a b, Irrational a \u2227 Irrational b \u2227 0 < a \u2227 \u00acIrrational (a ^ b)"}, {"line": "  \u00b7 use (\u221a2 ^ \u221a2), \u221a2, hc, irrational_sqrt_two, by positivity", "tactic_state": "case right\nhc : Irrational (\u221a2 ^ \u221a2)\n\u22a2 \u00acIrrational ((\u221a2 ^ \u221a2) ^ \u221a2)"}, {"line": "    rw [\u2190 rpow_mul, mul_self_sqrt, rpow_two, sq_sqrt] <;> norm_num", "tactic_state": ""}, {"line": "  \u00b7 use \u221a2, \u221a2, irrational_sqrt_two, irrational_sqrt_two, by positivity, hc", "tactic_state": ""}]}
{"declaration": "theorem euclid (n : \u2115) : \u2203 N, n < N \u2227 N.Prime := by\n  let N := n.factorial + 1\n  let p := minFac N\n  use p\n  have prime : p.Prime := by\n    apply minFac_prime\n    observe : n.factorial > 0\n    omega\n  constructor\n  \u00b7 by_contra!\n    observe : p \u2223 n.factorial\n    observe : p \u2223 N\n    observe : p \u2223 1\n    observe : \u00ac p \u2223 1\n    contradiction\n  \u00b7 exact prime", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/observe.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2203 N, n < N \u2227 Nat.Prime N"}, {"line": "  let N := n.factorial + 1", "tactic_state": "n : \u2115\nN : \u2115 := n ! + 1\n\u22a2 \u2203 N, n < N \u2227 Nat.Prime N"}, {"line": "  let p := minFac N", "tactic_state": "n : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\n\u22a2 \u2203 N, n < N \u2227 Nat.Prime N"}, {"line": "  use p", "tactic_state": "case h\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\n\u22a2 n < p \u2227 Nat.Prime p"}, {"line": "  have prime : p.Prime := by", "tactic_state": "case h\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\n\u22a2 n < p \u2227 Nat.Prime p"}, {"line": "    apply minFac_prime", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\n\u22a2 n < p\n---\ncase h.right\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\n\u22a2 Nat.Prime p"}, {"line": "    observe : n.factorial > 0", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis : p \u2264 n\n\u22a2 False"}, {"line": "    omega", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis\u271d : p \u2264 n\nthis : p \u2223 n !\n\u22a2 False"}, {"line": "  constructor", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis\u271d\u00b9 : p \u2264 n\nthis\u271d : p \u2223 n !\nthis : N.minFac \u2223 N\n\u22a2 False"}, {"line": "  \u00b7 by_contra!", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis\u271d\u00b2 : p \u2264 n\nthis\u271d\u00b9 : p \u2223 n !\nthis\u271d : N.minFac \u2223 N\nthis : p \u2223 1\n\u22a2 False"}, {"line": "    observe : p \u2223 n.factorial", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis\u271d\u00b3 : p \u2264 n\nthis\u271d\u00b2 : p \u2223 n !\nthis\u271d\u00b9 : N.minFac \u2223 N\nthis\u271d : p \u2223 1\nthis : \u00acp \u2223 1\n\u22a2 False"}, {"line": "    observe : p \u2223 N", "tactic_state": ""}, {"line": "    observe : p \u2223 1", "tactic_state": ""}]}
{"declaration": "example : \u2203 x : Nat, x = x := by use 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by use 42, rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by use! 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}]}
{"declaration": "example (h : 42 = y) : \u2203 x : Nat, x = y := by use 42, h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh : 42 = y\n\u22a2 \u2203 x, x = y"}]}
{"declaration": "example (h : 42 = y) : \u2203 x : Nat, x = y := by use 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh : 42 = y\n\u22a2 \u2203 x, x = y"}]}
{"declaration": "example (n : Fin 3) : \u2203 x : Nat, x = x := show_term by use n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Fin 3\n\u22a2 \u2203 x, x = x"}]}
{"declaration": "example : \u2203 x : Nat, \u2203 y : Nat, x = y := by use 42, 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x y, x = y"}]}
{"declaration": "example : \u2203 p : Nat \u00d7 Nat, p.1 = p.2 := by use 42; sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = p.2"}]}
{"declaration": "example : \u2203 p : Nat \u00d7 Nat, p.1 = p.2 := by use! 42, 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = p.2"}]}
{"declaration": "example : \u2203 p : Nat \u00d7 Nat, p.1 = p.2 := by use! (42, 42)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = p.2"}]}
{"declaration": "example (r : Nat \u2192 Nat \u2192 Prop) (h : \u2200 x, r x x) :\n    \u2203 p : Nat \u00d7 Nat, r p.1 p.2 := by use! 42; use! 42; apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (x : \u2115), r x x\n\u22a2 \u2203 p, r p.1 p.2"}]}
{"declaration": "example (r : Nat \u2192 Nat \u2192 Prop) (h : \u2200 x, r x x) :\n    \u2203 p : Nat \u00d7 Nat, r p.1 p.2 := by use! 42, 42; apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (x : \u2115), r x x\n\u22a2 \u2203 p, r p.1 p.2"}]}
{"declaration": "example (r : Nat \u2192 Nat \u2192 Prop) (h : \u2200 x, r x x) :\n    \u2203 p : Nat \u00d7 Nat, r p.1 p.2 := by use! 42, 42, h _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (x : \u2115), r x x\n\u22a2 \u2203 p, r p.1 p.2"}]}
{"declaration": "example : \u2203 x : String \u00d7 String, x.1 = x.2 := by use (\"a\", \"a\")\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x.1 = x.2"}]}
{"declaration": "example : \u2203 x : String \u00d7 String, x.1 = x.2 := by use! \"a\", \"a\"\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x.1 = x.2"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by\n  use ?_\n  exact 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "  use ?_", "tactic_state": "case w\n\u22a2 \u2115"}, {"line": "  exact 42", "tactic_state": ""}]}
{"declaration": "example (\u03b1 : Type) : \u2203 S : List \u03b1, S = S := by use \u2205\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\n\u22a2 \u2203 S, S = S"}]}
{"declaration": "example : \u2203 x : Int, x = x := by use 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}]}
{"declaration": "example : \u2203 a b c : Int, a + b + c = 6 := by\n  use 1, 2, 3\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 a b c, a + b + c = 6"}, {"line": "  use 1, 2, 3", "tactic_state": "case h\n\u22a2 1 + 2 + 3 = 6"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : \u2203 p : Int \u00d7 Int, p.1 = 1 := by use \u27e81, 42\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = 1"}]}
{"declaration": "example : \u2203 p : Int \u00d7 Int, p.1 = 1 := by use! 1, 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = 1"}]}
{"declaration": "example : \u2203 n : Int, n * 3 = 3 * 2 := by\n  use 2\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 n, n * 3 = 3 * 2"}, {"line": "  use 2", "tactic_state": "case h\n\u22a2 2 * 3 = 3 * 2"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : \u03a3 _x _y : Int, Int \u00d7 Int \u00d7 Int := by\n  use 1, 2, 3, 4, 5\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (_ : \u2124) \u00d7 (_ : \u2124) \u00d7 \u2124 \u00d7 \u2124 \u00d7 \u2124"}, {"line": "  use 1, 2, 3, 4, 5", "tactic_state": ""}]}
{"declaration": "example : \u03a3 _x _y : Int, (Int \u00d7 Int) \u00d7 Int := by\n  use! 1, 2, 3, 4, 5\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (_ : \u2124) \u00d7 (_ : \u2124) \u00d7 (\u2124 \u00d7 \u2124) \u00d7 \u2124"}, {"line": "  use! 1, 2, 3, 4, 5", "tactic_state": ""}]}
{"declaration": "example : Option Nat := by use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Option \u2115"}]}
{"declaration": "example : Nat \u2192 Nat := by use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115 \u2192 \u2115"}]}
{"declaration": "example : foo := by\n  use 100, \u27e8true, 4\u27e9, 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo : Sort ?u.5\n\u22a2 foo"}, {"line": "  use 100, \u27e8true, 4\u27e9, 3", "tactic_state": ""}]}
{"declaration": "example : foo := by\n  use! 100, true, 4, 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo : Sort ?u.5\n\u22a2 foo"}, {"line": "  use! 100, true, 4, 3", "tactic_state": ""}]}
{"declaration": "example : foo := show_term by\n  use ?x, \u27e8?b, 4\u27e9\n  exact (3 : Nat)\n  exact (100 : Nat)\n  exact true\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo : Sort ?u.5\n\u22a2 foo"}, {"line": "  use ?x, \u27e8?b, 4\u27e9", "tactic_state": ""}]}
{"declaration": "example : foo := show_term by\n  -- Type ascriptions keep refinement from occurring before applying the constructor\n  use! (?x : Nat), (?b : Bool), 4\n  exact (3 : Nat)\n  exact (100 : Nat)\n  exact true\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo : Sort ?u.5\n\u22a2 foo"}, {"line": "  -- Type ascriptions keep refinement from occurring before applying the constructor", "tactic_state": ""}]}
{"declaration": "example : \u2203 p : {x : Nat // 0 < x}, 1 < p.1 := by use! 2 <;> decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, 1 < \u2191p"}]}
{"declaration": "example : Baz 0 3 := by use _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.2\nBaz : x\u271d\n\u22a2 sorry"}]}
{"declaration": "example : Baz 0 3 := by use 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.2\nBaz : x\u271d\n\u22a2 sorry"}]}
{"declaration": "example : Baz 0 3 := by use 4\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.2\nBaz : x\u271d\n\u22a2 sorry"}]}
{"declaration": "example : Baz 1 3 := by use (3 : Nat)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.2\nBaz : x\u271d\n\u22a2 sorry"}]}
{"declaration": "example : DecidableType := by\n  use Nat\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "DecidableType : Sort ?u.5\n\u22a2 DecidableType"}, {"line": "  use Nat", "tactic_state": ""}]}
{"declaration": "example (\u03b2 : Type) [DecidableEq \u03b2] : DecidableType := by\n  use \u03b2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "DecidableType : Sort ?u.27\n\u03b2 : Type\ninst\u271d : DecidableEq \u03b2\n\u22a2 DecidableType"}, {"line": "  use \u03b2", "tactic_state": ""}]}
{"declaration": "example (\u03b2 : Type) : DecidableType := by\n  use \u03b2\n  guard_target = DecidableEq \u03b2\n  apply Classical.typeDecidableEq\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "DecidableType : Sort ?u.9\n\u03b2 : Type\n\u22a2 DecidableType"}, {"line": "  use \u03b2", "tactic_state": ""}, {"line": "  guard_target = DecidableEq \u03b2", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : Nat := by use n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2115"}]}
{"declaration": "example (\u03b1 : Type u) : Embedding \u03b1 \u03b1 \u00d7 Unit := by\n  constructor\n  -- testing that `use` actually focuses on the main goal\n  use id\n  \u00b7 simp\n  constructor\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 sorry \u00d7 Unit"}, {"line": "  constructor", "tactic_state": "case fst\nx\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 sorry\n---\ncase snd\nx\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 Unit"}, {"line": "  -- testing that `use` actually focuses on the main goal", "tactic_state": "case snd\nx\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 Unit"}, {"line": "  use id", "tactic_state": "case snd\nx\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 Unit"}, {"line": "  \u00b7 simp", "tactic_state": ""}]}
{"declaration": "example (h1 : 1 > 0) : \u2203 (n : Nat) (_h : n > 0), n = n := by\n  use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h1 : 1 > 0\n\u22a2 \u2203 n, \u2203 (_ : n > 0), n = n"}, {"line": "  use 1", "tactic_state": ""}]}
{"declaration": "example : let P : Nat \u2192 Prop := fun _x => \u2203 _n : Nat, True; P 1 := by\n  intro P\n  use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let P := fun _x => \u2203 _n, True;\n  P 1"}, {"line": "  intro P", "tactic_state": "P : \u2115 \u2192 Prop := fun _x => \u2203 _n, True\n\u22a2 P 1"}, {"line": "  use 1", "tactic_state": ""}]}
{"declaration": "example : \u2203 f : Nat \u2192 Nat, f 1 = 1 := by\n  use \u00b7\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 f, f 1 = 1"}, {"line": "  use \u00b7", "tactic_state": "case h\n\u22a2 sorry 1 = 1"}]}
{"declaration": "example : \u2203 f : Nat \u2192 Nat, f 1 = 1 := by\n  use (\u00b7)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 f, f 1 = 1"}, {"line": "  use (\u00b7)", "tactic_state": ""}]}
{"declaration": "example {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} (hF : \u2200 i, Measurable (F i)) : Measurable (F 0) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), Measurable (F i)\n\u22a2 Measurable (F 0)"}]}
{"declaration": "example {\u03b9} [Encodable \u03b9] {S\u2081 S\u2082 : \u03b9 \u2192 Set \u03b1} (hS\u2081 : \u2200 i, MeasurableSet (S\u2081 i))\n    (hS\u2082 : \u2200 i, MeasurableSet (S\u2082 i)) : MeasurableSet (\u22c3 i, (S\u2081 i) \u222a (S\u2082 i)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03b9 : Type u_3\ninst\u271d : Encodable \u03b9\nS\u2081 S\u2082 : \u03b9 \u2192 Set \u03b1\nhS\u2081 : \u2200 (i : \u03b9), MeasurableSet (S\u2081 i)\nhS\u2082 : \u2200 (i : \u03b9), MeasurableSet (S\u2082 i)\n\u22a2 MeasurableSet (\u22c3 i, S\u2081 i \u222a S\u2082 i)"}]}
{"declaration": "example {\u03b9} [Encodable \u03b9] {S : \u03b9 \u2192 Set \u03b1} (hs : \u2200 i, MeasurableSet (S i)) :\n    MeasurableSet (\u22c3 i, S i) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03b9 : Type u_3\ninst\u271d : Encodable \u03b9\nS : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), MeasurableSet (S i)\n\u22a2 MeasurableSet (\u22c3 i, S i)"}]}
{"declaration": "example {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} (hF : \u2200 i, StronglyMeasurable (F i)) : Measurable (F 0) := by\n  measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), StronglyMeasurable (F i)\n\u22a2 Measurable (F 0)"}, {"line": "  measurability", "tactic_state": ""}]}
{"declaration": "example [Zero \u03b2] {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} (hF : \u2200 i, AEFinStronglyMeasurable (F i) \u03bc) :\n    AEMeasurable (F 0) \u03bc := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : Zero \u03b2\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), AEFinStronglyMeasurable (F i) \u03bc\n\u22a2 AEMeasurable (F 0) \u03bc"}]}
{"declaration": "example {\u03b9} [Encodable \u03b9] {S\u2081 S\u2082 : \u03b9 \u2192 Set \u03b1} (hS\u2081 : \u2200 i, MeasurableSet (S\u2081 i))\n    (hS\u2082 : \u2200 i, MeasurableSet (S\u2082 i)) : MeasurableSet (\u22c3 i, (S\u2081 i) \u222a (S\u2082 i)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b9 : BorelSpace \u03b2\n\u03b9 : Type u_3\ninst\u271d : Encodable \u03b9\nS\u2081 S\u2082 : \u03b9 \u2192 Set \u03b1\nhS\u2081 : \u2200 (i : \u03b9), MeasurableSet (S\u2081 i)\nhS\u2082 : \u2200 (i : \u03b9), MeasurableSet (S\u2082 i)\n\u22a2 MeasurableSet (\u22c3 i, S\u2081 i \u222a S\u2082 i)"}]}
{"declaration": "example {a b : \u211d} : MeasurableSet (Set.Icc a b) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\na b : \u211d\n\u22a2 MeasurableSet (Set.Icc a b)"}]}
{"declaration": "example [AddCommMonoid \u03b2] [MeasurableAdd\u2082 \u03b2] {s : Finset \u2115} {F : \u2115 \u2192 \u03b1 \u2192 \u03b2}\n    (hF : \u2200 i, Measurable (F i)) : Measurable (\u2211 i \u2208 s, (fun x => F (i+1) x + F i x)) := by\n  fun_prop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : MeasurableAdd\u2082 \u03b2\ns : Finset \u2115\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), Measurable (F i)\n\u22a2 Measurable (\u2211 i \u2208 s, fun x => F (i + 1) x + F i x)"}, {"line": "  fun_prop", "tactic_state": ""}]}
{"declaration": "example [AddCommMonoid \u03b2] [MeasurableAdd\u2082 \u03b2] {s : Finset \u2115} {F : \u2115 \u2192 \u03b1 \u2192 \u03b2}\n    (hF : \u2200 i, AEMeasurable (F i) \u03bc) : AEMeasurable (\u2211 i \u2208 s, (fun x => F (i+1) x + F i x)) \u03bc := by\n  measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b2\ninst\u271d\u2074 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b3 : BorelSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : MeasurableAdd\u2082 \u03b2\ns : Finset \u2115\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), AEMeasurable (F i) \u03bc\n\u22a2 AEMeasurable (\u2211 i \u2208 s, fun x => F (i + 1) x + F i x) \u03bc"}, {"line": "  measurability", "tactic_state": ""}]}
{"declaration": "example [TopologicalSpace \u03b1] [BorelSpace \u03b1] [NormedAddCommGroup \u03b2] [BorelSpace \u03b2]\n    [MeasurableAdd\u2082 \u03b2] [MeasurableSub\u2082 \u03b2] {s : Finset \u2115} {F : \u2115 \u2192 \u03b1 \u2192 \u03b2}\n    (hF : \u2200 i, Measurable (F i)) : AEMeasurable (\u2211 i \u2208 s, (fun x => F (i+1) x - F i x)) \u03bc := by\n  measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b2\ninst\u271d\u2079 : TopologicalSpace \u03b2\ninst\u271d\u2078 : PseudoMetrizableSpace \u03b2\ninst\u271d\u2077 : BorelSpace \u03b2\ninst\u271d\u2076 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : BorelSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : MeasurableAdd\u2082 \u03b2\ninst\u271d : MeasurableSub\u2082 \u03b2\ns : Finset \u2115\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), Measurable (F i)\n\u22a2 AEMeasurable (\u2211 i \u2208 s, fun x => F (i + 1) x - F i x) \u03bc"}, {"line": "  measurability", "tactic_state": ""}]}
{"declaration": "example : Measurable (fun x : \u211d => Real.exp (2 * inner 3 x)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u22a2 Measurable fun x => Real.exp (2 * inner 3 x)"}]}
{"declaration": "example : StronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u22a2 StronglyMeasurable fun x => Real.exp (2 * inner 3 x)"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} :\n  AEMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u03b3 : Measure \u211d\n\u22a2 AEMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} :\n  AEStronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u03b3 : Measure \u211d\n\u22a2 AEStronglyMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} [SigmaFinite \u03b3] :\n  FinStronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b9 : BorelSpace \u03b2\n\u03b3 : Measure \u211d\ninst\u271d : SigmaFinite \u03b3\n\u22a2 FinStronglyMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} [SigmaFinite \u03b3] :\n  AEFinStronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b9 : BorelSpace \u03b2\n\u03b3 : Measure \u211d\ninst\u271d : SigmaFinite \u03b3\n\u22a2 AEFinStronglyMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}]}
{"declaration": "example {\u03b9 : Type _} (i k : \u03b9) (hik : i \u2260 k) : Measurable (id : \u03b1 \u2192 \u03b1) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u03b9 : Type u_3\ni k : \u03b9\nhik : i \u2260 k\n\u22a2 Measurable id"}]}
{"declaration": "example {a b c d e : Nat} (h1 : a \u2264 b) (h2 : c \u2264 d) (h3 : 0 \u2264 e) :\n    a + c * e + a + c + 0 \u2264 b + d * e + b + d + e := by\n  apply_rules [Nat.add_le_add, Nat.mul_le_mul_right]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 a + c * e + a + c + 0 \u2264 b + d * e + b + d + e"}, {"line": "  apply_rules [Nat.add_le_add, Nat.mul_le_mul_right]", "tactic_state": ""}]}
{"declaration": "example {a b c d e : Nat} (h1 : a \u2264 b) (h2 : c \u2264 d) (h3 : 0 \u2264 e) :\n    a + c * e + a + c + 0 \u2264 b + d * e + b + d + e := by\n  apply_rules (config := {maxDepth := 9}) [Nat.add_le_add, Nat.mul_le_mul_right]\n  guard_target = 0 \u2264 e\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 a + c * e + a + c + 0 \u2264 b + d * e + b + d + e"}, {"line": "  apply_rules (config := {maxDepth := 9}) [Nat.add_le_add, Nat.mul_le_mul_right]", "tactic_state": "case h\u2082\na b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 0 \u2264 e"}, {"line": "  guard_target = 0 \u2264 e", "tactic_state": "case h\u2082\na b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 0 \u2264 e"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example {P Q : Prop} (p : P) (f : P \u2192 Q) : Q := by\n  apply_rules only [f]\n  exact p\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 Q"}, {"line": "  apply_rules only [f]", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 P"}, {"line": "  exact p", "tactic_state": ""}]}
{"declaration": "example {P Q : Prop} (p : P) (f : P \u2192 Q) : Q := by\n  apply_rules [-p]\n  exact p\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 Q"}, {"line": "  apply_rules [-p]", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 P"}, {"line": "  exact p", "tactic_state": ""}]}
{"declaration": "example (P : Nat \u2192 Type) (f : {n : Nat} \u2192 P n \u2192 P (n + 1)) (g : P 0) : P 2 := by\n  apply_rules only [f, g]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Type\nf : {n : \u2115} \u2192 P n \u2192 P (n + 1)\ng : P 0\n\u22a2 P 2"}, {"line": "  apply_rules only [f, g]", "tactic_state": ""}]}
{"declaration": "example (Q : Type) (f : Nat \u2192 Q) : Int \u00d7 Q := by\n  apply_rules only [Prod.mk, f]\n  guard_target = Int\n  exact 0\n  guard_target = Nat\n  exact 37\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Q : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2124 \u00d7 Q"}, {"line": "  apply_rules only [Prod.mk, f]", "tactic_state": "case fst\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2124\n---\ncase snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "  guard_target = Int", "tactic_state": "case fst\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2124\n---\ncase snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "  exact 0", "tactic_state": "case snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "  guard_target = Nat", "tactic_state": "case snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "  exact 37", "tactic_state": ""}]}
{"declaration": "example [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b : \u03b1} (hb : 0 \u2264 b) (hab : a \u2264 b) :\n    a / 2 \u2264 b / 2 := by\n  fail_if_success\n    apply_rules (config := { transparency := .reducible }) [mul_le_mul]\n  guard_target = a / 2 \u2264 b / 2\n  exact div_le_div\u2080 hb hab zero_lt_two le_rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nhb : 0 \u2264 b\nhab : a \u2264 b\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nhb : 0 \u2264 b\nhab : a \u2264 b\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "    apply_rules (config := { transparency := .reducible }) [mul_le_mul]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nhb : 0 \u2264 b\nhab : a \u2264 b\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "  guard_target = a / 2 \u2264 b / 2", "tactic_state": ""}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  refine' (by refine' .intro)", "tactic_state": ""}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  refine' (by refine' .intro)", "tactic_state": ""}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  refine' (by refine' .intro)", "tactic_state": ""}]}
{"declaration": "example (a : (True \u2228 True) \u2228 (True \u2228 True)): True := by\n  cases' a with b b <;> cases' b <;> trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : (True \u2228 True) \u2228 True \u2228 True\n\u22a2 True"}, {"line": "  cases' a with b b <;> cases' b <;> trivial", "tactic_state": ""}]}
{"declaration": "example (a : (True \u2228 True) \u2228 (True \u2228 True)): True := by\n  cases' a with b b <;> cases' b <;> trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : (True \u2228 True) \u2228 True \u2228 True\n\u22a2 True"}, {"line": "  cases' a with b b <;> cases' b <;> trivial", "tactic_state": ""}]}
{"declaration": "example : False := by admit\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}]}
{"declaration": "example : True \u2227 True := by\n  have : True := by\n    \u00b7 admit\n  let foo : Nat := by admit\n  refine \u27e8?_, ?_\u27e9\n  \u00b7 admit\n  \u00b7 admit\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True \u2227 True"}, {"line": "  have : True := by", "tactic_state": "this : True\n\u22a2 True \u2227 True"}, {"line": "    \u00b7 admit", "tactic_state": "this : True\nfoo : \u2115 := sorry\n\u22a2 True \u2227 True"}, {"line": "  let foo : Nat := by admit", "tactic_state": "case refine_1\nthis : True\nfoo : \u2115 := sorry\n\u22a2 True\n---\ncase refine_2\nthis : True\nfoo : \u2115 := sorry\n\u22a2 True"}, {"line": "  refine \u27e8?_, ?_\u27e9", "tactic_state": ""}, {"line": "  \u00b7 admit", "tactic_state": ""}]}
{"declaration": "example : False := by admit\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}]}
{"declaration": "example : p \u2227 p := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\nh : p \u2227 q \u2228 p \u2227 r\n\u22a2 p \u2227 p"}]}
{"declaration": "example : \u2203 x, p x := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\n\u03b1 : Type\np q r : \u03b1 \u2192 Prop\nh : (\u2203 x, p x \u2227 q x) \u2228 \u2203 x, p x \u2227 r x\n\u22a2 \u2203 x, p x"}]}
{"declaration": "example : \u2203 x, r x := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b9 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b9 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p x\nh\u2082 : q x\n\u22a2 \u2203 x, r x"}]}
{"declaration": "example (p : Prop) : p \u2227 True \u2194 p := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\n\u22a2 p \u2227 True \u2194 p"}]}
{"declaration": "example (p : Prop) : p \u2228 False \u2194 p := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\n\u22a2 p \u2228 False \u2194 p"}]}
{"declaration": "example (p q : Prop) (h : p \u2260 q) : \u00ac p \u2194 q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : p \u2260 q\n\u22a2 \u00acp \u2194 q"}]}
{"declaration": "example (p q : Prop) (h : \u00ac p = q) : \u00ac p \u2194 q := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00acp = q\n\u22a2 \u00acp \u2194 q"}]}
{"declaration": "example (p q r : Prop) : p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r) := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\n\u22a2 p \u2228 q \u2227 r \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r)"}]}
{"declaration": "example (p q r : Prop) : p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r) := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\n\u22a2 p \u2228 q \u2227 r \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r)"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : \u00ac p) : q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acp\n\u22a2 q"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : p) : \u00ac q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : p\n\u22a2 \u00acq"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : q) : \u00ac p := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : q\n\u22a2 \u00acp"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : \u00ac q) : p := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acq\n\u22a2 p"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : \u00ac q) (h'' : \u00ac p) : False := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acq\nh'' : \u00acp\n\u22a2 False"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (p q r : Prop) (h : p \u2194 q) (h' : r \u2194 q) (h'' : \u00ac r) : \u00ac p := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\nh : p \u2194 q\nh' : r \u2194 q\nh'' : \u00acr\n\u22a2 \u00acp"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (p q r : Prop) (h : p \u2194 q) (h' : r \u2194 q) : p \u2194 r := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\nh : p \u2194 q\nh' : r \u2194 q\n\u22a2 p \u2194 r"}]}
{"declaration": "example (p q r : Prop) (h : \u00ac p = q) (h' : r = q) : p \u2194 \u00ac r := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\nh : \u00acp = q\nh' : r = q\n\u22a2 p \u2194 \u00acr"}]}
{"declaration": "example (p : Prop) : p \u2192 \u00ac (p \u2192 \u00ac p) := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\n\u22a2 p \u2192 \u00ac(p \u2192 \u00acp)"}]}
{"declaration": "example (p : Prop) (em : p \u2228 \u00ac p) : \u00ac (p \u2194 \u00ac p) := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nem : p \u2228 \u00acp\n\u22a2 \u00ac(p \u2194 \u00acp)"}]}
{"declaration": "example (p : Prop) (h : False) : p := by\n  -- causes `h'` to have a type that's a metavariable:\n  have h' := h\n  clear h\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nh : False\n\u22a2 p"}, {"line": "  -- causes `h'` to have a type that's a metavariable:", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nh h' : False\n\u22a2 p"}, {"line": "  have h' := h", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nh' : False\n\u22a2 p"}, {"line": "  clear h", "tactic_state": ""}]}
{"declaration": "example (P : Nat \u2192 Prop) (n : Nat) : P n \u2192 n = 7 \u2228 n = 0 \u2228 \u00ac (n = 7 \u2228 n = 0) \u2227 P n := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b9 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b9 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p x\nh\u2082 : q x\nP : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 P n \u2192 n = 7 \u2228 n = 0 \u2228 \u00ac(n = 7 \u2228 n = 0) \u2227 P n"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example : \u00ac(\u00aca \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 a \u2264 b) \u2194 a \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 \u00aca \u2264 b := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b9 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b9 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p x\nh\u2082 : q x\na b c : \u2115\n\u22a2 \u00ac(\u00aca \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 a \u2264 b) \u2194 a \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 \u00aca \u2264 b"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (h' : p \u2227 \u00ac y = x) : p \u2227 q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b9 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b9 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d : Type\nx\u271d : \u03b1\u271d\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\nh\u2081 : p\u271d x\u271d\nh\u2082 : q\u271d x\u271d\na b c : \u2115\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\nh' : p \u2227 \u00acy = x\n\u22a2 p \u2227 q"}]}
{"declaration": "example : y = x := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b9 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b9 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d : Type\nx\u271d : \u03b1\u271d\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\nh\u2081 : p\u271d x\u271d\nh\u2082 : q\u271d x\u271d\na b c : \u2115\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u22a2 y = x"}]}
{"declaration": "example (h' : \u00ac x = y) : p \u2227 q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b9 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b9 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d : Type\nx\u271d : \u03b1\u271d\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\nh\u2081 : p\u271d x\u271d\nh\u2082 : q\u271d x\u271d\na b c : \u2115\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\nh' : \u00acx = y\n\u22a2 p \u2227 q"}]}
{"declaration": "example : x = y := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b9 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b9 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d : Type\nx\u271d : \u03b1\u271d\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\nh\u2081 : p\u271d x\u271d\nh\u2082 : q\u271d x\u271d\na b c : \u2115\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u22a2 x = y"}]}
{"declaration": "example {\u03b1 : Type*} {\u03b2 : Type*} (a : \u03b1) {s_1 : Set \u03b1} :\n    (\u2203 (a_1 : \u03b1), a_1 = a \u2228 a_1 \u2208 s_1) := by\n  tauto {closer := `[simp]}\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))", "(\u03b1 : Type)", "(x y z w : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b9 : \u03b1\u271d\u00b2\np\u271d q\u271d r\u271d : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\u00b9\nh\u2081 : p\u271d x\u271d\u00b9\nh\u2082 : q\u271d x\u271d\u00b9\na\u271d b c : \u2115\np q r : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d y\u271d : \u03b1\u271d\u00b9\nh : x\u271d = y\u271d\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u03b1\u271d : Type\nx y z w : \u03b1\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\ns_1 : Set \u03b1\n\u22a2 \u2203 a_1, a_1 = a \u2228 a_1 \u2208 s_1"}, {"line": "  tauto {closer := `[simp]}", "tactic_state": ""}]}
{"declaration": "example : (((r \u2227 p \u2194 r \u2228 q) \u2227 (q \u2228 r)) \u2192 (p \u2227 (x = w) \u2227 (\u00ac x = w \u2192 p \u2227 q \u2227 r))) := by\n  tauto {closer := `[cc]}\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))", "(\u03b1 : Type)", "(x y z w : \u03b1)", "{p q r : Prop} {\u03b1 : Type} {x y z w : \u03b1}", "(h : x = y) (h\u2081 : y = z) (h\u2082 : z = w)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b3 q\u271d\u00b3 r\u271d\u00b3 : Prop\nh\u271d\u00b2 : p\u271d\u00b3 \u2227 q\u271d\u00b3 \u2228 p\u271d\u00b3 \u2227 r\u271d\u00b3\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d\u00b9 : (\u2203 x, p\u271d\u00b2 x \u2227 q\u271d\u00b2 x) \u2228 \u2203 x, p\u271d\u00b2 x \u2227 r\u271d\u00b2 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b2 : \u03b1\u271d\u00b2\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d\u00b9 x \u2192 q\u271d\u00b9 x \u2192 r\u271d\u00b9 x) \u2228 r\u271d\u00b9 x\u271d\u00b2\nh\u2081\u271d : p\u271d\u00b9 x\u271d\u00b2\nh\u2082\u271d : q\u271d\u00b9 x\u271d\u00b2\na b c : \u2115\np\u271d q\u271d r\u271d : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d\u00b9 y\u271d\u00b9 : \u03b1\u271d\u00b9\nh\u271d : x\u271d\u00b9 = y\u271d\u00b9\nh''\u271d : (p\u271d \u2227 q\u271d \u2194 q\u271d \u2228 r\u271d) \u2194 (r\u271d \u2227 p\u271d \u2194 r\u271d \u2228 q\u271d)\n\u03b1\u271d : Type\nx\u271d y\u271d z\u271d w\u271d : \u03b1\u271d\np q r : Prop\n\u03b1 : Type\nx y z w : \u03b1\nh : x = y\nh\u2081 : y = z\nh\u2082 : z = w\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u22a2 (r \u2227 p \u2194 r \u2228 q) \u2227 (q \u2228 r) \u2192 p \u2227 x = w \u2227 (\u00acx = w \u2192 p \u2227 q \u2227 r)"}, {"line": "  tauto {closer := `[cc]}", "tactic_state": ""}]}
{"declaration": "example {x y : Nat} (h : \u00acx \u2260 y) : x = y := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))", "(\u03b1 : Type)", "(x y z w : \u03b1)", "{p q r : Prop} {\u03b1 : Type} {x y z w : \u03b1}", "(h : x = y) (h\u2081 : y = z) (h\u2082 : z = w)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b3 q\u271d\u00b3 r\u271d\u00b3 : Prop\nh\u271d\u00b3 : p\u271d\u00b3 \u2227 q\u271d\u00b3 \u2228 p\u271d\u00b3 \u2227 r\u271d\u00b3\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d\u00b2 : (\u2203 x, p\u271d\u00b2 x \u2227 q\u271d\u00b2 x) \u2228 \u2203 x, p\u271d\u00b2 x \u2227 r\u271d\u00b2 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b3 : \u03b1\u271d\u00b2\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d\u00b9 x \u2192 q\u271d\u00b9 x \u2192 r\u271d\u00b9 x) \u2228 r\u271d\u00b9 x\u271d\u00b3\nh\u2081\u271d : p\u271d\u00b9 x\u271d\u00b3\nh\u2082\u271d : q\u271d\u00b9 x\u271d\u00b3\na b c : \u2115\np\u271d q\u271d r\u271d : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d\u00b2 y\u271d\u00b2 : \u03b1\u271d\u00b9\nh\u271d\u00b9 : x\u271d\u00b2 = y\u271d\u00b2\nh''\u271d : (p\u271d \u2227 q\u271d \u2194 q\u271d \u2228 r\u271d) \u2194 (r\u271d \u2227 p\u271d \u2194 r\u271d \u2228 q\u271d)\n\u03b1\u271d : Type\nx\u271d\u00b9 y\u271d\u00b9 z\u271d w\u271d : \u03b1\u271d\np q r : Prop\n\u03b1 : Type\nx\u271d y\u271d z w : \u03b1\nh\u271d : x\u271d = y\u271d\nh\u2081 : y\u271d = z\nh\u2082 : z = w\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\nx y : \u2115\nh : \u00acx \u2260 y\n\u22a2 x = y"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (p : Prop) (o : Part \u03b1) (h : p \u2192 o.Dom) (a : \u03b1) :\n    a \u2208 restrict p o h \u2194 p \u2227 a \u2208 o := by\n  dsimp [restrict, mem_eq]\n  tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in", "Part"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))", "(\u03b1 : Type)", "(x y z w : \u03b1)", "{p q r : Prop} {\u03b1 : Type} {x y z w : \u03b1}", "(h : x = y) (h\u2081 : y = z) (h\u2082 : z = w)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u2074 q\u271d\u00b3 r\u271d\u00b3 : Prop\nh\u271d\u00b3 : p\u271d\u2074 \u2227 q\u271d\u00b3 \u2228 p\u271d\u2074 \u2227 r\u271d\u00b3\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b3 q\u271d\u00b2 r\u271d\u00b2 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d\u00b2 : (\u2203 x, p\u271d\u00b3 x \u2227 q\u271d\u00b2 x) \u2228 \u2203 x, p\u271d\u00b3 x \u2227 r\u271d\u00b2 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b3 : \u03b1\u271d\u00b2\np\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d\u00b2 x \u2192 q\u271d\u00b9 x \u2192 r\u271d\u00b9 x) \u2228 r\u271d\u00b9 x\u271d\u00b3\nh\u2081\u271d : p\u271d\u00b2 x\u271d\u00b3\nh\u2082\u271d : q\u271d\u00b9 x\u271d\u00b3\na\u271d b c : \u2115\np\u271d\u00b9 q\u271d r\u271d : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d\u00b2 y\u271d\u00b9 : \u03b1\u271d\u00b9\nh\u271d\u00b9 : x\u271d\u00b2 = y\u271d\u00b9\nh''\u271d : (p\u271d\u00b9 \u2227 q\u271d \u2194 q\u271d \u2228 r\u271d) \u2194 (r\u271d \u2227 p\u271d\u00b9 \u2194 r\u271d \u2228 q\u271d)\n\u03b1\u271d : Type\nx\u271d\u00b9 y\u271d z\u271d w\u271d : \u03b1\u271d\np\u271d q r : Prop\n\u03b1 : Type\nx y z w : \u03b1\nh\u271d : x = y\nh\u2081 : y = z\nh\u2082 : z = w\nh'' : (p\u271d \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p\u271d \u2194 r \u2228 q)\nx\u271d : Sort u_1\nrestrict : x\u271d\np : Prop\no : Part \u03b1\nh : p \u2192 o.Dom\na : \u03b1\n\u22a2 a \u2208 sorry \u2194 p \u2227 a \u2208 o"}, {"line": "  dsimp [restrict, mem_eq]", "tactic_state": "p\u271d\u2074 q\u271d\u00b3 r\u271d\u00b3 : Prop\nh\u271d\u00b3 : p\u271d\u2074 \u2227 q\u271d\u00b3 \u2228 p\u271d\u2074 \u2227 r\u271d\u00b3\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b3 q\u271d\u00b2 r\u271d\u00b2 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d\u00b2 : (\u2203 x, p\u271d\u00b3 x \u2227 q\u271d\u00b2 x) \u2228 \u2203 x, p\u271d\u00b3 x \u2227 r\u271d\u00b2 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b3 : \u03b1\u271d\u00b2\np\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d\u00b2 x \u2192 q\u271d\u00b9 x \u2192 r\u271d\u00b9 x) \u2228 r\u271d\u00b9 x\u271d\u00b3\nh\u2081\u271d : p\u271d\u00b2 x\u271d\u00b3\nh\u2082\u271d : q\u271d\u00b9 x\u271d\u00b3\na\u271d b c : \u2115\np\u271d\u00b9 q\u271d r\u271d : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d\u00b2 y\u271d\u00b9 : \u03b1\u271d\u00b9\nh\u271d\u00b9 : x\u271d\u00b2 = y\u271d\u00b9\nh''\u271d : (p\u271d\u00b9 \u2227 q\u271d \u2194 q\u271d \u2228 r\u271d) \u2194 (r\u271d \u2227 p\u271d\u00b9 \u2194 r\u271d \u2228 q\u271d)\n\u03b1\u271d : Type\nx\u271d\u00b9 y\u271d z\u271d w\u271d : \u03b1\u271d\np\u271d q r : Prop\n\u03b1 : Type\nx y z w : \u03b1\nh\u271d : x = y\nh\u2081 : y = z\nh\u2082 : z = w\nh'' : (p\u271d \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p\u271d \u2194 r \u2228 q)\nx\u271d : Sort u_1\nrestrict : x\u271d\np : Prop\no : Part \u03b1\nh : p \u2192 o.Dom\na : \u03b1\n\u22a2 a \u2208 sorry () \u2194 p \u2227 a \u2208 o"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (x : Nat) (h : x = x) : x = x := by\n  set! p := h\n  set q : x = x := p\n  apply q\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x = x\n\u22a2 x = x"}, {"line": "  set! p := h", "tactic_state": "x : \u2115\nh : x = x\np : x = x := h\n\u22a2 x = x"}, {"line": "  set q : x = x := p", "tactic_state": "x : \u2115\nh : x = x\np : x = x := h\nq : x = x := p\n\u22a2 x = x"}, {"line": "  apply q", "tactic_state": ""}]}
{"declaration": "example (x : Nat) (h : x + x - x = 3) : x + x - x = 3 := by\n  set! y := x with \u2190 h2\n  set w := x\n  guard_hyp y := x\n  guard_hyp w := x\n  guard_hyp h : w + w - w = 3\n  guard_hyp h2 : w = y\n  set z := w with _h3\n  set a := 3\n  guard_target = z + z - z = a\n  set i'm_the_goal : Prop := z + z - z = a\n  guard_target = i'm_the_goal\n  apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x + x - x = 3\n\u22a2 x + x - x = 3"}, {"line": "  set! y := x with \u2190 h2", "tactic_state": "x : \u2115\nh : x + x - x = 3\ny : \u2115 := x\nh2 : x = y\n\u22a2 x + x - x = 3"}, {"line": "  set w := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  guard_hyp y := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  guard_hyp w := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  guard_hyp h : w + w - w = 3", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  guard_hyp h2 : w = y", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  set z := w with _h3", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh : z + z - z = 3\nh2 : z = y\n_h3 : z = w\n\u22a2 z + z - z = 3"}, {"line": "  set a := 3", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\nh : z + z - z = a\n\u22a2 z + z - z = a"}, {"line": "  guard_target = z + z - z = a", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\nh : z + z - z = a\n\u22a2 z + z - z = a"}, {"line": "  set i'm_the_goal : Prop := z + z - z = a", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\ni'm_the_goal : Prop := z + z - z = a\nh : i'm_the_goal\n\u22a2 i'm_the_goal"}, {"line": "  guard_target = i'm_the_goal", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\ni'm_the_goal : Prop := z + z - z = a\nh : i'm_the_goal\n\u22a2 i'm_the_goal"}, {"line": "  apply h", "tactic_state": ""}]}
{"declaration": "example (x : Nat) (h : x - x = 0) : x = x := by\n  set y : Nat := x\n  set! z := y + 1 with \u2190 _eq1\n  set! p : x - x = 0 := h with _eq2\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x - x = 0\n\u22a2 x = x"}, {"line": "  set y : Nat := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nh : y - y = 0\n\u22a2 y = y"}, {"line": "  set! z := y + 1 with \u2190 _eq1", "tactic_state": "x : \u2115\ny : \u2115 := x\nh : y - y = 0\nz : \u2115 := y + 1\n_eq1 : y + 1 = z\n\u22a2 y = y"}, {"line": "  set! p : x - x = 0 := h with _eq2", "tactic_state": "x : \u2115\ny : \u2115 := x\nh : y - y = 0\nz : \u2115 := y + 1\n_eq1 : y + 1 = z\np : x - x = 0 := h\n_eq2 : p = h\n\u22a2 y = y"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : True := by\n  set g : Nat \u2192 Int := (fun \u03b5 => \u03b5) with _h\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  set g : Nat \u2192 Int := (fun \u03b5 => \u03b5) with _h", "tactic_state": "g : \u2115 \u2192 \u2124 := fun \u03b5 => \u2191\u03b5\n_h : g = fun \u03b5 => \u2191\u03b5\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example {_a _b _c _d _e _f _g _h : Nat} : 1 = 1 := by\n  set a : Nat := test with _h\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": ["Qq in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_a _b _c _d _e _f _g _h : \u2115\n\u22a2 1 = 1"}, {"line": "  set a : Nat := test with _h", "tactic_state": "_a _b _c _d _e _f _g _h\u271d : \u2115\na : \u2115 := sorry\n_h : a = sorry\n\u22a2 1 = 1"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  classical\n  let zero' := 0\n  replace _zero := zero'\n  let eq := (rfl : 0 = 0)\n  replace _eq := eq\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  classical", "tactic_state": ""}]}
{"declaration": "example : True := by\n  noise\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  noise", "tactic_state": "\u22a2 True"}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "  exact .intro", "tactic_state": ""}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "  exact .intro", "tactic_state": ""}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  noise\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "  noise", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  noise\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "  noise", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}]}
{"declaration": "example : True := by\n  noise\n  have _a := 0\n  have _b : Nat := 0\n  have _b : 0 = 0 := rfl\n  have _oh : Nat := 0\n  have _b : Nat := 2\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  noise", "tactic_state": "\u22a2 True"}]}
{"declaration": "example : True := by\n  have := Nat.succ ?_;\n  noise\n  exact .intro\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have := Nat.succ ?_;", "tactic_state": "case refine_2\nthis : \u2115\n\u22a2 True\n---\ncase refine_1\n\u22a2 \u2115"}, {"line": "  noise", "tactic_state": "case refine_2\nthis : \u2115\n\u22a2 True\n---\ncase refine_1\n\u22a2 \u2115"}]}
{"declaration": "example : True := by\n  have := And.intro (Nat.add_comm ?_ ?_) (Nat.add_comm ?_ ?_)\n  apply True.intro\n  noise\n  repeat exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have := And.intro (Nat.add_comm ?_ ?_) (Nat.add_comm ?_ ?_)", "tactic_state": "case refine_5\nthis : ?refine_1 + ?refine_2 = ?refine_2 + ?refine_1 \u2227 ?refine_3 + ?refine_4 = ?refine_4 + ?refine_3\n\u22a2 True\n---\ncase refine_1\n\u22a2 \u2115\n---\ncase refine_2\n\u22a2 \u2115\n---\ncase refine_3\n\u22a2 \u2115\n---\ncase refine_4\n\u22a2 \u2115"}, {"line": "  apply True.intro", "tactic_state": "case refine_1\n\u22a2 \u2115\n---\ncase refine_2\n\u22a2 \u2115\n---\ncase refine_3\n\u22a2 \u2115\n---\ncase refine_4\n\u22a2 \u2115"}, {"line": "  noise", "tactic_state": "case refine_1\n\u22a2 \u2115\n---\ncase refine_2\n\u22a2 \u2115\n---\ncase refine_3\n\u22a2 \u2115\n---\ncase refine_4\n\u22a2 \u2115"}]}
{"declaration": "example (h : False) : True := by\n  have : False := h\n  noise\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : False\n\u22a2 True"}, {"line": "  have : False := h", "tactic_state": "h this : False\n\u22a2 True"}, {"line": "  noise", "tactic_state": "h this : False\n\u22a2 True"}]}
{"declaration": "theorem ghi : True := by\n  noise\n  have : Nat := Nat.succ 1;\n  exact .intro", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  noise", "tactic_state": "\u22a2 True"}]}
{"declaration": "example : 0 = 0 := by\n  rw [] -- this goal is closed by the `rfl` implied by `rw`", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/PPRoundtrip.lean", "context": {"open": [], "variables": ["{a: Nat}", "{a :Nat}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a\u271d a : \u2115\n\u22a2 0 = 0"}, {"line": "  rw [] -- this goal is closed by the `rfl` implied by `rw`", "tactic_state": ""}]}
{"declaration": "example [AddCommMonoid \u03b1] : a + (b + a) = a + a + b := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommMonoid \u03b1\n\u22a2 a + (b + a) = a + a + b"}]}
{"declaration": "example [AddCommGroup \u03b1] : (a + b) - ((b + a) + a) = -a := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\n\u22a2 a + b - (b + a + a) = -a"}]}
{"declaration": "example [AddCommGroup \u03b1] (x : \u03b1) : x - 0 = x := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\n\u22a2 x - 0 = x"}]}
{"declaration": "example [AddCommMonoid \u03b1] : (3 : \u2115) \u2022 a = a + (2 : \u2115) \u2022 a := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommMonoid \u03b1\n\u22a2 3 \u2022 a = a + 2 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] : (3 : \u2124) \u2022 a = a + (2 : \u2124) \u2022 a := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\n\u22a2 3 \u2022 a = a + 2 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : a-2\u2022b = a -2\u2022b := by abel\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a - 2 \u2022 b = a - 2 \u2022 b"}]}
{"declaration": "example [AddCommMonoid \u03b1] (a b : \u03b1) : a + (b + a) = a + a + b := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b : \u03b1\n\u22a2 a + (b + a) = a + a + b"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : (a + b) - ((b + a) + a) = -a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a + b - (b + a + a) = -a"}]}
{"declaration": "example [AddCommGroup \u03b1] (x : \u03b1) : x - 0 = x := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\n\u22a2 x - 0 = x"}]}
{"declaration": "example [AddCommMonoid \u03b1] (a : \u03b1) : (3 : \u2115) \u2022 a = a + (2 : \u2115) \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na : \u03b1\n\u22a2 3 \u2022 a = a + 2 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a : \u03b1) : (3 : \u2124) \u2022 a = a + (2 : \u2124) \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommGroup \u03b1\na : \u03b1\n\u22a2 3 \u2022 a = a + 2 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : a - 2\u2022b = a - 2\u2022b := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a - 2 \u2022 b = a - 2 \u2022 b"}]}
{"declaration": "example [AddCommGroup \u03b1] (a : \u03b1) : 0 + a = a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommGroup \u03b1\na : \u03b1\n\u22a2 0 + a = a"}]}
{"declaration": "example [AddCommGroup \u03b1] (n : \u2115) (a : \u03b1) : n \u2022 a = n \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nn : \u2115\na : \u03b1\n\u22a2 n \u2022 a = n \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (n : \u2115) (a : \u03b1) : 0 + n \u2022 a = n \u2022 a := by abel1\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nn : \u2115\na : \u03b1\n\u22a2 0 + n \u2022 a = n \u2022 a"}, {"line": "", "tactic_state": ""}]}
{"declaration": "example [AddCommMonoid \u03b1] (a b c d e : \u03b1) :\n  a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c d e : \u03b1) :\n  a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c d : \u03b1) :\n  a + b + (c + d - a) = b + c + d := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d : \u03b1\n\u22a2 a + b + (c + d - a) = b + c + d"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c : \u03b1) :\n  a + b + c + (c - a - a) = (-1)\u2022a + b + 2\u2022c := by abel1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c : \u03b1\n\u22a2 a + b + c + (c - a - a) = -1 \u2022 a + b + 2 \u2022 c"}]}
{"declaration": "example [AddCommMonoid \u03b1] (a b c d e : \u03b1) :\n    a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True := by\n  fail_if_success\n    left; abel1\n  right; trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True"}, {"line": "    left; abel1", "tactic_state": "case h\n\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b c d e : \u03b1\n\u22a2 True"}, {"line": "  right; trivial", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c d e : \u03b1) :\n    a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True := by\n  fail_if_success\n    left; abel1\n  right; trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True"}, {"line": "    left; abel1", "tactic_state": "case h\n\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d e : \u03b1\n\u22a2 True"}, {"line": "  right; trivial", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c d : \u03b1) :\n    a + b + (c + d - a) = b + c - d \u2228 True := by\n  fail_if_success\n    left; abel1\n  right; trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d : \u03b1\n\u22a2 a + b + (c + d - a) = b + c - d \u2228 True"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d : \u03b1\n\u22a2 a + b + (c + d - a) = b + c - d \u2228 True"}, {"line": "    left; abel1", "tactic_state": "case h\n\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d : \u03b1\n\u22a2 True"}, {"line": "  right; trivial", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c : \u03b1) :\n    a + b + c + (c - a - a) = (-1)\u2022a + b + c \u2228 True := by\n  fail_if_success\n    left; abel1\n  right; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c : \u03b1\n\u22a2 a + b + c + (c - a - a) = -1 \u2022 a + b + c \u2228 True"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c : \u03b1\n\u22a2 a + b + c + (c - a - a) = -1 \u2022 a + b + c \u2228 True"}, {"line": "    left; abel1", "tactic_state": "case h\n\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c : \u03b1\n\u22a2 True"}, {"line": "  right; trivial", "tactic_state": ""}]}
{"declaration": "example : MyTrue := by\n  abel_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nMyTrue : Sort ?u.19\n\u22a2 MyTrue"}, {"line": "  abel_nf", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nMyTrue : Sort ?u.19\n\u22a2 MyTrue"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : a + b - b - id' a = 0 := by\n  fail_if_success\n    abel1\n  abel1!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\na\u271d b\u271d : \u03b1\nx\u271d : Sort u_1\nid' : x\u271d\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a + b - b - sorry = 0"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_2\na\u271d b\u271d : \u03b1\nx\u271d : Sort u_1\nid' : x\u271d\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a + b - b - sorry = 0"}, {"line": "    abel1", "tactic_state": "\u03b1 : Type u_2\na\u271d b\u271d : \u03b1\nx\u271d : Sort u_1\nid' : x\u271d\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a + b - b - sorry = 0"}]}
{"declaration": "example [AddCommGroup \u03b1] : True := by\n  have : \u2200 (p q r s : \u03b1), s + p - q = s - r - (q - r - p) := by\n    intro p q r s\n    abel\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\n\u22a2 True"}, {"line": "  have : \u2200 (p q r s : \u03b1), s + p - q = s - r - (q - r - p) := by", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nthis : \u2200 (p q r s : \u03b1), s + p - q = s - r - (q - r - p)\n\u22a2 True"}, {"line": "    intro p q r s", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) : y = x + z - (x - y + z) := by\n  have : True := trivial\n  abel\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\n\u22a2 y = x + z - (x - y + z)"}, {"line": "  have : True := trivial", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nthis : True\n\u22a2 y = x + z - (x - y + z)"}, {"line": "  abel", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (a b s : \u03b1) : -b + (s - a) = s - b - a := by abel_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b s : \u03b1\n\u22a2 -b + (s - a) = s - b - a"}]}
{"declaration": "example : True := by\n  have := 0\n  abel_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\n\u22a2 True"}, {"line": "  have := 0", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nthis : \u2115\n\u22a2 True"}, {"line": "  abel_nf", "tactic_state": ""}]}
{"declaration": "example : False := by abel_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\n\u22a2 False"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (w : x = y + z) : False := by\n  abel_nf at w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x = y + z\n\u22a2 False"}, {"line": "  abel_nf at w", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x = y + z\n\u22a2 False"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (h : False) (w : x - x = y + z) : False := by\n  abel_nf at w\n  guard_hyp w : 0 = y + z\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : x - x = y + z\n\u22a2 False"}, {"line": "  abel_nf at w", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : 0 = y + z\n\u22a2 False"}, {"line": "  guard_hyp w : 0 = y + z", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : 0 = y + z\n\u22a2 False"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (_w : x = y + z) : False := by\n  abel_nf at *\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\n_w : x = y + z\n\u22a2 False"}, {"line": "  abel_nf at *", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\n_w : x = y + z\n\u22a2 False"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (_w : x = y + z) : x - x = 0 := by\n  abel_nf at *\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\n_w : x = y + z\n\u22a2 x - x = 0"}, {"line": "  abel_nf at *", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (w : x = y + z) : x - x = 0 := by\n  abel_nf at w \u22a2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x = y + z\n\u22a2 x - x = 0"}, {"line": "  abel_nf at w \u22a2", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x = y + z\n\u22a2 x - x = 0"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (w : x - x = y + z) : x = 0 := by\n  abel_nf at w \u22a2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x - x = y + z\n\u22a2 x = 0"}, {"line": "  abel_nf at w \u22a2", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : 0 = y + z\n\u22a2 x = 0"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (h : False) (w : x - x = y + z) : False := by\n  abel_nf at *\n  guard_hyp w : 0 = y + z\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : x - x = y + z\n\u22a2 False"}, {"line": "  abel_nf at *", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : 0 = y + z\n\u22a2 False"}, {"line": "  guard_hyp w : 0 = y + z", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : 0 = y + z\n\u22a2 False"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (x : \u2124) (R : \u2124 \u2192 \u2124 \u2192 Prop) (hR : Reflexive R) : True := by\n  have h : R (myId x + x) (x + myId x) := hR ..\n  abel_nf at h\n  trace_state\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nx : \u2124\nR : \u2124 \u2192 \u2124 \u2192 Prop\nhR : Reflexive R\n\u22a2 True"}, {"line": "  have h : R (myId x + x) (x + myId x) := hR ..", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nx : \u2124\nR : \u2124 \u2192 \u2124 \u2192 Prop\nhR : Reflexive R\n\u22a2 True"}]}
{"declaration": "example [AddCommGroup \u03b1] (x : \u03b1) (f : \u03b1 \u2192 \u03b1) : True := by\n  let y := x\n  have : x = y := by\n    fail_if_success abel_nf\n    abel_nf!\n  have : x - y = 0 := by\n    abel_nf\n    abel_nf!\n  have : f x = f y := by\n    fail_if_success abel_nf\n    abel_nf!\n  have : f x - f y = 0 := by\n    abel_nf\n    abel_nf!\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\n\u22a2 True"}, {"line": "  let y := x", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\n\u22a2 True"}, {"line": "  have : x = y := by", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis : x = y\n\u22a2 True"}, {"line": "    fail_if_success abel_nf", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis\u271d : x = y\nthis : x - y = 0\n\u22a2 True"}, {"line": "    abel_nf!", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis\u271d\u00b9 : x = y\nthis\u271d : x - y = 0\nthis : f x = f y\n\u22a2 True"}, {"line": "  have : x - y = 0 := by", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis\u271d\u00b2 : x = y\nthis\u271d\u00b9 : x - y = 0\nthis\u271d : f x = f y\nthis : f x - f y = 0\n\u22a2 True"}, {"line": "    abel_nf", "tactic_state": ""}]}
{"declaration": "example : True := by\n  run_tac\n    let t : Option Bool := (\u2190 Lean.MonadOptions.getOptions).get? `pp.all\n    -- should be true as set\n    guard (t == true)\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnsetOption.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  run_tac", "tactic_state": "\u22a2 True"}]}
{"declaration": "example : True := by\n  run_tac\n    let t : Option Bool := (\u2190 Lean.MonadOptions.getOptions).get? `pp.all\n    -- should be none as unset\n    guard (t == Option.none)\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnsetOption.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  run_tac", "tactic_state": "\u22a2 True"}, {"line": "    let t : Option Bool := (\u2190 Lean.MonadOptions.getOptions).get? `pp.all", "tactic_state": ""}]}
{"declaration": "example : True := by\n  run_tac\n    let t : Option Bool := (\u2190 Lean.MonadOptions.getOptions).get? `pp.all\n    -- should be true as only unset within section\n    guard (t == true)\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnsetOption.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  run_tac", "tactic_state": "\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2227 d) (h2 : e \u2227 f) : True := by\n  casesm* _\u2228_, _\u2227_\n  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039e\u203a \u2039f\u203a; (fail_if_success clear \u2039c\u203a); trivial\n  \u00b7 clear \u2039c\u203a \u2039d\u203a \u2039e\u203a \u2039f\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e f : Prop\nh : a \u2227 b \u2228 c \u2227 d\nh2 : e \u2227 f\n\u22a2 True"}, {"line": "  casesm* _\u2228_, _\u2227_", "tactic_state": "case inl.intro.intro\na b c d e f : Prop\nleft\u271d\u00b9 : e\nright\u271d\u00b9 : f\nleft\u271d : a\nright\u271d : b\n\u22a2 True\n---\ncase inr.intro.intro\na b c d e f : Prop\nleft\u271d\u00b9 : e\nright\u271d\u00b9 : f\nleft\u271d : c\nright\u271d : d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039e\u203a \u2039f\u203a; (fail_if_success clear \u2039c\u203a); trivial", "tactic_state": "case inl.intro.intro\na b c d e f : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c\u203a \u2039d\u203a \u2039e\u203a \u2039f\u203a; trivial", "tactic_state": "case inl.intro.intro\na b c d e f : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2227 d) : True := by\n  fail_if_success casesm* _\u2227_ -- no match expected\n  clear \u2039a \u2227 b \u2228 c \u2227 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2227 d\n\u22a2 True"}, {"line": "  fail_if_success casesm* _\u2227_ -- no match expected", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2227 d\n\u22a2 True"}, {"line": "  clear \u2039a \u2227 b \u2228 c \u2227 d\u203a; trivial", "tactic_state": "a b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  casesm* _\u2228_\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c\u203a; trivial\n  \u00b7 clear \u2039d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  casesm* _\u2228_", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr.inl\na b c d : Prop\nh : c\n\u22a2 True\n---\ncase inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c\u203a; trivial", "tactic_state": ""}, {"line": "  \u00b7 clear \u2039d\u203a; trivial", "tactic_state": "case inr.inl\na b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  casesm _\u2228_\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  casesm _\u2228_", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c \u2228 d\u203a; trivial", "tactic_state": ""}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  cases_type And Or\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  cases_type And Or", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c \u2228 d\u203a; trivial", "tactic_state": ""}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  fail_if_success cases_type* And -- no match expected\n  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  fail_if_success cases_type* And -- no match expected", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial", "tactic_state": "a b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  cases_type Or\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  cases_type Or", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c \u2228 d\u203a; trivial", "tactic_state": ""}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  cases_type* Or\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c\u203a; trivial\n  \u00b7 clear \u2039d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  cases_type* Or", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr.inl\na b c d : Prop\nh : c\n\u22a2 True\n---\ncase inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c\u203a; trivial", "tactic_state": ""}, {"line": "  \u00b7 clear \u2039d\u203a; trivial", "tactic_state": "case inr.inl\na b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  fail_if_success cases_type!* And Or -- no match expected\n  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  fail_if_success cases_type!* And Or -- no match expected", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial", "tactic_state": "a b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2227 (c \u2228 d)) : True := by\n  cases_type! And Or\n  \u00b7 clear \u2039a\u203a \u2039b \u2227 (c \u2228 d)\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2227 (c \u2228 d)\n\u22a2 True"}, {"line": "  cases_type! And Or", "tactic_state": "case intro\na b c d : Prop\nh : a\nright\u271d : b \u2227 (c \u2228 d)\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a\u203a \u2039b \u2227 (c \u2228 d)\u203a; trivial", "tactic_state": "case intro\na b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2227 (c \u2228 d)) : True := by\n  cases_type!* And Or\n  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2227 (c \u2228 d)\n\u22a2 True"}, {"line": "  cases_type!* And Or", "tactic_state": "case intro.intro\na b c d : Prop\nh : a\nright\u271d\u00b9 : b\nright\u271d : c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039c \u2228 d\u203a; trivial", "tactic_state": "case intro.intro\na b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (_ : Test n) (h2 : Test (m + 1)) : True := by\n  cases_type!* Test\n  \u00b7 clear \u2039Test n\u203a \u2039False\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}, {"line": "  cases_type!* Test", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}]}
{"declaration": "example (_ : Test n) (h2 : Test (m + 1)) : True := by\n  cases_type Test\n  \u00b7 clear \u2039Test (m + 1)\u203a; trivial\n  \u00b7 clear \u2039False\u203a \u2039Test (m + 1)\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}, {"line": "  cases_type Test", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}]}
{"declaration": "example (_ : Test n) (h2 : Test (m + 1)) : True := by\n  cases_type* Test\n  \u00b7 clear \u2039False\u203a; trivial\n  \u00b7 clear \u2039False\u203a; clear \u2039False\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}, {"line": "  cases_type* Test", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}]}
{"declaration": "example : True \u2227 True \u2227 True := by\n  fail_if_success constructorm* True, _\u2228_ -- no match expected\n  guard_target = True \u2227 True \u2227 True\n  constructorm _\u2227_\n  \u00b7 guard_target = True; constructorm True\n  \u00b7 guard_target = True \u2227 True; constructorm* True, _\u2227_\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True \u2227 True \u2227 True"}, {"line": "  fail_if_success constructorm* True, _\u2228_ -- no match expected", "tactic_state": "\u22a2 True \u2227 True \u2227 True"}, {"line": "  guard_target = True \u2227 True \u2227 True", "tactic_state": "\u22a2 True \u2227 True \u2227 True"}, {"line": "  constructorm _\u2227_", "tactic_state": "case left\n\u22a2 True\n---\ncase right\n\u22a2 True \u2227 True"}, {"line": "  \u00b7 guard_target = True; constructorm True", "tactic_state": "case left\n\u22a2 True"}, {"line": "  \u00b7 guard_target = True \u2227 True; constructorm* True, _\u2227_", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : True := by\n  fail_if_success casesm! Nat  -- two constructors, so `casesm!` doesn't fire\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  fail_if_success casesm! Nat  -- two constructors, so `casesm!` doesn't fire", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : Array Nat) : True := by\n  casesm! Array _\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : Array \u2115\n\u22a2 True"}, {"line": "  casesm! Array _", "tactic_state": "case mk\nh : List \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : Array Nat) : True := by\n  casesm Array _\n  -- user facing name is preserved:\n  guard_hyp h : List Nat\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : Array \u2115\n\u22a2 True"}, {"line": "  casesm Array _", "tactic_state": "case mk\nh : List \u2115\n\u22a2 True"}, {"line": "  -- user facing name is preserved:", "tactic_state": "case mk\nh : List \u2115\n\u22a2 True"}, {"line": "  guard_hyp h : List Nat", "tactic_state": ""}]}
{"declaration": "example (n : Nat) (h : n = 0) : True := by\n  casesm Nat\n  \u00b7 trivial\n  \u00b7 -- user facing name is preserved:\n    guard_hyp h : n + 1 = 0\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : n = 0\n\u22a2 True"}, {"line": "  casesm Nat", "tactic_state": "case zero\nh : Nat.zero = 0\n\u22a2 True\n---\ncase succ\nn : \u2115\nh : n.succ = 0\n\u22a2 True"}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 -- user facing name is preserved:", "tactic_state": "case succ\nn : \u2115\nh : n.succ = 0\n\u22a2 True"}, {"line": "    guard_hyp h : n + 1 = 0", "tactic_state": ""}]}
{"declaration": "example (h : P \u2227 Q) : True := by\n  casesm _ \u2227 _\n  -- user facing name is not used here, because there are multiple new hypotheses.\n  fail_if_success guard_hyp h : P\n  rename_i p q\n  guard_hyp p : P\n  guard_hyp q : Q\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\nh : P \u2227 Q\n\u22a2 True"}, {"line": "  casesm _ \u2227 _", "tactic_state": "case intro\nP Q : Prop\nleft\u271d : P\nright\u271d : Q\n\u22a2 True"}, {"line": "  -- user facing name is not used here, because there are multiple new hypotheses.", "tactic_state": "case intro\nP Q : Prop\nleft\u271d : P\nright\u271d : Q\n\u22a2 True"}, {"line": "  fail_if_success guard_hyp h : P", "tactic_state": "case intro\nP Q : Prop\np : P\nq : Q\n\u22a2 True"}, {"line": "  rename_i p q", "tactic_state": "case intro\nP Q : Prop\np : P\nq : Q\n\u22a2 True"}, {"line": "  guard_hyp p : P", "tactic_state": "case intro\nP Q : Prop\np : P\nq : Q\n\u22a2 True"}, {"line": "  guard_hyp q : Q", "tactic_state": ""}]}
{"declaration": "theorem foo : p \u2227 p := by\n  cases h\n  \u00b7 casesm (_ \u2227 _)\n    constructor <;> assumption\n  \u00b7 casesm (_ \u2227 _)\n    constructor <;> assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": ["{p q r : Prop}", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\n\u22a2 p \u2227 p"}, {"line": "  cases h", "tactic_state": "p : Prop\nx\u271d : ?m.27\n\u22a2 p \u2227 p"}]}
{"declaration": "example : (2 : \u211d) ^ (3 : \u211d) = 8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 ^ 3 = 8"}]}
{"declaration": "example : (1 : \u211d) ^ (20 : \u211d) = 1 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 ^ 20 = 1"}]}
{"declaration": "example : (-2 : \u211d) ^ (3 : \u211d) = -8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (-2) ^ 3 = -8"}]}
{"declaration": "example : (1/5 : \u211d) ^ (2 : \u211d) = 1/25 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (1 / 5) ^ 2 = 1 / 25"}]}
{"declaration": "example : (-1/3 : \u211d) ^ (-3 : \u211d) = -27 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (-1 / 3) ^ (-3) = -27"}]}
{"declaration": "example : (1/2 : \u211d) ^ (-3 : \u211d) = 8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (1 / 2) ^ (-3) = 8"}]}
{"declaration": "example : (2 : \u211d) ^ (-3 : \u211d) = 1/8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 ^ (-3) = 1 / 8"}]}
{"declaration": "example : (-2 : \u211d) ^ (-3 : \u211d) = -1/8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (-2) ^ (-3) = -1 / 8"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) \u2264 b \u2194 a \u2264 b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) < b \u2194 a < b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a < \u2191b \u2194 a < b"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) = b \u2194 a = b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a = \u2191b \u2194 a = b"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) \u2260 b \u2194 a \u2260 b := by qify\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a \u2260 \u2191b \u2194 a \u2260 b"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) \u2264 b \u2194 a \u2264 b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) < b \u2194 a < b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a < \u2191b \u2194 a < b"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) = b \u2194 a = b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a = \u2191b \u2194 a = b"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) \u2260 b \u2194 a \u2260 b := by qify\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a \u2260 \u2191b \u2194 a \u2260 b"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) \u2264 b \u2194 a \u2264 b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) < b \u2194 a < b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a < \u2191b \u2194 a < b"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) = b \u2194 a = b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a = \u2191b \u2194 a = b"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) \u2260 b \u2194 a \u2260 b := by qify\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a \u2260 \u2191b \u2194 a \u2260 b"}]}
{"declaration": "example (a b c : \u2115) (h : a - b = c) (hab : b \u2264 a) : a = c + b := by\n  qify [hab] at h \u22a2 -- `zify` does the same thing here.\n  exact sub_eq_iff_eq_add.1 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a - b = c\nhab : b \u2264 a\n\u22a2 a = c + b"}, {"line": "  qify [hab] at h \u22a2 -- `zify` does the same thing here.", "tactic_state": "a b c : \u2115\nhab : b \u2264 a\nh : \u2191a - \u2191b = \u2191c\n\u22a2 \u2191a = \u2191c + \u2191b"}, {"line": "  exact sub_eq_iff_eq_add.1 h", "tactic_state": ""}]}
{"declaration": "example (a b c : \u211a\u22650) (h : a - b = c) (hab : b \u2264 a) : a = c + b := by\n  qify [hab] at h \u22a2\n  exact sub_eq_iff_eq_add.1 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\u22650\nh : a - b = c\nhab : b \u2264 a\n\u22a2 a = c + b"}, {"line": "  qify [hab] at h \u22a2", "tactic_state": "a b c : \u211a\u22650\nhab : b \u2264 a\nh : \u2191a - \u2191b = \u2191c\n\u22a2 \u2191a = \u2191c + \u2191b"}, {"line": "  exact sub_eq_iff_eq_add.1 h", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2124) (h : a / b = c) (hab : b \u2223 a) (hb : b \u2260 0) : a = c * b := by\n  qify [hab] at h hb \u22a2\n  exact (div_eq_iff hb).1 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2124\nh : a / b = c\nhab : b \u2223 a\nhb : b \u2260 0\n\u22a2 a = c * b"}, {"line": "  qify [hab] at h hb \u22a2", "tactic_state": "a b c : \u2124\nhab : b \u2223 a\nh : \u2191a / \u2191b = \u2191c\nhb : \u2191b \u2260 0\n\u22a2 \u2191a = \u2191c * \u2191b"}, {"line": "  exact (div_eq_iff hb).1 h", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2115) (h : a / b = c) (hab : b \u2223 a) (hb : b \u2260 0) : a = c * b := by\n  qify [hab] at h hb \u22a2\n  exact (div_eq_iff hb).1 h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a / b = c\nhab : b \u2223 a\nhb : b \u2260 0\n\u22a2 a = c * b"}, {"line": "  qify [hab] at h hb \u22a2", "tactic_state": "a b c : \u2115\nhab : b \u2223 a\nh : \u2191a / \u2191b = \u2191c\nhb : \u2191b \u2260 0\n\u22a2 \u2191a = \u2191c * \u2191b"}, {"line": "  exact (div_eq_iff hb).1 h", "tactic_state": ""}]}
{"declaration": "example : \u2203 x : Nat, x = x := by\n  existsi 42\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExistsI.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "  existsi 42", "tactic_state": "\u22a2 42 = 42"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : \u2203 x : Nat, \u2203 y : Nat, x = y := by\n  existsi 42, 42\n  rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExistsI.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x y, x = y"}, {"line": "  existsi 42, 42", "tactic_state": "\u22a2 42 = 42"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : Nat := by\n  have h : Nat\n  exact 5\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115"}, {"line": "  have h : Nat", "tactic_state": "case h\n\u22a2 \u2115\n---\nh : \u2115\n\u22a2 \u2115"}, {"line": "  exact 5", "tactic_state": "h : \u2115\n\u22a2 \u2115"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example : Nat := by\n  have : Nat\n  \u00b7 exact 5\n  exact this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115"}, {"line": "  have : Nat", "tactic_state": "case this\n\u22a2 \u2115\n---\nthis : \u2115\n\u22a2 \u2115"}, {"line": "  \u00b7 exact 5", "tactic_state": ""}, {"line": "  exact this", "tactic_state": ""}]}
{"declaration": "example {a : Nat} : a = a := by\n  have h : a = a\n  \u00b7 rfl\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "  have h : a = a", "tactic_state": "case h\na : \u2115\n\u22a2 a = a\n---\na : \u2115\nh : a = a\n\u22a2 a = a"}, {"line": "  \u00b7 rfl", "tactic_state": ""}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example {a : Nat} : a = a := by\n  have : a = a\n  \u00b7 rfl\n  exact this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "  have : a = a", "tactic_state": "case this\na : \u2115\n\u22a2 a = a\n---\na : \u2115\nthis : a = a\n\u22a2 a = a"}, {"line": "  \u00b7 rfl", "tactic_state": ""}, {"line": "  exact this", "tactic_state": ""}]}
{"declaration": "example : True := by\n  let _N; -- FIXME: https://github.com/leanprover/lean4/issues/1670\n  exact Nat\n  have\n  \u00b7 exact 0\n  have _h : Nat\n  \u00b7 exact this\n  have _h' x : x < x + 1\n  \u00b7 exact Nat.lt.base x\n  have _h'' (x : Nat) : x < x + 1\n  \u00b7 exact Nat.lt.base x\n  let _m\n  \u00b7 exact 6\n  let _m' x (y : Nat) : x + y = y + x\n  rw [Nat.add_comm]\n  have _q\n  \u00b7 exact 6\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  let _N; -- FIXME: https://github.com/leanprover/lean4/issues/1670", "tactic_state": "case _N\n\u22a2 ?m.5\n---\n_N : ?m.5 := ?_N\n\u22a2 True"}, {"line": "  exact Nat", "tactic_state": "_N : Type := \u2115\n\u22a2 True"}, {"line": "  have", "tactic_state": "case this\n_N : Type := \u2115\n\u22a2 ?m.12\n---\n_N : Type := \u2115\nthis : ?m.12\n\u22a2 True"}, {"line": "  \u00b7 exact 0", "tactic_state": ""}, {"line": "  have _h : Nat", "tactic_state": "case _h\n_N : Type := \u2115\nthis : \u2115\n\u22a2 \u2115\n---\n_N : Type := \u2115\nthis _h : \u2115\n\u22a2 True"}, {"line": "  \u00b7 exact this", "tactic_state": ""}, {"line": "  have _h' x : x < x + 1", "tactic_state": "case _h'\n_N : Type := \u2115\nthis _h x : \u2115\n\u22a2 x < x + 1\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' : \u2200 (x : \u2115), x < x + 1\n\u22a2 True"}, {"line": "  \u00b7 exact Nat.lt.base x", "tactic_state": ""}, {"line": "  have _h'' (x : Nat) : x < x + 1", "tactic_state": "case _h''\n_N : Type := \u2115\nthis _h : \u2115\n_h' : \u2200 (x : \u2115), x < x + 1\nx : \u2115\n\u22a2 x < x + 1\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n\u22a2 True"}, {"line": "  \u00b7 exact Nat.lt.base x", "tactic_state": ""}, {"line": "  let _m", "tactic_state": "case _m\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n\u22a2 ?m.883\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : ?m.883 := ?_m\n\u22a2 True"}, {"line": "  \u00b7 exact 6", "tactic_state": ""}, {"line": "  let _m' x (y : Nat) : x + y = y + x", "tactic_state": "case _m'\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\nx y : \u2115\n\u22a2 x + y = y + x\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\n_m' : \u2200 (x y : \u2115), x + y = y + x := fun x y => ?_m'\n\u22a2 True"}, {"line": "  rw [Nat.add_comm]", "tactic_state": "_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\n_m' : \u2200 (x y : \u2115), x + y = y + x :=\n  fun x y => Eq.mpr (id (congrArg (fun _a => _a = y + x) (Nat.add_comm x y))) (Eq.refl (y + x))\n\u22a2 True"}, {"line": "  have _q", "tactic_state": "case _q\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\n_m' : \u2200 (x y : \u2115), x + y = y + x :=\n  fun x y => Eq.mpr (id (congrArg (fun _a => _a = y + x) (Nat.add_comm x y))) (Eq.refl (y + x))\n\u22a2 ?m.1001\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\n_m' : \u2200 (x y : \u2115), x + y = y + x :=\n  fun x y => Eq.mpr (id (congrArg (fun _a => _a = y + x) (Nat.add_comm x y))) (Eq.refl (y + x))\n_q : ?m.1001\n\u22a2 True"}, {"line": "  \u00b7 exact 6", "tactic_state": ""}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example : True := by have h : Nat.zero", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}]}
{"declaration": "theorem ex1 (a b c : Nat) (h : a = b) : a + c = b + c := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a = b\n\u22a2 a + c = b + c"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex2 (a b : Nat) (h : a = b) : \u2200 c, a + c = b + c := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 \u2200 (c : \u2115), a + c = b + c"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex3 (a b : Nat) (h : a = b) : (fun c => a + c) = (fun c => b + c) := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 (fun c => a + c) = fun c => b + c"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex4 (a b : Nat) : Fin (a + b) = Fin (b + a) := by\n  congr! 1\n  guard_target = a + b = b + a\n  apply Nat.add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Fin (a + b) = Fin (b + a)"}, {"line": "  congr! 1", "tactic_state": "case h.e'_1\na b : \u2115\n\u22a2 a + b = b + a"}, {"line": "  guard_target = a + b = b + a", "tactic_state": "case h.e'_1\na b : \u2115\n\u22a2 a + b = b + a"}, {"line": "  apply Nat.add_comm", "tactic_state": ""}]}
{"declaration": "theorem ex5 : ((a : Nat) \u2192 Fin (a + 1)) = ((a : Nat) \u2192 Fin (1 + a)) := by\n  congr! 2 with a\n  guard_target = a + 1 = 1 + a\n  apply Nat.add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ((a : \u2115) \u2192 Fin (a + 1)) = ((a : \u2115) \u2192 Fin (1 + a))"}, {"line": "  congr! 2 with a", "tactic_state": "case h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "  guard_target = a + 1 = 1 + a", "tactic_state": "case h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "  apply Nat.add_comm", "tactic_state": ""}]}
{"declaration": "theorem ex6 : ((a : Nat) \u00d7 Fin (a + 1)) = ((a : Nat) \u00d7 Fin (1 + a)) := by\n  congr! 3 with a\n  guard_target = a + 1 = 1 + a\n  apply Nat.add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ((a : \u2115) \u00d7 Fin (a + 1)) = ((a : \u2115) \u00d7 Fin (1 + a))"}, {"line": "  congr! 3 with a", "tactic_state": "case h.e'_2.h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "  guard_target = a + 1 = 1 + a", "tactic_state": "case h.e'_2.h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "  apply Nat.add_comm", "tactic_state": ""}]}
{"declaration": "theorem ex7 (p : Prop) (h1 h2 : p) : h1 = h2 := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\nh1 h2 : p\n\u22a2 h1 = h2"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex8 (p q : Prop) (h1 : p) (h2 : q) : HEq h1 h2 := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh1 : p\nh2 : q\n\u22a2 HEq h1 h2"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex9 (a b : Nat) (h : a = b) : a + 1 \u2264 b + 1 := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + 1 \u2264 b + 1"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex10 (x y : Unit) : x = y := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Unit\n\u22a2 x = y"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex11 (p q r : Nat \u2192 Prop) (h : q = r) : (\u2200 n, p n \u2192 q n) \u2194 (\u2200 n, p n \u2192 r n) := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : \u2115 \u2192 Prop\nh : q = r\n\u22a2 (\u2200 (n : \u2115), p n \u2192 q n) \u2194 \u2200 (n : \u2115), p n \u2192 r n"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex12 (p q : Prop) (h : p \u2194 q) : p = q := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : p \u2194 q\n\u22a2 p = q"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex13 (x y : \u03b1) (h : x = y) (f : \u03b1 \u2192 Nat) : f x = f y := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx y : \u03b1\nh : x = y\nf : \u03b1 \u2192 \u2115\n\u22a2 f x = f y"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex14 {\u03b1 : Type} (f : Nat \u2192 Nat) (h : \u2200 x, f x = 0) (z : \u03b1) (hz : HEq z 0) :\n    HEq f (fun (_ : \u03b1) => z) := by\n  congr!\n  \u00b7 guard_target = Nat = \u03b1\n    exact type_eq_of_heq hz.symm\n  next n x _ =>\n    guard_target = HEq (f n) z\n    rw [h]\n    exact hz.symm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\n\u22a2 HEq f fun x => z"}, {"line": "  congr!", "tactic_state": "case h\u03b1\n\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\n\u22a2 \u2115 = \u03b1\n---\ncase h\n\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\na\u271d\u00b9 : \u2115\na'\u271d : \u03b1\na\u271d : HEq a\u271d\u00b9 a'\u271d\n\u22a2 HEq (f a\u271d\u00b9) z"}, {"line": "  \u00b7 guard_target = Nat = \u03b1", "tactic_state": "case h\u03b1\n\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\n\u22a2 \u2115 = \u03b1"}, {"line": "    exact type_eq_of_heq hz.symm", "tactic_state": ""}, {"line": "  next n x _ =>", "tactic_state": ""}]}
{"declaration": "theorem ex15 (p q : Nat \u2192 Prop) :\n    (\u2200 \u03b5 > 0, p \u03b5) \u2194 \u2200 \u03b5 > 0, q \u03b5 := by\n  congr! 2 with \u03b5 h\u03b5\n  guard_hyp h\u03b5 : \u03b5 > 0\n  guard_target = p \u03b5 \u2194 q \u03b5\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u2115 \u2192 Prop\n\u22a2 (\u2200 \u03b5 > 0, p \u03b5) \u2194 \u2200 \u03b5 > 0, q \u03b5"}, {"line": "  congr! 2 with \u03b5 h\u03b5", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "  guard_hyp h\u03b5 : \u03b5 > 0", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "  guard_target = p \u03b5 \u2194 q \u03b5", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (s t : Set \u03b1) : (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t) := by\n  congr! 1\n  guard_target = Subtype s = Subtype t\n  congr! 1\n  guard_target = s = t\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t)"}, {"line": "  congr! 1", "tactic_state": "case h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 Subtype s = Subtype t"}, {"line": "  guard_target = Subtype s = Subtype t", "tactic_state": "case h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 Subtype s = Subtype t"}, {"line": "  congr! 1", "tactic_state": "case h.e'_2.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 s = t"}, {"line": "  guard_target = s = t", "tactic_state": "case h.e'_2.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 s = t"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (s t : Set \u03b1) (f : Subtype s \u2192 \u03b1) (g : Subtype t \u2192 \u03b1) :\n    Set.image f Set.univ = Set.image g Set.univ := by\n  congr!\n  \u00b7 guard_target = s = t\n    exact test_sorry\n  \u00b7 guard_target = HEq f g\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "  congr!", "tactic_state": "case h.e'_1.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\n\u22a2 s = t\n---\ncase h.e'_3\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\ne_1\u271d : Subtype s = Subtype t\n\u22a2 HEq f g"}, {"line": "  \u00b7 guard_target = s = t", "tactic_state": "case h.e'_1.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\n\u22a2 s = t"}, {"line": "    exact test_sorry", "tactic_state": ""}, {"line": "  \u00b7 guard_target = HEq f g", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\ne_1\u271d : Subtype s = Subtype t\n\u22a2 HEq f g"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example {\u03b9 \u03ba : Type u} (f : \u03b9 \u2192 \u03b1) (g : \u03ba \u2192 \u03b1) :\n    Set.image f Set.univ = Set.image g Set.univ := by\n  congr!\n  guard_target = Set.image f Set.univ = Set.image g Set.univ\n  congr! (config := {typeEqs := true})\n  \u00b7 guard_target = \u03b9 = \u03ba\n    exact test_sorry\n  \u00b7 guard_target = HEq f g\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "  congr!", "tactic_state": "\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "  guard_target = Set.image f Set.univ = Set.image g Set.univ", "tactic_state": "\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "  congr! (config := {typeEqs := true})", "tactic_state": "case h.e'_1\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 \u03b9 = \u03ba\n---\ncase h.e'_3\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\ne_1\u271d : \u03b9 = \u03ba\n\u22a2 HEq f g"}, {"line": "  \u00b7 guard_target = \u03b9 = \u03ba", "tactic_state": "case h.e'_1\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 \u03b9 = \u03ba"}, {"line": "    exact test_sorry", "tactic_state": ""}, {"line": "  \u00b7 guard_target = HEq f g", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\ne_1\u271d : \u03b9 = \u03ba\n\u22a2 HEq f g"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (s : Set \u03b1) (t : Set \u03b2) : (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t) := by\n  congr!\n  guard_target = Subtype s = Subtype t\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u_1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t)"}, {"line": "  congr!", "tactic_state": "case h.e'_2\n\u03b1 \u03b2 : Type u_1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Subtype s = Subtype t"}, {"line": "  guard_target = Subtype s = Subtype t", "tactic_state": "case h.e'_2\n\u03b1 \u03b2 : Type u_1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Subtype s = Subtype t"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (m n : Nat) (h : m = n) (x : Fin m) (y : Fin n) : HEq (x + x) (y + y) := by\n  congr!\n  guard_target = HEq x y\n  exact test_sorry\n  guard_target = HEq x y\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  congr!", "tactic_state": "case e'_5\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_1\u271d : Fin m = Fin n\n\u22a2 HEq x y\n---\ncase e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "  guard_target = HEq x y", "tactic_state": "case e'_5\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_1\u271d : Fin m = Fin n\n\u22a2 HEq x y\n---\ncase e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "  exact test_sorry", "tactic_state": "case e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "  guard_target = HEq x y", "tactic_state": "case e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (p q r : Prop) : p \u2227 q \u2194 p \u2227 r := by\n  congr!\n  guard_target = q \u2194 r\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\n\u22a2 p \u2227 q \u2194 p \u2227 r"}, {"line": "  congr!", "tactic_state": "case a.h.e'_2.a\np q r : Prop\n\u22a2 q \u2194 r"}, {"line": "  guard_target = q \u2194 r", "tactic_state": "case a.h.e'_2.a\np q r : Prop\n\u22a2 q \u2194 r"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (\u03b1 \u03b2) [inst1 : Add \u03b1] [inst2 : Add \u03b2] (x : \u03b1) (y : \u03b2) : HEq (x + x) (y + y) := by\n  congr!\n  guard_target = HEq (x + x) (y + y)\n  -- But with typeEqs we can get it to generate the congruence anyway:\n  have : \u03b1 = \u03b2 := test_sorry\n  have : HEq inst1 inst2 := test_sorry\n  congr! (config := { typeEqs := true })\n  guard_target = HEq x y\n  exact test_sorry\n  guard_target = HEq x y\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  congr!", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  guard_target = HEq (x + x) (y + y)", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  -- But with typeEqs we can get it to generate the congruence anyway:", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis : \u03b1 = \u03b2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  have : \u03b1 = \u03b2 := test_sorry", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  have : HEq inst1 inst2 := test_sorry", "tactic_state": "case e'_5\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y\n---\ncase e'_6\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y"}, {"line": "  congr! (config := { typeEqs := true })", "tactic_state": "case e'_5\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y\n---\ncase e'_6\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y"}, {"line": "  guard_target = HEq x y", "tactic_state": "case e'_6\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y"}, {"line": "  exact test_sorry", "tactic_state": "case e'_6\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y"}, {"line": "  guard_target = HEq x y", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr!\n  \u00b7 guard_target =\u209b (HMul.hMul : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd\n    exact test_sorry\n  \u00b7 guard_target = 2 = n\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "  congr!", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 HMul.hMul = HAdd.hAdd\n---\ncase h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "  \u00b7 guard_target =\u209b (HMul.hMul : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 HMul.hMul = HAdd.hAdd"}, {"line": "    exact test_sorry", "tactic_state": ""}, {"line": "  \u00b7 guard_target = 2 = n", "tactic_state": "case h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr! (config := {etaExpand := true})\n  \u00b7 guard_target =\u209b (fun (x y : Nat) => x * y) = (fun (x y : Nat) => x + y)\n    exact test_sorry\n  \u00b7 guard_target = 2 = n\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "  congr! (config := {etaExpand := true})", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 (fun a a_1 => a * a_1) = fun a a_1 => a + a_1\n---\ncase h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "  \u00b7 guard_target =\u209b (fun (x y : Nat) => x * y) = (fun (x y : Nat) => x + y)", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 (fun a a_1 => a * a_1) = fun a a_1 => a + a_1"}, {"line": "    exact test_sorry", "tactic_state": ""}, {"line": "  \u00b7 guard_target = 2 = n", "tactic_state": "case h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr! 2\n  guard_target = 2 * n = n + n\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "  congr! 2", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "  guard_target = 2 * n = n + n", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr! (config := .unfoldSameFun)\n  guard_target = 2 * n = n + n\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "  congr! (config := .unfoldSameFun)", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "  guard_target = 2 * n = n + n", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : partiallyApplied (True \u2227 True) = partiallyApplied True := by\n  congr!\n  decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\npartiallyApplied : x\u271d\n\u22a2 sorry = sorry"}, {"line": "  congr!", "tactic_state": ""}, {"line": "  decide", "tactic_state": ""}]}
{"declaration": "example (w : walk \u03b1 x y) (w' : walk \u03b1 x' y') (f : \u03b1 \u2192 \u03b2) : HEq (w.map f) (w'.map f) := by\n  congr!\n  guard_target = x = x'\n  exact test_sorry\n  guard_target = y = y'\n  exact test_sorry\n  -- get x = y and y = y' in context for `HEq w w'` goal.\n  have : x = x' := by assumption\n  have : y = y' := by assumption\n  guard_target = HEq w w'\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwalk : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nw : sorry\nw' : sorry\nf : \u03b1 \u2192 \u03b2\n\u22a2 HEq sorry sorry"}, {"line": "  congr!", "tactic_state": ""}, {"line": "  guard_target = x = x'", "tactic_state": ""}]}
{"declaration": "example (w : walk \u03b1 x y) (w' : walk \u03b1 x' y') (f : \u03b1 \u2192 \u03b2) : HEq (w.map f) (w'.map f) := by\n  congr! with rfl rfl\n  guard_target = x = x'\n  exact test_sorry\n  guard_target = y = y'\n  exact test_sorry\n  guard_target = w = w'\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwalk : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nw : sorry\nw' : sorry\nf : \u03b1 \u2192 \u03b2\n\u22a2 HEq sorry sorry"}, {"line": "  congr! with rfl rfl", "tactic_state": ""}, {"line": "  guard_target = x = x'", "tactic_state": ""}]}
{"declaration": "example (s t : MySet \u03b1) (f g : \u03b1 \u2192 \u03b2) (h1 : s = t) (h2 : f = g) :\n    MySet.image f s = MySet.image g t := by\n  congr!\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nMySet : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\ns : sorry\nt : sorry\nf g : \u03b1 \u2192 \u03b2\nh1 : s = t\nh2 : f = g\n\u22a2 sorry = sorry"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "example (c : Prop \u2192 Prop \u2192 Prop \u2192 Prop) (x x' y z z' : Prop)\n    (h\u2080 : x \u2194 x') (h\u2081 : z \u2194 z') : c x y z \u2194 c x' y z' := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Prop \u2192 Prop \u2192 Prop \u2192 Prop\nx x' y z z' : Prop\nh\u2080 : x \u2194 x'\nh\u2081 : z \u2194 z'\n\u22a2 c x y z \u2194 c x' y z'"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4} {F : \u2200 {\u03b1 \u03b2}, (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4} {f g : \u03b1 \u2192 \u03b2} {s : \u03b3} (h : \u2200 (x : \u03b1), f x = g x) :\n    F f s = F g s := by\n  congr!\n  funext\n  apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nF : {\u03b1 : Sort u_1} \u2192 {\u03b2 : Sort u_2} \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : \u03b3\nh : \u2200 (x : \u03b1), f x = g x\n\u22a2 F f s = F g s"}, {"line": "  congr!", "tactic_state": "case h.e'_3\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nF : {\u03b1 : Sort u_1} \u2192 {\u03b2 : Sort u_2} \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : \u03b3\nh : \u2200 (x : \u03b1), f x = g x\n\u22a2 f = g"}, {"line": "  funext", "tactic_state": "case h.e'_3.h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nF : {\u03b1 : Sort u_1} \u2192 {\u03b2 : Sort u_2} \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : \u03b3\nh : \u2200 (x : \u03b1), f x = g x\nx\u271d : \u03b1\n\u22a2 f x\u271d = g x\u271d"}, {"line": "  apply h", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2} {f : _ \u2192 \u03b2} {x y : {x : {x : \u03b1 // x = x} // x = x}} (h : x.1 = y.1) :\n    f x = f y := by\n  congr! 1\n  ext1\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : { x // x = x } \u2192 \u03b2\nx y : { x // x = x }\nh : \u2191x = \u2191y\n\u22a2 f x = f y"}, {"line": "  congr! 1", "tactic_state": "case h.e'_1\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : { x // x = x } \u2192 \u03b2\nx y : { x // x = x }\nh : \u2191x = \u2191y\n\u22a2 x = y"}, {"line": "  ext1", "tactic_state": "case h.e'_1.a\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : { x // x = x } \u2192 \u03b2\nx y : { x // x = x }\nh : \u2191x = \u2191y\n\u22a2 \u2191x = \u2191y"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2} {F : _ \u2192 \u03b2} {f g : {f : \u03b1 \u2192 \u03b2 // f = f}}\n    (h : \u2200 x : \u03b1, (f : \u03b1 \u2192 \u03b2) x = (g : \u03b1 \u2192 \u03b2) x) :\n    F f = F g := by\n  congr!\n  ext x\n  apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nF : { f // f = f } \u2192 \u03b2\nf g : { f // f = f }\nh : \u2200 (x : \u03b1), \u2191f x = \u2191g x\n\u22a2 F f = F g"}, {"line": "  congr!", "tactic_state": "case h.e'_1\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nF : { f // f = f } \u2192 \u03b2\nf g : { f // f = f }\nh : \u2200 (x : \u03b1), \u2191f x = \u2191g x\n\u22a2 f = g"}, {"line": "  ext x", "tactic_state": "case h.e'_1.a.h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nF : { f // f = f } \u2192 \u03b2\nf g : { f // f = f }\nh : \u2200 (x : \u03b1), \u2191f x = \u2191g x\nx : \u03b1\n\u22a2 \u2191f x = \u2191g x"}, {"line": "  apply h", "tactic_state": ""}]}
{"declaration": "example {ls : List \u2115} :\n    ls.map (fun x => (ls.map (fun y => 1 + y)).sum + 1) =\n      ls.map (fun x => (ls.map (fun y => Nat.succ y)).sum + 1) := by\n  congr! 6 with - y\n  guard_target = 1 + y = y.succ\n  rw [Nat.add_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "ls : List \u2115\n\u22a2 List.map (fun x => (List.map (fun y => 1 + y) ls).sum + 1) ls =\n    List.map (fun x => (List.map (fun y => y.succ) ls).sum + 1) ls"}, {"line": "  congr! 6 with - y", "tactic_state": "case h.e'_3.h.h.e'_5.h.e'_4.h.e'_3.h\nls : List \u2115\ny : \u2115\n\u22a2 1 + y = y.succ"}, {"line": "  guard_target = 1 + y = y.succ", "tactic_state": "case h.e'_3.h.h.e'_5.h.e'_4.h.e'_3.h\nls : List \u2115\ny : \u2115\n\u22a2 1 + y = y.succ"}, {"line": "  rw [Nat.add_comm]", "tactic_state": ""}]}
{"declaration": "example {ls : List \u2115} {f g : \u2115 \u2192 \u2115} {h : \u2200 x, f x = g x} :\n    ls.map (fun x => f x + 3) = ls.map (fun x => g x + 3) := by\n  congr! 3 with x -- it's a little too powerful and will get to `f = g`\n  exact h x\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "ls : List \u2115\nf g : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = g x\n\u22a2 List.map (fun x => f x + 3) ls = List.map (fun x => g x + 3) ls"}, {"line": "  congr! 3 with x -- it's a little too powerful and will get to `f = g`", "tactic_state": "case h.e'_3.h.h.e'_5\nls : List \u2115\nf g : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = g x\nx : \u2115\n\u22a2 f x = g x"}, {"line": "  exact h x", "tactic_state": ""}]}
{"declaration": "example : () = () := by congr!", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 () = ()"}]}
{"declaration": "example : 0 = 0 := by congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 = 0"}]}
{"declaration": "example {\u03b1} (a : \u03b1) : a = a := by congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\na : \u03b1\n\u22a2 a = a"}]}
{"declaration": "example {\u03b1} (a b : \u03b1) (h : false) : a = b := by\n  fail_if_success { congr! }\n  cases h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\na b : \u03b1\nh : false = true\n\u22a2 a = b"}, {"line": "  fail_if_success { congr! }", "tactic_state": "\u03b1 : Sort u_1\na b : \u03b1\nh : false = true\n\u22a2 a = b"}, {"line": "  cases h", "tactic_state": ""}]}
{"declaration": "example (x y z : Nat) (h : x = z) (hy : y = 2) : 1 + x + y = g z + 2 := by\n  congr!\n  guard_target = HAdd.hAdd 1 = g\n  funext\n  simp [g, Nat.add_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ng : x\u271d\nx y z : \u2115\nh : x = z\nhy : y = 2\n\u22a2 1 + x + y = sorry + 2"}, {"line": "  congr!", "tactic_state": "case h.e'_5\nx\u271d : Sort u_1\ng : x\u271d\nx y z : \u2115\nh : x = z\nhy : y = 2\n\u22a2 1 + x = sorry"}, {"line": "  guard_target = HAdd.hAdd 1 = g", "tactic_state": "case h.e'_5\nx\u271d : Sort u_1\ng : x\u271d\nx y z : \u2115\nh : x = z\nhy : y = 2\n\u22a2 1 + x = sorry"}]}
{"declaration": "example (Fintype : Type \u2192 Type)\n    (\u03b1 \u03b2 : Type) (inst : Fintype \u03b1) (inst' : Fintype \u03b2) : HEq inst inst' := by\n  congr!\n  guard_target = HEq inst inst'\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Fintype : Type \u2192 Type\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "  congr!", "tactic_state": "Fintype : Type \u2192 Type\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "  guard_target = HEq inst inst'", "tactic_state": "Fintype : Type \u2192 Type\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (Fintype : Type \u2192 Type) [\u2200 \u03b3, Subsingleton (Fintype \u03b3)]\n    (\u03b1 \u03b2 : Type) (inst : Fintype \u03b1) (inst' : Fintype \u03b2) : HEq inst inst' := by\n  congr!\n  guard_target = \u03b1 = \u03b2\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Fintype : Type \u2192 Type\ninst\u271d : \u2200 (\u03b3 : Type), Subsingleton (Fintype \u03b3)\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "  congr!", "tactic_state": "case h.e'_1\nFintype : Type \u2192 Type\ninst\u271d\u00b9 : \u2200 (\u03b3 : Type), Subsingleton (Fintype \u03b3)\n\u03b1 \u03b2 : Type\ninst\u271d : Fintype \u03b1\ninst' : Fintype \u03b2\ninst : \u2200 (\u03b3 : Type), Lean.Meta.FastSubsingleton (Fintype \u03b3)\n\u22a2 \u03b1 = \u03b2"}, {"line": "  guard_target = \u03b1 = \u03b2", "tactic_state": "case h.e'_1\nFintype : Type \u2192 Type\ninst\u271d\u00b9 : \u2200 (\u03b3 : Type), Subsingleton (Fintype \u03b3)\n\u03b1 \u03b2 : Type\ninst\u271d : Fintype \u03b1\ninst' : Fintype \u03b2\ninst : \u2200 (\u03b3 : Type), Lean.Meta.FastSubsingleton (Fintype \u03b3)\n\u22a2 \u03b1 = \u03b2"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : n = m \u2192 3 + n = m + 3 := by\n  congr! 0 with rfl\n  guard_target = 3 + n = n + 3\n  apply add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 n = m \u2192 3 + n = m + 3"}, {"line": "  congr! 0 with rfl", "tactic_state": "n : \u2115\n\u22a2 3 + n = n + 3"}, {"line": "  guard_target = 3 + n = n + 3", "tactic_state": "n : \u2115\n\u22a2 3 + n = n + 3"}, {"line": "  apply add_comm", "tactic_state": ""}]}
{"declaration": "example (x y x' y' : Nat) (hx : x = x') (hy : y = y') : x + y = x' + y' := by\n  congr! (config := { closePre := false, closePost := false })\n  exact hx\n  exact hy\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 x + y = x' + y'"}, {"line": "  congr! (config := { closePre := false, closePost := false })", "tactic_state": "case h.e'_5\nx y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 x = x'\n---\ncase h.e'_6\nx y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 y = y'"}, {"line": "  exact hx", "tactic_state": "case h.e'_6\nx y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 y = y'"}, {"line": "  exact hy", "tactic_state": ""}]}
{"declaration": "example (x y x' : Nat) (hx : id x = id x') : x + y = x' + y := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' : \u2115\nhx : id x = id x'\n\u22a2 x + y = x' + y"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "example (x y x' : Nat) (hx : id x = id x') : x + y = x' + y := by\n  congr! (config := { closePost := false })\n  exact hx\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' : \u2115\nhx : id x = id x'\n\u22a2 x + y = x' + y"}, {"line": "  congr! (config := { closePost := false })", "tactic_state": "case h.e'_5\nx y x' : \u2115\nhx : id x = id x'\n\u22a2 x = x'"}, {"line": "  exact hx", "tactic_state": ""}]}
{"declaration": "example : { f : Nat \u2192 Nat // f = id } :=\n  \u27e8?_, by\n    -- prevents `rfl` from solving for `?m` in `?m = id`:\n    congr! (config := { closePre := false, closePost := false })\n    ext x\n    exact Nat.zero_add x\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ?m.58 = id"}, {"line": "  \u27e8?_, by", "tactic_state": "\u22a2 ?m.58 = id"}, {"line": "    -- prevents `rfl` from solving for `?m` in `?m = id`:", "tactic_state": "case h\nx : \u2115\n\u22a2 ?m.58 x = id x"}, {"line": "    congr! (config := { closePre := false, closePost := false })", "tactic_state": ""}]}
{"declaration": "example (h : z = y) : (x = y \u2228 x = z) \u2192 x = y := by\n  congr! with (rfl|rfl)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\nz y x : \u03b1\u271d\nh : z = y\n\u22a2 x = y \u2228 x = z \u2192 x = y"}, {"line": "  congr! with (rfl|rfl)", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [AddCommMonoid \u03b1] [PartialOrder \u03b1] {a b c d e f g : \u03b1} :\n    (a + b) + (c + d) + (e + f) + g \u2264 a + d + e + f + c + g + b := by\n  ac_change a + d + e + f + c + g + b \u2264 _; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g \u2264 a + d + e + f + c + g + b"}, {"line": "  ac_change a + d + e + f + c + g + b \u2264 _; rfl", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g = a + d + e + f + c + g + b\n---\ncase convert_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b"}]}
{"declaration": "example {\u03b1} [AddCommMonoid \u03b1] [PartialOrder \u03b1] {a b c d e f g : \u03b1} :\n    (a + b) + (c + d) + (e + f) + g \u2264 a + d + e + f + c + b + g := by\n  ac_change a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g \u2264 a + d + e + f + c + b + g"}, {"line": "  ac_change a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g = a + d + e + f + c + g + b\n---\ncase h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + b + g = a + d + e + f + c + g + b\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b"}, {"line": "  rfl", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g = a + d + e + f + c + g + b\n---\ncase h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + b + g = a + d + e + f + c + g + b\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b"}]}
{"declaration": "example : True := by\n  rsuffices \u27e8n : \u2115, h : n = n, -\u27e9 : \u2203 n : \u2115, n = n \u2227 True\n  \u00b7 guard_hyp n : \u2115\n    guard_hyp h : n = n\n    trivial\n  \u00b7 existsi 0\n    simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  rsuffices \u27e8n : \u2115, h : n = n, -\u27e9 : \u2203 n : \u2115, n = n \u2227 True", "tactic_state": "case intro.intro\nn : \u2115\nh : n = n\n\u22a2 True\n---\n\u22a2 \u2203 n, n = n \u2227 True"}, {"line": "  \u00b7 guard_hyp n : \u2115", "tactic_state": "case intro.intro\nn : \u2115\nh : n = n\n\u22a2 True"}, {"line": "    guard_hyp h : n = n", "tactic_state": "case intro.intro\nn : \u2115\nh : n = n\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 existsi 0", "tactic_state": "\u22a2 0 = 0 \u2227 True"}, {"line": "    simp", "tactic_state": ""}]}
{"declaration": "example : True := by\n  rsuffices : \u2203 n : \u2115, n = n \u2227 True\n  \u00b7 trivial\n  \u00b7 existsi 0\n    simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  rsuffices : \u2203 n : \u2115, n = n \u2227 True", "tactic_state": "this\u271d : \u2203 n, n = n \u2227 True\n\u22a2 True\n---\n\u22a2 \u2203 n, n = n \u2227 True"}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 existsi 0", "tactic_state": "\u22a2 0 = 0 \u2227 True"}, {"line": "    simp", "tactic_state": ""}]}
{"declaration": "example : True := by\n  rsuffices (h : True) | \u27e8\u27e8\u27e9\u27e9 : True \u2228 False\n  \u00b7 guard_hyp h : True\n    trivial\n  \u00b7 left\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  rsuffices (h : True) | \u27e8\u27e8\u27e9\u27e9 : True \u2228 False", "tactic_state": "case inl\nh : True\n\u22a2 True\n---\n\u22a2 True \u2228 False"}, {"line": "  \u00b7 guard_hyp h : True", "tactic_state": "case inl\nh : True\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 left", "tactic_state": "case h\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}]}
{"declaration": "example (x y : \u03b1 \u00d7 \u03b2) : True := by\n  rsuffices \u27e8\u27e8a, b\u27e9, c, d\u27e9 : (\u03b1 \u00d7 \u03b2) \u00d7 (\u03b1 \u00d7 \u03b2)\n  \u00b7 guard_hyp a : \u03b1\n    guard_hyp b : \u03b2\n    guard_hyp c : \u03b1\n    guard_hyp d : \u03b2\n    trivial\n  \u00b7 exact \u27e8x, y\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 True"}, {"line": "  rsuffices \u27e8\u27e8a, b\u27e9, c, d\u27e9 : (\u03b1 \u00d7 \u03b2) \u00d7 (\u03b1 \u00d7 \u03b2)", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2"}, {"line": "  \u00b7 guard_hyp a : \u03b1", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp b : \u03b2", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp c : \u03b1", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp d : \u03b2", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 exact \u27e8x, y\u27e9", "tactic_state": ""}]}
{"declaration": "example (x y : \u03b1 \u2295 \u03b2) : True := by\n  rsuffices \u27e8a|b, c|d\u27e9 : (\u03b1 \u2295 \u03b2) \u00d7 (\u03b1 \u2295 \u03b2)\n  \u00b7 guard_hyp a : \u03b1\n    guard_hyp c : \u03b1\n    trivial\n  \u00b7 guard_hyp a : \u03b1\n    guard_hyp d : \u03b2\n    trivial\n  \u00b7 guard_hyp b : \u03b2\n    guard_hyp c : \u03b1\n    trivial\n  \u00b7 guard_hyp b : \u03b2\n    guard_hyp d : \u03b2\n    trivial\n  exact \u27e8x, y\u27e9\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 True"}, {"line": "  rsuffices \u27e8a|b, c|d\u27e9 : (\u03b1 \u2295 \u03b2) \u00d7 (\u03b1 \u2295 \u03b2)", "tactic_state": "case mk.inl.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na c : \u03b1\n\u22a2 True\n---\ncase mk.inl.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na : \u03b1\nd : \u03b2\n\u22a2 True\n---\ncase mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb : \u03b2\nc : \u03b1\n\u22a2 True\n---\ncase mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb d : \u03b2\n\u22a2 True\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 (\u03b1 \u2295 \u03b2) \u00d7 (\u03b1 \u2295 \u03b2)"}, {"line": "  \u00b7 guard_hyp a : \u03b1", "tactic_state": "case mk.inl.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na c : \u03b1\n\u22a2 True"}, {"line": "    guard_hyp c : \u03b1", "tactic_state": "case mk.inl.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na c : \u03b1\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp a : \u03b1", "tactic_state": "case mk.inl.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp d : \u03b2", "tactic_state": "case mk.inl.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp b : \u03b2", "tactic_state": "case mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb : \u03b2\nc : \u03b1\n\u22a2 True"}, {"line": "    guard_hyp c : \u03b1", "tactic_state": "case mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb : \u03b2\nc : \u03b1\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp b : \u03b2", "tactic_state": "case mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb d : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp d : \u03b2", "tactic_state": "case mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb d : \u03b2\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  exact \u27e8x, y\u27e9", "tactic_state": ""}]}
{"declaration": "example {\u03b1} (V : Set \u03b1) (w : True \u2192 \u2203 p, p \u2208 (V.foo V) \u2229 (V.foo V)) : True := by\n  rsuffices \u27e8_, _\u27e9 : \u2203 p, p \u2208 (V.foo V) \u2229 (V.foo V)\n  \u00b7 trivial\n  \u00b7 exact w trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nV : Set \u03b1\nw : True \u2192 \u2203 p, p \u2208 sorry \u2229 sorry\n\u22a2 True"}, {"line": "  rsuffices \u27e8_, _\u27e9 : \u2203 p, p \u2208 (V.foo V) \u2229 (V.foo V)", "tactic_state": "case intro\n\u03b1 : Type u_1\nV : Set \u03b1\nw : True \u2192 \u2203 p, p \u2208 sorry \u2229 sorry\nw\u271d : ?m.625\nh\u271d : w\u271d \u2208 sorry \u2229 sorry\n\u22a2 True\n---\n\u03b1 : Type u_1\nV : Set \u03b1\nw : True \u2192 \u2203 p, p \u2208 sorry \u2229 sorry\n\u22a2 \u2203 p, p \u2208 sorry \u2229 sorry"}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 exact w trivial", "tactic_state": ""}]}
{"declaration": "example (a : Nat) (b : Int) : Int \u00d7 Nat := by\n  rename' a => c, b => d\n  exact (d, c)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rename.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\nb : \u2124\n\u22a2 \u2124 \u00d7 \u2115"}, {"line": "  rename' a => c, b => d", "tactic_state": "c : \u2115\nd : \u2124\n\u22a2 \u2124 \u00d7 \u2115"}, {"line": "  exact (d, c)", "tactic_state": ""}]}
{"declaration": "example (a : Nat) (b : Int) : Int \u00d7 Nat := by\n  rename' a => b, b => a\n  exact (a, b)", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rename.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\nb : \u2124\n\u22a2 \u2124 \u00d7 \u2115"}, {"line": "  rename' a => b, b => a", "tactic_state": "b : \u2115\na : \u2124\n\u22a2 \u2124 \u00d7 \u2115"}, {"line": "  exact (a, b)", "tactic_state": ""}]}
{"declaration": "example (a b : ENat) (h : a = b) : a - b = b - a := by\n  enat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\u221e\nh : a = b\n\u22a2 a - b = b - a"}, {"line": "  enat_to_nat", "tactic_state": "case coe.coe\na b : \u2115\nh : a = b\n\u22a2 a - b = b - a"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example (a b : ENat) (h : a \u2264 b) : a - b < b + 1 := by\n  enat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\u221e\nh : a \u2264 b\n\u22a2 a - b < b + 1"}, {"line": "  enat_to_nat", "tactic_state": "case coe.coe\na b : \u2115\nh : a \u2264 b\n\u22a2 a - b < b + 1"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example (a b : ENat) (h : a \u2264 b) : a - 2 * b \u2264 b + 1 := by\n  enat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\u221e\nh : a \u2264 b\n\u22a2 a - 2 * b \u2264 b + 1"}, {"line": "  enat_to_nat", "tactic_state": "case coe.coe\na b : \u2115\nh : a \u2264 b\n\u22a2 a - 2 * b \u2264 b + 1"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example (a b c : ENat) (hab : a \u2265 b) (hbc : b \u2265 c) : a \u2265 c := by\n  enat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\u221e\nhab : a \u2265 b\nhbc : b \u2265 c\n\u22a2 a \u2265 c"}, {"line": "  enat_to_nat", "tactic_state": "case coe.coe.coe\na b c : \u2115\nhab : b \u2264 a\nhbc : c \u2264 b\n\u22a2 c \u2264 a"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example (a b : ENat) (h : a = b) : a - b = b - a := by\n  -- to test if the tactic works with inaccessible names\n  let a : \u2124 := 42\n  let b : \u2124 := 32\n  enat_to_nat\n  omega", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\u221e\nh : a = b\n\u22a2 a - b = b - a"}, {"line": "  -- to test if the tactic works with inaccessible names", "tactic_state": "a\u271d b : \u2115\u221e\nh : a\u271d = b\na : \u2124 := 42\n\u22a2 a\u271d - b = b - a\u271d"}, {"line": "  let a : \u2124 := 42", "tactic_state": "a\u271d b\u271d : \u2115\u221e\nh : a\u271d = b\u271d\na : \u2124 := 42\nb : \u2124 := 32\n\u22a2 a\u271d - b\u271d = b\u271d - a\u271d"}, {"line": "  let b : \u2124 := 32", "tactic_state": "case coe.coe\na : \u2124 := 42\nb : \u2124 := 32\na\u271d\u00b9 a\u271d : \u2115\nh : a\u271d\u00b9 = a\u271d\n\u22a2 a\u271d\u00b9 - a\u271d = a\u271d - a\u271d\u00b9"}, {"line": "  enat_to_nat", "tactic_state": ""}]}
{"declaration": "example {x : Nat} (h : x \u2208 [0, 2, 37]) : x \u2264 57 := by\n  fin_cases h\n  repeat decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x \u2208 [0, 2, 37]\n\u22a2 x \u2264 57"}, {"line": "  fin_cases h", "tactic_state": "case \u00ab0\u00bb\n\u22a2 0 \u2264 57\n---\ncase \u00ab1\u00bb\n\u22a2 2 \u2264 57\n---\ncase \u00ab2\u00bb\n\u22a2 37 \u2264 57"}, {"line": "  repeat decide", "tactic_state": ""}]}
{"declaration": "example {x : Nat} (h : x \u2208 [0, 2, 37]) : x = 0 \u2228 x = 2 \u2228 x = 37 := by\n  fin_cases h\n  repeat simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x \u2208 [0, 2, 37]\n\u22a2 x = 0 \u2228 x = 2 \u2228 x = 37"}, {"line": "  fin_cases h", "tactic_state": "case \u00ab0\u00bb\n\u22a2 0 = 0 \u2228 0 = 2 \u2228 0 = 37\n---\ncase \u00ab1\u00bb\n\u22a2 2 = 0 \u2228 2 = 2 \u2228 2 = 37\n---\ncase \u00ab2\u00bb\n\u22a2 37 = 0 \u2228 37 = 2 \u2228 37 = 37"}, {"line": "  repeat simp", "tactic_state": ""}]}
{"declaration": "example {x : Nat} (h : x \u2208 List.range 5) : x \u2264 4 := by\n  fin_cases h\n  repeat decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x \u2208 List.range 5\n\u22a2 x \u2264 4"}, {"line": "  fin_cases h", "tactic_state": "case \u00ab0\u00bb\n\u22a2 0 \u2264 4\n---\ncase \u00ab1\u00bb\n\u22a2 1 \u2264 4\n---\ncase \u00ab2\u00bb\n\u22a2 2 \u2264 4\n---\ncase \u00ab3\u00bb\n\u22a2 3 \u2264 4\n---\ncase \u00ab4\u00bb\n\u22a2 4 \u2264 4"}, {"line": "  repeat decide", "tactic_state": ""}]}
{"declaration": "example {p : Fin 4 \u2192 Prop} (i : Fin 4) (h : p i) : p i := by\n  fin_cases i\n  repeat exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Fin 4 \u2192 Prop\ni : Fin 4\nh : p i\n\u22a2 p i"}, {"line": "  fin_cases i", "tactic_state": "case \u00ab0\u00bb\np : Fin 4 \u2192 Prop\nh : p ((fun i => i) \u27e80, \u22ef\u27e9)\n\u22a2 p ((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb\np : Fin 4 \u2192 Prop\nh : p ((fun i => i) \u27e81, \u22ef\u27e9)\n\u22a2 p ((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab2\u00bb\np : Fin 4 \u2192 Prop\nh : p ((fun i => i) \u27e82, \u22ef\u27e9)\n\u22a2 p ((fun i => i) \u27e82, \u22ef\u27e9)\n---\ncase \u00ab3\u00bb\np : Fin 4 \u2192 Prop\nh : p ((fun i => i) \u27e83, \u22ef\u27e9)\n\u22a2 p ((fun i => i) \u27e83, \u22ef\u27e9)"}, {"line": "  repeat exact h", "tactic_state": ""}]}
{"declaration": "example (f : Nat \u2192 Prop) (p : Fin 3) (h0 : f 0) (h1 : f 1) (h2 : f 2) : f p.val := by\n  fin_cases p\n  all_goals\n    assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 Prop\np : Fin 3\nh0 : f 0\nh1 : f 1\nh2 : f 2\n\u22a2 f \u2191p"}, {"line": "  fin_cases p", "tactic_state": "case \u00ab0\u00bb\nf : \u2115 \u2192 Prop\nh0 : f 0\nh1 : f 1\nh2 : f 2\n\u22a2 f \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb\nf : \u2115 \u2192 Prop\nh0 : f 0\nh1 : f 1\nh2 : f 2\n\u22a2 f \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab2\u00bb\nf : \u2115 \u2192 Prop\nh0 : f 0\nh1 : f 1\nh2 : f 2\n\u22a2 f \u2191((fun i => i) \u27e82, \u22ef\u27e9)"}, {"line": "  all_goals", "tactic_state": ""}]}
{"declaration": "example (f : Nat \u2192 Prop) (p : Fin 0) : f p.val := by\n  fin_cases p\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 Prop\np : Fin 0\n\u22a2 f \u2191p"}, {"line": "  fin_cases p", "tactic_state": ""}]}
{"declaration": "example (x2 : Fin 2) (x3 : Fin 3) : True := by\n  fin_cases x2, x3\n  all_goals trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x2 : Fin 2\nx3 : Fin 3\n\u22a2 True"}, {"line": "  fin_cases x2, x3", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\n\u22a2 True\n---\ncase \u00ab0\u00bb.\u00ab2\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab2\u00bb\n\u22a2 True"}, {"line": "  all_goals trivial", "tactic_state": ""}]}
{"declaration": "example (p : \u2115) (h2 : 2 < p) (h5 : p < 5) : p = 3 \u2228 p = 4 := by\n  have hp : ?_ := ?foo\n  case foo => exact (Finset.mem_Ioo).2 \u27e8h2, h5\u27e9\n  fin_cases hp\n  \u00b7 norm_num\n  \u00b7 norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nh2 : 2 < p\nh5 : p < 5\n\u22a2 p = 3 \u2228 p = 4"}, {"line": "  have hp : ?_ := ?foo", "tactic_state": "case refine_2\np : \u2115\nh2 : 2 < p\nh5 : p < 5\nhp : ?refine_1\n\u22a2 p = 3 \u2228 p = 4\n---\ncase refine_1\np : \u2115\nh2 : 2 < p\nh5 : p < 5\n\u22a2 Sort ?u.129\n---\ncase foo\np : \u2115\nh2 : 2 < p\nh5 : p < 5\n\u22a2 ?refine_1"}, {"line": "  case foo => exact (Finset.mem_Ioo).2 \u27e8h2, h5\u27e9", "tactic_state": "case refine_2\np : \u2115\nh2 : 2 < p\nh5 : p < 5\nhp : p \u2208 Finset.Ioo 2 5\n\u22a2 p = 3 \u2228 p = 4"}, {"line": "  fin_cases hp", "tactic_state": "case refine_2.\u00ab0\u00bb\nh2 : 2 < 2 + 1\nh5 : 2 + 1 < 5\n\u22a2 2 + 1 = 3 \u2228 2 + 1 = 4\n---\ncase refine_2.\u00ab1\u00bb\nh2 : 2 < 2 + 1 + 1\nh5 : 2 + 1 + 1 < 5\n\u22a2 2 + 1 + 1 = 3 \u2228 2 + 1 + 1 = 4"}, {"line": "  \u00b7 norm_num", "tactic_state": ""}, {"line": "  \u00b7 norm_num", "tactic_state": ""}]}
{"declaration": "example (x y : Fin 2): True := by\n  fin_cases x, y\n  trace_state\n  all_goals trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Fin 2\n\u22a2 True"}, {"line": "  fin_cases x, y", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\n\u22a2 True"}, {"line": "  trace_state", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\n\u22a2 True"}, {"line": "  all_goals trivial", "tactic_state": ""}]}
{"declaration": "example (x2 : Fin 2) (x3 : Fin 3) (n : Nat) (y : Fin n) : x2.val * x3.val = x3.val * x2.val := by\n  fin_cases x2 <;> fin_cases x3\n  fail_if_success\n    fin_cases y\n  all_goals rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x2 : Fin 2\nx3 : Fin 3\nn : \u2115\ny : Fin n\n\u22a2 \u2191x2 * \u2191x3 = \u2191x3 * \u2191x2"}, {"line": "  fin_cases x2 <;> fin_cases x3", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9) = \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9) = \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab0\u00bb.\u00ab2\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e82, \u22ef\u27e9) = \u2191((fun i => i) \u27e82, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9) = \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9) = \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab2\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e82, \u22ef\u27e9) = \u2191((fun i => i) \u27e82, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)"}, {"line": "  fail_if_success", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9) = \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9) = \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab0\u00bb.\u00ab2\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e82, \u22ef\u27e9) = \u2191((fun i => i) \u27e82, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9) = \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9) = \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab2\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e82, \u22ef\u27e9) = \u2191((fun i => i) \u27e82, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)"}, {"line": "    fin_cases y", "tactic_state": ""}]}
{"declaration": "example : List.nthLe [1, 2] 1 (by simp) = 2 := by\n  generalize_proofs h\n  guard_hyp h :\u209b 1 < List.length [1, 2]\n  guard_target =\u209b [1, 2].nthLe 1 h = 2\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 2"}, {"line": "  generalize_proofs h", "tactic_state": "\u22a2 sorry = 2"}, {"line": "  guard_hyp h :\u209b 1 < List.length [1, 2]", "tactic_state": "\u22a2 sorry = 2"}]}
{"declaration": "example (x : \u2115) (h : x < 2) : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) < 2 := by\n  generalize_proofs a\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_target =\u209b Classical.choose a < 2\n  exact Classical.choose_spec a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef < 2"}, {"line": "  generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_target =\u209b Classical.choose a < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  exact Classical.choose_spec a", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) := by\n  generalize_proofs a\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_target =\u209b Classical.choose a = Classical.choose a\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  guard_target =\u209b Classical.choose a = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) (h' : x < 1) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n      = Classical.choose (\u27e8x, (by clear h; omega)\u27e9 : \u2203 x, x < 2) := by\n  generalize_proofs a\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_target =\u209b Classical.choose a = Classical.choose a\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\n\u22a2 x < 2"}, {"line": "  generalize_proofs a", "tactic_state": "x : \u2115\nh' : x < 1\n\u22a2 x < 2"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": ""}, {"line": "  guard_target =\u209b Classical.choose a = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  rfl", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}]}
{"declaration": "example (x : \u2115) (h h' : x < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h'\u27e9 : \u2203 x, x < 2) := by\n  change _ at h'\n  fail_if_success guard_target =\u209b\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n  generalize_proofs at h'\n  fail_if_success change _ at h'\n  guard_target =\u209b Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n  generalize_proofs a\n  guard_target =\u209b Classical.choose a = Classical.choose a\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh h' : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  change _ at h'", "tactic_state": "x : \u2115\nh h' : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  fail_if_success guard_target =\u209b", "tactic_state": "x : \u2115\nh h' : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs at h'", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  fail_if_success change _ at h'", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  guard_target =\u209b Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  guard_target =\u209b Classical.choose a = Classical.choose a", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n      = Classical.choose (\u27e8x, Nat.lt_succ_of_lt h\u27e9 : \u2203 x, x < 3) := by\n  generalize_proofs a a'\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_hyp a' :\u209b \u2203 x, x < 3\n  guard_target =\u209b Classical.choose a = Classical.choose a'\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs a a'", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "  guard_hyp a' :\u209b \u2203 x, x < 3", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "  guard_target =\u209b Classical.choose a = Classical.choose a'", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) =\n  Classical.choose (\u27e8x, Nat.lt_succ_of_lt h\u27e9 : \u2203 x, x < 3) := by\n  generalize_proofs\n  guard_target = Classical.choose _ = Classical.choose _\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d\u00b9 : \u2203 x, x < 2\npf\u271d : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d\u00b9 = Classical.choose pf\u271d"}, {"line": "  guard_target = Classical.choose _ = Classical.choose _", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d\u00b9 : \u2203 x, x < 2\npf\u271d : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d\u00b9 = Classical.choose pf\u271d"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) =\n  Classical.choose (\u27e8x, Nat.lt_succ_of_lt h\u27e9 : \u2203 x, x < 3) := by\n  generalize_proofs _ a\n  guard_hyp a : \u2203 x, x < 3\n  guard_target = Classical.choose _ = Classical.choose a\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs _ a", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d : \u2203 x, x < 2\na : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d = Classical.choose a"}, {"line": "  guard_hyp a : \u2203 x, x < 3", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d : \u2203 x, x < 2\na : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d = Classical.choose a"}, {"line": "  guard_target = Classical.choose _ = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d : \u2203 x, x < 2\na : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d = Classical.choose a"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (a : \u2203 x, x < 2) : Classical.choose a < 2 := by\n  generalize_proofs\n  guard_target =\u209b Classical.choose a < 2\n  exact Classical.choose_spec a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  generalize_proofs", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_target =\u209b Classical.choose a < 2", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  exact Classical.choose_spec a", "tactic_state": ""}]}
{"declaration": "example (a : \u2203 x, x < 2) : Classical.choose a < 2 := by\n  generalize_proofs t\n  guard_target =\u209b Classical.choose a < 2\n  exact Classical.choose_spec a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  generalize_proofs t", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_target =\u209b Classical.choose a < 2", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  exact Classical.choose_spec a", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) (H : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) < 2 := by\n  generalize_proofs a at H \u22a2\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_hyp H :\u209b Classical.choose a < 2\n  guard_target =\u209b Classical.choose a < 2\n  exact H\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\nH : Classical.choose \u22ef < 2\n\u22a2 Classical.choose \u22ef < 2"}, {"line": "  generalize_proofs a at H \u22a2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_hyp H :\u209b Classical.choose a < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_target =\u209b Classical.choose a < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  exact H", "tactic_state": ""}]}
{"declaration": "example (H : \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y) :\n    \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y := by\n  generalize_proofs (config := { abstract := false })\n  guard_target =\u209b \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y\n  generalize_proofs a at H \u22a2\n  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y\n  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  exact H\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  generalize_proofs (config := { abstract := false })", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_target =\u209b \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  generalize_proofs a at H \u22a2", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  exact H", "tactic_state": ""}]}
{"declaration": "example (H : \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y) :\n    \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y := by\n  generalize_proofs a at *\n  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y\n  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  exact H\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  generalize_proofs a at *", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  exact H", "tactic_state": ""}]}
{"declaration": "example [Ring R] (S : Subring R) (hx : x \u2208 S) (hy : y \u2208 S) (hz : z \u2208 S) (n m : \u2115) :\n    n \u2022 x ^ 3 - 2 \u2022 y + z ^ m \u2208 S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nR : Type u_1\nx y z : R\ninst\u271d : Ring R\nS : Subring R\nhx : x \u2208 S\nhy : y \u2208 S\nhz : z \u2208 S\nn m : \u2115\n\u22a2 n \u2022 x ^ 3 - 2 \u2022 y + z ^ m \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Ring R] (S : Set R) (hx : x \u2208 S) (hy : y \u2208 S) (hz : z \u2208 S) (n m : \u2115) :\n    n \u2022 x ^ 3 - y + z ^ m \u2208 Subring.closure S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nR : Type u_1\nx y z : R\ninst\u271d : Ring R\nS : Set R\nhx : x \u2208 S\nhy : y \u2208 S\nhz : z \u2208 S\nn m : \u2115\n\u22a2 n \u2022 x ^ 3 - y + z ^ m \u2208 Subring.closure S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [CommRing R] [Ring A] [Algebra R A] [StarRing R] [StarRing A] [StarModule R A]\n    (r : R) (a b c : A) (n : \u2115) :\n    -b + star (algebraMap R A r) + a ^ n * c \u2208 StarAlgebra.adjoin R {a, b, c} := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u2076 : Monoid M\nS S' : Submonoid M\nR : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : StarRing R\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\nr : R\na b c : A\nn : \u2115\n\u22a2 -b + star ((algebraMap R A) r) + a ^ n * c \u2208 StarAlgebra.adjoin R {a, b, c}"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x : M) (n : \u2115) : x ^ n \u2208 Submonoid.closure {x} := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Monoid M\nx : M\nn : \u2115\n\u22a2 x ^ n \u2208 Submonoid.closure {x}"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x y z w : M) (n : \u2115) : (x * y) ^ n * w \u2208 Submonoid.closure {x, y, z, w} := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Monoid M\nx y z w : M\nn : \u2115\n\u22a2 (x * y) ^ n * w \u2208 Submonoid.closure {x, y, z, w}"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Group M] (x : M) (n : \u2124) : x ^ n \u2208 Subgroup.closure {x} := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Group M\nx : M\nn : \u2124\n\u22a2 x ^ n \u2208 Subgroup.closure {x}"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x y z : M) (S\u2081 S\u2082 : Submonoid M) (h : S\u2081 \u2264 S\u2082) (hx : x \u2208 S\u2081)\n    (hy : y \u2208 S\u2081) (hz : z \u2208 S\u2082) :\n    x * y * z \u2208 S\u2082 := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Monoid M\nx y z : M\nS\u2081 S\u2082 : Submonoid M\nh : S\u2081 \u2264 S\u2082\nhx : x \u2208 S\u2081\nhy : y \u2208 S\u2081\nhz : z \u2208 S\u2082\n\u22a2 x * y * z \u2208 S\u2082"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x y z : M) (S\u2081 S\u2082 : Submonoid M) (h : S\u2081 \u2264 S\u2082) (hx : x \u2208 S\u2081)\n    (hy : y \u2208 S\u2081) (hz : z \u2208 S\u2082) :\n    x * y * z \u2208 S\u2081 \u2294 S\u2082 := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Monoid M\nx y z : M\nS\u2081 S\u2082 : Submonoid M\nh : S\u2081 \u2264 S\u2082\nhx : x \u2208 S\u2081\nhy : y \u2208 S\u2081\nhz : z \u2208 S\u2082\n\u22a2 x * y * z \u2208 S\u2081 \u2294 S\u2082"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x y z : M) (S : Submonoid M) (hxy : x * y \u2208 S) (hz : z \u2208 S) :\n    z * (x * y) \u2208 S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\ninst\u271d : Monoid M\nx y z : M\nS : Submonoid M\nhxy : x * y \u2208 S\nhz : z \u2208 S\n\u22a2 z * (x * y) \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Field F] (S : Subfield F) (q : \u211a) : (q : F) \u2208 S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nF : Type u_1\ninst\u271d : Field F\nS : Subfield F\nq : \u211a\n\u22a2 \u2191q \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Field F] (S : Subfield F) : (1.2 : F) \u2208 S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nF : Type u_1\ninst\u271d : Field F\nS : Subfield F\n\u22a2 1.2 \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Field F] (S : Subfield F) (x : F) (hx : x \u2208 S) : ((12e-100 : F) \u2022 x\u207b\u00b9) \u2208 S := by\n  aesop", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nF : Type u_1\ninst\u271d : Field F\nS : Subfield F\nx : F\nhx : x \u2208 S\n\u22a2 12e-100 \u2022 x\u207b\u00b9 \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "theorem bar0_works : bar0 3 4 = 7 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar0 : x\u271d\n\u22a2 sorry = 7"}]}
{"declaration": "theorem foo1_works : foo1 3 4 = Nat.pow 3 4 := by decide", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfoo1 : x\u271d\n\u22a2 sorry = Nat.pow 3 4"}]}
{"declaration": "theorem bar1_works : bar1 3 4 = 3 * 4 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar1 : x\u271d\n\u22a2 sorry = 3 * 4"}]}
{"declaration": "theorem foo2_works : foo2 2 3 (PLift.up 2) = Nat.pow 2 5 := by decide", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfoo2 : x\u271d\n\u22a2 sorry = Nat.pow 2 5"}]}
{"declaration": "theorem bar2_works : bar2 2 3 (PLift.up 2) = 2 * 5 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar2 : x\u271d\n\u22a2 sorry = 2 * 5"}]}
{"declaration": "theorem foo3_works : foo3 2 3 = Nat.pow 2 3 := by decide", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfoo3 : x\u271d\n\u22a2 sorry = Nat.pow 2 3"}]}
{"declaration": "theorem bar3_works : bar3 2 3 = 2 * 3 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar3 : x\u271d\n\u22a2 sorry = 2 * 3"}]}
{"declaration": "theorem bar8_works : bar8 2 3 = 6 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar8 : x\u271d\n\u22a2 sorry = 6"}]}
{"declaration": "theorem bar9_works : bar9 = 1 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "bar9 : \u2115\n\u22a2 bar9 = 1"}]}
{"declaration": "example [Group \u03b1] (x : \u03b1) : foo17 x = 1 * x := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nfoo17 : x\u271d\ninst\u271d : Group \u03b1\nx : \u03b1\n\u22a2 sorry = 1 * x"}]}
{"declaration": "example [Group \u03b1] (x : \u03b1) : foo17 x = x := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nfoo17 : x\u271d\ninst\u271d : Group \u03b1\nx : \u03b1\n\u22a2 sorry = x"}]}
{"declaration": "example [AddGroup \u03b1] (x : \u03b1) : bar17 x = 0 + x := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nbar17 : x\u271d\ninst\u271d : AddGroup \u03b1\nx : \u03b1\n\u22a2 sorry = 0 + x"}]}
{"declaration": "example [AddGroup \u03b1] (x : \u03b1) : bar17 x = x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nbar17 : x\u271d\ninst\u271d : AddGroup \u03b1\nx : \u03b1\n\u22a2 sorry = x"}]}
{"declaration": "example {x} (h : 1 = x) : foo19 = x := by simp; guard_target = 1 = x; exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo19 x : \u2115\nh : 1 = x\n\u22a2 foo19 = x"}]}
{"declaration": "example {x} (h : 1 = x) : bar19 = x := by simp; guard_target = 1 = x; exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "bar19 x : \u2115\nh : 1 = x\n\u22a2 bar19 = x"}]}
{"declaration": "example {x} (h : 1 = x) : baz19 = x := by simp; guard_target = 1 = x; exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "baz19 x : \u2115\nh : 1 = x\n\u22a2 baz19 = x"}]}
{"declaration": "example {x} (h : 1 = x) : foo20 = x := by simp; guard_target = 1 = x; exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo20 x : \u2115\nh : 1 = x\n\u22a2 foo20 = x"}]}
{"declaration": "example {x} (h : 1 = x) : bar20 = x := by simp; guard_target = 1 = x; exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "bar20 x : \u2115\nh : 1 = x\n\u22a2 bar20 = x"}]}
{"declaration": "example {x} (h : 1 = x) : baz20 = x := by simp; guard_target = 1 = x; exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "baz20 x : \u2115\nh : 1 = x\n\u22a2 baz20 = x"}]}
{"declaration": "example [TopologicalSpace \u03b1] [inst : MeasurableSpace \u03b1] [BorelSpace \u03b1] :\n    MeasurableSet (\u2205 : Set \u03b1) := by\n  guard_target = @MeasurableSet \u03b1 inst \u2205\n  borelize \u03b1\n  guard_target = @MeasurableSet \u03b1 (borel \u03b1) \u2205\n  apply MeasurableSet.empty\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst : MeasurableSpace \u03b1\ninst\u271d : BorelSpace \u03b1\n\u22a2 MeasurableSet \u2205"}, {"line": "  guard_target = @MeasurableSet \u03b1 inst \u2205", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst : MeasurableSpace \u03b1\ninst\u271d : BorelSpace \u03b1\n\u22a2 MeasurableSet \u2205"}, {"line": "  borelize \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : BorelSpace \u03b1\nthis\u271d : MeasurableSpace \u03b1 := borel \u03b1\n\u22a2 MeasurableSet \u2205"}, {"line": "  guard_target = @MeasurableSet \u03b1 (borel \u03b1) \u2205", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : BorelSpace \u03b1\nthis\u271d : MeasurableSpace \u03b1 := borel \u03b1\n\u22a2 MeasurableSet \u2205"}, {"line": "  apply MeasurableSet.empty", "tactic_state": ""}]}
{"declaration": "example [TopologicalSpace \u03b1] : True := by\n  borelize \u03b1\n  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty\n  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 True"}, {"line": "  borelize \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\n\u22a2 True"}, {"line": "  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  obtain \u27e8\u03b1, \u27e8h\u03b1\u27e9\u27e9 : \u2203 \u03b1 : Type, Nonempty (TopologicalSpace \u03b1) := \u27e8\u2115, \u27e8inferInstance\u27e9\u27e9\n  borelize \u03b1\n  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty\n  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  obtain \u27e8\u03b1, \u27e8h\u03b1\u27e9\u27e9 : \u2203 \u03b1 : Type, Nonempty (TopologicalSpace \u03b1) := \u27e8\u2115, \u27e8inferInstance\u27e9\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type\nh\u03b1 : TopologicalSpace \u03b1\n\u22a2 True"}, {"line": "  borelize \u03b1", "tactic_state": "case intro.intro\n\u03b1 : Type\nh\u03b1 : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\n\u22a2 True"}, {"line": "  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty", "tactic_state": "case intro.intro\n\u03b1 : Type\nh\u03b1 : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205", "tactic_state": "case intro.intro\n\u03b1 : Type\nh\u03b1 : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  set \u03b1 := \u2115\n  borelize \u03b1\n  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty\n  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  set \u03b1 := \u2115", "tactic_state": "\u03b1 : Type := \u2115\n\u22a2 True"}, {"line": "  borelize \u03b1", "tactic_state": "\u03b1 : Type := \u2115\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\n\u22a2 True"}, {"line": "  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty", "tactic_state": "\u03b1 : Type := \u2115\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205", "tactic_state": "\u03b1 : Type := \u2115\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  have h1 : MeasurableSet (\u2205 : Set \u2115) := MeasurableSet.empty\n  guard_hyp h1 : @MeasurableSet \u2115 Nat.instMeasurableSpace \u2205\n  borelize \u2115\n  have h2 : MeasurableSet (\u2205 : Set \u2115) := MeasurableSet.empty\n  guard_hyp h2 : @MeasurableSet \u2115 (borel \u2115) \u2205\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have h1 : MeasurableSet (\u2205 : Set \u2115) := MeasurableSet.empty", "tactic_state": "h1 : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h1 : @MeasurableSet \u2115 Nat.instMeasurableSpace \u2205", "tactic_state": "h1 : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  borelize \u2115", "tactic_state": "h1 : MeasurableSet \u2205\nthis\u271d\u00b9 : MeasurableSpace \u2115 := borel \u2115\nthis\u271d : BorelSpace \u2115\n\u22a2 True"}, {"line": "  have h2 : MeasurableSet (\u2205 : Set \u2115) := MeasurableSet.empty", "tactic_state": "h1 : MeasurableSet \u2205\nthis\u271d\u00b9 : MeasurableSpace \u2115 := borel \u2115\nthis\u271d : BorelSpace \u2115\nh2 : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h2 : @MeasurableSet \u2115 (borel \u2115) \u2205", "tactic_state": "h1 : MeasurableSet \u2205\nthis\u271d\u00b9 : MeasurableSpace \u2115 := borel \u2115\nthis\u271d : BorelSpace \u2115\nh2 : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : id (1 = 1) := by\n  with_reducible whnf\n  guard_target =\u209b id (1 = 1)\n  whnf\n  guard_target =\u209b 1 = 1\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 id (1 = 1)"}, {"line": "  with_reducible whnf", "tactic_state": "\u22a2 id (1 = 1)"}, {"line": "  guard_target =\u209b id (1 = 1)", "tactic_state": "\u22a2 id (1 = 1)"}, {"line": "  whnf", "tactic_state": "\u22a2 1 = 1"}, {"line": "  guard_target =\u209b 1 = 1", "tactic_state": "\u22a2 1 = 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (fun x => 1 + x) 1 = 2 := by\n  beta_reduce\n  guard_target =\u209b 1 + 1 = 2\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x => 1 + x) 1 = 2"}, {"line": "  beta_reduce", "tactic_state": "\u22a2 1 + 1 = 2"}, {"line": "  guard_target =\u209b 1 + 1 = 2", "tactic_state": "\u22a2 1 + 1 = 2"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (fun x => 1 + x) 2 = (fun y => 2 + y) 3 := by\n  conv =>\n    lhs\n    beta_reduce\n    guard_target =\u209b 1 + 2\n  guard_target =\u209b 1 + 2 = (fun y => 2 + y) 3\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x => 1 + x) 2 = (fun y => 2 + y) 3"}, {"line": "  conv =>", "tactic_state": "\u22a2 1 + 2 = (fun y => 2 + y) 3"}, {"line": "    lhs", "tactic_state": "\u22a2 1 + 2 = (fun y => 2 + y) 3"}, {"line": "    beta_reduce", "tactic_state": ""}]}
{"declaration": "example : 1 + 2 * 3 = 7 := by\n  reduce\n  guard_target =\u209b nat_lit 7 = nat_lit 7\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 + 2 * 3 = 7"}, {"line": "  reduce", "tactic_state": "\u22a2 7 = 7"}, {"line": "  guard_target =\u209b nat_lit 7 = nat_lit 7", "tactic_state": "\u22a2 7 = 7"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : let x := 1; let y := 2 + x; 2 + 1 = 3 := by\n  intro x y\n  refold_let x\n  guard_target =\u209b 2 + x = 3\n  refold_let y\n  guard_target =\u209b y = 3\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 1;\n  let y := 2 + x;\n  2 + 1 = 3"}, {"line": "  intro x y", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 2 + 1 = 3"}, {"line": "  refold_let x", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 2 + x = 3"}, {"line": "  guard_target =\u209b 2 + x = 3", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 2 + x = 3"}, {"line": "  refold_let y", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 y = 3"}, {"line": "  guard_target =\u209b y = 3", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 y = 3"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : 5 = 5 := by\n  let x := 5\n  refold_let x\n  guard_target =\u209b x = x\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 5 = 5"}, {"line": "  let x := 5", "tactic_state": "x : \u2115 := 5\n\u22a2 5 = 5"}, {"line": "  refold_let x", "tactic_state": "x : \u2115 := 5\n\u22a2 x = x"}, {"line": "  guard_target =\u209b x = x", "tactic_state": "x : \u2115 := 5\n\u22a2 x = x"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : 2 + 1 = 3 := by\n  let a : Fin 1 := 0\n  let x := 1\n  let b : Fin 1 := 0\n  refold_let x at *\n  guard_hyp a :\u209b Fin 1 := 0\n  guard_hyp b :\u209b Fin x := 0\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 + 1 = 3"}, {"line": "  let a : Fin 1 := 0", "tactic_state": "a : Fin 1 := 0\n\u22a2 2 + 1 = 3"}, {"line": "  let x := 1", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\n\u22a2 2 + 1 = 3"}, {"line": "  let b : Fin 1 := 0", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\nb : Fin 1 := 0\n\u22a2 2 + 1 = 3"}, {"line": "  refold_let x at *", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\nb : Fin x := 0\n\u22a2 2 + x = 3"}, {"line": "  guard_hyp a :\u209b Fin 1 := 0", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\nb : Fin x := 0\n\u22a2 2 + x = 3"}, {"line": "  guard_hyp b :\u209b Fin x := 0", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\nb : Fin x := 0\n\u22a2 2 + x = 3"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : 1 + 2 = 2 + 1 := by\n  unfold_projs\n  guard_target =\u209b Nat.add (nat_lit 1) (nat_lit 2) = Nat.add (nat_lit 2) (nat_lit 1)\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 + 2 = 2 + 1"}, {"line": "  unfold_projs", "tactic_state": "\u22a2 Nat.add 1 2 = Nat.add 2 1"}, {"line": "  guard_target =\u209b Nat.add (nat_lit 1) (nat_lit 2) = Nat.add (nat_lit 2) (nat_lit 1)", "tactic_state": "\u22a2 Nat.add 1 2 = Nat.add 2 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (m n : Nat) : (m == n) = true := by\n  unfold_projs\n  guard_target =\u209b decide (m = n) = true\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 (m == n) = true"}, {"line": "  unfold_projs", "tactic_state": "m n : \u2115\n\u22a2 decide (m = n) = true"}, {"line": "  guard_target =\u209b decide (m = n) = true", "tactic_state": "m n : \u2115\n\u22a2 decide (m = n) = true"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1) (a : \u03b1) :\n    (fun x => (fun x => f x) x) a = f a := by\n  eta_reduce\n  guard_target =\u209b f a = f a\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 (fun x => (fun x => f x) x) a = f a"}, {"line": "  eta_reduce", "tactic_state": "\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 f a = f a"}, {"line": "  guard_target =\u209b f a = f a", "tactic_state": "\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 f a = f a"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (f : Nat \u2192 Nat) : (fun a => f a) = (fun a => f (f a)) := by\n  eta_expand\n  guard_target =\u209b (fun a => f a) = (fun a => f (f a))\n  eta_reduce\n  guard_target =\u209b f = fun a => f (f a)\n  eta_expand\n  guard_target =\u209b (fun a => f a) = (fun a => f (f a))\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "  eta_expand", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "  guard_target =\u209b (fun a => f a) = (fun a => f (f a))", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "  eta_reduce", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 f = fun a => f (f a)"}, {"line": "  guard_target =\u209b f = fun a => f (f a)", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 f = fun a => f (f a)"}, {"line": "  eta_expand", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "  guard_target =\u209b (fun a => f a) = (fun a => f (f a))", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : (fun (a b : Nat) => a + b) = (\u00b7 + \u00b7) := by\n  eta_reduce\n  guard_target =\u209b (HAdd.hAdd : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd\n  eta_expand\n  guard_target =\u209b (fun (a b : Nat) => a + b) = fun a b => a + b\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun a b => a + b) = fun x1 x2 => x1 + x2"}, {"line": "  eta_reduce", "tactic_state": "\u22a2 HAdd.hAdd = HAdd.hAdd"}, {"line": "  guard_target =\u209b (HAdd.hAdd : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd", "tactic_state": "\u22a2 HAdd.hAdd = HAdd.hAdd"}, {"line": "  eta_expand", "tactic_state": "\u22a2 (fun a a_1 => a + a_1) = fun a a_1 => a + a_1"}, {"line": "  guard_target =\u209b (fun (a b : Nat) => a + b) = fun a b => a + b", "tactic_state": "\u22a2 (fun a a_1 => a + a_1) = fun a a_1 => a + a_1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (fun (a : Nat) => 1 + a) = (1 + \u00b7) := by\n  eta_reduce\n  guard_target =\u209b (HAdd.hAdd 1) = HAdd.hAdd 1\n  eta_expand\n  guard_target =\u209b (fun a \u21a6 1 + a) = fun a \u21a6 1 + a\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun a => 1 + a) = fun x => 1 + x"}, {"line": "  eta_reduce", "tactic_state": "\u22a2 HAdd.hAdd 1 = HAdd.hAdd 1"}, {"line": "  guard_target =\u209b (HAdd.hAdd 1) = HAdd.hAdd 1", "tactic_state": "\u22a2 HAdd.hAdd 1 = HAdd.hAdd 1"}, {"line": "  eta_expand", "tactic_state": "\u22a2 (fun a => 1 + a) = fun a => 1 + a"}, {"line": "  guard_target =\u209b (fun a \u21a6 1 + a) = fun a \u21a6 1 + a", "tactic_state": "\u22a2 (fun a => 1 + a) = fun a => 1 + a"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (f : Nat \u2192 Nat \u2192 Nat) : (fun x => f 1 x) 2 = 3 := by\n  eta_expand\n  guard_target =\u209b f 1 2 = 3\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 (fun x => f 1 x) 2 = 3"}, {"line": "  eta_expand", "tactic_state": "f : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 f 1 2 = 3"}, {"line": "  guard_target =\u209b f 1 2 = 3", "tactic_state": "f : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 f 1 2 = 3"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : (fun (a : Nat) => 1 + a) 2 = (1 + \u00b7) 2 := by\n  eta_expand\n  guard_target =\u209b 1 + 2 = 1 + 2\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun a => 1 + a) 2 = (fun x => 1 + x) 2"}, {"line": "  eta_expand", "tactic_state": "\u22a2 1 + 2 = 1 + 2"}, {"line": "  guard_target =\u209b 1 + 2 = 1 + 2", "tactic_state": "\u22a2 1 + 2 = 1 + 2"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (p : Nat \u00d7 Nat) : (p.1, p.2) = (p.2, p.1) := by\n  eta_struct\n  guard_target =\u209b p = (p.2, p.1)\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 (p.1, p.2) = (p.2, p.1)"}, {"line": "  eta_struct", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 p = (p.2, p.1)"}, {"line": "  guard_target =\u209b p = (p.2, p.1)", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 p = (p.2, p.1)"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (p : Nat \u00d7 Nat) : ((p.1, p.2).1, (p.1, p.2).2) = ((p.1, p.2).2, (p.1, p.2).1) := by\n  eta_struct\n  guard_target =\u209b p = (p.2, p.1)\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 ((p.1, p.2).1, (p.1, p.2).2) = ((p.1, p.2).2, (p.1, p.2).1)"}, {"line": "  eta_struct", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 p = (p.2, p.1)"}, {"line": "  guard_target =\u209b p = (p.2, p.1)", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 p = (p.2, p.1)"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (n : Fin 5) : n = \u27e8n.1, n.2\u27e9 := by\n  eta_struct\n  guard_target =\u209b n = n\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Fin 5\n\u22a2 n = \u27e8\u2191n, \u22ef\u27e9"}, {"line": "  eta_struct", "tactic_state": "n : Fin 5\n\u22a2 n = n"}, {"line": "  guard_target =\u209b n = n", "tactic_state": "n : Fin 5\n\u22a2 n = n"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (n : Fin 5) : n = \u27e8n.val2, n.prop2\u27e9 := by\n  eta_struct\n  guard_target =\u209b n = n\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Fin 5\n\u22a2 n = \u27e8sorry, \u22ef\u27e9"}, {"line": "  eta_struct", "tactic_state": "n : Fin 5\n\u22a2 n = \u27e8sorry, \u22ef\u27e9"}, {"line": "  guard_target =\u209b n = n", "tactic_state": "n : Fin 5\n\u22a2 n = \u27e8sorry, \u22ef\u27e9"}]}
{"declaration": "example : true \u2227 true := by\n  constructor\n  guard_goal_nums 2\n  all_goals {constructor}\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GuardGoalNums.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 true = true \u2227 true = true"}, {"line": "  constructor", "tactic_state": "case left\n\u22a2 true = true\n---\ncase right\n\u22a2 true = true"}, {"line": "  guard_goal_nums 2", "tactic_state": "case left\n\u22a2 true = true\n---\ncase right\n\u22a2 true = true"}, {"line": "  all_goals {constructor}", "tactic_state": ""}]}
{"declaration": "example : (true \u2227 true) \u2227 (true \u2227 true) := by\n  constructor <;> constructor\n  guard_goal_nums 4\n  all_goals {constructor}", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GuardGoalNums.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (true = true \u2227 true = true) \u2227 true = true \u2227 true = true"}, {"line": "  constructor <;> constructor", "tactic_state": "case left.left\n\u22a2 true = true\n---\ncase left.right\n\u22a2 true = true\n---\ncase right.left\n\u22a2 true = true\n---\ncase right.right\n\u22a2 true = true"}, {"line": "  guard_goal_nums 4", "tactic_state": "case left.left\n\u22a2 true = true\n---\ncase left.right\n\u22a2 true = true\n---\ncase right.left\n\u22a2 true = true\n---\ncase right.right\n\u22a2 true = true"}, {"line": "  all_goals {constructor}", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (foo : False)  : a < b := by\n  by_contra!\n  guard_hyp this : b \u2264 a\n  exact foo\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/byContra.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nfoo : False\n\u22a2 a < b"}, {"line": "  by_contra!", "tactic_state": "a b : \u2115\nfoo : False\nthis : b \u2264 a\n\u22a2 False"}, {"line": "  guard_hyp this : b \u2264 a", "tactic_state": "a b : \u2115\nfoo : False\nthis : b \u2264 a\n\u22a2 False"}, {"line": "  exact foo", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : False) : a < b := by\n  by_contra! foo\n  revert foo; change b \u2264 a \u2192 False; intro;\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/byContra.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : False\n\u22a2 a < b"}, {"line": "  by_contra! foo", "tactic_state": "a b : \u2115\nh : False\nfoo : b \u2264 a\n\u22a2 False"}, {"line": "  revert foo; change b \u2264 a \u2192 False; intro;", "tactic_state": "a b : \u2115\nh : False\n\u22a2 b \u2264 a \u2192 False"}, {"line": "  exact h", "tactic_state": "a b : \u2115\nh : False\n\u22a2 b \u2264 a \u2192 False"}]}
{"declaration": "example (a b : \u2115) (h : False) : a < b := by\n  by_contra! foo : \u00ac a < b -- can avoid push_neg\n  guard_hyp foo : \u00ac a < b\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/byContra.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : False\n\u22a2 a < b"}, {"line": "  by_contra! foo : \u00ac a < b -- can avoid push_neg", "tactic_state": "a b : \u2115\nh : False\nfoo : \u00aca < b\n\u22a2 False"}, {"line": "  guard_hyp foo : \u00ac a < b", "tactic_state": "a b : \u2115\nh : False\nfoo : \u00aca < b\n\u22a2 False"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example : 1 < 2 := by\n  by_contra!\n  guard_hyp this : 2 \u2264 1\n  contradiction\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/byContra.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 < 2"}, {"line": "  by_contra!", "tactic_state": "this : 2 \u2264 1\n\u22a2 False"}, {"line": "  guard_hyp this : 2 \u2264 1", "tactic_state": "this : 2 \u2264 1\n\u22a2 False"}, {"line": "  contradiction", "tactic_state": ""}]}
{"declaration": "example (_p : Prop) (bar : False) : \u00ac \u00ac \u00ac \u00ac \u00ac \u00ac P := by\n  by_contra! foo : \u00ac \u00ac \u00ac P -- normalises to \u00ac P, as does \u00ac (goal).\n  guard_hyp foo : \u00ac \u00ac \u00ac P\n  exact bar\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/byContra.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P _p : Prop\nbar : False\n\u22a2 \u00ac\u00ac\u00ac\u00ac\u00ac\u00acP"}, {"line": "  by_contra! foo : \u00ac \u00ac \u00ac P -- normalises to \u00ac P, as does \u00ac (goal).", "tactic_state": "P _p : Prop\nbar : False\nfoo : \u00ac\u00ac\u00acP\n\u22a2 False"}, {"line": "  guard_hyp foo : \u00ac \u00ac \u00ac P", "tactic_state": "P _p : Prop\nbar : False\nfoo : \u00ac\u00ac\u00acP\n\u22a2 False"}, {"line": "  exact bar", "tactic_state": ""}]}
{"declaration": "example (_p : Prop) (bar : False) : \u00ac \u00ac \u00ac \u00ac \u00ac \u00ac P := by\n  by_contra! : \u00ac \u00ac \u00ac P\n  guard_hyp this : \u00ac \u00ac \u00ac P\n  exact bar\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/byContra.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P _p : Prop\nbar : False\n\u22a2 \u00ac\u00ac\u00ac\u00ac\u00ac\u00acP"}, {"line": "  by_contra! : \u00ac \u00ac \u00ac P", "tactic_state": "P _p : Prop\nbar : False\nthis : \u00ac\u00ac\u00acP\n\u22a2 False"}, {"line": "  guard_hyp this : \u00ac \u00ac \u00ac P", "tactic_state": "P _p : Prop\nbar : False\nthis : \u00ac\u00ac\u00acP\n\u22a2 False"}, {"line": "  exact bar", "tactic_state": ""}]}
{"declaration": "example (x : \u03b1) (f : False) : x \u2264 1 := by\n  set a := x * x\n  by_contra! h\n  guard_hyp h : 1 < x\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/byContra.lean", "context": {"open": [], "variables": ["[LinearOrder \u03b1] [One \u03b1] [Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\n\u22a2 x \u2264 1"}, {"line": "  set a := x * x", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\na : \u03b1 := x * x\n\u22a2 x \u2264 1"}, {"line": "  by_contra! h", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\na : \u03b1 := x * x\nh : 1 < x\n\u22a2 False"}, {"line": "  guard_hyp h : 1 < x", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\na : \u03b1 := x * x\nh : 1 < x\n\u22a2 False"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (x : \u03b1) (f : False) : x \u2264 1 := by\n  let _a := x * x\n  by_contra! h\n  guard_hyp h : 1 < x\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/byContra.lean", "context": {"open": [], "variables": ["[LinearOrder \u03b1] [One \u03b1] [Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\n\u22a2 x \u2264 1"}, {"line": "  let _a := x * x", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\n_a : \u03b1 := x * x\n\u22a2 x \u2264 1"}, {"line": "  by_contra! h", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\n_a : \u03b1 := x * x\nh : 1 < x\n\u22a2 False"}, {"line": "  guard_hyp h : 1 < x", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\n_a : \u03b1 := x * x\nh : 1 < x\n\u22a2 False"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (x : \u03b1) (f : False) : x \u2264 1 := by\n  set a := x * x\n  have : a \u2264 a := le_rfl\n  by_contra! h\n  guard_hyp h : 1 < x\n  assumption", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/byContra.lean", "context": {"open": [], "variables": ["[LinearOrder \u03b1] [One \u03b1] [Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\n\u22a2 x \u2264 1"}, {"line": "  set a := x * x", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\na : \u03b1 := x * x\n\u22a2 x \u2264 1"}, {"line": "  have : a \u2264 a := le_rfl", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\na : \u03b1 := x * x\nthis : a \u2264 a\n\u22a2 x \u2264 1"}, {"line": "  by_contra! h", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\na : \u03b1 := x * x\nthis : a \u2264 a\nh : 1 < x\n\u22a2 False"}, {"line": "  guard_hyp h : 1 < x", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nf : False\na : \u03b1 := x * x\nthis : a \u2264 a\nh : 1 < x\n\u22a2 False"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example : f 37 = 38 := by\n  erw? [f]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ErwQuestion.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\n\u22a2 sorry = 38"}, {"line": "  erw? [f]", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\n\u22a2 sorry = 38"}]}
{"declaration": "example : f b = 38 := by rw [f_a]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ErwQuestion.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\n\u22a2 sorry = 38"}]}
{"declaration": "example : f b = 38 := by erw [f_a]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ErwQuestion.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\n\u22a2 sorry = 38"}]}
{"declaration": "example : f b = 38 := by erw? [f_a]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ErwQuestion.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\n\u22a2 sorry = 38"}]}
{"declaration": "example : f b = 38 := by erw? [f_a]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ErwQuestion.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\n\u22a2 sorry = 38"}]}
{"declaration": "example (a b c : Nat) (h1 : a \u2264 b) (h2 : b \u2264 c) : a \u2264 c := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh1 : a \u2264 b\nh2 : b \u2264 c\n\u22a2 a \u2264 c"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example (a b c d e : Nat) (h1 : a \u2264 b) (h2 : b \u2264 c) (h3 : c \u2264 d) (h4 : d \u2264 e) (h5 : b \u2260 d) :\n    a < e := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e : \u2115\nh1 : a \u2264 b\nh2 : b \u2264 c\nh3 : c \u2264 d\nh4 : d \u2264 e\nh5 : b \u2260 d\n\u22a2 a < e"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) (h1 : a = b) (h2 : b = c) : a = c := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh1 : a = b\nh2 : b = c\n\u22a2 a = c"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example (a b : Int) (h1 : \u00ac(a < b)) (h2 : \u00ac(b < a)) : a = b := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh1 : \u00aca < b\nh2 : \u00acb < a\n\u22a2 a = b"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} [LinearOrder \u03b1] (a b : \u03b1) (h1 : \u00ac(a < b)) (h2 : \u00ac(b < a)) : a = b := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh1 : \u00aca < b\nh2 : \u00acb < a\n\u22a2 a = b"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} [PartialOrder \u03b1] (a b c d e : \u03b1) (h1 : a \u2264 b) (h2 : b \u2264 c) (h3 : c \u2264 d) (h4 : d \u2264 e) (h5 : b \u2260 d) :\n    a < e := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\ninst\u271d : PartialOrder \u03b1\na b c d e : \u03b1\nh1 : a \u2264 b\nh2 : b \u2264 c\nh3 : c \u2264 d\nh4 : d \u2264 e\nh5 : b \u2260 d\n\u22a2 a < e"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} [PartialOrder \u03b1] (s t x y : \u03b1) (h1 : s \u2264 x) (h2 : x \u2264 t) (h3 : s \u2264 y)\n    (h4 : y \u2264 t) (h5 : x \u2260 y) :\n    s < t := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\ninst\u271d : PartialOrder \u03b1\ns t x y : \u03b1\nh1 : s \u2264 x\nh2 : x \u2264 t\nh3 : s \u2264 y\nh4 : y \u2264 t\nh5 : x \u2260 y\n\u22a2 s < t"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} [PartialOrder \u03b1] (a b c d : \u03b1) (h1 : a \u2264 b) (h2 : b \u2264 c) (h3 : \u00ac(a < c))\n    (h4 : a \u2264 d) :\n    c \u2264 d := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\ninst\u271d : PartialOrder \u03b1\na b c d : \u03b1\nh1 : a \u2264 b\nh2 : b \u2264 c\nh3 : \u00aca < c\nh4 : a \u2264 d\n\u22a2 c \u2264 d"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} [PartialOrder \u03b1] (a : \u03b1) :\n    \u00ac (a < a) := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\ninst\u271d : PartialOrder \u03b1\na : \u03b1\n\u22a2 \u00aca < a"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} [Preorder \u03b1] (a b c d : \u03b1) (h1 : a \u2264 b) (h2 : b \u2264 c) (h3 : \u00ac(a < c))\n    (h4 : a \u2264 d) :\n    c \u2264 d := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\ninst\u271d : Preorder \u03b1\na b c d : \u03b1\nh1 : a \u2264 b\nh2 : b \u2264 c\nh3 : \u00aca < c\nh4 : a \u2264 d\n\u22a2 c \u2264 d"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} [Preorder \u03b1] (a b : \u03b1) (h1 : a < b) : b > a := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\ninst\u271d : Preorder \u03b1\na b : \u03b1\nh1 : a < b\n\u22a2 b > a"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} [Preorder \u03b1] (a b : \u03b1) (h1 : a > b) : b < a := by\n  order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\ninst\u271d : Preorder \u03b1\na b : \u03b1\nh1 : a > b\n\u22a2 b < a"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example {n : Nat} (A B C : Matrix (Fin n) (Fin n) \u211a) : (A * B * C).rank \u2264 A.rank \u2293 C.rank := by\n  have h1 := Matrix.rank_mul_le A B\n  have h2 := Matrix.rank_mul_le (A * B) C\n  have h3 : A.rank \u2293 B.rank \u2264 A.rank := inf_le_left\n  have h4 : (A * B).rank \u2293 C.rank \u2264 (A * B).rank := inf_le_left\n  have h5 : (A * B).rank \u2293 C.rank \u2264 C.rank := inf_le_right\n  simp\n  constructor\n  \u00b7 order\n  \u00b7 order\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nA B C : Matrix (Fin n) (Fin n) \u211a\n\u22a2 (A * B * C).rank \u2264 min A.rank C.rank"}, {"line": "  have h1 := Matrix.rank_mul_le A B", "tactic_state": "n : \u2115\nA B C : Matrix (Fin n) (Fin n) \u211a\nh1 : (A * B).rank \u2264 min A.rank B.rank\n\u22a2 (A * B * C).rank \u2264 min A.rank C.rank"}, {"line": "  have h2 := Matrix.rank_mul_le (A * B) C", "tactic_state": "n : \u2115\nA B C : Matrix (Fin n) (Fin n) \u211a\nh1 : (A * B).rank \u2264 min A.rank B.rank\nh2 : (A * B * C).rank \u2264 min (A * B).rank C.rank\n\u22a2 (A * B * C).rank \u2264 min A.rank C.rank"}, {"line": "  have h3 : A.rank \u2293 B.rank \u2264 A.rank := inf_le_left", "tactic_state": "n : \u2115\nA B C : Matrix (Fin n) (Fin n) \u211a\nh1 : (A * B).rank \u2264 min A.rank B.rank\nh2 : (A * B * C).rank \u2264 min (A * B).rank C.rank\nh3 : min A.rank B.rank \u2264 A.rank\n\u22a2 (A * B * C).rank \u2264 min A.rank C.rank"}, {"line": "  have h4 : (A * B).rank \u2293 C.rank \u2264 (A * B).rank := inf_le_left", "tactic_state": "n : \u2115\nA B C : Matrix (Fin n) (Fin n) \u211a\nh1 : (A * B).rank \u2264 min A.rank B.rank\nh2 : (A * B * C).rank \u2264 min (A * B).rank C.rank\nh3 : min A.rank B.rank \u2264 A.rank\nh4 : min (A * B).rank C.rank \u2264 (A * B).rank\n\u22a2 (A * B * C).rank \u2264 min A.rank C.rank"}, {"line": "  have h5 : (A * B).rank \u2293 C.rank \u2264 C.rank := inf_le_right", "tactic_state": "n : \u2115\nA B C : Matrix (Fin n) (Fin n) \u211a\nh1 : (A * B).rank \u2264 min A.rank B.rank\nh2 : (A * B * C).rank \u2264 min (A * B).rank C.rank\nh3 : min A.rank B.rank \u2264 A.rank\nh4 : min (A * B).rank C.rank \u2264 (A * B).rank\nh5 : min (A * B).rank C.rank \u2264 C.rank\n\u22a2 (A * B * C).rank \u2264 min A.rank C.rank"}, {"line": "  simp", "tactic_state": "n : \u2115\nA B C : Matrix (Fin n) (Fin n) \u211a\nh1 : (A * B).rank \u2264 min A.rank B.rank\nh2 : (A * B * C).rank \u2264 min (A * B).rank C.rank\nh3 : min A.rank B.rank \u2264 A.rank\nh4 : min (A * B).rank C.rank \u2264 (A * B).rank\nh5 : min (A * B).rank C.rank \u2264 C.rank\n\u22a2 (A * B * C).rank \u2264 A.rank \u2227 (A * B * C).rank \u2264 C.rank"}, {"line": "  constructor", "tactic_state": "case left\nn : \u2115\nA B C : Matrix (Fin n) (Fin n) \u211a\nh1 : (A * B).rank \u2264 min A.rank B.rank\nh2 : (A * B * C).rank \u2264 min (A * B).rank C.rank\nh3 : min A.rank B.rank \u2264 A.rank\nh4 : min (A * B).rank C.rank \u2264 (A * B).rank\nh5 : min (A * B).rank C.rank \u2264 C.rank\n\u22a2 (A * B * C).rank \u2264 A.rank\n---\ncase right\nn : \u2115\nA B C : Matrix (Fin n) (Fin n) \u211a\nh1 : (A * B).rank \u2264 min A.rank B.rank\nh2 : (A * B * C).rank \u2264 min (A * B).rank C.rank\nh3 : min A.rank B.rank \u2264 A.rank\nh4 : min (A * B).rank C.rank \u2264 (A * B).rank\nh5 : min (A * B).rank C.rank \u2264 C.rank\n\u22a2 (A * B * C).rank \u2264 C.rank"}, {"line": "  \u00b7 order", "tactic_state": ""}, {"line": "  \u00b7 order", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type u} [PartialOrder \u03b1]\n    (x1 y1 : \u03b1)\n    (x2 y2 : \u03b1)\n    (x3 y3 : \u03b1)\n    (x4 y4 : \u03b1)\n    (x5 y5 : \u03b1)\n    (x6 y6 : \u03b1)\n    (x7 y7 : \u03b1)\n    (x8 y8 : \u03b1)\n    (x9 y9 : \u03b1)\n    (x10 y10 : \u03b1)\n    (x11 y11 : \u03b1)\n    (x12 y12 : \u03b1)\n    (x13 y13 : \u03b1)\n    (x14 y14 : \u03b1)\n    (x15 y15 : \u03b1)\n    (x16 y16 : \u03b1)\n    (x17 y17 : \u03b1)\n    (x18 y18 : \u03b1)\n    (x19 y19 : \u03b1)\n    (x20 y20 : \u03b1)\n    (x21 y21 : \u03b1)\n    (x22 y22 : \u03b1)\n    (x23 y23 : \u03b1)\n    (x24 y24 : \u03b1)\n    (x25 y25 : \u03b1)\n    (x26 y26 : \u03b1)\n    (x27 y27 : \u03b1)\n    (x28 y28 : \u03b1)\n    (x29 y29 : \u03b1)\n    (x30 y30 : \u03b1)\n    (h0 : y1 \u2264 x1)\n    (h1 : \u00ac(y1 < x1)) (h2 : y2 \u2264 x1) (h3 : y1 \u2264 x2)\n    (h4 : \u00ac(y2 < x2)) (h5 : y3 \u2264 x2) (h6 : y2 \u2264 x3)\n    (h7 : \u00ac(y3 < x3)) (h8 : y4 \u2264 x3) (h9 : y3 \u2264 x4)\n    (h10 : \u00ac(y4 < x4)) (h11 : y5 \u2264 x4) (h12 : y4 \u2264 x5)\n    (h13 : \u00ac(y5 < x5)) (h14 : y6 \u2264 x5) (h15 : y5 \u2264 x6)\n    (h16 : \u00ac(y6 < x6)) (h17 : y7 \u2264 x6) (h18 : y6 \u2264 x7)\n    (h19 : \u00ac(y7 < x7)) (h20 : y8 \u2264 x7) (h21 : y7 \u2264 x8)\n    (h22 : \u00ac(y8 < x8)) (h23 : y9 \u2264 x8) (h24 : y8 \u2264 x9)\n    (h25 : \u00ac(y9 < x9)) (h26 : y10 \u2264 x9) (h27 : y9 \u2264 x10)\n    (h28 : \u00ac(y10 < x10)) (h29 : y11 \u2264 x10) (h30 : y10 \u2264 x11)\n    (h31 : \u00ac(y11 < x11)) (h32 : y12 \u2264 x11) (h33 : y11 \u2264 x12)\n    (h34 : \u00ac(y12 < x12)) (h35 : y13 \u2264 x12) (h36 : y12 \u2264 x13)\n    (h37 : \u00ac(y13 < x13)) (h38 : y14 \u2264 x13) (h39 : y13 \u2264 x14)\n    (h40 : \u00ac(y14 < x14)) (h41 : y15 \u2264 x14) (h42 : y14 \u2264 x15)\n    (h43 : \u00ac(y15 < x15)) (h44 : y16 \u2264 x15) (h45 : y15 \u2264 x16)\n    (h46 : \u00ac(y16 < x16)) (h47 : y17 \u2264 x16) (h48 : y16 \u2264 x17)\n    (h49 : \u00ac(y17 < x17)) (h50 : y18 \u2264 x17) (h51 : y17 \u2264 x18)\n    (h52 : \u00ac(y18 < x18)) (h53 : y19 \u2264 x18) (h54 : y18 \u2264 x19)\n    (h55 : \u00ac(y19 < x19)) (h56 : y20 \u2264 x19) (h57 : y19 \u2264 x20)\n    (h58 : \u00ac(y20 < x20)) (h59 : y21 \u2264 x20) (h60 : y20 \u2264 x21)\n    (h61 : \u00ac(y21 < x21)) (h62 : y22 \u2264 x21) (h63 : y21 \u2264 x22)\n    (h64 : \u00ac(y22 < x22)) (h65 : y23 \u2264 x22) (h66 : y22 \u2264 x23)\n    (h67 : \u00ac(y23 < x23)) (h68 : y24 \u2264 x23) (h69 : y23 \u2264 x24)\n    (h70 : \u00ac(y24 < x24)) (h71 : y25 \u2264 x24) (h72 : y24 \u2264 x25)\n    (h73 : \u00ac(y25 < x25)) (h74 : y26 \u2264 x25) (h75 : y25 \u2264 x26)\n    (h76 : \u00ac(y26 < x26)) (h77 : y27 \u2264 x26) (h78 : y26 \u2264 x27)\n    (h79 : \u00ac(y27 < x27)) (h80 : y28 \u2264 x27) (h81 : y27 \u2264 x28)\n    (h82 : \u00ac(y28 < x28)) (h83 : y29 \u2264 x28) (h84 : y28 \u2264 x29)\n    (h85 : \u00ac(y29 < x29)) (h86 : y30 \u2264 x29) (h87 : y29 \u2264 x30)\n    (h88 : \u00ac(y30 < x30)) : x30 = y30 := by\n  order", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/order.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PartialOrder \u03b1\nx1 y1 x2 y2 x3 y3 x4 y4 x5 y5 x6 y6 x7 y7 x8 y8 x9 y9 x10 y10 x11 y11 x12 y12 x13 y13 x14 y14 x15 y15 x16 y16 x17 y17 x18 y18 x19 y19 x20 y20 x21 y21 x22 y22 x23 y23 x24 y24 x25 y25 x26 y26 x27 y27 x28 y28 x29 y29 x30 y30 :\n  \u03b1\nh0 : y1 \u2264 x1\nh1 : \u00acy1 < x1\nh2 : y2 \u2264 x1\nh3 : y1 \u2264 x2\nh4 : \u00acy2 < x2\nh5 : y3 \u2264 x2\nh6 : y2 \u2264 x3\nh7 : \u00acy3 < x3\nh8 : y4 \u2264 x3\nh9 : y3 \u2264 x4\nh10 : \u00acy4 < x4\nh11 : y5 \u2264 x4\nh12 : y4 \u2264 x5\nh13 : \u00acy5 < x5\nh14 : y6 \u2264 x5\nh15 : y5 \u2264 x6\nh16 : \u00acy6 < x6\nh17 : y7 \u2264 x6\nh18 : y6 \u2264 x7\nh19 : \u00acy7 < x7\nh20 : y8 \u2264 x7\nh21 : y7 \u2264 x8\nh22 : \u00acy8 < x8\nh23 : y9 \u2264 x8\nh24 : y8 \u2264 x9\nh25 : \u00acy9 < x9\nh26 : y10 \u2264 x9\nh27 : y9 \u2264 x10\nh28 : \u00acy10 < x10\nh29 : y11 \u2264 x10\nh30 : y10 \u2264 x11\nh31 : \u00acy11 < x11\nh32 : y12 \u2264 x11\nh33 : y11 \u2264 x12\nh34 : \u00acy12 < x12\nh35 : y13 \u2264 x12\nh36 : y12 \u2264 x13\nh37 : \u00acy13 < x13\nh38 : y14 \u2264 x13\nh39 : y13 \u2264 x14\nh40 : \u00acy14 < x14\nh41 : y15 \u2264 x14\nh42 : y14 \u2264 x15\nh43 : \u00acy15 < x15\nh44 : y16 \u2264 x15\nh45 : y15 \u2264 x16\nh46 : \u00acy16 < x16\nh47 : y17 \u2264 x16\nh48 : y16 \u2264 x17\nh49 : \u00acy17 < x17\nh50 : y18 \u2264 x17\nh51 : y17 \u2264 x18\nh52 : \u00acy18 < x18\nh53 : y19 \u2264 x18\nh54 : y18 \u2264 x19\nh55 : \u00acy19 < x19\nh56 : y20 \u2264 x19\nh57 : y19 \u2264 x20\nh58 : \u00acy20 < x20\nh59 : y21 \u2264 x20\nh60 : y20 \u2264 x21\nh61 : \u00acy21 < x21\nh62 : y22 \u2264 x21\nh63 : y21 \u2264 x22\nh64 : \u00acy22 < x22\nh65 : y23 \u2264 x22\nh66 : y22 \u2264 x23\nh67 : \u00acy23 < x23\nh68 : y24 \u2264 x23\nh69 : y23 \u2264 x24\nh70 : \u00acy24 < x24\nh71 : y25 \u2264 x24\nh72 : y24 \u2264 x25\nh73 : \u00acy25 < x25\nh74 : y26 \u2264 x25\nh75 : y25 \u2264 x26\nh76 : \u00acy26 < x26\nh77 : y27 \u2264 x26\nh78 : y26 \u2264 x27\nh79 : \u00acy27 < x27\nh80 : y28 \u2264 x27\nh81 : y27 \u2264 x28\nh82 : \u00acy28 < x28\nh83 : y29 \u2264 x28\nh84 : y28 \u2264 x29\nh85 : \u00acy29 < x29\nh86 : y30 \u2264 x29\nh87 : y29 \u2264 x30\nh88 : \u00acy30 < x30\n\u22a2 x30 = y30"}, {"line": "  order", "tactic_state": ""}]}
{"declaration": "example [AddZeroClass G] {a : G} (h : a = a): a = (a + 0) := by\n  nth_rewrite 2 [\u2190 add_zero a] at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : AddZeroClass G\na : G\nh : a = a\n\u22a2 a = a + 0"}, {"line": "  nth_rewrite 2 [\u2190 add_zero a] at h", "tactic_state": "G : Type u_1\ninst\u271d : AddZeroClass G\na : G\nh : a = a + 0\n\u22a2 a = a + 0"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example [AddZeroClass G] {a : G} : a + a = a + (a + 0) := by\n  nth_rw 2 [\u2190 add_zero a]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : AddZeroClass G\na : G\n\u22a2 a + a = a + (a + 0)"}, {"line": "  nth_rw 2 [\u2190 add_zero a]", "tactic_state": ""}]}
{"declaration": "example (f : F) : f.v.val = [] := by\n  nth_rw 1 [f.p]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Sort u_1\nf : F\n\u22a2 sorry = []"}, {"line": "  nth_rw 1 [f.p]", "tactic_state": "F : Sort u_1\nf : F\n\u22a2 sorry = []"}]}
{"declaration": "example (C : Cat) (W X Y Z : C.O) (f : C.H X Y) (g : C.H W X) (h _k : C.H Y Z) :\n    C.c (C.c g f) h = C.c g (C.c f h) := by\n  nth_rw 1 [C.a]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cat : Sort u_1\nC : Cat\nW : sorry\nX : sorry\nY : sorry\nZ : sorry\nf : sorry\ng : sorry\nh : sorry\n_k : sorry\n\u22a2 sorry = sorry"}, {"line": "  nth_rw 1 [C.a]", "tactic_state": "Cat : Sort u_1\nC : Cat\nW : sorry\nX : sorry\nY : sorry\nZ : sorry\nf : sorry\ng : sorry\nh : sorry\n_k : sorry\n\u22a2 sorry = sorry"}]}
{"declaration": "example (C : Cat) (X Y : C.O) (f : C.H X Y) : C.c f (C.i Y) = f := by\n  nth_rw 1 [C.ri]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cat : Sort u_1\nC : Cat\nX : sorry\nY : sorry\nf : sorry\n\u22a2 sorry = f"}, {"line": "  nth_rw 1 [C.ri]", "tactic_state": "Cat : Sort u_1\nC : Cat\nX : sorry\nY : sorry\nf : sorry\n\u22a2 sorry = f"}]}
{"declaration": "example (x y z : \u2115) (h1 : x = y) (h2 : y = z) :\n    x + x + x + y = y + y + x + x := by\n  nth_rewrite 3 [h1, h2] -- h2 *is* used, this is different from mathlib3\n  nth_rewrite 3 [h2]\n  rw [h1]\n  rw [h2]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2115\nh1 : x = y\nh2 : y = z\n\u22a2 x + x + x + y = y + y + x + x"}, {"line": "  nth_rewrite 3 [h1, h2] -- h2 *is* used, this is different from mathlib3", "tactic_state": "x y z : \u2115\nh1 : x = y\nh2 : y = z\n\u22a2 x + x + y + y = z + y + x + x"}, {"line": "  nth_rewrite 3 [h2]", "tactic_state": "x y z : \u2115\nh1 : x = y\nh2 : y = z\n\u22a2 x + x + y + y = z + z + x + x"}, {"line": "  rw [h1]", "tactic_state": "x y z : \u2115\nh1 : x = y\nh2 : y = z\n\u22a2 y + y + y + y = z + z + y + y"}, {"line": "  rw [h2]", "tactic_state": ""}]}
{"declaration": "example : [[1], [1], [1]] = [[1], [2], [1]] := by\n  nth_rw 2 [foo]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 [[1], [1], [1]] = [[1], [2], [1]]"}, {"line": "  nth_rw 2 [foo]", "tactic_state": "\u22a2 [[1], [1], [1]] = [[1], [2], [1]]"}]}
{"declaration": "example : [[7],[6]] = [[5],[5]] := by\n  nth_rewrite 1 [foo']\n  nth_rewrite 1 [bar']\n  nth_rewrite 1 [\u2190 foo']\n  nth_rewrite 1 [\u2190 foo']\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 [[7], [6]] = [[5], [5]]"}, {"line": "  nth_rewrite 1 [foo']", "tactic_state": "\u22a2 [[7], [6]] = [[5], [5]]"}]}
{"declaration": "example (a b c : \u2115) : c + a + b = a + c + b := by\n  nth_rewrite 4 [add_comm]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 c + a + b = a + c + b"}, {"line": "  nth_rewrite 4 [add_comm]", "tactic_state": "a b c : \u2115\n\u22a2 c + a + b = c + a + b"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : [(3, 3), (5, 9), (5, 9)] = [(4, 5), (3, 6), (1, 1)] := by\n  nth_rewrite 1 [wowzer]\n  nth_rewrite 3 [\u2190 pchew]\n  nth_rewrite 1 [pchew]\n\n  nth_rewrite 1 [smash]\n  nth_rewrite 2 [smash]\n  nth_rewrite 3 [smash]\n  nth_rewrite 4 [smash]\n  nth_rewrite 5 [smash]\n  nth_rewrite 6 [smash]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 [(3, 3), (5, 9), (5, 9)] = [(4, 5), (3, 6), (1, 1)]"}, {"line": "  nth_rewrite 1 [wowzer]", "tactic_state": "\u22a2 [(3, 3), (5, 9), (5, 9)] = [(4, 5), (3, 6), (1, 1)]"}]}
{"declaration": "example (x y : Prop) (h\u2081 : x \u2194 y) (h\u2082 : x \u2194 x \u2227 x) : x \u2227 x \u2194 x := by\n  nth_rewrite 3 [h\u2081] at h\u2082\n  nth_rewrite 1 [\u2190 h\u2081] at h\u2082\n  nth_rewrite 3 [h\u2082]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Prop\nh\u2081 : x \u2194 y\nh\u2082 : x \u2194 x \u2227 x\n\u22a2 x \u2227 x \u2194 x"}, {"line": "  nth_rewrite 3 [h\u2081] at h\u2082", "tactic_state": "x y : Prop\nh\u2081 : x \u2194 y\nh\u2082 : x \u2194 x \u2227 y\n\u22a2 x \u2227 x \u2194 x"}, {"line": "  nth_rewrite 1 [\u2190 h\u2081] at h\u2082", "tactic_state": "x y : Prop\nh\u2081 : x \u2194 y\nh\u2082 : x \u2194 x \u2227 x\n\u22a2 x \u2227 x \u2194 x"}, {"line": "  nth_rewrite 3 [h\u2082]", "tactic_state": "x y : Prop\nh\u2081 : x \u2194 y\nh\u2082 : x \u2194 x \u2227 x\n\u22a2 x \u2227 x \u2194 x \u2227 x"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (x y : \u2115) (h\u2081 : x = y) (h\u2082 : x = x + x) : x + x = x := by\n  nth_rewrite 3 [h\u2081] at h\u2082\n  nth_rewrite 1 [\u2190 h\u2081] at h\u2082\n  nth_rewrite 3 [h\u2082]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nh\u2081 : x = y\nh\u2082 : x = x + x\n\u22a2 x + x = x"}, {"line": "  nth_rewrite 3 [h\u2081] at h\u2082", "tactic_state": "x y : \u2115\nh\u2081 : x = y\nh\u2082 : x = x + y\n\u22a2 x + x = x"}, {"line": "  nth_rewrite 1 [\u2190 h\u2081] at h\u2082", "tactic_state": "x y : \u2115\nh\u2081 : x = y\nh\u2082 : x = x + x\n\u22a2 x + x = x"}, {"line": "  nth_rewrite 3 [h\u2082]", "tactic_state": "x y : \u2115\nh\u2081 : x = y\nh\u2082 : x = x + x\n\u22a2 x + x = x + x"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (x y : \u2115) (h : x = y) : x + x + x = x + y + y := by\n  nth_rw 2 3 [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NthRewrite.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nh : x = y\n\u22a2 x + x + x = x + y + y"}, {"line": "  nth_rw 2 3 [h]", "tactic_state": ""}]}
{"declaration": "example {f : \u03b1 \u2192 \u03b2} (s t : Set \u03b2) (h : Surjective f) :\n    f '' (f \u207b\u00b9' s) \u2286 t \u2194 f '' (f \u207b\u00b9' s) \u2286 t := by\n  conv =>\n    congr\n    \u00b7 simp [h, -image_preimage_eq, -subset_range_of_surjective]\n    \u00b7 simp [h, -image_subset_iff, -subset_range_of_surjective]\n  fail_if_success simp [h, -subset_range_of_surjective]\n  simp [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/simp_confluence.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b2\nh : Surjective f\n\u22a2 f '' (f \u207b\u00b9' s) \u2286 t \u2194 f '' (f \u207b\u00b9' s) \u2286 t"}, {"line": "  conv =>", "tactic_state": ""}, {"line": "    congr", "tactic_state": ""}, {"line": "    \u00b7 simp [h, -image_preimage_eq, -subset_range_of_surjective]", "tactic_state": ""}]}
{"declaration": "example {s : Set \u03b1} (hs : Set.Nonempty s) (t : Set \u03b2) (a : \u03b2) :\n    (fun _ => a) '' s \u2286 t \u2194 (fun _ => a) '' s \u2286 t := by\n  conv =>\n    congr\n    \u00b7 simp [hs, -Nonempty.image_const, -Nonempty.subset_preimage_const]\n    \u00b7 simp [hs, -image_subset_iff, -Nonempty.subset_preimage_const]\n  fail_if_success simp [hs, -Nonempty.subset_preimage_const]\n  simp [hs]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/simp_confluence.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nhs : s.Nonempty\nt : Set \u03b2\na : \u03b2\n\u22a2 (fun x => a) '' s \u2286 t \u2194 (fun x => a) '' s \u2286 t"}, {"line": "  conv =>", "tactic_state": ""}, {"line": "    congr", "tactic_state": ""}, {"line": "    \u00b7 simp [hs, -Nonempty.image_const, -Nonempty.subset_preimage_const]", "tactic_state": ""}]}
{"declaration": "example {f : \u03b1 \u2192 \u03b2} (s) : f '' univ \u2286 s \u2194 f '' univ \u2286 s := by\n  conv =>\n    congr\n    \u00b7 simp [-image_univ, -preimage_eq_univ_iff]\n    \u00b7 simp [-image_subset_iff, -preimage_eq_univ_iff]\n  fail_if_success simp [-preimage_eq_univ_iff]\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/simp_confluence.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nuniv : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f '' univ \u2286 s \u2194 f '' univ \u2286 s"}, {"line": "  conv =>", "tactic_state": ""}, {"line": "    congr", "tactic_state": ""}, {"line": "    \u00b7 simp [-image_univ, -preimage_eq_univ_iff]", "tactic_state": ""}]}
{"declaration": "example : (\u00acp \u2227 \u00acq) \u2192 \u00ac(p \u2228 q) := by\n  intro h\n  push_neg\n  guard_target = \u00acp \u2227 \u00acq\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 \u00acp \u2227 \u00acq \u2192 \u00ac(p \u2228 q)"}, {"line": "  intro h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u00acp \u2227 \u00acq\n\u22a2 \u00ac(p \u2228 q)"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u00acp \u2227 \u00acq\n\u22a2 \u00acp \u2227 \u00acq"}, {"line": "  guard_target = \u00acp \u2227 \u00acq", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u00acp \u2227 \u00acq\n\u22a2 \u00acp \u2227 \u00acq"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example : \u00ac(p \u2227 q) \u2192 (p \u2192 \u00acq) := by\n  intro h\n  push_neg at h\n  guard_hyp h : p \u2192 \u00acq\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 \u00ac(p \u2227 q) \u2192 p \u2192 \u00acq"}, {"line": "  intro h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u00ac(p \u2227 q)\n\u22a2 p \u2192 \u00acq"}, {"line": "  push_neg at h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2192 \u00acq\n\u22a2 p \u2192 \u00acq"}, {"line": "  guard_hyp h : p \u2192 \u00acq", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2192 \u00acq\n\u22a2 p \u2192 \u00acq"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example : (\u2200(x : \u03b1), \u00ac p' x) \u2192 \u00ac \u2203(x : \u03b1), p' x := by\n  intro h\n  push_neg\n  guard_target = \u2200 (x : \u03b1), \u00acp' x\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 (\u2200 (x : \u03b1), \u00acp' x) \u2192 \u00ac\u2203 x, p' x"}, {"line": "  intro h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u2200 (x : \u03b1), \u00acp' x\n\u22a2 \u00ac\u2203 x, p' x"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u2200 (x : \u03b1), \u00acp' x\n\u22a2 \u2200 (x : \u03b1), \u00acp' x"}, {"line": "  guard_target = \u2200 (x : \u03b1), \u00acp' x", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u2200 (x : \u03b1), \u00acp' x\n\u22a2 \u2200 (x : \u03b1), \u00acp' x"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example : (\u00ac \u2200(x : \u03b1), p' x) \u2192 (\u2203(x : \u03b1), \u00ac p' x) := by\n  intro h\n  push_neg at h\n  guard_hyp h : \u2203 (x : \u03b1), \u00acp' x\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 (\u00ac\u2200 (x : \u03b1), p' x) \u2192 \u2203 x, \u00acp' x"}, {"line": "  intro h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u00ac\u2200 (x : \u03b1), p' x\n\u22a2 \u2203 x, \u00acp' x"}, {"line": "  push_neg at h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u2203 x, \u00acp' x\n\u22a2 \u2203 x, \u00acp' x"}, {"line": "  guard_hyp h : \u2203 (x : \u03b1), \u00acp' x", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u2203 x, \u00acp' x\n\u22a2 \u2203 x, \u00acp' x"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (p : Bool) : decide (\u00ac \u00ac p) = p := by\n  push_neg\n  guard_target = decide p = p\n  cases p <;> rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np\u271d q : Prop\np' q' : \u03b1 \u2192 Prop\np : Bool\n\u22a2 (decide \u00ac\u00acp = true) = p"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np\u271d q : Prop\np' q' : \u03b1 \u2192 Prop\np : Bool\n\u22a2 decide (p = true) = p"}, {"line": "  guard_target = decide p = p", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np\u271d q : Prop\np' q' : \u03b1 \u2192 Prop\np : Bool\n\u22a2 decide (p = true) = p"}, {"line": "  cases p <;> rfl", "tactic_state": ""}]}
{"declaration": "example : ((fun x => x+x) 1) = 2 := by\n  push_neg\n  guard_target = 1 + 1 = 2\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 (fun x => x + x) 1 = 2"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 1 + 1 = 2"}, {"line": "  guard_target = 1 + 1 = 2", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 1 + 1 = 2"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example : \u00ac \u00ac p = p := by\n  push_neg\n  guard_target = p = p\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 \u00ac\u00acp = p"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 p = p"}, {"line": "  guard_target = p = p", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 p = p"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (x y : \u03b2) (h : y < x) : \u00ac(x \u2264 y) := by\n  push_neg\n  guard_target = y < x\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh : y < x\n\u22a2 \u00acx \u2264 y"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh : y < x\n\u22a2 y < x"}, {"line": "  guard_target = y < x", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh : y < x\n\u22a2 y < x"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (a b : \u03b2) (h : a \u2264 b) : \u00ac a > b := by\n  push_neg\n  guard_target = a \u2264 b\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\na b : \u03b2\nh : a \u2264 b\n\u22a2 \u00aca > b"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\na b : \u03b2\nh : a \u2264 b\n\u22a2 a \u2264 b"}, {"line": "  guard_target = a \u2264 b", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\na b : \u03b2\nh : a \u2264 b\n\u22a2 a \u2264 b"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (x y : \u03b1) (h : x = y) : \u00ac (x \u2260 y) := by\n  push_neg\n  guard_target = x = y\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b1\nh : x = y\n\u22a2 \u00acx \u2260 y"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b1\nh : x = y\n\u22a2 x = y"}, {"line": "  guard_target = x = y", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b1\nh : x = y\n\u22a2 x = y"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example : \u00ac\u2203 (y : Unit), (y \u2260 ()) := by\n  push_neg\n  guard_target = \u2200 (y : Unit), y = ()\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 \u00ac\u2203 y, y \u2260 ()"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 \u2200 (y : Unit), y = ()"}, {"line": "  guard_target = \u2200 (y : Unit), y = ()", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 \u2200 (y : Unit), y = ()"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example (h : \u2203 y : Nat, \u00ac(y=1)): \u00ac\u2200 (y : Nat), (y = 1) := by\n  push_neg\n  guard_target = \u2203 (y : Nat), y \u2260 1\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u2203 y, \u00acy = 1\n\u22a2 \u00ac\u2200 (y : \u2115), y = 1"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u2203 y, \u00acy = 1\n\u22a2 \u2203 y, y \u2260 1"}, {"line": "  guard_target = \u2203 (y : Nat), y \u2260 1", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u2203 y, \u00acy = 1\n\u22a2 \u2203 y, y \u2260 1"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (x y : \u03b2) (h : y < x) : \u00ac\u00ac\u00ac (x \u2264 y) := by\n  push_neg\n  guard_target = y < x\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh : y < x\n\u22a2 \u00ac\u00ac\u00acx \u2264 y"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh : y < x\n\u22a2 y < x"}, {"line": "  guard_target = y < x", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh : y < x\n\u22a2 y < x"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (x y : \u03b2) (h\u2081 : \u00ac\u00ac\u00ac(x < y)) (h\u2082 : \u00ac\u2203 (x y : Nat), x = y) : \u00ac \u2200(x y : Nat), x = y := by\n  push_neg at *\n  guard_target = \u2203 (x y : Nat), x \u2260 y\n  guard_hyp h\u2081 : y \u2264 x\n  guard_hyp h\u2082 : \u2200 (x y : Nat), x \u2260 y\n  exact \u27e80, 1, by simp\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2081 : \u00ac\u00ac\u00acx < y\nh\u2082 : \u00ac\u2203 x y, x = y\n\u22a2 \u00ac\u2200 (x y : \u2115), x = y"}, {"line": "  push_neg at *", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2082 : \u2200 (x y : \u2115), x \u2260 y\nh\u2081 : y \u2264 x\n\u22a2 \u2203 x y, x \u2260 y"}, {"line": "  guard_target = \u2203 (x y : Nat), x \u2260 y", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2082 : \u2200 (x y : \u2115), x \u2260 y\nh\u2081 : y \u2264 x\n\u22a2 \u2203 x y, x \u2260 y"}, {"line": "  guard_hyp h\u2081 : y \u2264 x", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2082 : \u2200 (x y : \u2115), x \u2260 y\nh\u2081 : y \u2264 x\n\u22a2 \u2203 x y, x \u2260 y"}, {"line": "  guard_hyp h\u2082 : \u2200 (x y : Nat), x \u2260 y", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2082 : \u2200 (x y : \u2115), x \u2260 y\nh\u2081 : y \u2264 x\n\u22a2 \u2203 x y, x \u2260 y"}, {"line": "  exact \u27e80, 1, by simp\u27e9", "tactic_state": ""}]}
{"declaration": "example (x y : \u03b2) (h\u2081 : \u00ac\u00ac\u00ac(x < y)) (h\u2082 : \u00ac\u2203 (x y : Nat), x = y) : \u00ac \u2200(x y : Nat), x = y := by\n  push_neg at h\u2081 h\u2082 \u22a2\n  guard_target = \u2203 (x y : Nat), x \u2260 y\n  guard_hyp h\u2081 : y \u2264 x\n  guard_hyp h\u2082 : \u2200 (x y : Nat), x \u2260 y\n  exact \u27e80, 1, by simp\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2081 : \u00ac\u00ac\u00acx < y\nh\u2082 : \u00ac\u2203 x y, x = y\n\u22a2 \u00ac\u2200 (x y : \u2115), x = y"}, {"line": "  push_neg at h\u2081 h\u2082 \u22a2", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2081 : y \u2264 x\nh\u2082 : \u2200 (x y : \u2115), x \u2260 y\n\u22a2 \u2203 x y, x \u2260 y"}, {"line": "  guard_target = \u2203 (x y : Nat), x \u2260 y", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2081 : y \u2264 x\nh\u2082 : \u2200 (x y : \u2115), x \u2260 y\n\u22a2 \u2203 x y, x \u2260 y"}, {"line": "  guard_hyp h\u2081 : y \u2264 x", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2081 : y \u2264 x\nh\u2082 : \u2200 (x y : \u2115), x \u2260 y\n\u22a2 \u2203 x y, x \u2260 y"}, {"line": "  guard_hyp h\u2082 : \u2200 (x y : Nat), x \u2260 y", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u03b2\nh\u2081 : y \u2264 x\nh\u2082 : \u2200 (x y : \u2115), x \u2260 y\n\u22a2 \u2203 x y, x \u2260 y"}, {"line": "  exact \u27e80, 1, by simp\u27e9", "tactic_state": ""}]}
{"declaration": "example (h : p \u2192 \u00ac q) : \u00ac (p \u2227 q) := by\n  push_neg\n  guard_target = p \u2192 \u00acq\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2192 \u00acq\n\u22a2 \u00ac(p \u2227 q)"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2192 \u00acq\n\u22a2 p \u2192 \u00acq"}, {"line": "  guard_target = p \u2192 \u00acq", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2192 \u00acq\n\u22a2 p \u2192 \u00acq"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (a : \u03b2) : \u00ac \u2200 x : \u03b2, x < a \u2192 \u2203 y : \u03b2, (y < a) \u2227 \u2200 z : \u03b2, x = z := by\n  push_neg\n  guard_target = \u2203 x, x < a \u2227 \u2200 (y : \u03b2), y < a \u2192 \u2203 z, x \u2260 z\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\na : \u03b2\n\u22a2 \u00ac\u2200 x < a, \u2203 y < a, \u2200 (z : \u03b2), x = z"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\na : \u03b2\n\u22a2 \u2203 x < a, \u2200 y < a, \u2203 z, x \u2260 z"}, {"line": "  guard_target = \u2203 x, x < a \u2227 \u2200 (y : \u03b2), y < a \u2192 \u2203 z, x \u2260 z", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\na : \u03b2\n\u22a2 \u2203 x < a, \u2200 y < a, \u2203 z, x \u2260 z"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [Preorder \u03b1] (m n : \u03b1) (h : \u00ac(\u2203 k : \u03b1, m \u2264 k)) (h\u2082 : m \u2264 n) : m \u2264 n := by\n  push_neg at h\n  guard_hyp h : \u2200 k, \u00ac(m \u2264 k)\n  exact h\u2082\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d \u03b2 : Type\ninst\u271d\u00b9 : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nm n : \u03b1\nh : \u00ac\u2203 k, m \u2264 k\nh\u2082 : m \u2264 n\n\u22a2 m \u2264 n"}, {"line": "  push_neg at h", "tactic_state": "\u03b1\u271d \u03b2 : Type\ninst\u271d\u00b9 : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nm n : \u03b1\nh\u2082 : m \u2264 n\nh : \u2200 (k : \u03b1), \u00acm \u2264 k\n\u22a2 m \u2264 n"}, {"line": "  guard_hyp h : \u2200 k, \u00ac(m \u2264 k)", "tactic_state": "\u03b1\u271d \u03b2 : Type\ninst\u271d\u00b9 : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nm n : \u03b1\nh\u2082 : m \u2264 n\nh : \u2200 (k : \u03b1), \u00acm \u2264 k\n\u22a2 m \u2264 n"}, {"line": "  exact h\u2082", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [Preorder \u03b1] (m n : \u03b1) (h : \u00ac(\u2203 k : \u03b1, m < k)) (h\u2082 : m \u2264 n) : m \u2264 n := by\n  push_neg at h\n  guard_hyp h : \u2200 k, \u00ac(m < k)\n  exact h\u2082\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d \u03b2 : Type\ninst\u271d\u00b9 : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nm n : \u03b1\nh : \u00ac\u2203 k, m < k\nh\u2082 : m \u2264 n\n\u22a2 m \u2264 n"}, {"line": "  push_neg at h", "tactic_state": "\u03b1\u271d \u03b2 : Type\ninst\u271d\u00b9 : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nm n : \u03b1\nh\u2082 : m \u2264 n\nh : \u2200 (k : \u03b1), \u00acm < k\n\u22a2 m \u2264 n"}, {"line": "  guard_hyp h : \u2200 k, \u00ac(m < k)", "tactic_state": "\u03b1\u271d \u03b2 : Type\ninst\u271d\u00b9 : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nm n : \u03b1\nh\u2082 : m \u2264 n\nh : \u2200 (k : \u03b1), \u00acm < k\n\u22a2 m \u2264 n"}, {"line": "  exact h\u2082", "tactic_state": ""}]}
{"declaration": "example (r : LinearOrder \u03b1) (s : Preorder \u03b1) (a b : \u03b1) : \u00ac(s.lt a b \u2192 r.lt a b) := by\n  push_neg\n  guard_target = s.lt a b \u2227 r.le b a\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nr : LinearOrder \u03b1\ns : Preorder \u03b1\na b : \u03b1\n\u22a2 \u00ac(a < b \u2192 a < b)"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nr : LinearOrder \u03b1\ns : Preorder \u03b1\na b : \u03b1\n\u22a2 a < b \u2227 b \u2264 a"}, {"line": "  guard_target = s.lt a b \u2227 r.le b a", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nr : LinearOrder \u03b1\ns : Preorder \u03b1\na b : \u03b1\n\u22a2 a < b \u2227 b \u2264 a"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (r : LinearOrder \u03b1) (s : Preorder \u03b1) (a b : \u03b1) : \u00ac(r.lt a b \u2192 s.lt a b) := by\n  push_neg\n  guard_target = r.lt a b \u2227 \u00ac s.lt a b\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nr : LinearOrder \u03b1\ns : Preorder \u03b1\na b : \u03b1\n\u22a2 \u00ac(a < b \u2192 a < b)"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nr : LinearOrder \u03b1\ns : Preorder \u03b1\na b : \u03b1\n\u22a2 a < b \u2227 \u00aca < b"}, {"line": "  guard_target = r.lt a b \u2227 \u00ac s.lt a b", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nr : LinearOrder \u03b1\ns : Preorder \u03b1\na b : \u03b1\n\u22a2 a < b \u2227 \u00aca < b"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (h : p \u2227 q) : \u00ac\u00ac(p \u2227 q) := by\n  let r := p \u2227 q\n  change \u00ac\u00acr\n  push_neg\n  guard_target =\u209b r\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2227 q\n\u22a2 \u00ac\u00ac(p \u2227 q)"}, {"line": "  let r := p \u2227 q", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2227 q\nr : Prop := p \u2227 q\n\u22a2 \u00ac\u00ac(p \u2227 q)"}, {"line": "  change \u00ac\u00acr", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2227 q\nr : Prop := p \u2227 q\n\u22a2 \u00ac\u00acr"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2227 q\nr : Prop := p \u2227 q\n\u22a2 r"}, {"line": "  guard_target =\u209b r", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : p \u2227 q\nr : Prop := p \u2227 q\n\u22a2 r"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : \u00ac p \u2228 \u00ac q): \u00ac (p \u2227 q) := by\n  push_neg\n  guard_target = \u00acp \u2228 \u00acq\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u00acp \u2228 \u00acq\n\u22a2 \u00ac(p \u2227 q)"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u00acp \u2228 \u00acq\n\u22a2 p \u2192 \u00acq"}, {"line": "  guard_target = \u00acp \u2228 \u00acq", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nh : \u00acp \u2228 \u00acq\n\u22a2 p \u2192 \u00acq"}]}
{"declaration": "example : p \u2192 \u00ac \u00ac \u00ac \u00ac \u00ac \u00ac p := by\n  push_neg\n  guard_target = p \u2192 p\n  exact id\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 p \u2192 \u00ac\u00ac\u00ac\u00ac\u00ac\u00acp"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 p \u2192 p"}, {"line": "  guard_target = p \u2192 p", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\n\u22a2 p \u2192 p"}, {"line": "  exact id", "tactic_state": ""}]}
{"declaration": "example (h : x = 0 \u2227 y \u2260 0) : \u00ac(x = 0 \u2192 y = 0) := by\n  push_neg\n  guard_target = x = 0 \u2227 y \u2260 0\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u2115\nh : x = 0 \u2227 y \u2260 0\n\u22a2 \u00ac(x = 0 \u2192 y = 0)"}, {"line": "  push_neg", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u2115\nh : x = 0 \u2227 y \u2260 0\n\u22a2 x = 0 \u2227 y \u2260 0"}, {"line": "  guard_target = x = 0 \u2227 y \u2260 0", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\nx y : \u2115\nh : x = 0 \u2227 y \u2260 0\n\u22a2 x = 0 \u2227 y \u2260 0"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (a : \u03b1) (o : Option \u03b1) (h : \u00ac\u2200 hs, o.get hs \u2260 a) : \u2203 hs, o.get hs = a := by\n  push_neg at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\na : \u03b1\no : Option \u03b1\nh : \u00ac\u2200 (hs : o.isSome = true), o.get hs \u2260 a\n\u22a2 \u2203 (hs : o.isSome = true), o.get hs = a"}, {"line": "  push_neg at h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\na : \u03b1\no : Option \u03b1\nh : \u2203 (h : o.isSome = true), o.get \u22ef = a\n\u22a2 \u2203 (hs : o.isSome = true), o.get hs = a"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (s : Set \u03b1) (h : \u00acs.Nonempty) : s = \u2205 := by\n  push_neg at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\ns : Set \u03b1\nh : \u00acs.Nonempty\n\u22a2 s = \u2205"}, {"line": "  push_neg at h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\ns : Set \u03b1\nh : s = \u2205\n\u22a2 s = \u2205"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (s : Set \u03b1) (h : \u00ac s = \u2205) : s.Nonempty := by\n  push_neg at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\ns : Set \u03b1\nh : \u00acs = \u2205\n\u22a2 s.Nonempty"}, {"line": "  push_neg at h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\ns : Set \u03b1\nh : s.Nonempty\n\u22a2 s.Nonempty"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (s : Set \u03b1) (h : s \u2260 \u2205) : s.Nonempty := by\n  push_neg at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\ns : Set \u03b1\nh : s \u2260 \u2205\n\u22a2 s.Nonempty"}, {"line": "  push_neg at h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\ns : Set \u03b1\nh : s.Nonempty\n\u22a2 s.Nonempty"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (s : Set \u03b1) (h : \u2205 \u2260 s) : s.Nonempty := by\n  push_neg at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\ns : Set \u03b1\nh : \u2205 \u2260 s\n\u22a2 s.Nonempty"}, {"line": "  push_neg at h", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np q : Prop\np' q' : \u03b1 \u2192 Prop\ns : Set \u03b1\nh : s.Nonempty\n\u22a2 s.Nonempty"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example {p q : Nat} : \u00ac g.Adj p q := by\n  rw [g]\n  guard_target =\u209b \u00ac G.Adj { Adj := fun a b => (a \u2260 b) \u2227 ((a \u2223 b) \u2228 (b \u2223 a)) } p q\n  fail_if_success push_neg\n  guard_target =\u209b \u00ac G.Adj { Adj := fun a b => (a \u2260 b) \u2227 ((a \u2223 b) \u2228 (b \u2223 a)) } p q\n  dsimp only\n  guard_target =\u209b \u00ac ((p \u2260 q) \u2227 ((p \u2223 q) \u2228 (q \u2223 p)))\n  push_neg\n  guard_target =\u209b p \u2260 q \u2192 \u00acp \u2223 q \u2227 \u00acq \u2223 p\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/push_neg.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type} [LinearOrder \u03b2] {p q : Prop} {p' q' : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np\u271d q\u271d : Prop\np' q' : \u03b1 \u2192 Prop\np q : \u2115\n\u22a2 \u00acsorry"}, {"line": "  rw [g]", "tactic_state": "\u03b1 \u03b2 : Type\ninst\u271d : LinearOrder \u03b2\np\u271d q\u271d : Prop\np' q' : \u03b1 \u2192 Prop\np q : \u2115\n\u22a2 \u00acsorry"}]}
{"declaration": "example : True := by\n  success_if_fail_with_msg \"no goals to be solved\" trivial; trivial\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/success_if_fail_with_msg.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  success_if_fail_with_msg \"no goals to be solved\" trivial; trivial", "tactic_state": "\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : Nat \u2192 Nat \u2192 True := by\n  success_if_fail_with_msg \"no goals to be solved\"\n    intro\n    intro\n    trivial\n    trivial\n  intros; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/success_if_fail_with_msg.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115 \u2192 \u2115 \u2192 True"}, {"line": "  success_if_fail_with_msg \"no goals to be solved\"", "tactic_state": "\u22a2 \u2115 \u2192 \u2115 \u2192 True"}, {"line": "    intro", "tactic_state": "a\u271d\u00b9 a\u271d : \u2115\n\u22a2 True"}, {"line": "    intro", "tactic_state": ""}]}
{"declaration": "example : Nat \u2192 Nat \u2192 True := by\n  success_if_fail_with_msg \"no goals\"\n    intro\n    intro\n    trivial\n    trivial\n  intros; trivial\n\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/success_if_fail_with_msg.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115 \u2192 \u2115 \u2192 True"}, {"line": "  success_if_fail_with_msg \"no goals\"", "tactic_state": "\u22a2 \u2115 \u2192 \u2115 \u2192 True"}]}
{"declaration": "example (n : Nat) : True := by\n  success_if_fail_with_msg (err true) rw [Nat.le_succ n]\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/success_if_fail_with_msg.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  success_if_fail_with_msg (err true) rw [Nat.le_succ n]", "tactic_state": "n : \u2115\n\u22a2 True"}]}
{"declaration": "example : True := by\n  success_if_fail_with_msg (err false) fail \"not that message\"\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/success_if_fail_with_msg.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  success_if_fail_with_msg (err false) fail \"not that message\"", "tactic_state": "\u22a2 True"}]}
{"declaration": "example : True := by\n  success_if_fail_with_msg \"tactic 'trivial' succeeded, but was expected to fail\"\n    success_if_fail_with_msg \"message\" trivial\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/success_if_fail_with_msg.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  success_if_fail_with_msg \"tactic 'trivial' succeeded, but was expected to fail\"", "tactic_state": "\u22a2 True"}, {"line": "    success_if_fail_with_msg \"message\" trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  success_if_fail_with_msg err\u2082\n    success_if_fail_with_msg \"message\" fail \"different message!\"\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/success_if_fail_with_msg.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  success_if_fail_with_msg err\u2082", "tactic_state": "\u22a2 True"}]}
{"declaration": "example (a b : PNat) (h : a < b) : 1 < b := by\n  pnat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/pnat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\nh : a < b\n\u22a2 1 < b"}, {"line": "  pnat_to_nat", "tactic_state": "a b : \u2115+\na\u271d\u00b9 : 0 < \u2191a\na\u271d : 0 < \u2191b\nh : \u2191a < \u2191b\n\u22a2 1 < \u2191b"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example (a b : PNat) (h : a = b) : b = a := by\n  -- to test if the tactic works with inaccessible names\n  let a : \u2124 := 42\n  pnat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/pnat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\nh : a = b\n\u22a2 b = a"}, {"line": "  -- to test if the tactic works with inaccessible names", "tactic_state": "a\u271d b : \u2115+\nh : a\u271d = b\na : \u2124 := 42\n\u22a2 b = a\u271d"}, {"line": "  let a : \u2124 := 42", "tactic_state": "a\u271d\u00b2 b : \u2115+\na : \u2124 := 42\na\u271d\u00b9 : 0 < \u2191a\u271d\u00b2\na\u271d : 0 < \u2191b\nh : \u2191a\u271d\u00b2 = \u2191b\n\u22a2 \u2191b = \u2191a\u271d\u00b2"}, {"line": "  pnat_to_nat", "tactic_state": ""}]}
{"declaration": "example (a b : PNat) (h : a < b) : 1 < b := by\n  have := a.pos\n  pnat_to_nat\n  omega", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/pnat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\nh : a < b\n\u22a2 1 < b"}, {"line": "  have := a.pos", "tactic_state": "a b : \u2115+\nh : a < b\nthis : 0 < \u2191a\n\u22a2 1 < b"}, {"line": "  pnat_to_nat", "tactic_state": "a b : \u2115+\nthis : 0 < \u2191a\na\u271d : 0 < \u2191b\nh : \u2191a < \u2191b\n\u22a2 1 < \u2191b"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example : 0 = 0 := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.20\ninst\u271d : Ring R\na b c : R\n\u22a2 0 = 0"}]}
{"declaration": "example : a = a := by noncomm_ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a = a"}]}
{"declaration": "example : (a + b) * c = a * c + b * c := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 (a + b) * c = a * c + b * c"}]}
{"declaration": "example : a * (b + c) = a * b + a * c := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a * (b + c) = a * b + a * c"}]}
{"declaration": "example : a - b = a + -b := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a - b = a + -b"}]}
{"declaration": "example : a * b * c = a * (b * c) := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a * b * c = a * (b * c)"}]}
{"declaration": "example : a + a = 2 * a := by noncomm_ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a + a = 2 * a"}]}
{"declaration": "example : a + a = a * 2 := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a + a = a * 2"}]}
{"declaration": "example : -a - a = a * (-2) := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 -a - a = a * -2"}]}
{"declaration": "example : -a = (-1) * a := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 -a = -1 * a"}]}
{"declaration": "example : a + a + a = 3 * a := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a + a + a = 3 * a"}]}
{"declaration": "example : a ^ 2 = a * a := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a ^ 2 = a * a"}]}
{"declaration": "example : a ^ 3 = a * a * a := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a ^ 3 = a * a * a"}]}
{"declaration": "example : (-a) * b = -(a * b) := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 -a * b = -(a * b)"}]}
{"declaration": "example : a * (-b) = -(a * b) := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a * -b = -(a * b)"}]}
{"declaration": "example : a * (b + c + b + c - 2*b) = 2*a*c := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a * (b + c + b + c - 2 * b) = 2 * a * c"}]}
{"declaration": "example : a * (b + c + b + c - (2 : \u2115) \u2022 b) = 2*a*c := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a * (b + c + b + c - 2 \u2022 b) = 2 * a * c"}]}
{"declaration": "example : (a + b)^2 = a^2 + a*b + b*a + b^2 := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 (a + b) ^ 2 = a ^ 2 + a * b + b * a + b ^ 2"}]}
{"declaration": "example : (a - b)^2 = a^2 - a*b - b*a + b^2 := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 (a - b) ^ 2 = a ^ 2 - a * b - b * a + b ^ 2"}]}
{"declaration": "example : (a + b)^3 = a^3 + a^2*b + a*b*a + a*b^2 + b*a^2 + b*a*b + b^2*a + b^3 := by noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 (a + b) ^ 3 = a ^ 3 + a ^ 2 * b + a * b * a + a * b ^ 2 + b * a ^ 2 + b * a * b + b ^ 2 * a + b ^ 3"}]}
{"declaration": "example : (a - b)^3 = a^3 - a^2*b - a*b*a + a*b^2 - b*a^2 + b*a*b + b^2*a - b^3 := by noncomm_ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 (a - b) ^ 3 = a ^ 3 - a ^ 2 * b - a * b * a + a * b ^ 2 - b * a ^ 2 + b * a * b + b ^ 2 * a - b ^ 3"}]}
{"declaration": "example : \u2045a, a\u2046 = 0 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a, a\u2046 = 0"}]}
{"declaration": "example : \u2045a, b\u2046 = -\u2045b, a\u2046 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a, b\u2046 = -\u2045b, a\u2046"}]}
{"declaration": "example : \u2045a + b, c\u2046 = \u2045a, c\u2046 + \u2045b, c\u2046 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a + b, c\u2046 = \u2045a, c\u2046 + \u2045b, c\u2046"}]}
{"declaration": "example : \u2045a, b + c\u2046 = \u2045a, b\u2046 + \u2045a, c\u2046 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a, b + c\u2046 = \u2045a, b\u2046 + \u2045a, c\u2046"}]}
{"declaration": "example : \u2045a, \u2045b, c\u2046\u2046 + \u2045b, \u2045c, a\u2046\u2046 + \u2045c, \u2045a, b\u2046\u2046 = 0 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a, \u2045b, c\u2046\u2046 + \u2045b, \u2045c, a\u2046\u2046 + \u2045c, \u2045a, b\u2046\u2046 = 0"}]}
{"declaration": "example : \u2045\u2045a, b\u2046, c\u2046 + \u2045\u2045b, c\u2046, a\u2046 + \u2045\u2045c, a\u2046, b\u2046 = 0 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045\u2045a, b\u2046, c\u2046 + \u2045\u2045b, c\u2046, a\u2046 + \u2045\u2045c, a\u2046, b\u2046 = 0"}]}
{"declaration": "example : \u2045a, \u2045b, c\u2046\u2046 = \u2045\u2045a, b\u2046, c\u2046 + \u2045b, \u2045a, c\u2046\u2046 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a, \u2045b, c\u2046\u2046 = \u2045\u2045a, b\u2046, c\u2046 + \u2045b, \u2045a, c\u2046\u2046"}]}
{"declaration": "example : \u2045\u2045a, b\u2046, c\u2046 = \u2045\u2045a, c\u2046, b\u2046 + \u2045a, \u2045b, c\u2046\u2046 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045\u2045a, b\u2046, c\u2046 = \u2045\u2045a, c\u2046, b\u2046 + \u2045a, \u2045b, c\u2046\u2046"}]}
{"declaration": "example : \u2045a * b, c\u2046 = a * \u2045b, c\u2046 + \u2045a, c\u2046 * b := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a * b, c\u2046 = a * \u2045b, c\u2046 + \u2045a, c\u2046 * b"}]}
{"declaration": "example : \u2045a, b * c\u2046 = \u2045a, b\u2046 * c + b * \u2045a, c\u2046 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a, b * c\u2046 = \u2045a, b\u2046 * c + b * \u2045a, c\u2046"}]}
{"declaration": "example : \u20453 * a, a\u2046 = 0 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u20453 * a, a\u2046 = 0"}]}
{"declaration": "example : \u2045a * -5, a\u2046 = 0 := by simp only [Ring.lie_def]; noncomm_ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a * -5, a\u2046 = 0"}]}
{"declaration": "example : \u2045a^3, a\u2046 = 0 := by simp only [Ring.lie_def]; noncomm_ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 \u2045a ^ 3, a\u2046 = 0"}]}
{"declaration": "example : a + -b = -b + a := by\n  -- This should print \"`noncomm_ring` simp lemmas don't apply; try `abel` instead\"\n  -- but I don't know how to test for this:\n  -- See https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.60fail.60.20that.20doesn't.20print.20the.20goal.3F/near/382280010\n  fail_if_success noncomm_ring\n  abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a + -b = -b + a"}, {"line": "  -- This should print \"`noncomm_ring` simp lemmas don't apply; try `abel` instead\"", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a + -b = -b + a"}, {"line": "  -- but I don't know how to test for this:", "tactic_state": ""}]}
{"declaration": "example : a ^ 50 * a ^ 37 = a ^ 23 * a ^ 64 := by noncomm_ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\n\u22a2 a ^ 50 * a ^ 37 = a ^ 23 * a ^ 64"}]}
{"declaration": "example (h : \u2200 a : R, (2 : \u2124) \u2022 a = 0) : (a + 1) ^ 2 = a ^ 2 + 1 := by\n  noncomm_ring [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\nh : \u2200 (a : R), 2 \u2022 a = 0\n\u22a2 (a + 1) ^ 2 = a ^ 2 + 1"}, {"line": "  noncomm_ring [h]", "tactic_state": ""}]}
{"declaration": "example (h : a = b) (h2 : a = c) : a = c := by\n  fail_if_success noncomm_ring [h]\n  noncomm_ring [h2]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/NoncommRing.lean", "context": {"open": [], "variables": ["{R : Type _} [Ring R]", "(a b c : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\nh : a = b\nh2 : a = c\n\u22a2 a = c"}, {"line": "  fail_if_success noncomm_ring [h]", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\na b c : R\nh : a = b\nh2 : a = c\n\u22a2 a = c"}, {"line": "  noncomm_ring [h2]", "tactic_state": ""}]}
{"declaration": "example (delete_this : Nat) (_delete_this_dep : delete_this = delete_this) : Nat := by\n  clear! delete_this\n  fail_if_success assumption\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear!.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "delete_this : \u2115\n_delete_this_dep : delete_this = delete_this\n\u22a2 \u2115"}, {"line": "  clear! delete_this", "tactic_state": "\u22a2 \u2115"}, {"line": "  fail_if_success assumption", "tactic_state": "\u22a2 \u2115"}, {"line": "  exact 0", "tactic_state": ""}]}
{"declaration": "example [delete_this : Inhabited Nat] : Inhabited Nat := by\n  clear! delete_this\n  fail_if_success assumption\n  infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear!.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "delete_this : Inhabited \u2115\n\u22a2 Inhabited \u2115"}, {"line": "  clear! delete_this", "tactic_state": "\u22a2 Inhabited \u2115"}, {"line": "  fail_if_success assumption", "tactic_state": "\u22a2 Inhabited \u2115"}, {"line": "  infer_instance", "tactic_state": ""}]}
{"declaration": "example (delete_this : Nat) (delete_this2 : Nat) (_delete_this_dep : delete_this = delete_this2) :\n    Nat := by\n  clear! delete_this delete_this2\n  fail_if_success assumption\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear!.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "delete_this delete_this2 : \u2115\n_delete_this_dep : delete_this = delete_this2\n\u22a2 \u2115"}, {"line": "  clear! delete_this delete_this2", "tactic_state": "\u22a2 \u2115"}, {"line": "  fail_if_success assumption", "tactic_state": "\u22a2 \u2115"}, {"line": "  exact 0", "tactic_state": ""}]}
{"declaration": "example (delete_this : Nat) (dont_delete_this : Int) : Nat := by\n  clear! delete_this\n  fail_if_success assumption\n  exact dont_delete_this.toNat\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear!.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "delete_this : \u2115\ndont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  clear! delete_this", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  fail_if_success assumption", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  exact dont_delete_this.toNat", "tactic_state": ""}]}
{"declaration": "example (dont_delete_this : Nat) (delete_this : dont_delete_this = dont_delete_this) : Nat := by\n  clear! delete_this\n  assumption", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear!.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "dont_delete_this : \u2115\ndelete_this : dont_delete_this = dont_delete_this\n\u22a2 \u2115"}, {"line": "  clear! delete_this", "tactic_state": "dont_delete_this : \u2115\n\u22a2 \u2115"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example : True := by\n  type_check Nat -- Type\n  type_check Bool.true -- Bool\n  type_check nat_lit 1 -- Nat\n  type_check (1 : Nat) -- Nat\n  type_check (True :) -- Prop\n  type_check \u2200 x y : Nat, x = y -- Prop\n  type_check fun x : Nat => 2 * x + 1 -- Nat -> Nat\n  type_check [1]\n  fail_if_success type_check wrong\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TypeCheck.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  type_check Nat -- Type", "tactic_state": "\u22a2 True"}, {"line": "  type_check Bool.true -- Bool", "tactic_state": "\u22a2 True"}, {"line": "  type_check nat_lit 1 -- Nat", "tactic_state": "\u22a2 True"}, {"line": "  type_check (1 : Nat) -- Nat", "tactic_state": "\u22a2 True"}, {"line": "  type_check (True :) -- Prop", "tactic_state": "\u22a2 True"}, {"line": "  type_check \u2200 x y : Nat, x = y -- Prop", "tactic_state": "\u22a2 True"}, {"line": "  type_check fun x : Nat => 2 * x + 1 -- Nat -> Nat", "tactic_state": "\u22a2 True"}, {"line": "  type_check [1]", "tactic_state": "\u22a2 True"}, {"line": "  fail_if_success type_check wrong", "tactic_state": "\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  run_tac\n    evalApplyLikeTactic MVarId.apply (\u2190 `(True.intro))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/runCmd.lean", "context": {"open": ["Lean Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  run_tac", "tactic_state": ""}]}
{"declaration": "example : (fun x : Nat => x) 0 = 1 := by\n  change? 0 = _  -- change 0 = 1\n  change?        -- change (fun x \u21a6 x) 0 = 1\n  change? _      -- change (fun x \u21a6 x) 0 = 1\n  change? 1 = 0\n    -- The term\n    --   1 = 0\n    -- is not defeq to the goal:\n    --   (fun x \u21a6 x) 0 = 1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Change.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x => x) 0 = 1"}, {"line": "  change? 0 = _  -- change 0 = 1", "tactic_state": "\u22a2 (fun x => x) 0 = 1"}, {"line": "  change?        -- change (fun x \u21a6 x) 0 = 1", "tactic_state": "\u22a2 (fun x => x) 0 = 1"}, {"line": "  change? _      -- change (fun x \u21a6 x) 0 = 1", "tactic_state": "\u22a2 (fun x => x) 0 = 1"}, {"line": "  change? 1 = 0", "tactic_state": "\u22a2 (fun x => x) 0 = 1"}]}
{"declaration": "example (f : \u2200 x : Nat, x = x \u2192 \u03b1) : \u03b1 := by\n  apply (config := {}) f\n  apply rfl\n  apply 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_with.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 \u03b1"}, {"line": "  apply (config := {}) f", "tactic_state": "case a\n\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 ?x = ?x\n---\ncase x\n\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 \u2115"}, {"line": "  apply rfl", "tactic_state": "case x\n\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 \u2115"}, {"line": "  apply 1", "tactic_state": ""}]}
{"declaration": "example (f : \u2200 x : Nat, x = x \u2192 \u03b1) : \u03b1 := by\n  apply (config := { newGoals := .nonDependentOnly }) f\n  apply @rfl _ 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_with.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 \u03b1"}, {"line": "  apply (config := { newGoals := .nonDependentOnly }) f", "tactic_state": "case a\n\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 ?x = ?x"}, {"line": "  apply @rfl _ 1", "tactic_state": ""}]}
{"declaration": "example (f : \u2200 x : Nat, x = x \u2192 \u03b1) : \u03b1 := by\n  apply (config := { newGoals := .all }) f\n  apply 1\n  apply rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_with.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 \u03b1"}, {"line": "  apply (config := { newGoals := .all }) f", "tactic_state": "case x\n\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 \u2115\n---\ncase a\n\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 ?x = ?x"}, {"line": "  apply 1", "tactic_state": "case a\n\u03b1 : Sort ?u.19\nf : (x : \u2115) \u2192 x = x \u2192 \u03b1\n\u22a2 1 = 1"}, {"line": "  apply rfl", "tactic_state": ""}]}
{"declaration": "example (h : B \u222a C \u2286 A \u222a A) : B \u2286 A := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : B \u222a C \u2286 A \u222a A\n\u22a2 B \u2286 A"}]}
{"declaration": "example (h : B \u2229 B \u2229 C \u2287 A) : A \u2286 B := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : B \u2229 B \u2229 C \u2287 A\n\u22a2 A \u2286 B"}]}
{"declaration": "example (hABC : A \u2286 B \u222a C) (hCD : C \u2286 D): A \u2286 B \u222a D := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhABC : A \u2286 B \u222a C\nhCD : C \u2286 D\n\u22a2 A \u2286 B \u222a D"}]}
{"declaration": "example (h : A = A\u1d9c) : B = \u2205 := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : A = A\u1d9c\n\u22a2 B = \u2205"}]}
{"declaration": "example (h : A = A\u1d9c) : B = C := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : A = A\u1d9c\n\u22a2 B = C"}]}
{"declaration": "example (h : A \u2286 A\u1d9c \\ B) : A = \u2205 := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : A \u2286 A\u1d9c \\ B\n\u22a2 A = \u2205"}]}
{"declaration": "example (h1 : A \u2286 B \\ C) : A \u2286 B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh1 : A \u2286 B \\ C\n\u22a2 A \u2286 B"}]}
{"declaration": "example (h : Set.univ \u2286 ((A \u222a B) \u2229 C) \u2229 ((A\u1d9c \u2229 B\u1d9c) \u222a C\u1d9c)) : D \\ B \u2286 E \u2229 A\u1d9c := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : Set.univ \u2286 (A \u222a B) \u2229 C \u2229 (A\u1d9c \u2229 B\u1d9c \u222a C\u1d9c)\n\u22a2 D \\ B \u2286 E \u2229 A\u1d9c"}]}
{"declaration": "example (h : A \u2229 B \u2286 C) (h2 : C \u2229 D \u2286 E) : A \u2229 B \u2229 D \u2286 E := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : A \u2229 B \u2286 C\nh2 : C \u2229 D \u2286 E\n\u22a2 A \u2229 B \u2229 D \u2286 E"}]}
{"declaration": "example (h : E = A\u1d9c\u1d9c \u2229 C\u1d9c\u1d9c\u1d9c \u2229 D) : D \u2229 (B \u222a C\u1d9c) \u2229 A = E \u222a (A \u2229 D\u1d9c\u1d9c \u2229 B)\u1d9c\u1d9c := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : E = A\u1d9c\u1d9c \u2229 C\u1d9c\u1d9c\u1d9c \u2229 D\n\u22a2 D \u2229 (B \u222a C\u1d9c) \u2229 A = E \u222a (A \u2229 D\u1d9c\u1d9c \u2229 B)\u1d9c\u1d9c"}]}
{"declaration": "example (h : E \u2287 A\u1d9c\u1d9c \u2229 C\u1d9c\u1d9c\u1d9c \u2229 D) : D \u2229 (B \u222a C\u1d9c) \u2229 A \u2286  E \u222a (A \u2229 D\u1d9c\u1d9c \u2229 B)\u1d9c\u1d9c := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : E \u2287 A\u1d9c\u1d9c \u2229 C\u1d9c\u1d9c\u1d9c \u2229 D\n\u22a2 D \u2229 (B \u222a C\u1d9c) \u2229 A \u2286 E \u222a (A \u2229 D\u1d9c\u1d9c \u2229 B)\u1d9c\u1d9c"}]}
{"declaration": "example (h1 : A = B) : A = B := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh1 : A = B\n\u22a2 A = B"}]}
{"declaration": "example (h1 : A = B) (h2 : B \u2286 C): A \u2286 C := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh1 : A = B\nh2 : B \u2286 C\n\u22a2 A \u2286 C"}]}
{"declaration": "example (h1 : A \u2229 B = Set.univ) : A = Set.univ := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh1 : A \u2229 B = Set.univ\n\u22a2 A = Set.univ"}]}
{"declaration": "example (h1 : A \u222a B = \u2205) : A = \u2205 := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh1 : A \u222a B = \u2205\n\u22a2 A = \u2205"}]}
{"declaration": "example (h: A\u1d9c \u2286 \u2205) : A = Set.univ := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : A\u1d9c \u2286 \u2205\n\u22a2 A = Set.univ"}]}
{"declaration": "example (h: Set.univ \u2286 A\u1d9c) : A = \u2205 := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nh : Set.univ \u2286 A\u1d9c\n\u22a2 A = \u2205"}]}
{"declaration": "example : A \u2229 \u2205 = \u2205 := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u2229 \u2205 = \u2205"}]}
{"declaration": "example : A \u222a Set.univ = Set.univ := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u222a Set.univ = Set.univ"}]}
{"declaration": "example : \u2205 \u2286 A := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 \u2205 \u2286 A"}]}
{"declaration": "example : A \u2286 Set.univ := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u2286 Set.univ"}]}
{"declaration": "example (hAB : A \u2286 B) (hBA: B \u2286 A) : A = B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhAB : A \u2286 B\nhBA : B \u2286 A\n\u22a2 A = B"}]}
{"declaration": "example : A \u222a (B \u2229 C) = (A \u222a B) \u2229 (A \u222a C) := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u222a B \u2229 C = (A \u222a B) \u2229 (A \u222a C)"}]}
{"declaration": "example : A \u2229 (B \u222a C) = (A \u2229 B) \u222a (A \u2229 C) := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u2229 (B \u222a C) = A \u2229 B \u222a A \u2229 C"}]}
{"declaration": "example : A \u2229 (B \u222a C) \u2286 (A \u2229 B) \u222a (A \u2229 C) := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u2229 (B \u222a C) \u2286 A \u2229 B \u222a A \u2229 C"}]}
{"declaration": "example : A \u2286 (A \u222a B) \u222a C := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u2286 A \u222a B \u222a C"}]}
{"declaration": "example : A \u2229 B \u2286 A := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u2229 B \u2286 A"}]}
{"declaration": "example : A \u2286 A \u222a B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u2286 A \u222a B"}]}
{"declaration": "example (hBA : B \u2286 A) (hB : Set.univ \u2286 B): Set.univ = A := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhBA : B \u2286 A\nhB : Set.univ \u2286 B\n\u22a2 Set.univ = A"}]}
{"declaration": "example (hAB : A \u2286 B) (hCD : C \u2286 D) : C \\ B \u2286 D \\ A := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhAB : A \u2286 B\nhCD : C \u2286 D\n\u22a2 C \\ B \u2286 D \\ A"}]}
{"declaration": "example (hAB : Disjoint A B) (hCA : C \u2286 A) : Disjoint C (B \\ D) := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhAB : Disjoint A B\nhCA : C \u2286 A\n\u22a2 Disjoint C (B \\ D)"}]}
{"declaration": "example : A\u1d9c\u1d9c\u1d9c = A\u1d9c := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A\u1d9c\u1d9c\u1d9c = A\u1d9c"}]}
{"declaration": "example : A\u1d9c\u1d9c = A := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A\u1d9c\u1d9c = A"}]}
{"declaration": "example (hAB : A \u2286 B) (hBC : B \u2286 C) : A \u2286 C := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhAB : A \u2286 B\nhBC : B \u2286 C\n\u22a2 A \u2286 C"}]}
{"declaration": "example : (A\u1d9c \u2229 B \u2229 C\u1d9c\u1d9c)\u1d9c\u1d9c\u1d9c\u1d9c\u1d9c = C\u1d9c \u222a B\u1d9c \u222a \u2205 \u222a A \u222a \u2205 := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 (A\u1d9c \u2229 B \u2229 C\u1d9c\u1d9c)\u1d9c\u1d9c\u1d9c\u1d9c\u1d9c = C\u1d9c \u222a B\u1d9c \u222a \u2205 \u222a A \u222a \u2205"}]}
{"declaration": "example : D \u2229 (B \u222a C\u1d9c) \u2229 A = (A\u1d9c\u1d9c \u2229 C\u1d9c\u1d9c\u1d9c \u2229 D) \u222a (A \u2229 D\u1d9c\u1d9c \u2229 B)\u1d9c\u1d9c := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 D \u2229 (B \u222a C\u1d9c) \u2229 A = A\u1d9c\u1d9c \u2229 C\u1d9c\u1d9c\u1d9c \u2229 D \u222a (A \u2229 D\u1d9c\u1d9c \u2229 B)\u1d9c\u1d9c"}]}
{"declaration": "example (hAB : A \u2286 B) (hBC : B \u2286 C) (hCD : C \u2286 D) (hDE : D = E) (hEA : E \u2286 A) :\n    (A\u1d9c \u2229 B \u222a (C \u2229 B\u1d9c)\u1d9c \u2229 (E\u1d9c \u222a A))\u1d9c \u2229 (B \u222a E\u1d9c\u1d9c)\u1d9c =\n    (D\u1d9c \u2229 C \u222a (B \u2229 A\u1d9c)\u1d9c \u2229 (E\u1d9c \u222a E))\u1d9c \u2229 (D \u222a C\u1d9c\u1d9c)\u1d9c := by tauto_set\n\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhAB : A \u2286 B\nhBC : B \u2286 C\nhCD : C \u2286 D\nhDE : D = E\nhEA : E \u2286 A\n\u22a2 (A\u1d9c \u2229 B \u222a (C \u2229 B\u1d9c)\u1d9c \u2229 (E\u1d9c \u222a A))\u1d9c \u2229 (B \u222a E\u1d9c\u1d9c)\u1d9c = (D\u1d9c \u2229 C \u222a (B \u2229 A\u1d9c)\u1d9c \u2229 (E\u1d9c \u222a E))\u1d9c \u2229 (D \u222a C\u1d9c\u1d9c)\u1d9c"}, {"line": "", "tactic_state": ""}]}
{"declaration": "example : A \\ (A \u2229 B) \u222a B = A \u222a B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \\ (A \u2229 B) \u222a B = A \u222a B"}]}
{"declaration": "example (hA : A \u2286 B \u222a C) : (A \u2229 B) \u222a (A \u2229 C) = A := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhA : A \u2286 B \u222a C\n\u22a2 A \u2229 B \u222a A \u2229 C = A"}]}
{"declaration": "example (a : \u03b1) : a \u2209 A \\ {a} := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\na : \u03b1\n\u22a2 a \u2209 A \\ {a}"}]}
{"declaration": "example (hA : A \u2286 B \\ C) : A \u2286 B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhA : A \u2286 B \\ C\n\u22a2 A \u2286 B"}]}
{"declaration": "example (hAB : A \u2229 B = {a}) : {a} \u2286 A := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\na : \u03b1\nhAB : A \u2229 B = {a}\n\u22a2 {a} \u2286 A"}]}
{"declaration": "example (hAB : A \u2229 B = {a}) : {a} \u2286 B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\na : \u03b1\nhAB : A \u2229 B = {a}\n\u22a2 {a} \u2286 B"}]}
{"declaration": "example (hAB : A \u2286 C) : A \\ B \u2286 C := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhAB : A \u2286 C\n\u22a2 A \\ B \u2286 C"}]}
{"declaration": "example (hAC : A \u2286 C) : A \u2229 B \u2286 C := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhAC : A \u2286 C\n\u22a2 A \u2229 B \u2286 C"}]}
{"declaration": "example (hBC : B \u2286 C) : A \u2229 B \u2286 C := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhBC : B \u2286 C\n\u22a2 A \u2229 B \u2286 C"}]}
{"declaration": "example : A \u2229 B \u2286 A \u222a B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 A \u2229 B \u2286 A \u222a B"}]}
{"declaration": "example (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhAB : A \u2286 B\nhBA : B \\ A = \u2205\n\u22a2 A = B"}]}
{"declaration": "example (hAB : Disjoint A B) (ha : a \u2208 A) : a \u2209 B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\na : \u03b1\nhAB : Disjoint A B\nha : a \u2208 A\n\u22a2 a \u2209 B"}]}
{"declaration": "example (hAB : A \u2229 B = {a}) : Disjoint (A \\ {a}) B := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\na : \u03b1\nhAB : A \u2229 B = {a}\n\u22a2 Disjoint (A \\ {a}) B"}]}
{"declaration": "example (hAB : A \u2229 B = {a}) : Disjoint A (B \\ {a}) := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\na : \u03b1\nhAB : A \u2229 B = {a}\n\u22a2 Disjoint A (B \\ {a})"}]}
{"declaration": "example (hAB : A \u2229 B = {a}) : Disjoint (A \\ {a}) (B \\ {a}) := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\na : \u03b1\nhAB : A \u2229 B = {a}\n\u22a2 Disjoint (A \\ {a}) (B \\ {a})"}]}
{"declaration": "example (hAC : Disjoint A C) (hBC : Disjoint B C) :\n    A \u222a C \u2286 B \u222a C \u2194 A \u2286 B := by\n  constructor <;> (intro; tauto_set)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhAC : Disjoint A C\nhBC : Disjoint B C\n\u22a2 A \u222a C \u2286 B \u222a C \u2194 A \u2286 B"}, {"line": "  constructor <;> (intro; tauto_set)", "tactic_state": ""}]}
{"declaration": "example : symmDiff A B = (A \u222a B) \\ (A \u2229 B) := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 symmDiff A B = (A \u222a B) \\ (A \u2229 B)"}]}
{"declaration": "example : Disjoint (symmDiff A B) (A \u2229 B) := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 Disjoint (symmDiff A B) (A \u2229 B)"}]}
{"declaration": "example : symmDiff A \u2205 = A := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 symmDiff A \u2205 = A"}]}
{"declaration": "example : symmDiff \u2205 A = A := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\n\u22a2 symmDiff \u2205 A = A"}]}
{"declaration": "example (hC : symmDiff A B \u2286 C) (hA : A \u2286 C) : B \u2286 C := by tauto_set\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhC : symmDiff A B \u2286 C\nhA : A \u2286 C\n\u22a2 B \u2286 C"}]}
{"declaration": "example (hC : symmDiff A B \u2286 C) (hB : B \u2286 C) : A \u2286 C := by tauto_set", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/TautoSet.lean", "context": {"open": [], "variables": ["{\u03b1 : Type} {A B C D E : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nA B C D E : Set \u03b1\nhC : symmDiff A B \u2286 C\nhB : B \u2286 C\n\u22a2 A \u2286 C"}]}
{"declaration": "example : (fun\u2080 | 1 => 3 : \u03a0\u2080 i, Fin (i + 10)) 1 = 3 := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/dfinsupp_notation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun\u2080 | 1 => 3) 1 = 3"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example : (fun\u2080 | 1 | 2 | 3 => 3 | 3 => 4 : \u03a0\u2080 i, Fin (i + 10)) 1 = 3 := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/dfinsupp_notation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun\u2080 | 1 => 3 | 2 => 3 | 3 => 3 | 3 => 4) 1 = 3"}]}
{"declaration": "example : (fun\u2080 | 1 | 2 | 3 => 3 | 3 => 4 : \u03a0\u2080 i, Fin (i + 10)) 2 = 3 := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/dfinsupp_notation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun\u2080 | 1 => 3 | 2 => 3 | 3 => 3 | 3 => 4) 2 = 3"}]}
{"declaration": "example : (fun\u2080 | 1 | 2 | 3 => 3 | 3 => 4 : \u03a0\u2080 i, Fin (i + 10)) 3 = 4 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/dfinsupp_notation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun\u2080 | 1 => 3 | 2 => 3 | 3 => 3 | 3 => 4) 3 = 4"}]}
{"declaration": "example : (an : \u2124) = bn \u2192 an = bn := by intro h; exact mod_cast h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191an = \u2191bn \u2192 an = bn"}]}
{"declaration": "example : an = bn \u2192 (an : \u2124) = bn := by intro h; exact mod_cast h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 an = bn \u2192 \u2191an = \u2191bn"}]}
{"declaration": "example : az = bz \u2194 (az : \u211a) = bz := by norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 az = bz \u2194 \u2191az = \u2191bz"}]}
{"declaration": "example : (aq : \u211d) = br \u2194 (aq : \u2102) = br := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191aq = br \u2194 \u2191aq = \u2191br"}]}
{"declaration": "example : (an : \u211a) = bz \u2194 (an : \u2102) = bz := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191an = \u2191bz \u2194 \u2191an = \u2191bz"}]}
{"declaration": "example : (((an : \u2124) : \u211a) : \u211d) = bq \u2194 ((an : \u211a) : \u2102) = (bq : \u211d) := by norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191\u2191\u2191an = \u2191bq \u2194 \u2191\u2191an = \u2191\u2191bq"}]}
{"declaration": "example : (an : \u2124) < bn \u2194 an < bn := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191an < \u2191bn \u2194 an < bn"}]}
{"declaration": "example : (an : \u211a) < bz \u2194 (an : \u211d) < bz := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191an < \u2191bz \u2194 \u2191an < \u2191bz"}]}
{"declaration": "example : ((an : \u2124) : \u211d) < bq \u2194 (an : \u211a) < bq := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191\u2191an < \u2191bq \u2194 \u2191an < bq"}]}
{"declaration": "example : (an : \u2124) \u2260 (bn : \u2124) \u2194 an \u2260 bn := by norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191an \u2260 \u2191bn \u2194 an \u2260 bn"}]}
{"declaration": "example : 0 < (bq : \u211d) \u2194 0 < bq := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 0 < \u2191bq \u2194 0 < bq"}]}
{"declaration": "example : az > (1 : \u2115) \u2194 az > 1 := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 az > \u21911 \u2194 az > 1"}]}
{"declaration": "example : az > (0 : \u2115) \u2194 az > 0 := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 az > \u21910 \u2194 az > 0"}]}
{"declaration": "example : (an : \u2124) \u2260 0 \u2194 an \u2260 0 := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191an \u2260 0 \u2194 an \u2260 0"}]}
{"declaration": "example : aq < (1 : \u2115) \u2194 (aq : \u211a) < (1 : \u2124) := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 aq < \u21911 \u2194 aq < \u21911"}]}
{"declaration": "example : aq < (1 : \u2115) \u2194 (aq : \u211d) < (1 : \u2124) := by norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 aq < \u21911 \u2194 \u2191aq < \u21911"}]}
{"declaration": "example : (an : \u2124) + bn = (an + bn : \u2115) := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191an + \u2191bn = \u2191(an + bn)"}]}
{"declaration": "example : (an : \u2102) + bq = ((an + bq) : \u211a) := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191an + \u2191bq = \u2191(\u2191an + bq)"}]}
{"declaration": "example : (((an : \u2124) : \u211a) : \u211d) + bn = (an + (bn : \u2124)) := by norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191\u2191\u2191an + \u2191bn = \u2191an + \u2191\u2191bn"}]}
{"declaration": "example (h : ((an + bn : \u2115) : \u2124) = (an : \u2124) + (bn : \u2124)) : True := by\n  push_cast at h\n  guard_hyp h : (an : \u2124) + (bn : \u2124) = (an : \u2124) + (bn : \u2124)\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nh : \u2191(an + bn) = \u2191an + \u2191bn\n\u22a2 True"}, {"line": "  push_cast at h", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nh : \u2191an + \u2191bn = \u2191an + \u2191bn\n\u22a2 True"}, {"line": "  guard_hyp h : (an : \u2124) + (bn : \u2124) = (an : \u2124) + (bn : \u2124)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nh : \u2191an + \u2191bn = \u2191an + \u2191bn\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : ((an * bn : \u2115) : \u2124) = (an : \u2124) * (bn : \u2124)) : True := by\n  push_cast at h\n  guard_hyp h : (an : \u2124) * (bn : \u2124) = (an : \u2124) * (bn : \u2124)\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nh : \u2191(an * bn) = \u2191an * \u2191bn\n\u22a2 True"}, {"line": "  push_cast at h", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nh : \u2191an * \u2191bn = \u2191an * \u2191bn\n\u22a2 True"}, {"line": "  guard_hyp h : (an : \u2124) * (bn : \u2124) = (an : \u2124) * (bn : \u2124)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nh : \u2191an * \u2191bn = \u2191an * \u2191bn\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : (((((an : \u211a) : \u211d) * bq) + (cq : \u211d) ^ dn) : \u2102) = (an : \u2102) * (bq : \u211d) + cq ^ dn := by\n  norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191\u2191\u2191an * \u2191bq + \u2191\u2191cq ^ dn = \u2191an * \u2191\u2191bq + \u2191cq ^ dn"}, {"line": "  norm_cast", "tactic_state": ""}]}
{"declaration": "example : ((an : \u2124) : \u211d) < bq \u2227 (cr : \u2102) ^ 2 = dz \u2194 (an : \u211a) < bq \u2227 ((cr ^ 2) : \u2102) = dz := by\n  norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u2191\u2191an < \u2191bq \u2227 \u2191cr ^ 2 = \u2191dz \u2194 \u2191an < bq \u2227 \u2191cr ^ 2 = \u2191dz"}, {"line": "  norm_cast", "tactic_state": ""}]}
{"declaration": "example : ((42 : \u2115) : \u2124) = 42 := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u219142 = 42"}]}
{"declaration": "example : ((42 : \u2115) : \u2102) = 42 := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u219142 = 42"}]}
{"declaration": "example : ((42 : \u2124) : \u211a) = 42 := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u219142 = 42"}]}
{"declaration": "example : ((42 : \u211a) : \u211d) = 42 := by norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\n\u22a2 \u219142 = 42"}]}
{"declaration": "example : p 42 := by\n  norm_cast\n  guard_target = p 42\n  exact \u27e8\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nx\u271d : Sort ?u.122\np : x\u271d\n\u22a2 sorry"}, {"line": "  norm_cast", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nx\u271d : Sort ?u.122\np : x\u271d\n\u22a2 sorry"}, {"line": "  guard_target = p 42", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nx\u271d : Sort ?u.122\np : x\u271d\n\u22a2 sorry"}, {"line": "  exact \u27e8\u27e9", "tactic_state": ""}]}
{"declaration": "example (h : bn \u2264 an) : an - bn = 1 \u2194 (an - bn : \u2124) = 1 := by norm_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nh : bn \u2264 an\n\u22a2 an - bn = 1 \u2194 \u2191an - \u2191bn = 1"}]}
{"declaration": "example (h : (cz : \u211a) = az / bz) : (cz : \u211d) = az / bz := by assumption_mod_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nh : \u2191cz = \u2191az / \u2191bz\n\u22a2 \u2191cz = \u2191az / \u2191bz"}]}
{"declaration": "example (k : \u2115) {x y : \u2115} :\n    (x * x + y * y : \u2124) - \u2191((x * y + 1) * k) = \u2191y * \u2191y - \u2191k * \u2191x * \u2191y + (\u2191x * \u2191x - \u2191k) := by\n  push_cast\n  ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nk x y : \u2115\n\u22a2 \u2191x * \u2191x + \u2191y * \u2191y - \u2191((x * y + 1) * k) = \u2191y * \u2191y - \u2191k * \u2191x * \u2191y + (\u2191x * \u2191x - \u2191k)"}, {"line": "  push_cast", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nk x y : \u2115\n\u22a2 \u2191x * \u2191x + \u2191y * \u2191y - (\u2191x * \u2191y + 1) * \u2191k = \u2191y * \u2191y - \u2191k * \u2191x * \u2191y + (\u2191x * \u2191x - \u2191k)"}, {"line": "  ring", "tactic_state": ""}]}
{"declaration": "example (k : \u2115) {x y : \u2115} (h : ((x + y + k : \u2115) : \u2124) = 0) : x + y + k = 0 := by\n  push_cast at h\n  guard_hyp h : (x : \u2124) + y + k = 0\n  assumption_mod_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nk x y : \u2115\nh : \u2191(x + y + k) = 0\n\u22a2 x + y + k = 0"}, {"line": "  push_cast at h", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nk x y : \u2115\nh : \u2191x + \u2191y + \u2191k = 0\n\u22a2 x + y + k = 0"}, {"line": "  guard_hyp h : (x : \u2124) + y + k = 0", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\nk x y : \u2115\nh : \u2191x + \u2191y + \u2191k = 0\n\u22a2 x + y + k = 0"}, {"line": "  assumption_mod_cast", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h2 : ((a + b + 0 : \u2115) : \u2124) = 10) :\n    ((a + b : \u2115) : \u2124) = 10 := by\n  push_cast\n  push_cast [Int.add_zero] at h2\n  exact h2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\na b : \u2115\nh2 : \u2191(a + b + 0) = 10\n\u22a2 \u2191(a + b) = 10"}, {"line": "  push_cast", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\na b : \u2115\nh2 : \u2191(a + b + 0) = 10\n\u22a2 \u2191a + \u2191b = 10"}, {"line": "  push_cast [Int.add_zero] at h2", "tactic_state": "an bn cn dn : \u2115\naz bz cz dz : \u2124\naq bq cq dq : \u211a\nar br cr dr : \u211d\nac bc cc dc : \u2102\na b : \u2115\nh2 : \u2191a + \u2191b = 10\n\u22a2 \u2191a + \u2191b = 10"}, {"line": "  exact h2", "tactic_state": ""}]}
{"declaration": "lemma b (_h g : true) : true \u2227 true := by\n  constructor\n  assumption_mod_cast\n  assumption_mod_cast", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_cast.lean", "context": {"open": [], "variables": ["(an bn cn dn : \u2115) (az bz cz dz : \u2124)", "(aq bq cq dq : \u211a)", "(ar br cr dr : \u211d) (ac bc cc dc : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "_h g : true = true\n\u22a2 true = true \u2227 true = true"}, {"line": "  constructor", "tactic_state": "case left\n_h g : true = true\n\u22a2 true = true\n---\ncase right\n_h g : true = true\n\u22a2 true = true"}, {"line": "  assumption_mod_cast", "tactic_state": "case right\n_h g : true = true\n\u22a2 true = true"}, {"line": "  assumption_mod_cast", "tactic_state": ""}]}
{"declaration": "example : limsup u f \u2264 limsup v f := limsup_le_limsup h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/IsBoundedDefault.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal} (h : u \u2264\u1da0[f] v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\nu v : \u03b1 \u2192 EReal\nh : u \u2264\u1da0[f] v\n\u22a2 IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f u"}]}
{"declaration": "example : limsup u f \u2264 limsup v f := by exact limsup_le_limsup h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/IsBoundedDefault.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal} (h : u \u2264\u1da0[f] v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\nu v : \u03b1 \u2192 EReal\nh : u \u2264\u1da0[f] v\n\u22a2 limsup u f \u2264 limsup v f"}]}
{"declaration": "example : limsup u f \u2264 limsup v f := by apply limsup_le_limsup h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/IsBoundedDefault.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal} (h : u \u2264\u1da0[f] v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\nu v : \u03b1 \u2192 EReal\nh : u \u2264\u1da0[f] v\n\u22a2 limsup u f \u2264 limsup v f"}]}
{"declaration": "example : \u2200 x : \u2115, 2 \u2223 x \u2192 x < 100 := by\n  plausible (config := { randomSeed := some 257, maxSize := 200 })\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (x : \u2115), 2 \u2223 x \u2192 x < 100"}, {"line": "  plausible (config := { randomSeed := some 257, maxSize := 200 })", "tactic_state": "\u22a2 \u2200 (x : \u2115), 2 \u2223 x \u2192 x < 100"}]}
{"declaration": "example (x : \u2115) (_h : 2 \u2223 x) : true := by\n  have : x < 100 := by\n    success_if_fail_with_msg\n    \"", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n_h : 2 \u2223 x\n\u22a2 true = true"}, {"line": "  have : x < 100 := by", "tactic_state": "x : \u2115\n_h : 2 \u2223 x\nthis : x < 100\n\u22a2 true = true"}]}
{"declaration": "example (f : \u2124 \u2192 \u2124) (_h : Injective f) (g : \u2124 \u2192 \u2124) (_h : Injective g) (i : \u2124) : f i = g i := by\n  plausible (config := { randomSeed := some 257 })\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2124 \u2192 \u2124\n_h\u271d : Injective f\ng : \u2124 \u2192 \u2124\n_h : Injective g\ni : \u2124\n\u22a2 f i = g i"}, {"line": "  plausible (config := { randomSeed := some 257 })", "tactic_state": ""}]}
{"declaration": "example (f : \u2124 \u2192 \u2124) (_h : Injective f) : Monotone f := by\n  plausible (config := { randomSeed := some 257 })\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2124 \u2192 \u2124\n_h : Injective f\n\u22a2 Monotone f"}, {"line": "  plausible (config := { randomSeed := some 257 })", "tactic_state": ""}]}
{"declaration": "example (f : \u2124 \u2192 \u2124) : Injective f := by\n  plausible (config := { randomSeed := some 257 })\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2124 \u2192 \u2124\n\u22a2 Injective f"}, {"line": "  plausible (config := { randomSeed := some 257 })", "tactic_state": ""}]}
{"declaration": "example (f : \u2124 \u2192 \u2124) : Monotone f := by\n  plausible (config := { randomSeed := some 257 })\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2124 \u2192 \u2124\n\u22a2 Monotone f"}, {"line": "  plausible (config := { randomSeed := some 257 })", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192\u2080 \u2115) : true := by\n  have : f = 0 := by\n    success_if_fail_with_msg\n    \"", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192\u2080 \u2115\n\u22a2 true = true"}, {"line": "  have : f = 0 := by", "tactic_state": "f : \u2115 \u2192\u2080 \u2115\nthis : f = 0\n\u22a2 true = true"}]}
{"declaration": "example (f : \u03a0\u2080 _n : \u2115, \u2115) : true := by\n  have : f.update 0 0 = 0 := by\n    success_if_fail_with_msg\n    \"", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u03a0\u2080 (_n : \u2115), \u2115\n\u22a2 true = true"}, {"line": "  have : f.update 0 0 = 0 := by", "tactic_state": "f : \u03a0\u2080 (_n : \u2115), \u2115\nthis : f.update 0 0 = 0\n\u22a2 true = true"}]}
{"declaration": "example (n : \u2115) : true := by\n  have : \u2211 f : Unit \u2192 Fin (n + 1), f () = 0 := by\n    success_if_fail_with_msg \"", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 true = true"}, {"line": "  have : \u2211 f : Unit \u2192 Fin (n + 1), f () = 0 := by", "tactic_state": "n : \u2115\nthis : \u2211 f, f () = 0\n\u22a2 true = true"}]}
{"declaration": "example (q : \u2115) : q = 0 \u2228 q \u2265 2 \u2228\n    8 = \u2211 k \u2208 Finset.range 2, 5 ^ k * Nat.choose (2 * q + 1) (2 * k + 1) := by\n  plausible\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u2115\n\u22a2 q = 0 \u2228 q \u2265 2 \u2228 8 = \u2211 k \u2208 Finset.range 2, 5 ^ k * (2 * q + 1).choose (2 * k + 1)"}, {"line": "  plausible", "tactic_state": ""}]}
{"declaration": "example {a : \u2115} [Fact a.Prime] : (a + 1).Prime \u2228 (a + 2).Prime := by\n  plausible (config := { randomSeed := some 257 })\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\ninst\u271d : Fact (Nat.Prime a)\n\u22a2 Nat.Prime (a + 1) \u2228 Nat.Prime (a + 2)"}, {"line": "  plausible (config := { randomSeed := some 257 })", "tactic_state": ""}]}
{"declaration": "example (x : PNat) : x^3 < 2*x^2 + 10:= by\n  plausible (config := { randomSeed := some 257 })", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/slim_check.lean", "context": {"open": ["Function Plausible"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115+\n\u22a2 x ^ 3 < 2 * x ^ 2 + 10"}, {"line": "  plausible (config := { randomSeed := some 257 })", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) (f : Nat \u2192 Nat \u2192 Nat) :\n    a = b \u2192 b = c \u2192 d + (if b > 0 then a else b) = 0 \u2192 f (b + b) b \u2260 f (a + c) c \u2192 False := by\n  intro _ _ _ h\n  run_tac withMainContext do\n    let s \u2190 CCState.mkUsingHs\n    logInfo (toMessageData s)\n    let some (_, t\u2081, t\u2082) \u2190 liftM <| getFVarFromUserName `h >>= inferType >>= matchNe? | failure\n    let b \u2190 getFVarFromUserName `b\n    let d \u2190 getFVarFromUserName `d\n    guard s.inconsistent\n    guard (s.eqcSize b = 4)\n    guard !(s.inSingletonEqc b)\n    guard (s.inSingletonEqc d)\n    logInfo (m!\">>> Equivalence roots\" ++ .ofFormat .line ++ toMessageData s.roots)\n    logInfo (m!\">>> b's equivalence class\" ++ .ofFormat .line ++ toMessageData (s.eqcOf b))\n    let pr \u2190 s.eqvProof t\u2081 t\u2082\n    let spr \u2190 Term.exprToSyntax pr\n    evalTactic <| \u2190 `(tactic| have h := $spr; contradiction)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 a = b \u2192 b = c \u2192 (d + if b > 0 then a else b) = 0 \u2192 f (b + b) b \u2260 f (a + c) c \u2192 False"}, {"line": "  intro _ _ _ h", "tactic_state": "a b c d : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\na\u271d\u00b2 : a = b\na\u271d\u00b9 : b = c\na\u271d : (d + if b > 0 then a else b) = 0\nh : f (b + b) b \u2260 f (a + c) c\n\u22a2 False"}, {"line": "  run_tac withMainContext do", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (f : Nat \u2192 Nat) : a = b \u2192 f a = f b := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 a = b \u2192 f a = f b"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (f : Nat \u2192 Nat) : a = b \u2192 f a \u2260 f b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 a = b \u2192 f a \u2260 f b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (f : Nat \u2192 Nat) : a = b \u2192 f (f a) \u2260 f (f b) \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 a = b \u2192 f (f a) \u2260 f (f b) \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) (f : Nat \u2192 Nat) : a = b \u2192 c = b \u2192 f (f a) \u2260 f (f c) \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 a = b \u2192 c = b \u2192 f (f a) \u2260 f (f c) \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) (f : Nat \u2192 Nat \u2192 Nat) :\n    a = b \u2192 c = b \u2192 f (f a b) a \u2260 f (f c c) c \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 a = b \u2192 c = b \u2192 f (f a b) a \u2260 f (f c c) c \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) (f : Nat \u2192 Nat \u2192 Nat) : a = b \u2192 c = b \u2192 f (f a b) a = f (f c c) c := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 a = b \u2192 c = b \u2192 f (f a b) a = f (f c c) c"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) : HEq a b \u2192 b = c \u2192 HEq c d \u2192 HEq a d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 HEq a b \u2192 b = c \u2192 HEq c d \u2192 HEq a d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) : a = b \u2192 b = c \u2192 HEq c d \u2192 HEq a d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 a = b \u2192 b = c \u2192 HEq c d \u2192 HEq a d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) : a = b \u2192 HEq b c \u2192 HEq c d \u2192 HEq a d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 a = b \u2192 HEq b c \u2192 HEq c d \u2192 HEq a d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) : HEq a b \u2192 HEq b c \u2192 c = d \u2192 HEq a d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 HEq a b \u2192 HEq b c \u2192 c = d \u2192 HEq a d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) : HEq a b \u2192 b = c \u2192 c = d \u2192 HEq a d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 HEq a b \u2192 b = c \u2192 c = d \u2192 HEq a d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) : a = b \u2192 b = c \u2192 c = d \u2192 HEq a d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 a = b \u2192 b = c \u2192 c = d \u2192 HEq a d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) : a = b \u2192 HEq b c \u2192 c = d \u2192 HEq a d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 a = b \u2192 HEq b c \u2192 c = d \u2192 HEq a d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) : a = b \u2192 HEq (g\u2081 a) (g\u2081 b) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ng\u2081 : x\u271d\na b c : \u2115\n\u22a2 a = b \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) : a = b \u2192 c = b \u2192 f\u2081 (f\u2081 a b) (g\u2081 c) = f\u2081 (f\u2081 c a) (g\u2081 b) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nf\u2081 : x\u271d\na b c : \u2115\n\u22a2 a = b \u2192 c = b \u2192 sorry = sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d e x y : Nat) : a = b \u2192 a = x \u2192 b = y \u2192 c = d \u2192 c = e \u2192 c = b \u2192 a = e := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e x y : \u2115\n\u22a2 a = b \u2192 a = x \u2192 b = y \u2192 c = d \u2192 c = e \u2192 c = b \u2192 a = e"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115) (x : \u2115) (H1 : f (f (f x)) = x) (H2 : f (f (f (f (f x)))) = x) : f x = x := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115\nx : \u2115\nH1 : f (f (f x)) = x\nH2 : f (f (f (f (f x)))) = x\n\u22a2 f x = x"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a\u2081 a\u2082 b\u2081 b\u2082 c d : Nat)\n        (H\u2081 : a\u2081 > b\u2081)\n        (H\u2082 : a\u2082 > b\u2082) :\n        a\u2081 = c \u2192 a\u2082 = c \u2192\n        b\u2081 = d \u2192 d  = b\u2082 \u2192\n        g\u2082 (g\u2082 (f\u2082 a\u2081 b\u2081 H\u2081)) = g\u2082 (g\u2082 (f\u2082 a\u2082 b\u2082 H\u2082)) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ng\u2082 : x\u271d\na\u2081 a\u2082 b\u2081 b\u2082 c d : \u2115\nH\u2081 : a\u2081 > b\u2081\nH\u2082 : a\u2082 > b\u2082\n\u22a2 a\u2081 = c \u2192 a\u2082 = c \u2192 b\u2081 = d \u2192 d = b\u2082 \u2192 sorry = sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a\u2081 a\u2082 b\u2081 b\u2082 c d : Nat) :\n        a\u2081 = c \u2192 a\u2082 = c \u2192\n        b\u2081 = d \u2192 d  = b\u2082 \u2192\n        a\u2081 + b\u2081 + a\u2081 = a\u2082 + b\u2082 + c := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a\u2081 a\u2082 b\u2081 b\u2082 c d : \u2115\n\u22a2 a\u2081 = c \u2192 a\u2082 = c \u2192 b\u2081 = d \u2192 d = b\u2082 \u2192 a\u2081 + b\u2081 + a\u2081 = a\u2082 + b\u2082 + c"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Prop) : (a \u2194 b) \u2192 ((a \u2227 (c \u2228 b)) \u2194 (b \u2227 (c \u2228 a))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Prop\n\u22a2 (a \u2194 b) \u2192 (a \u2227 (c \u2228 b) \u2194 b \u2227 (c \u2228 a))"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Prop)\n    [d\u2081 : Decidable a] [d\u2082 : Decidable b] [d\u2083 : Decidable c] [d\u2084 : Decidable d] :\n    (a \u2194 b) \u2192 (c \u2194 d) \u2192\n      ((if (a \u2227 c) then True else False) \u2194 (if (b \u2227 d) then True else False)) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nd\u2081 : Decidable a\nd\u2082 : Decidable b\nd\u2083 : Decidable c\nd\u2084 : Decidable d\n\u22a2 (a \u2194 b) \u2192 (c \u2194 d) \u2192 ((if a \u2227 c then True else False) \u2194 if b \u2227 d then True else False)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Prop) (x y z : Nat)\n    [d\u2081 : Decidable a] [d\u2082 : Decidable b] [d\u2083 : Decidable c] [d\u2084 : Decidable d] :\n    (a \u2194 b) \u2192 (c \u2194 d) \u2192 x = y \u2192\n      ((if (a \u2227 c \u2227 a) then x else y) = (if (b \u2227 d \u2227 b) then y else x)) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nx y z : \u2115\nd\u2081 : Decidable a\nd\u2082 : Decidable b\nd\u2083 : Decidable c\nd\u2084 : Decidable d\n\u22a2 (a \u2194 b) \u2192 (c \u2194 d) \u2192 x = y \u2192 (if a \u2227 c \u2227 a then x else y) = if b \u2227 d \u2227 b then y else x"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) : (a = b \u2194 a = b) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a = b \u2194 a = b"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) : (a = b) = (b = a) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 (a = b) = (b = a)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) : HEq (a = b) (b = a) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 HEq (a = b) (b = a)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (p : Nat \u2192 Nat \u2192 Prop) (f : Nat \u2192 Nat) (a b c d : Nat) :\n    p (f a) (f b) \u2192 a = c \u2192 b = d \u2192 b = c \u2192 p (f c) (f c) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 \u2115 \u2192 Prop\nf : \u2115 \u2192 \u2115\na b c d : \u2115\n\u22a2 p (f a) (f b) \u2192 a = c \u2192 b = d \u2192 b = c \u2192 p (f c) (f c)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (p : Nat \u2192 Nat \u2192 Prop) (a b c d : Nat) :\n    p a b \u2192 a = c \u2192 b = d \u2192 p c d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 \u2115 \u2192 Prop\na b c d : \u2115\n\u22a2 p a b \u2192 a = c \u2192 b = d \u2192 p c d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (p : Nat \u2192 Nat \u2192 Prop) (f : Nat \u2192 Nat) (a b c d : Nat) :\n    p (f (f (f (f (f (f a))))))\n      (f (f (f (f (f (f b)))))) \u2192\n    a = c \u2192 b = d \u2192 b = c \u2192\n    p (f (f (f (f (f (f c))))))\n      (f (f (f (f (f (f c)))))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 \u2115 \u2192 Prop\nf : \u2115 \u2192 \u2115\na b c d : \u2115\n\u22a2 p (f (f (f (f (f (f a)))))) (f (f (f (f (f (f b)))))) \u2192\n    a = c \u2192 b = d \u2192 b = c \u2192 p (f (f (f (f (f (f c)))))) (f (f (f (f (f (f c))))))"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) : a = b \u2192 R a b \u2192 R a a := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.13\nR : x\u271d\na b c : \u2115\n\u22a2 a = b \u2192 sorry \u2192 sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Prop) : a = b \u2192 b = c \u2192 (a \u2194 c) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Prop\n\u22a2 a = b \u2192 b = c \u2192 (a \u2194 c)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Prop) : a = b \u2192 HEq b c \u2192 (a \u2194 c) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Prop\n\u22a2 a = b \u2192 HEq b c \u2192 (a \u2194 c)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) : HEq a b \u2192 b = c \u2192 HEq a c := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 HEq a b \u2192 b = c \u2192 HEq a c"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) : HEq a b \u2192 b = c \u2192 a = c := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 HEq a b \u2192 b = c \u2192 a = c"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) : HEq a b \u2192 HEq b c \u2192 HEq c d \u2192 a = d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 HEq a b \u2192 HEq b c \u2192 HEq c d \u2192 a = d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) : HEq a b \u2192 b = c \u2192 HEq c d \u2192 a = d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 HEq a b \u2192 b = c \u2192 HEq c d \u2192 a = d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Prop) : a = b \u2192 b = c \u2192 (a \u2194 c) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Prop\n\u22a2 a = b \u2192 b = c \u2192 (a \u2194 c)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Prop) : HEq a b \u2192 b = c \u2192 (a \u2194 c) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Prop\n\u22a2 HEq a b \u2192 b = c \u2192 (a \u2194 c)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Prop) : HEq a b \u2192 HEq b c \u2192 HEq c d \u2192 (a \u2194 d) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\n\u22a2 HEq a b \u2192 HEq b c \u2192 HEq c d \u2192 (a \u2194 d)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) (f : Nat \u2192 Nat) : HEq a b \u2192 b = c \u2192 HEq (f a) (f c) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 HEq a b \u2192 b = c \u2192 HEq (f a) (f c)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) (f : Nat \u2192 Nat) : HEq a b \u2192 b = c \u2192 f a = f c := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 HEq a b \u2192 b = c \u2192 f a = f c"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) (f : Nat \u2192 Nat) : HEq a b \u2192 b = c \u2192 HEq c (f d) \u2192 f a = f (f d) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 HEq a b \u2192 b = c \u2192 HEq c (f d) \u2192 f a = f (f d)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (n1 n2 n3 : Nat)\n    (v1 w1 : List.Vector Nat n1) (w1' : List.Vector Nat n3) (v2 w2 : List.Vector Nat n2) :\n    n1 = n3 \u2192 v1 = w1 \u2192 HEq w1 w1' \u2192 v2 = w2 \u2192 HEq (app v1 v2) (app w1' w2) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\napp : x\u271d\nn1 n2 n3 : \u2115\nv1 w1 : List.Vector \u2115 n1\nw1' : List.Vector \u2115 n3\nv2 w2 : List.Vector \u2115 n2\n\u22a2 n1 = n3 \u2192 v1 = w1 \u2192 HEq w1 w1' \u2192 v2 = w2 \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (n1 n2 n3 : Nat)\n    (v1 w1 : List.Vector Nat n1) (w1' : List.Vector Nat n3) (v2 w2 : List.Vector Nat n2) :\n    HEq n1 n3 \u2192 v1 = w1 \u2192 HEq w1 w1' \u2192 HEq v2 w2 \u2192 HEq (app v1 v2) (app w1' w2) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\napp : x\u271d\nn1 n2 n3 : \u2115\nv1 w1 : List.Vector \u2115 n1\nw1' : List.Vector \u2115 n3\nv2 w2 : List.Vector \u2115 n2\n\u22a2 HEq n1 n3 \u2192 v1 = w1 \u2192 HEq w1 w1' \u2192 HEq v2 w2 \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (n1 n2 n3 : Nat)\n    (v1 w1 v : List.Vector Nat n1) (w1' : List.Vector Nat n3) (v2 w2 w : List.Vector Nat n2) :\n    HEq n1 n3 \u2192 v1 = w1 \u2192 HEq w1 w1' \u2192 HEq v2 w2 \u2192 HEq (app w1' w2) (app v w) \u2192\n      app v1 v2 = app v w := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\napp : x\u271d\nn1 n2 n3 : \u2115\nv1 w1 v : List.Vector \u2115 n1\nw1' : List.Vector \u2115 n3\nv2 w2 w : List.Vector \u2115 n2\n\u22a2 HEq n1 n3 \u2192 v1 = w1 \u2192 HEq w1 w1' \u2192 HEq v2 w2 \u2192 HEq sorry sorry \u2192 sorry = sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : \u2200 (a a' : A), HEq a a' \u2192 HEq (mk_B1 a) (mk_B1 a') := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Sort u_1\nx\u271d : Sort u_2\nmk_B1 : x\u271d\n\u22a2 \u2200 (a a' : A), HEq a a' \u2192 HEq ?m.35 ?m.37"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : \u2200 (a a' : A), HEq a a' \u2192 HEq (mk_B2 a) (mk_B2 a') := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Sort u_1\nx\u271d : Sort u_2\nmk_B2 : x\u271d\n\u22a2 \u2200 (a a' : A), HEq a a' \u2192 HEq ?m.35 ?m.37"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : \u2200 (a a' : A) (h : a = a') (b : B a), HEq (h \u25b8 b) b := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Sort u_1\nx\u271d : Sort u_2\nB : x\u271d\n\u22a2 \u2200 (a a' : A) (h : a = a') (b : sorry), HEq ?m.34 b"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : HEq a1 (y a2) \u2192 HEq (mk_B1 a1) (mk_B1 (y a2)) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\na1 : \u03b1\u271d\nx\u271d\u00b9 : Sort u_2\ny : x\u271d\u00b9\nx\u271d : Sort u_3\nmk_B1 : x\u271d\n\u22a2 HEq a1 sorry \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : HEq a1 (x a2) \u2192 HEq a2 (y a1) \u2192 HEq (mk_B1 (x (y a1))) (mk_B1 (x (y (x a2)))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Sort u_1\na1 : \u03b1\u271d\u00b9\nx\u271d\u00b2 : Sort u_2\nx : x\u271d\u00b2\n\u03b1\u271d : Sort u_3\na2 : \u03b1\u271d\nx\u271d\u00b9 : Sort u_4\ny : x\u271d\u00b9\nx\u271d : Sort u_5\nmk_B1 : x\u271d\n\u22a2 HEq a1 sorry \u2192 HEq a2 sorry \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : HEq a1 (y a2) \u2192 HEq (mk_B1 a1) (mk_B2 (y a2)) \u2192\n    HEq (f (mk_C1 (mk_B2 a1))) (f (mk_C2 (mk_B1 (y a2)))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\na1 : \u03b1\u271d\nx\u271d\u00b3 : Sort u_2\ny : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_3\nmk_B1 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\nmk_B2 : x\u271d\u00b9\nx\u271d : Sort u_5\nf : x\u271d\n\u22a2 HEq a1 sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : HEq a1 (y a2) \u2192 HEq (tr_B (mk_B1 a1)) (mk_B2 (y a2)) \u2192\n    HEq (f (mk_C1 (mk_B2 a1))) (f (mk_C2 (tr_B (mk_B1 (y a2))))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\na1 : \u03b1\u271d\nx\u271d\u00b3 : Sort u_2\ny : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_3\ntr_B : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\nmk_B2 : x\u271d\u00b9\nx\u271d : Sort u_5\nf : x\u271d\n\u22a2 HEq a1 sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : HEq a1 (y a2) \u2192 HEq (mk_B1 a1) (mk_B2 (y a2)) \u2192\n    HEq (g (f (mk_C1 (mk_B2 a1)))) (g (f (mk_C2 (mk_B1 (y a2))))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\na1 : \u03b1\u271d\nx\u271d\u00b3 : Sort u_2\ny : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_3\nmk_B1 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\nmk_B2 : x\u271d\u00b9\nx\u271d : Sort u_5\ng : x\u271d\n\u22a2 HEq a1 sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : HEq a1 (y a2) \u2192 HEq (tr_B (mk_B1 a1)) (mk_B2 (y a2)) \u2192\n    HEq (g (f (mk_C1 (mk_B2 a1)))) (g (f (mk_C2 (tr_B (mk_B1 (y a2)))))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\na1 : \u03b1\u271d\nx\u271d\u00b3 : Sort u_2\ny : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_3\ntr_B : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\nmk_B2 : x\u271d\u00b9\nx\u271d : Sort u_5\ng : x\u271d\n\u22a2 HEq a1 sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : HEq a1 (y a2) \u2192 HEq a2 (z a3) \u2192 HEq a3 (x a1) \u2192 HEq (mk_B1 a1) (mk_B2 (y (z (x a1)))) \u2192\n          HEq (f (mk_C1 (mk_B2 (y (z (x a1)))))) (f' (mk_C2 (mk_B1 a1))) \u2192\n          HEq (g (f (mk_C1 (mk_B2 (y (z (x a1))))))) (g (f' (mk_C2 (mk_B1 a1)))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b2 : Sort u_1\na1 : \u03b1\u271d\u00b2\nx\u271d\u2077 : Sort u_2\ny : x\u271d\u2077\n\u03b1\u271d\u00b9 : Sort u_3\na2 : \u03b1\u271d\u00b9\nx\u271d\u2076 : Sort u_4\nz : x\u271d\u2076\n\u03b1\u271d : Sort u_5\na3 : \u03b1\u271d\nx\u271d\u2075 : Sort u_6\nx : x\u271d\u2075\nx\u271d\u2074 : Sort u_7\nmk_B1 : x\u271d\u2074\nx\u271d\u00b3 : Sort u_8\nmk_B2 : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_9\nf : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_10\nf' : x\u271d\u00b9\nx\u271d : Sort u_11\ng : x\u271d\n\u22a2 HEq a1 sorry \u2192 HEq a2 sorry \u2192 HEq a3 sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : HEq a1 (y a2) \u2192 HEq a2 (z a3) \u2192 HEq a3 (x a1) \u2192 HEq (mk_B1 a1) (mk_B2 (y (z (x a1)))) \u2192\n          HEq (f (mk_C1 (mk_B2 (y (z (x a1)))))) (f' (mk_C2 (mk_B1 a1))) \u2192\n          HEq (f' (mk_C1 (mk_B1 a1))) (f (mk_C2 (mk_B2 (y (z (x a1)))))) \u2192\n          HEq (g (f (mk_C1 (mk_B1 (y (z (x a1))))))) (g (f' (mk_C2 (mk_B2 a1)))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b2 : Sort u_1\na1 : \u03b1\u271d\u00b2\nx\u271d\u2077 : Sort u_2\ny : x\u271d\u2077\n\u03b1\u271d\u00b9 : Sort u_3\na2 : \u03b1\u271d\u00b9\nx\u271d\u2076 : Sort u_4\nz : x\u271d\u2076\n\u03b1\u271d : Sort u_5\na3 : \u03b1\u271d\nx\u271d\u2075 : Sort u_6\nx : x\u271d\u2075\nx\u271d\u2074 : Sort u_7\nmk_B1 : x\u271d\u2074\nx\u271d\u00b3 : Sort u_8\nmk_B2 : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_9\nf : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_10\nf' : x\u271d\u00b9\nx\u271d : Sort u_11\ng : x\u271d\n\u22a2 HEq a1 sorry \u2192 HEq a2 sorry \u2192 HEq a3 sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : HEq a1 (y a2) \u2192 HEq a2 (z a3) \u2192 HEq a3 (x a1) \u2192\n          HEq (tr_B (mk_B1 a1)) (mk_B2 (y (z (x a1)))) \u2192\n          HEq (f (mk_C1 (mk_B2 (y (z (x a1)))))) (f' (mk_C2 (tr_B (mk_B1 a1)))) \u2192\n          HEq (f' (mk_C1 (tr_B (mk_B1 a1)))) (f (mk_C2 (mk_B2 (y (z (x a1)))))) \u2192\n          HEq (g (f (mk_C1 (tr_B (mk_B1 (y (z (x a1)))))))) (g (f' (mk_C2 (mk_B2 a1)))) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b2 : Sort u_1\na1 : \u03b1\u271d\u00b2\nx\u271d\u2077 : Sort u_2\ny : x\u271d\u2077\n\u03b1\u271d\u00b9 : Sort u_3\na2 : \u03b1\u271d\u00b9\nx\u271d\u2076 : Sort u_4\nz : x\u271d\u2076\n\u03b1\u271d : Sort u_5\na3 : \u03b1\u271d\nx\u271d\u2075 : Sort u_6\nx : x\u271d\u2075\nx\u271d\u2074 : Sort u_7\ntr_B : x\u271d\u2074\nx\u271d\u00b3 : Sort u_8\nmk_B2 : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_9\nf : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_10\nf' : x\u271d\u00b9\nx\u271d : Sort u_11\ng : x\u271d\n\u22a2 HEq a1 sorry \u2192 HEq a2 sorry \u2192 HEq a3 sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry \u2192 HEq sorry sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c a' b' c' : Nat) : a = a' \u2192 b = b' \u2192 c = c' \u2192 a + b + c + a = a' + b' + c' + a' := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c a' b' c' : \u2115\n\u22a2 a = a' \u2192 b = b' \u2192 c = c' \u2192 a + b + c + a = a' + b' + c' + a'"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Unit) : a = b := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Unit\n\u22a2 a = b"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (h\u2081 : a = 0) (h\u2082 : b = 0) : a = b \u2192 HEq h\u2081 h\u2082 := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh\u2081 : a = 0\nh\u2082 : b = 0\n\u22a2 a = b \u2192 HEq h\u2081 h\u2082"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (h\u2081 : a \u2260 0) (h\u2082 : b \u2260 0) : a = b \u2192 inv' a h\u2081 = inv' b h\u2082 := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ninv' : x\u271d\na b : \u2115\nh\u2081 : a \u2260 0\nh\u2082 : b \u2260 0\n\u22a2 a = b \u2192 sorry = sorry"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (C : Nat \u2192 Type) (f : (n : _) \u2192 C n \u2192 C n) (n m : Nat) (c : C n) (d : C m) :\n    HEq (f n) (f m) \u2192 HEq c d \u2192 HEq n m \u2192 HEq (f n c) (f m d) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : \u2115 \u2192 Type\nf : (n : \u2115) \u2192 C n \u2192 C n\nn m : \u2115\nc : C n\nd : C m\n\u22a2 HEq (f n) (f m) \u2192 HEq c d \u2192 HEq n m \u2192 HEq (f n c) (f m d)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (f g : {\u03b1 : Type} \u2192 \u03b1 \u2192 \u03b1 \u2192 \u03b1) (h : Nat \u2192 Nat) (a b : Nat) :\n    h = f a \u2192 h b = f a b := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f g : {\u03b1 : Type} \u2192 \u03b1 \u2192 \u03b1 \u2192 \u03b1\nh : \u2115 \u2192 \u2115\na b : \u2115\n\u22a2 h = f a \u2192 h b = f a b"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (f g : {\u03b1 : Type} \u2192 (a b : \u03b1) \u2192 {x : \u03b1 // x \u2260 b})\n    (h : (b : Nat) \u2192 {x : Nat // x \u2260 b}) (a b\u2081 b\u2082 : Nat) :\n    h = f a \u2192 b\u2081 = b\u2082 \u2192 HEq (h b\u2081) (f a b\u2082) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f g : {\u03b1 : Type} \u2192 \u03b1 \u2192 (b : \u03b1) \u2192 { x // x \u2260 b }\nh : (b : \u2115) \u2192 { x // x \u2260 b }\na b\u2081 b\u2082 : \u2115\n\u22a2 h = f a \u2192 b\u2081 = b\u2082 \u2192 HEq (h b\u2081) (f a b\u2082)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (f : Nat \u2192 Nat \u2192 Nat) (a b c d : Nat) :\n    c = d \u2192 f a = f b \u2192 f a c = f b d := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115 \u2192 \u2115\na b c d : \u2115\n\u22a2 c = d \u2192 f a = f b \u2192 f a c = f b d"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (f : Nat \u2192 Nat \u2192 Nat) (a b c d : Nat) :\n        HEq c d \u2192 HEq (f a) (f b) \u2192 HEq (f a c) (f b d) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115 \u2192 \u2115\na b c d : \u2115\n\u22a2 HEq c d \u2192 HEq (f a) (f b) \u2192 HEq (f a c) (f b d)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) (f : Nat \u2192 Nat) : f (a + b + c) = f (c + b + a) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 f (a + b + c) = f (c + b + a)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) (f : Nat \u2192 Nat) : a + b = c \u2192 f (c + c) = f (a + b + c) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 a + b = c \u2192 f (c + c) = f (a + b + c)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) (f : Nat \u2192 Nat \u2192 Nat) : b + a = d \u2192 f (a + b + c) a = f (c + d) a := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 b + a = d \u2192 f (a + b + c) a = f (c + d) a"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d e : Nat) (f : Nat \u2192 Nat \u2192 Nat) :\n    b + a = d \u2192 b + c = e \u2192 f (a + b + c) (a + b + c) = f (c + d) (a + e) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 b + a = d \u2192 b + c = e \u2192 f (a + b + c) (a + b + c) = f (c + d) (a + e)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d e : Nat) (f : Nat \u2192 Nat \u2192 Nat) :\n    b + a = d + d \u2192 b + c = e + e \u2192 f (a + b + c) (a + b + c) = f (c + d + d) (e + a + e) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 b + a = d + d \u2192 b + c = e + e \u2192 f (a + b + c) (a + b + c) = f (c + d + d) (e + a + e)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "lemma ex\u2081 (a b c d e : \u03b1) (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) :\n    op b a = op d d \u2192 op b c = op e e \u2192\n    f (op a (op b c)) (op (op a b) c) = f (op (op c d) d) (op e (op a e)) := by\n  cc", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Std.Associative op\ninst\u271d : Std.Commutative op\na b c d e : \u03b1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\n\u22a2 op b a = op d d \u2192 op b c = op e e \u2192 f (op a (op b c)) (op (op a b) c) = f (op (op c d) d) (op e (op a e))"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d\u2081 d\u2082 e\u2081 e\u2082 : Set \u03b1) (f : Set \u03b1 \u2192 Set \u03b1 \u2192 Set \u03b1) :\n    b \u222a a = d\u2081 \u222a d\u2082 \u2192 b \u222a c = e\u2082 \u222a e\u2081 \u2192\n      f (a \u222a b \u222a c) (a \u222a b \u222a c) = f (c \u222a d\u2082 \u222a d\u2081) (e\u2082 \u222a a \u222a e\u2081) := by\n  cc", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u\nop : \u03b1\u271d \u2192 \u03b1\u271d \u2192 \u03b1\u271d\ninst\u271d\u00b9 : Std.Associative op\ninst\u271d : Std.Commutative op\n\u03b1 : Type u\na b c d\u2081 d\u2082 e\u2081 e\u2082 : Set \u03b1\nf : Set \u03b1 \u2192 Set \u03b1 \u2192 Set \u03b1\n\u22a2 b \u222a a = d\u2081 \u222a d\u2082 \u2192 b \u222a c = e\u2082 \u222a e\u2081 \u2192 f (a \u222a b \u222a c) (a \u222a b \u222a c) = f (c \u222a d\u2082 \u222a d\u2081) (e\u2082 \u222a a \u222a e\u2081)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (x1 x2 x3 x4 x5 x6 : \u03b1) :\n    x1*x4 = x1 \u2192 x3*x6 = x5*x5 \u2192 x5 = x4 \u2192 x6 = x2 \u2192 x1 = x1*(x6*x3) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\nx1 x2 x3 x4 x5 x6 : \u03b1\n\u22a2 x1 * x4 = x1 \u2192 x3 * x6 = x5 * x5 \u2192 x5 = x4 \u2192 x6 = x2 \u2192 x1 = x1 * (x6 * x3)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (y1 y2 x2 x3 x4 x5 x6 : \u03b1) :\n    (y1 + y2)*x4 = (y2 + y1) \u2192 x3*x6 = x5*x5 \u2192 x5 = x4 \u2192 x6 = x2 \u2192\n      (y2 + y1) = (y1 + y2)*(x6*x3) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\ny1 y2 x2 x3 x4 x5 x6 : \u03b1\n\u22a2 (y1 + y2) * x4 = y2 + y1 \u2192 x3 * x6 = x5 * x5 \u2192 x5 = x4 \u2192 x6 = x2 \u2192 y2 + y1 = (y1 + y2) * (x6 * x3)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (y1 y2 y3 x2 x3 x4 x5 x6 : \u03b1) :\n    (y1 + y2)*x4 = (y3 + y1) \u2192 x3*x6 = x5*x5 \u2192 x5 = x4 \u2192 x6 = x2 \u2192 y2 = y3 \u2192\n      (y2 + y1) = (y1 + y3)*(x6*x3) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\ny1 y2 y3 x2 x3 x4 x5 x6 : \u03b1\n\u22a2 (y1 + y2) * x4 = y3 + y1 \u2192 x3 * x6 = x5 * x5 \u2192 x5 = x4 \u2192 x6 = x2 \u2192 y2 = y3 \u2192 y2 + y1 = (y1 + y3) * (x6 * x3)"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (s t : List Nat) : a :: s = b :: t \u2192 a \u2260 b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\ns t : List \u2115\n\u22a2 a :: s = b :: t \u2192 a \u2260 b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (s t : List Nat) : a :: s = b :: t \u2192 t \u2260 s \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\ns t : List \u2115\n\u22a2 a :: s = b :: t \u2192 t \u2260 s \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a c b : Nat) (s t : List Nat) : a :: s = b :: t \u2192 a \u2260 c \u2192 c = b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na c b : \u2115\ns t : List \u2115\n\u22a2 a :: s = b :: t \u2192 a \u2260 c \u2192 c = b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a c b : Nat) (s t : List Nat) : a :: a :: s = a :: b :: t \u2192 a \u2260 c \u2192 c = b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na c b : \u2115\ns t : List \u2115\n\u22a2 a :: a :: s = a :: b :: t \u2192 a \u2260 c \u2192 c = b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (s t r : List Nat) : a :: s = r \u2192 r = b :: t \u2192 a \u2260 b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\ns t r : List \u2115\n\u22a2 a :: s = r \u2192 r = b :: t \u2192 a \u2260 b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (s t r : List Nat) : a :: s = r \u2192 r = b :: t \u2192 a = b := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\ns t r : List \u2115\n\u22a2 a :: s = r \u2192 r = b :: t \u2192 a = b"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) (s t r : List Nat) : List.cons a = List.cons b \u2192 a = b := by\n  intro h1\n  /- In the current implementation, `cc` does not \"complete\" partially applied\n     constructor applications. So, the following one should fail. -/\n  try cc\n  /- Complete it manually. TODO(Leo): we can automate it for inhabited types. -/\n  have h := congr_fun h1 []\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\ns t r : List \u2115\n\u22a2 List.cons a = List.cons b \u2192 a = b"}, {"line": "  intro h1", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\ns t r : List \u2115\nh1 : List.cons a = List.cons b\n\u22a2 a = b"}, {"line": "  /- In the current implementation, `cc` does not \"complete\" partially applied", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\ns t r : List \u2115\nh1 : List.cons a = List.cons b\n\u22a2 a = b"}, {"line": "     constructor applications. So, the following one should fail. -/", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\ns t r : List \u2115\nh1 : List.cons a = List.cons b\nh : [a] = [b]\n\u22a2 a = b"}, {"line": "  try cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) : Foo.mk1 a = Foo.mk2 b \u2192 False := by\n  intro h1\n  /- In the current implementation, `cc` does not \"complete\" partially applied\n     constructor applications. So, the following one should fail. -/\n  try cc\n  have h := congr_fun h1 0\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\n\u22a2 sorry = sorry \u2192 False"}, {"line": "  intro h1", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\nh1 : sorry = sorry\n\u22a2 False"}, {"line": "  /- In the current implementation, `cc` does not \"complete\" partially applied", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\nh1 : sorry = sorry\n\u22a2 False"}, {"line": "     constructor applications. So, the following one should fail. -/", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\nh1 : sorry = sorry\n\u22a2 False"}]}
{"declaration": "example (\u03b1 : Type u) (a b c d : \u03b1) (n : Nat) (s t : Vec \u03b1 n) :\n    Vec.cons a s = Vec.cons b t \u2192 a \u2260 b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b2 : Type u\nop : \u03b1\u271d\u00b2 \u2192 \u03b1\u271d\u00b2 \u2192 \u03b1\u271d\u00b2\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d\u00b9 \u03b1\u271d : Type u\ninst\u271d : CommRing \u03b1\u271d\nx\u271d : Sort u_1\nVec : x\u271d\n\u03b1 : Type u\na b c d : \u03b1\nn : \u2115\ns : sorry\nt : sorry\n\u22a2 sorry = sorry \u2192 a \u2260 b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (\u03b1 : Type u) (a b c d : \u03b1) (n : Nat) (s t : Vec \u03b1 n) :\n    Vec.cons a s = Vec.cons b t \u2192 t \u2260 s \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b2 : Type u\nop : \u03b1\u271d\u00b2 \u2192 \u03b1\u271d\u00b2 \u2192 \u03b1\u271d\u00b2\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d\u00b9 \u03b1\u271d : Type u\ninst\u271d : CommRing \u03b1\u271d\nx\u271d : Sort u_1\nVec : x\u271d\n\u03b1 : Type u\na b c d : \u03b1\nn : \u2115\ns : sorry\nt : sorry\n\u22a2 sorry = sorry \u2192 t \u2260 s \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (\u03b1 : Type u) (a b c d : \u03b1) (n : Nat) (s t : Vec \u03b1 n) :\n    Vec.cons a (Vec.cons a s) = Vec.cons a (Vec.cons b t) \u2192 b \u2260 c \u2192 c = a \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b2 : Type u\nop : \u03b1\u271d\u00b2 \u2192 \u03b1\u271d\u00b2 \u2192 \u03b1\u271d\u00b2\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d\u00b9 \u03b1\u271d : Type u\ninst\u271d : CommRing \u03b1\u271d\nx\u271d : Sort u_1\nVec : x\u271d\n\u03b1 : Type u\na b c d : \u03b1\nn : \u2115\ns : sorry\nt : sorry\n\u22a2 sorry = sorry \u2192 b \u2260 c \u2192 c = a \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c d : Nat) (f : Nat \u2192 Nat \u00d7 Nat) : (f d).1 \u2260 a \u2192 f d = (b, c) \u2192 b = a \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b c d : \u2115\nf : \u2115 \u2192 \u2115 \u00d7 \u2115\n\u22a2 (f d).1 \u2260 a \u2192 f d = (b, c) \u2192 b = a \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) (f : Nat \u2192 Nat) : (f b, c).1 \u2260 f a \u2192 f b = f c \u2192 a = c \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b c : \u2115\nf : \u2115 \u2192 \u2115\n\u22a2 (f b, c).1 \u2260 f a \u2192 f b = f c \u2192 a = c \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) : a = 1 \u2192 b = 2 \u2192 a = b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : \u2115\n\u22a2 a = 1 \u2192 b = 2 \u2192 a = b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : Int) : a = 1 \u2192 c = -2 \u2192 a = b \u2192 c = b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b c : \u2124\n\u22a2 a = 1 \u2192 c = -2 \u2192 a = b \u2192 c = b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : Char) : a = 'h' \u2192 b = 'w' \u2192 a = b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : Char\n\u22a2 a = 'h' \u2192 b = 'w' \u2192 a = b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b : String) : a = \"hello\" \u2192 b = \"world\" \u2192 a = b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b : String\n\u22a2 a = \"hello\" \u2192 b = \"world\" \u2192 a = b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example (a b c : String) : a = c \u2192 a = \"hello\" \u2192 c = \"world\" \u2192 c = b \u2192 False := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\na b c : String\n\u22a2 a = c \u2192 a = \"hello\" \u2192 c = \"world\" \u2192 c = b \u2192 False"}, {"line": "  cc", "tactic_state": ""}]}
{"declaration": "example : @OfNat.ofNat \u2115 (nat_lit 0) (instOfNatNat _) =\n    @OfNat.ofNat \u2115 (nat_lit 0) (instOfNatNat' _) := by\n  cc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cc.lean", "context": {"open": ["List (Vector)", "Mathlib.Tactic.CC", "Lean Meta Elab Tactic", "Mathlib"], "variables": ["{\u03b1 : Type u}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[Std.Associative op]", "[Std.Commutative op]", "{\u03b1 : Type u}", "{\u03b1 : Type u}", "[CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\nx\u271d : Sort u_1\ninstOfNatNat' : x\u271d\n\u22a2 0 = 0"}, {"line": "  cc", "tactic_state": "\u03b1\u271d\u00b9 : Type u\nop : \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9 \u2192 \u03b1\u271d\u00b9\ninst\u271d\u00b2 : Std.Associative op\ninst\u271d\u00b9 : Std.Commutative op\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : CommRing \u03b1\nx\u271d : Sort u_1\ninstOfNatNat' : x\u271d\n\u22a2 0 = 0"}]}
{"declaration": "theorem transpose_const {m n} (c : Nat) :\n    transpose (fun (_i : m) (_j : n) => c) = fun _j _i => c := by\n  fail_if_success {rw [transpose]}\n  fail_if_success {simp [transpose]}\n  funext i j -- the rw below does not work without this line\n  rw [transpose]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/eqns.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntranspose : x\u271d\nm : ?m.459\nn : ?m.460\nc : \u2115\n\u22a2 sorry = fun _j _i => c"}, {"line": "  fail_if_success {rw [transpose]}", "tactic_state": "x\u271d : Sort u_1\ntranspose : x\u271d\nm : ?m.459\nn : ?m.460\nc : \u2115\n\u22a2 sorry = fun _j _i => c"}, {"line": "  fail_if_success {simp [transpose]}", "tactic_state": "x\u271d : Sort u_1\ntranspose : x\u271d\nm : ?m.459\nn : ?m.460\nc : \u2115\n\u22a2 sorry = fun _j _i => c"}, {"line": "  funext i j -- the rw below does not work without this line", "tactic_state": "case h.h\nx\u271d : Sort u_1\ntranspose : x\u271d\nm : ?m.459\nn : ?m.460\nc : \u2115\ni : ?m.461 c\nj : ?m.462 c i\n\u22a2 sorry i j = c"}, {"line": "  rw [transpose]", "tactic_state": "case h.h\nx\u271d : Sort u_1\ntranspose : x\u271d\nm : ?m.459\nn : ?m.460\nc : \u2115\ni : ?m.461 c\nj : ?m.462 c i\n\u22a2 sorry i j = c"}]}
{"declaration": "theorem t_def' : t = 1 := by rw [t]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/eqns.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : \u2115\n\u22a2 t = 1"}]}
{"declaration": "example (n : Nat) : t = n := by\n  rw [t]\n  admit", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/eqns.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "t n : \u2115\n\u22a2 t = n"}, {"line": "  rw [t]", "tactic_state": "t n : \u2115\n\u22a2 t = n"}]}
{"declaration": "example (x : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3) : True := by\n  cases' x with a b; cases' b with b c\n  guard_hyp a : \u03b1\n  guard_hyp b : \u03b2\n  guard_hyp c : \u03b3\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\n\u22a2 True"}, {"line": "  cases' x with a b; cases' b with b c", "tactic_state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na : \u03b1\nb : \u03b2 \u00d7 \u03b3\n\u22a2 True"}, {"line": "  guard_hyp a : \u03b1", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na : \u03b1\nb : \u03b2\nc : \u03b3\n\u22a2 True"}, {"line": "  guard_hyp b : \u03b2", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na : \u03b1\nb : \u03b2\nc : \u03b3\n\u22a2 True"}, {"line": "  guard_hyp c : \u03b3", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na : \u03b1\nb : \u03b2\nc : \u03b3\n\u22a2 True"}, {"line": "  trivial", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na : \u03b1\nb : \u03b2\nc : \u03b3\n\u22a2 True"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type u} (x : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3) : True := by\n  cases' h: x with a b\n  guard_hyp a : \u03b1\n  guard_hyp b : \u03b2 \u00d7 \u03b3\n  guard_hyp x : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\n  guard_hyp h : x = (a, b)\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type u\nx : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\n\u22a2 True"}, {"line": "  cases' h: x with a b", "tactic_state": "case mk\n\u03b1 \u03b2 \u03b3 : Type u\nx : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\na : \u03b1\nb : \u03b2 \u00d7 \u03b3\nh : x = (a, b)\n\u22a2 True"}, {"line": "  guard_hyp a : \u03b1", "tactic_state": "case mk\n\u03b1 \u03b2 \u03b3 : Type u\nx : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\na : \u03b1\nb : \u03b2 \u00d7 \u03b3\nh : x = (a, b)\n\u22a2 True"}, {"line": "  guard_hyp b : \u03b2 \u00d7 \u03b3", "tactic_state": "case mk\n\u03b1 \u03b2 \u03b3 : Type u\nx : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\na : \u03b1\nb : \u03b2 \u00d7 \u03b3\nh : x = (a, b)\n\u22a2 True"}, {"line": "  guard_hyp x : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3", "tactic_state": "case mk\n\u03b1 \u03b2 \u03b3 : Type u\nx : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\na : \u03b1\nb : \u03b2 \u00d7 \u03b3\nh : x = (a, b)\n\u22a2 True"}, {"line": "  guard_hyp h : x = (a, b)", "tactic_state": "case mk\n\u03b1 \u03b2 \u03b3 : Type u\nx : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\na : \u03b1\nb : \u03b2 \u00d7 \u03b3\nh : x = (a, b)\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) : True := by\n  cases' h: x using my_rec with y\n  case zee => guard_hyp h : x = 0; trivial\n  case soo => guard_hyp h : x = y + 1; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 True"}, {"line": "  cases' h: x using my_rec with y", "tactic_state": "x x\u271d : \u2115\nh : x = x\u271d\n\u22a2 True"}]}
{"declaration": "example (x : Foo \u03b1 \u03b2) : True := by\n  cases' x with a\u2080 a\u2081 _ a\u2082 b\u2082 c\u2082\n  \u00b7 guard_hyp a\u2080 : \u03b1; trivial\n  \u00b7 guard_hyp a\u2081 : \u03b1; have : \u03b2 := (by assumption); trivial\n  \u00b7 guard_hyp a\u2082 : \u03b1; guard_hyp b\u2082 : \u03b2; guard_hyp c\u2082 : Foo \u03b1 \u03b2; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nFoo : x\u271d\nx : sorry\n\u22a2 True"}, {"line": "  cases' x with a\u2080 a\u2081 _ a\u2082 b\u2082 c\u2082", "tactic_state": "x\u271d : Sort u_1\nFoo : x\u271d\nx : sorry\n\u22a2 True"}]}
{"declaration": "example (x : Bar 0) : True := by\n  cases' x with a b c d h\n  \u00b7 guard_hyp d : \u2115; guard_hyp h : Bar (0 + 1); trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nBar : x\u271d\nx : sorry\n\u22a2 True"}, {"line": "  cases' x with a b c d h", "tactic_state": "x\u271d : Sort u_1\nBar : x\u271d\nx : sorry\n\u22a2 True"}]}
{"declaration": "example (n : Nat) : n = n := by\n  induction' n with n ih\n  \u00b7 guard_target =\u209b 0 = 0; rfl\n  \u00b7 guard_hyp n : Nat; guard_hyp ih : n = n\n    guard_target =\u209b n + 1 = n + 1; exact congr_arg (\u00b7 + 1) ih\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n = n"}, {"line": "  induction' n with n ih", "tactic_state": "case zero\n\u22a2 0 = 0\n---\ncase succ\nn : \u2115\nih : n = n\n\u22a2 n + 1 = n + 1"}, {"line": "  \u00b7 guard_target =\u209b 0 = 0; rfl", "tactic_state": "case zero\n\u22a2 0 = 0"}, {"line": "  \u00b7 guard_hyp n : Nat; guard_hyp ih : n = n", "tactic_state": ""}, {"line": "    guard_target =\u209b n + 1 = n + 1; exact congr_arg (\u00b7 + 1) ih", "tactic_state": "case succ\nn : \u2115\nih : n = n\n\u22a2 n + 1 = n + 1"}]}
{"declaration": "example (n : Nat) (h : n < 5) : n = n := by\n  induction' n with n ih\n  \u00b7 guard_target =\u209b 0 = 0; rfl\n  \u00b7 guard_hyp n : Nat; guard_hyp ih : n < 5 \u2192 n = n; guard_hyp h :\u209b n + 1 < 5\n    guard_target =\u209b n + 1 = n + 1; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : n < 5\n\u22a2 n = n"}, {"line": "  induction' n with n ih", "tactic_state": "case zero\nh : 0 < 5\n\u22a2 0 = 0\n---\ncase succ\nn : \u2115\nih : n < 5 \u2192 n = n\nh : n + 1 < 5\n\u22a2 n + 1 = n + 1"}, {"line": "  \u00b7 guard_target =\u209b 0 = 0; rfl", "tactic_state": "case zero\nh : 0 < 5\n\u22a2 0 = 0"}, {"line": "  \u00b7 guard_hyp n : Nat; guard_hyp ih : n < 5 \u2192 n = n; guard_hyp h :\u209b n + 1 < 5", "tactic_state": ""}, {"line": "    guard_target =\u209b n + 1 = n + 1; rfl", "tactic_state": "case succ\nn : \u2115\nih : n < 5 \u2192 n = n\nh : n + 1 < 5\n\u22a2 n + 1 = n + 1"}]}
{"declaration": "example (n : Nat) {m} (h : m < 5) : n = n := by\n  induction' n with n ih\n  \u00b7 guard_target = Nat.zero = Nat.zero; rfl\n  \u00b7 guard_hyp n : Nat; guard_hyp ih : n = n; guard_hyp h : m < 5\n    guard_target = Nat.succ n = Nat.succ n; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : m < 5\n\u22a2 n = n"}, {"line": "  induction' n with n ih", "tactic_state": "case zero\nm : \u2115\nh : m < 5\n\u22a2 0 = 0\n---\ncase succ\nm : \u2115\nh : m < 5\nn : \u2115\nih : n = n\n\u22a2 n + 1 = n + 1"}, {"line": "  \u00b7 guard_target = Nat.zero = Nat.zero; rfl", "tactic_state": "case zero\nm : \u2115\nh : m < 5\n\u22a2 0 = 0"}, {"line": "  \u00b7 guard_hyp n : Nat; guard_hyp ih : n = n; guard_hyp h : m < 5", "tactic_state": ""}, {"line": "    guard_target = Nat.succ n = Nat.succ n; rfl", "tactic_state": "case succ\nm : \u2115\nh : m < 5\nn : \u2115\nih : n = n\n\u22a2 n + 1 = n + 1"}]}
{"declaration": "example (n : Nat) {m} (h : m < 5) : n = n := by\n  induction' n with n ih generalizing m\n  \u00b7 guard_target = Nat.zero = Nat.zero; rfl\n  \u00b7 guard_hyp n : Nat; guard_hyp ih : \u2200 {m}, m < 5 \u2192 n = n; guard_hyp h : m < 5\n    guard_target = Nat.succ n = Nat.succ n; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : m < 5\n\u22a2 n = n"}, {"line": "  induction' n with n ih generalizing m", "tactic_state": "case zero\nm : \u2115\nh : m < 5\n\u22a2 0 = 0\n---\ncase succ\nn : \u2115\nih : \u2200 {m : \u2115}, m < 5 \u2192 n = n\nm : \u2115\nh : m < 5\n\u22a2 n + 1 = n + 1"}, {"line": "  \u00b7 guard_target = Nat.zero = Nat.zero; rfl", "tactic_state": "case zero\nm : \u2115\nh : m < 5\n\u22a2 0 = 0"}, {"line": "  \u00b7 guard_hyp n : Nat; guard_hyp ih : \u2200 {m}, m < 5 \u2192 n = n; guard_hyp h : m < 5", "tactic_state": ""}, {"line": "    guard_target = Nat.succ n = Nat.succ n; rfl", "tactic_state": "case succ\nn : \u2115\nih : \u2200 {m : \u2115}, m < 5 \u2192 n = n\nm : \u2115\nh : m < 5\n\u22a2 n + 1 = n + 1"}]}
{"declaration": "example (n : Nat) : n = n := by\n  induction' e : n with m ih\n  \u00b7 guard_hyp e : n = Nat.zero; guard_target = Nat.zero = Nat.zero; rfl\n  \u00b7 guard_hyp m : Nat; guard_hyp ih : n = m \u2192 m = m\n    guard_hyp e : n = Nat.succ m; guard_target = Nat.succ m = Nat.succ m; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n = n"}, {"line": "  induction' e : n with m ih", "tactic_state": "case zero\nn : \u2115\ne : n = 0\n\u22a2 0 = 0\n---\ncase succ\nn m : \u2115\nih : n = m \u2192 m = m\ne : n = m + 1\n\u22a2 m + 1 = m + 1"}, {"line": "  \u00b7 guard_hyp e : n = Nat.zero; guard_target = Nat.zero = Nat.zero; rfl", "tactic_state": "case zero\nn : \u2115\ne : n = 0\n\u22a2 0 = 0"}, {"line": "  \u00b7 guard_hyp m : Nat; guard_hyp ih : n = m \u2192 m = m", "tactic_state": "case zero\nn : \u2115\ne : n = 0\n\u22a2 0 = 0"}, {"line": "    guard_hyp e : n = Nat.succ m; guard_target = Nat.succ m = Nat.succ m; rfl", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : n = n := by\n  induction' e : n using my_rec with m ih\n  case zee =>\n    guard_hyp e : n = 0; guard_target = 0 = 0; rfl\n  case soo =>\n    guard_hyp m : Nat; guard_hyp ih : n = m \u2192 m = m\n    guard_hyp e : n = m + 1; guard_target = m + 1 = m + 1; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n = n"}, {"line": "  induction' e : n using my_rec with m ih", "tactic_state": "n x\u271d : \u2115\ne : n = x\u271d\n\u22a2 x\u271d = x\u271d"}]}
{"declaration": "example (x : Foo \u03b1 Nat) : True := by\n  induction' x with a a' b' a'' b'' c'' ih\n  case A => guard_hyp a : \u03b1; trivial\n  case B => guard_hyp a' : \u03b1; guard_hyp b' : Nat; trivial\n  case C => guard_hyp a'' : \u03b1; guard_hyp b'' : Nat; guard_hyp c'' : Foo \u03b1 Nat\n            guard_hyp ih : True; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nFoo : x\u271d\nx : sorry\n\u22a2 True"}, {"line": "  induction' x with a a' b' a'' b'' c'' ih", "tactic_state": "x\u271d : Sort u_1\nFoo : x\u271d\nx : sorry\n\u22a2 True"}]}
{"declaration": "example (x : Bar n) : x = x := by\n  induction' x with a b c d h ih\n  case A => guard_target = Bar.A a b = Bar.A a b; rfl\n  case B => guard_hyp h : Bar (c + 1); guard_hyp ih : h = h\n            guard_target = Bar.B c d h = Bar.B c d h; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nBar : x\u271d\nx : sorry\n\u22a2 x = x"}, {"line": "  induction' x with a b c d h ih", "tactic_state": "x\u271d : Sort u_1\nBar : x\u271d\nx : sorry\n\u22a2 x = x"}]}
{"declaration": "example (p q : Prop) : (p \u2192 \u00ac q) \u2192 \u00ac (p \u2227 q) := by\n  intro hpnq hpq\n  apply hpnq\n  cases' hpq with hp hq\n  assumption\n  exact hpq.2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\n\u22a2 (p \u2192 \u00acq) \u2192 \u00ac(p \u2227 q)"}, {"line": "  intro hpnq hpq", "tactic_state": "p q : Prop\nhpnq : p \u2192 \u00acq\nhpq : p \u2227 q\n\u22a2 False"}, {"line": "  apply hpnq", "tactic_state": "case a\np q : Prop\nhpnq : p \u2192 \u00acq\nhpq : p \u2227 q\n\u22a2 p\n---\ncase a\np q : Prop\nhpnq : p \u2192 \u00acq\nhpq : p \u2227 q\n\u22a2 q"}, {"line": "  cases' hpq with hp hq", "tactic_state": "case a.intro\np q : Prop\nhpnq : p \u2192 \u00acq\nhp : p\nhq : q\n\u22a2 p\n---\ncase a\np q : Prop\nhpnq : p \u2192 \u00acq\nhpq : p \u2227 q\n\u22a2 q"}, {"line": "  assumption", "tactic_state": "case a\np q : Prop\nhpnq : p \u2192 \u00acq\nhpq : p \u2227 q\n\u22a2 q"}, {"line": "  exact hpq.2", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : a + b = a) : b = 0 := by\n  induction' a with d hd\n  \u00b7 -- Test the generalized vars have been removed\n    revert h\n    fail_if_success (guard_hyp a : Nat)\n    fail_if_success (guard_hyp h : a + b = a)\n    intro h\n    -- Sample proof\n    rw [Nat.zero_add] at h\n    assumption\n  \u00b7 -- Test the generalized vars have been removed\n    revert h\n    fail_if_success (guard_hyp a : Nat)\n    fail_if_success (guard_hyp h : a + b = a)\n    intro h\n    -- Sample proof\n    rw [Nat.succ_add, Nat.succ.injEq] at h\n    apply hd\n    assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a + b = a\n\u22a2 b = 0"}, {"line": "  induction' a with d hd", "tactic_state": "case zero\nb : \u2115\nh : 0 + b = 0\n\u22a2 b = 0\n---\ncase succ\nb d : \u2115\nhd : d + b = d \u2192 b = 0\nh : d + 1 + b = d + 1\n\u22a2 b = 0"}, {"line": "  \u00b7 -- Test the generalized vars have been removed", "tactic_state": "case zero\nb : \u2115\n\u22a2 0 + b = 0 \u2192 b = 0"}, {"line": "    revert h", "tactic_state": "case zero\nb : \u2115\n\u22a2 0 + b = 0 \u2192 b = 0"}, {"line": "    fail_if_success (guard_hyp a : Nat)", "tactic_state": "case zero\nb : \u2115\n\u22a2 0 + b = 0 \u2192 b = 0"}, {"line": "    fail_if_success (guard_hyp h : a + b = a)", "tactic_state": "case zero\nb : \u2115\nh : 0 + b = 0\n\u22a2 b = 0"}, {"line": "    intro h", "tactic_state": "case zero\nb : \u2115\nh : b = 0\n\u22a2 b = 0"}, {"line": "    -- Sample proof", "tactic_state": ""}, {"line": "    rw [Nat.zero_add] at h", "tactic_state": "case succ\nb d : \u2115\nhd : d + b = d \u2192 b = 0\n\u22a2 d + 1 + b = d + 1 \u2192 b = 0"}, {"line": "    assumption", "tactic_state": "case succ\nb d : \u2115\nhd : d + b = d \u2192 b = 0\n\u22a2 d + 1 + b = d + 1 \u2192 b = 0"}, {"line": "  \u00b7 -- Test the generalized vars have been removed", "tactic_state": "case succ\nb d : \u2115\nhd : d + b = d \u2192 b = 0\n\u22a2 d + 1 + b = d + 1 \u2192 b = 0"}, {"line": "    revert h", "tactic_state": "case succ\nb d : \u2115\nhd : d + b = d \u2192 b = 0\nh : d + 1 + b = d + 1\n\u22a2 b = 0"}, {"line": "    fail_if_success (guard_hyp a : Nat)", "tactic_state": "case succ\nb d : \u2115\nhd : d + b = d \u2192 b = 0\nh : d + b = d\n\u22a2 b = 0"}, {"line": "    fail_if_success (guard_hyp h : a + b = a)", "tactic_state": "case succ\nb d : \u2115\nhd : d + b = d \u2192 b = 0\nh : d + b = d\n\u22a2 d + b = d"}, {"line": "    intro h", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (a : Fin n) : True := by\n  induction' n generalizing a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin n\n\u22a2 True"}, {"line": "  induction' n generalizing a", "tactic_state": "n : \u2115\na : Fin n\n\u22a2 True"}]}
{"declaration": "example (m : \u2115) : True := by\n  induction' m generalizing m", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 True"}, {"line": "  induction' m generalizing m", "tactic_state": "m : \u2115\n\u22a2 True"}]}
{"declaration": "example : True := by\n  aesop (add safe (by simp))", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/AesopUnusedTactic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  aesop (add safe (by simp))", "tactic_state": ""}]}
{"declaration": "example {x y : \u2115} : True := by\n  wlog h : x \u2264 y\n  \u00b7 guard_hyp h : \u00acx \u2264 y\n    guard_hyp this : \u2200 {x y : \u2115}, x \u2264 y \u2192 True -- `wlog` generalizes by default\n    guard_target =\u209b True\n    trivial\n  \u00b7 guard_hyp h : x \u2264 y\n    guard_target =\u209b True\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/wlog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 True"}, {"line": "  wlog h : x \u2264 y", "tactic_state": "case inr\nx y : \u2115\nthis : \u2200 {x y : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True\n---\nx y : \u2115\nh : x \u2264 y\n\u22a2 True"}, {"line": "  \u00b7 guard_hyp h : \u00acx \u2264 y", "tactic_state": "case inr\nx y : \u2115\nthis : \u2200 {x y : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True"}, {"line": "    guard_hyp this : \u2200 {x y : \u2115}, x \u2264 y \u2192 True -- `wlog` generalizes by default", "tactic_state": "case inr\nx y : \u2115\nthis : \u2200 {x y : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True"}, {"line": "    guard_target =\u209b True", "tactic_state": "case inr\nx y : \u2115\nthis : \u2200 {x y : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp h : x \u2264 y", "tactic_state": "x y : \u2115\nh : x \u2264 y\n\u22a2 True"}, {"line": "    guard_target =\u209b True", "tactic_state": "x y : \u2115\nh : x \u2264 y\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}]}
{"declaration": "example {x y : \u2115} : True := by\n  wlog h : x \u2264 y generalizing x with H\n  \u00b7 guard_hyp h : \u00acx \u2264 y\n    guard_hyp H : \u2200 {x : \u2115}, x \u2264 y \u2192 True -- only `x` was generalized\n    guard_target =\u209b True\n    trivial\n  \u00b7 guard_hyp h : x \u2264 y\n    guard_target =\u209b True\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/wlog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 True"}, {"line": "  wlog h : x \u2264 y generalizing x with H", "tactic_state": "case inr\nx y : \u2115\nH : \u2200 {x : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True\n---\ny x : \u2115\nh : x \u2264 y\n\u22a2 True"}, {"line": "  \u00b7 guard_hyp h : \u00acx \u2264 y", "tactic_state": "case inr\nx y : \u2115\nH : \u2200 {x : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True"}, {"line": "    guard_hyp H : \u2200 {x : \u2115}, x \u2264 y \u2192 True -- only `x` was generalized", "tactic_state": "case inr\nx y : \u2115\nH : \u2200 {x : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True"}, {"line": "    guard_target =\u209b True", "tactic_state": "case inr\nx y : \u2115\nH : \u2200 {x : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp h : x \u2264 y", "tactic_state": "y x : \u2115\nh : x \u2264 y\n\u22a2 True"}, {"line": "    guard_target =\u209b True", "tactic_state": "y x : \u2115\nh : x \u2264 y\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}]}
{"declaration": "example {x y z : \u2115} : True := by\n  wlog h : x \u2264 y + z with H\n  \u00b7 guard_hyp h : \u00ac x \u2264 y + z\n    guard_hyp H : \u2200 {x y z : \u2115}, x \u2264 y + z \u2192 True -- wlog-claim is named `H` instead of `this`\n    guard_target =\u209b True\n    trivial\n  \u00b7 guard_hyp h : x \u2264 y + z\n    guard_target =\u209b True\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/wlog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2115\n\u22a2 True"}, {"line": "  wlog h : x \u2264 y + z with H", "tactic_state": "case inr\nx y z : \u2115\nH : \u2200 {x y z : \u2115}, x \u2264 y + z \u2192 True\nh : \u00acx \u2264 y + z\n\u22a2 True\n---\nx y z : \u2115\nh : x \u2264 y + z\n\u22a2 True"}, {"line": "  \u00b7 guard_hyp h : \u00ac x \u2264 y + z", "tactic_state": "case inr\nx y z : \u2115\nH : \u2200 {x y z : \u2115}, x \u2264 y + z \u2192 True\nh : \u00acx \u2264 y + z\n\u22a2 True"}, {"line": "    guard_hyp H : \u2200 {x y z : \u2115}, x \u2264 y + z \u2192 True -- wlog-claim is named `H` instead of `this`", "tactic_state": "case inr\nx y z : \u2115\nH : \u2200 {x y z : \u2115}, x \u2264 y + z \u2192 True\nh : \u00acx \u2264 y + z\n\u22a2 True"}, {"line": "    guard_target =\u209b True", "tactic_state": "case inr\nx y z : \u2115\nH : \u2200 {x y z : \u2115}, x \u2264 y + z \u2192 True\nh : \u00acx \u2264 y + z\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp h : x \u2264 y + z", "tactic_state": "x y z : \u2115\nh : x \u2264 y + z\n\u22a2 True"}, {"line": "    guard_target =\u209b True", "tactic_state": "x y z : \u2115\nh : x \u2264 y + z\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}]}
{"declaration": "example : \u2200 _ _ : \u2115, True := by\n  intro x y\n  wlog h : x \u2264 y -- `wlog` finds new variables\n  \u00b7 trivial\n  \u00b7 trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/wlog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115 \u2192 \u2115 \u2192 True"}, {"line": "  intro x y", "tactic_state": "x y : \u2115\n\u22a2 True"}, {"line": "  wlog h : x \u2264 y -- `wlog` finds new variables", "tactic_state": "case inr\nx y : \u2115\nthis : \u2200 (x y : \u2115), x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True\n---\nx y : \u2115\nh : x \u2264 y\n\u22a2 True"}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 trivial", "tactic_state": ""}]}
{"declaration": "example {x y : \u2115} : True := by\n  wlog h : x \u2264 y generalizing y x with H\n  \u00b7 guard_hyp h : \u00ac x \u2264 y\n    guard_hyp H : \u2200 {x y : \u2115}, x \u2264 y \u2192 True -- order of ids in `generalizing` is ignored\n    trivial\n  \u00b7 trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/wlog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 True"}, {"line": "  wlog h : x \u2264 y generalizing y x with H", "tactic_state": "case inr\nx y : \u2115\nH : \u2200 {x y : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True\n---\nx y : \u2115\nh : x \u2264 y\n\u22a2 True"}, {"line": "  \u00b7 guard_hyp h : \u00ac x \u2264 y", "tactic_state": "case inr\nx y : \u2115\nH : \u2200 {x y : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True"}, {"line": "    guard_hyp H : \u2200 {x y : \u2115}, x \u2264 y \u2192 True -- order of ids in `generalizing` is ignored", "tactic_state": "case inr\nx y : \u2115\nH : \u2200 {x y : \u2115}, x \u2264 y \u2192 True\nh : \u00acx \u2264 y\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 trivial", "tactic_state": ""}]}
{"declaration": "example (\u03b1 : Type := \u2115) (x : Option \u03b1 := none) (y : Option \u03b1 := by exact 0) : True := by\n  wlog h : x = y with H\n  \u00b7 guard_hyp h : \u00ac x = y\n    guard_hyp H : \u2200 \u03b1, \u2200 {x y : Option \u03b1}, x = y \u2192 True\n    trivial\n  \u00b7 guard_hyp h : x = y\n    guard_target =\u209b True\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/wlog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : optParam Type \u2115\nx : optParam (Option \u03b1) none\ny : autoParam (Option \u03b1) _auto\u271d\n\u22a2 True"}, {"line": "  wlog h : x = y with H", "tactic_state": "case inr\n\u03b1 : optParam Type \u2115\nx : optParam (Option \u03b1) none\ny : autoParam (Option \u03b1) _auto\u271d\nH : \u2200 (\u03b1 : optParam Type \u2115) (x : optParam (Option \u03b1) none) (y : autoParam (Option \u03b1) _auto\u271d), x = y \u2192 True\nh : \u00acx = y\n\u22a2 True\n---\n\u03b1 : optParam Type \u2115\nx : optParam (Option \u03b1) none\ny : autoParam (Option \u03b1) _auto\u271d\nh : x = y\n\u22a2 True"}, {"line": "  \u00b7 guard_hyp h : \u00ac x = y", "tactic_state": "case inr\n\u03b1 : optParam Type \u2115\nx : optParam (Option \u03b1) none\ny : autoParam (Option \u03b1) _auto\u271d\nH : \u2200 (\u03b1 : optParam Type \u2115) (x : optParam (Option \u03b1) none) (y : autoParam (Option \u03b1) _auto\u271d), x = y \u2192 True\nh : \u00acx = y\n\u22a2 True"}, {"line": "    guard_hyp H : \u2200 \u03b1, \u2200 {x y : Option \u03b1}, x = y \u2192 True", "tactic_state": "case inr\n\u03b1 : optParam Type \u2115\nx : optParam (Option \u03b1) none\ny : autoParam (Option \u03b1) _auto\u271d\nH : \u2200 (\u03b1 : optParam Type \u2115) (x : optParam (Option \u03b1) none) (y : autoParam (Option \u03b1) _auto\u271d), x = y \u2192 True\nh : \u00acx = y\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp h : x = y", "tactic_state": "\u03b1 : optParam Type \u2115\nx : optParam (Option \u03b1) none\ny : autoParam (Option \u03b1) _auto\u271d\nh : x = y\n\u22a2 True"}, {"line": "    guard_target =\u209b True", "tactic_state": "\u03b1 : optParam Type \u2115\nx : optParam (Option \u03b1) none\ny : autoParam (Option \u03b1) _auto\u271d\nh : x = y\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}]}
{"declaration": "example {x y : \u2115} : True := by\n  wlog _ : x \u2264 y\n  case _ h => -- if these hypotheses weren't inaccessible, they wouldn't be renamed by `case`\n    guard_hyp h : \u00acx \u2264 y\n    guard_hyp this : \u2200 {x y : \u2115}, x \u2264 y \u2192 True\n    guard_target =\u209b True\n    trivial\n  case _ h =>\n    guard_hyp h : x \u2264 y\n    guard_target =\u209b True\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/wlog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 True"}, {"line": "  wlog _ : x \u2264 y", "tactic_state": "case inr\nx y : \u2115\nthis : \u2200 {x y : \u2115}, x \u2264 y \u2192 True\nh\u271d : \u00acx \u2264 y\n\u22a2 True\n---\nx y : \u2115\nh\u271d : x \u2264 y\n\u22a2 True"}, {"line": "  case _ h => -- if these hypotheses weren't inaccessible, they wouldn't be renamed by `case`", "tactic_state": "x y : \u2115\nh\u271d : x \u2264 y\n\u22a2 True"}, {"line": "    guard_hyp h : \u00acx \u2264 y", "tactic_state": ""}]}
{"declaration": "example (x y : \u2115) : True := by\n  let z := 0\n  wlog hxy' : z \u2264 y with H\n  \u00b7 trivial\n  \u00b7 trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/wlog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 True"}, {"line": "  let z := 0", "tactic_state": "x y : \u2115\nz : \u2115 := 0\n\u22a2 True"}, {"line": "  wlog hxy' : z \u2264 y with H", "tactic_state": "case inr\nx y : \u2115\nz : \u2115 := 0\nH :\n  \u2115 \u2192\n    \u2200 (y : \u2115),\n      let z := 0;\n      z \u2264 y \u2192 True\nhxy' : \u00acz \u2264 y\n\u22a2 True\n---\nx y : \u2115\nz : \u2115 := 0\nhxy' : z \u2264 y\n\u22a2 True"}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 trivial", "tactic_state": ""}]}
{"declaration": "example (_h\u2081 : ((List.range 128).map (fun _ => 0)).sum = 0) : 0 \u2223 1 := by\n  apply Nat.dvd_of_mul_dvd_mul_left Nat.zero_lt_one\n  convert Nat.dvd_mul_left 0 1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_h\u2081 : (List.map (fun x => 0) (List.range 128)).sum = 0\n\u22a2 0 \u2223 1"}, {"line": "  apply Nat.dvd_of_mul_dvd_mul_left Nat.zero_lt_one", "tactic_state": "_h\u2081 : (List.map (fun x => 0) (List.range 128)).sum = 0\n\u22a2 1 * 0 \u2223 1 * 1"}, {"line": "  convert Nat.dvd_mul_left 0 1", "tactic_state": ""}]}
{"declaration": "example : (1 : \u211d\u22650\u221e) < \u221e := by finiteness", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finiteness.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 < \u22a4"}]}
{"declaration": "example : (3 : \u211d\u22650\u221e) \u2260 \u221e := by finiteness\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finiteness.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 3 \u2260 \u22a4"}]}
{"declaration": "example (a : \u211d) (b : \u2115) : ENNReal.ofReal a + b < \u221e := by finiteness\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finiteness.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nb : \u2115\n\u22a2 ENNReal.ofReal a + \u2191b < \u22a4"}]}
{"declaration": "example {a : \u211d\u22650\u221e} (ha : a \u2260 \u221e) : a + 3 < \u221e := by finiteness", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finiteness.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\u22650\u221e\nha : a \u2260 \u22a4\n\u22a2 a + 3 < \u22a4"}]}
{"declaration": "example {a : \u211d\u22650\u221e} (ha : a < \u221e) : a + 3 < \u221e := by finiteness", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finiteness.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\u22650\u221e\nha : a < \u22a4\n\u22a2 a + 3 < \u22a4"}]}
{"declaration": "example {a : \u211d\u22650\u221e} (ha : a = 0) : a + 3 < \u221e := by finiteness_nonterminal; simp [ha]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finiteness.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\u22650\u221e\nha : a = 0\n\u22a2 a + 3 < \u22a4"}]}
{"declaration": "example (a : \u211d) : (ENNReal.ofReal (1 + a ^ 2))\u207b\u00b9 < \u221e := by finiteness\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finiteness.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 (ENNReal.ofReal (1 + a ^ 2))\u207b\u00b9 < \u22a4"}]}
{"declaration": "example {\u03b1 : Type*} (f : \u03b1 \u2192 \u2115) : \u2200 i, (f i : \u211d\u22650\u221e) \u2260 \u221e := by finiteness\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finiteness.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\n\u22a2 \u2200 (i : \u03b1), \u2191(f i) \u2260 \u22a4"}]}
{"declaration": "example {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] (s : Set \u03b1) : \u03bc s \u2260 \u221e := by\n  finiteness", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finiteness.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\ns : Set \u03b1\n\u22a2 \u03bc s \u2260 \u22a4"}, {"line": "  finiteness", "tactic_state": ""}]}
{"declaration": "example : frobnicate a 0 = a := by\n  simp [frobnicate]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/irreducibleDef.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfrobnicate : x\u271d\n\u03b1\u271d : Sort u_2\na : \u03b1\u271d\n\u22a2 sorry = a"}, {"line": "  simp [frobnicate]", "tactic_state": "x\u271d : Sort u_1\nfrobnicate : x\u271d\n\u03b1\u271d : Sort u_2\na : \u03b1\u271d\n\u22a2 sorry () = a"}]}
{"declaration": "example : withUniv.{u, v} = (Type v, Type u) := by rw [withUniv]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/irreducibleDef.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwithUniv : x\u271d\n\u22a2 sorry = (Type v, Type u)"}]}
{"declaration": "example : Foo.foo = 42 := by rw [Foo.foo]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/irreducibleDef.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 42"}]}
{"declaration": "example : True := by\n  trace 2 + 2 + 3\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/trace.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  trace 2 + 2 + 3", "tactic_state": "\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  trace \"hello\" ++ \" world\"\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/trace.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  trace \"hello\" ++ \" world\"", "tactic_state": "\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : Nat := by\n  (show_term exact 37) says\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115"}, {"line": "  (show_term exact 37) says", "tactic_state": ""}]}
{"declaration": "example : Nat := by\n  (show_term exact 37) says exact 37\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115"}, {"line": "  (show_term exact 37) says exact 37", "tactic_state": ""}]}
{"declaration": "example (x y : List \u03b1) : (x ++ y).length = x.length + y.length := by\n  simp? says\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y : List \u03b1\n\u22a2 (x ++ y).length = x.length + y.length"}, {"line": "  simp? says", "tactic_state": ""}]}
{"declaration": "example (x y : List \u03b1) : (x ++ y).length = x.length + y.length := by\n  simp? says simp only [List.length_append]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y : List \u03b1\n\u22a2 (x ++ y).length = x.length + y.length"}, {"line": "  simp? says simp only [List.length_append]", "tactic_state": ""}]}
{"declaration": "example : true := by\n  have := 0 says\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 true = true"}, {"line": "  have := 0 says", "tactic_state": "this : \u2115\n\u22a2 true = true"}]}
{"declaration": "example : true := by\n  (run_tac do Lean.logInfo \"hi!\") says\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 true = true"}, {"line": "  (run_tac do Lean.logInfo \"hi!\") says", "tactic_state": "\u22a2 true = true"}]}
{"declaration": "example (x y : List \u03b1) : (x ++ y).length = x.length + y.length := by\n  simp? says skip\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y : List \u03b1\n\u22a2 (x ++ y).length = x.length + y.length"}, {"line": "  simp? says skip", "tactic_state": "\u03b1 : Type u_1\nx y : List \u03b1\n\u22a2 (x ++ y).length = x.length + y.length"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example (x y : List \u03b1) : (x ++ y).length = x.length + y.length := by\n  simp? says simp only []\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y : List \u03b1\n\u22a2 (x ++ y).length = x.length + y.length"}, {"line": "  simp? says simp only []", "tactic_state": "\u03b1 : Type u_1\nx y : List \u03b1\n\u22a2 (x ++ y).length = x.length + y.length"}]}
{"declaration": "example : True := by\n  simp says\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  simp says", "tactic_state": ""}]}
{"declaration": "example (x y : List \u03b1) : (x ++ y).length = x.length + y.length := by\n  simp? says simp only [List.length_append]\n  -- This is a comment to test that `says` ignores following comments.\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y : List \u03b1\n\u22a2 (x ++ y).length = x.length + y.length"}, {"line": "  simp? says simp only [List.length_append]", "tactic_state": ""}]}
{"declaration": "example : True := by\n  simp says\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  simp says", "tactic_state": ""}]}
{"declaration": "example : True := by\n  simp says\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  simp says", "tactic_state": ""}]}
{"declaration": "example : True := by\n  fail_if_success\n    run_tac do guard (\u2190 IO.getEnv \"CI\").isSome\n    simp says trivial\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  fail_if_success", "tactic_state": "\u22a2 True"}, {"line": "    run_tac do guard (\u2190 IO.getEnv \"CI\").isSome", "tactic_state": ""}]}
{"declaration": "example : P := by\n  aesop? says", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/says.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Sort ?u.5\n\u22a2 P"}, {"line": "  aesop? says", "tactic_state": "P : Sort ?u.5\n\u22a2 P"}]}
{"declaration": "example (h : let x := 1; x = x) : True := by\n  extract_lets y at h\n  fail_if_success extract_lets a at h\n  extract_lets at h\n  guard_hyp y : Nat := 1\n  guard_hyp h :\u209b y = y\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  x = x\n\u22a2 True"}, {"line": "  extract_lets y at h", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "  fail_if_success extract_lets a at h", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "  extract_lets at h", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "  guard_hyp y : Nat := 1", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "  guard_hyp h :\u209b y = y", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  let h : (let x := 1; x = x) := rfl\n  extract_lets y at h\n  guard_hyp y : Nat := 1\n  guard_hyp h :\u209b y = y := rfl\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  let h : (let x := 1; x = x) := rfl", "tactic_state": "h : let x := 1;\nx = x :=\n  rfl\n\u22a2 True"}, {"line": "  extract_lets y at h", "tactic_state": "y : \u2115 := 1\nh : y = y := rfl\n\u22a2 True"}, {"line": "  guard_hyp y : Nat := 1", "tactic_state": "y : \u2115 := 1\nh : y = y := rfl\n\u22a2 True"}, {"line": "  guard_hyp h :\u209b y = y := rfl", "tactic_state": "y : \u2115 := 1\nh : y = y := rfl\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : True := by\n  extract_lets x y at h\n  guard_hyp x : Nat := 1\n  guard_hyp y : Nat := 2\n  guard_hyp h :\u209b x + 1 = y\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "  extract_lets x y at h", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2\nh : x + 1 = y\n\u22a2 True"}, {"line": "  guard_hyp x : Nat := 1", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2\nh : x + 1 = y\n\u22a2 True"}, {"line": "  guard_hyp y : Nat := 2", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2\nh : x + 1 = y\n\u22a2 True"}, {"line": "  guard_hyp h :\u209b x + 1 = y", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2\nh : x + 1 = y\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : True := by\n  extract_lets at h\n  rename_i a b\n  guard_hyp a : Nat := 1\n  guard_hyp b : Nat := 2\n  guard_hyp h :\u209b a + 1 = b\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "  extract_lets at h", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 True"}, {"line": "  rename_i a b", "tactic_state": "a : \u2115 := 1\nb : \u2115 := 2\nh : a + 1 = b\n\u22a2 True"}, {"line": "  guard_hyp a : Nat := 1", "tactic_state": "a : \u2115 := 1\nb : \u2115 := 2\nh : a + 1 = b\n\u22a2 True"}, {"line": "  guard_hyp b : Nat := 2", "tactic_state": "a : \u2115 := 1\nb : \u2115 := 2\nh : a + 1 = b\n\u22a2 True"}, {"line": "  guard_hyp h :\u209b a + 1 = b", "tactic_state": "a : \u2115 := 1\nb : \u2115 := 2\nh : a + 1 = b\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : True := by\n  extract_lets x at h\n  guard_hyp x : Nat := 1\n  guard_hyp h :\u209b let y := 2; x + 1 = y\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "  extract_lets x at h", "tactic_state": "x : \u2115 := 1\nh :\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "  guard_hyp x : Nat := 1", "tactic_state": "x : \u2115 := 1\nh :\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "  guard_hyp h :\u209b let y := 2; x + 1 = y", "tactic_state": "x : \u2115 := 1\nh :\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : let _z := 3; \u2200 (_ : Nat), True := by\n  extract_lets at *\n  guard_hyp h : _ + 1 = _\n  fail_if_success extract_lets x at h\n  guard_target =\u209b \u2200 (_ : Nat), True\n  intro\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 let _z := 3;\n  \u2115 \u2192 True"}, {"line": "  extract_lets at *", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 \u2115 \u2192 True"}, {"line": "  guard_hyp h : _ + 1 = _", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 \u2115 \u2192 True"}, {"line": "  fail_if_success extract_lets x at h", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 \u2115 \u2192 True"}, {"line": "  guard_target =\u209b \u2200 (_ : Nat), True", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 \u2115 \u2192 True"}, {"line": "  intro", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d\u00b9 : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d\u00b9 + 1 = y\u271d\nx\u271d : \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) :\n    let _z := 3\n    let _z\u2082 := 5\n    \u2200 (_ : Nat), True := by\n  extract_lets at h \u22a2\n  guard_hyp h : _ + 1 = _\n  fail_if_success extract_lets x at h\n  guard_target =\u209b \u2200 (_ : Nat), True\n  intro\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 let _z := 3;\n  let _z\u2082 := 5;\n  \u2115 \u2192 True"}, {"line": "  extract_lets at h \u22a2", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "  guard_hyp h : _ + 1 = _", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "  fail_if_success extract_lets x at h", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "  guard_target =\u209b \u2200 (_ : Nat), True", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "  intro", "tactic_state": "x\u271d\u00b9 : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d\u00b9 + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\nx\u271d : \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) :\n    let _z := 3\n    let _z\u2082 := 5\n    \u2200 (_ : Nat), True := by\n  extract_lets\n  fail_if_success extract_lets x\n  guard_hyp h : let x := 1; let y := 2; x + 1 = y\n  guard_target =\u209b \u2200 (_ : Nat), True\n  intro\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 let _z := 3;\n  let _z\u2082 := 5;\n  \u2115 \u2192 True"}, {"line": "  extract_lets", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "  fail_if_success extract_lets x", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "  guard_hyp h : let x := 1; let y := 2; x + 1 = y", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "  guard_target =\u209b \u2200 (_ : Nat), True", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "  intro", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\nx\u271d : \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : let _z := 3; \u2200 (_ : Nat), True := by\n  extract_lets u\n  guard_hyp u : Nat := 3\n  fail_if_success extract_lets x\n  guard_target =\u209b \u2200 (_ : Nat), True\n  guard_hyp h : let x := 1; let y := 2; x + 1 = y\n  intro\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 let _z := 3;\n  \u2115 \u2192 True"}, {"line": "  extract_lets u", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "  guard_hyp u : Nat := 3", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "  fail_if_success extract_lets x", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "  guard_target =\u209b \u2200 (_ : Nat), True", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "  guard_hyp h : let x := 1; let y := 2; x + 1 = y", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "  intro", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\nx\u271d : \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) : True := by\n  fail_if_success interval_cases n\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  fail_if_success interval_cases n", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (_ : 2 \u2264 n) : True := by\n  fail_if_success interval_cases n\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : 2 \u2264 n\n\u22a2 True"}, {"line": "  fail_if_success interval_cases n", "tactic_state": "n : \u2115\nx\u271d : 2 \u2264 n\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (_ : n \u2264 m) : True := by\n  fail_if_success interval_cases n\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nx\u271d : n \u2264 m\n\u22a2 True"}, {"line": "  fail_if_success interval_cases n", "tactic_state": "n m : \u2115\nx\u271d : n \u2264 m\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2082 : n < 0) : False := by interval_cases n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2082 : n < 0\n\u22a2 False"}]}
{"declaration": "example (n : \u2115) (w\u2082 : n < 1) : n = 0 := by\n  interval_cases n\n  rfl -- done for free in the mathlib3 version\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2082 : n < 1\n\u22a2 n = 0"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab0\u00bb\nn : \u2115\nw\u2082 : 0 < 1\n\u22a2 0 = 0"}, {"line": "  rfl -- done for free in the mathlib3 version", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2082 : n < 2) : n = 0 \u2228 n = 1 := by\n  interval_cases n\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2082 : n < 2\n\u22a2 n = 0 \u2228 n = 1"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab0\u00bb\nn : \u2115\nw\u2082 : 0 < 2\n\u22a2 0 = 0 \u2228 0 = 1\n---\ncase \u00ab1\u00bb\nn : \u2115\nw\u2082 : 1 < 2\n\u22a2 1 = 0 \u2228 1 = 1"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab0\u00bb.h\nn : \u2115\nw\u2082 : 0 < 2\n\u22a2 0 = 0"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : 1 \u2264 n) (w\u2082 : n < 3) : n = 1 \u2228 n = 2 := by\n  interval_cases n\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081 : 1 \u2264 n\nw\u2082 : n < 3\n\u22a2 n = 1 \u2228 n = 2"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab1\u00bb\nn : \u2115\nw\u2081 : 1 \u2264 1\nw\u2082 : 1 < 3\n\u22a2 1 = 1 \u2228 1 = 2\n---\ncase \u00ab2\u00bb\nn : \u2115\nw\u2081 : 1 \u2264 2\nw\u2082 : 2 < 3\n\u22a2 2 = 1 \u2228 2 = 2"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab1\u00bb.h\nn : \u2115\nw\u2081 : 1 \u2264 1\nw\u2082 : 1 < 3\n\u22a2 1 = 1"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : 1 \u2264 n) (w\u2082 : n < 3) : n = 1 \u2228 n = 2 := by\n  interval_cases using w\u2081, w\u2082\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081 : 1 \u2264 n\nw\u2082 : n < 3\n\u22a2 n = 1 \u2228 n = 2"}, {"line": "  interval_cases using w\u2081, w\u2082", "tactic_state": "case \u00ab1\u00bb\nn : \u2115\nw\u2081 : 1 \u2264 1\nw\u2082 : 1 < 3\n\u22a2 1 = 1 \u2228 1 = 2\n---\ncase \u00ab2\u00bb\nn : \u2115\nw\u2081 : 1 \u2264 2\nw\u2082 : 2 < 3\n\u22a2 2 = 1 \u2228 2 = 2"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab1\u00bb.h\nn : \u2115\nw\u2081 : 1 \u2264 1\nw\u2082 : 1 < 3\n\u22a2 1 = 1"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (w\u2081 : 1 \u2264 n) (w\u2082 : n < 3) (_ : m < 2) : n = 1 \u2228 n = 2 := by\n  interval_cases n\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nw\u2081 : 1 \u2264 n\nw\u2082 : n < 3\nx\u271d : m < 2\n\u22a2 n = 1 \u2228 n = 2"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab1\u00bb\nn m : \u2115\nx\u271d : m < 2\nw\u2081 : 1 \u2264 1\nw\u2082 : 1 < 3\n\u22a2 1 = 1 \u2228 1 = 2\n---\ncase \u00ab2\u00bb\nn m : \u2115\nx\u271d : m < 2\nw\u2081 : 1 \u2264 2\nw\u2082 : 2 < 3\n\u22a2 2 = 1 \u2228 2 = 2"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab1\u00bb.h\nn m : \u2115\nx\u271d : m < 2\nw\u2081 : 1 \u2264 1\nw\u2082 : 1 < 3\n\u22a2 1 = 1"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : 1 < n) (w\u2082 : n < 4) : n = 2 \u2228 n = 3 := by\n  interval_cases n\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081 : 1 < n\nw\u2082 : n < 4\n\u22a2 n = 2 \u2228 n = 3"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab2\u00bb\nn : \u2115\nw\u2081 : 1 < 2\nw\u2082 : 2 < 4\n\u22a2 2 = 2 \u2228 2 = 3\n---\ncase \u00ab3\u00bb\nn : \u2115\nw\u2081 : 1 < 3\nw\u2082 : 3 < 4\n\u22a2 3 = 2 \u2228 3 = 3"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab2\u00bb.h\nn : \u2115\nw\u2081 : 1 < 2\nw\u2082 : 2 < 4\n\u22a2 2 = 2"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : n \u2265 3) (w\u2082 : n < 5) : n = 3 \u2228 n = 4 := by\n  interval_cases n\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081 : n \u2265 3\nw\u2082 : n < 5\n\u22a2 n = 3 \u2228 n = 4"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab3\u00bb\nn : \u2115\nw\u2081 : 3 \u2265 3\nw\u2082 : 3 < 5\n\u22a2 3 = 3 \u2228 3 = 4\n---\ncase \u00ab4\u00bb\nn : \u2115\nw\u2081 : 4 \u2265 3\nw\u2082 : 4 < 5\n\u22a2 4 = 3 \u2228 4 = 4"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab3\u00bb.h\nn : \u2115\nw\u2081 : 3 \u2265 3\nw\u2082 : 3 < 5\n\u22a2 3 = 3"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2080 : n \u2265 2) (w\u2081 : n \u2265 3) (w\u2082 : n < 5) : n = 3 \u2228 n = 4 := by\n  interval_cases n\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2080 : n \u2265 2\nw\u2081 : n \u2265 3\nw\u2082 : n < 5\n\u22a2 n = 3 \u2228 n = 4"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab3\u00bb\nn : \u2115\nw\u2080 : 3 \u2265 2\nw\u2081 : 3 \u2265 3\nw\u2082 : 3 < 5\n\u22a2 3 = 3 \u2228 3 = 4\n---\ncase \u00ab4\u00bb\nn : \u2115\nw\u2080 : 4 \u2265 2\nw\u2081 : 4 \u2265 3\nw\u2082 : 4 < 5\n\u22a2 4 = 3 \u2228 4 = 4"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab3\u00bb.h\nn : \u2115\nw\u2080 : 3 \u2265 2\nw\u2081 : 3 \u2265 3\nw\u2082 : 3 < 5\n\u22a2 3 = 3"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : n > 2) (w\u2082 : n < 5) : n = 3 \u2228 n = 4 := by\n  interval_cases n\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081 : n > 2\nw\u2082 : n < 5\n\u22a2 n = 3 \u2228 n = 4"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab3\u00bb\nn : \u2115\nw\u2081 : 3 > 2\nw\u2082 : 3 < 5\n\u22a2 3 = 3 \u2228 3 = 4\n---\ncase \u00ab4\u00bb\nn : \u2115\nw\u2081 : 4 > 2\nw\u2082 : 4 < 5\n\u22a2 4 = 3 \u2228 4 = 4"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab3\u00bb.h\nn : \u2115\nw\u2081 : 3 > 2\nw\u2082 : 3 < 5\n\u22a2 3 = 3"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : n > 2) (w\u2082 : n \u2264 4) : n = 3 \u2228 n = 4 := by\n  interval_cases n\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081 : n > 2\nw\u2082 : n \u2264 4\n\u22a2 n = 3 \u2228 n = 4"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab3\u00bb\nn : \u2115\nw\u2081 : 3 > 2\nw\u2082 : 3 \u2264 4\n\u22a2 3 = 3 \u2228 3 = 4\n---\ncase \u00ab4\u00bb\nn : \u2115\nw\u2081 : 4 > 2\nw\u2082 : 4 \u2264 4\n\u22a2 4 = 3 \u2228 4 = 4"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab3\u00bb.h\nn : \u2115\nw\u2081 : 3 > 2\nw\u2082 : 3 \u2264 4\n\u22a2 3 = 3"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : 2 < n) (w\u2082 : 4 \u2265 n) : n = 3 \u2228 n = 4 := by\n  interval_cases n\n  \u00b7 left; rfl\n  \u00b7 right; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081 : 2 < n\nw\u2082 : 4 \u2265 n\n\u22a2 n = 3 \u2228 n = 4"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab3\u00bb\nn : \u2115\nw\u2081 : 2 < 3\nw\u2082 : 4 \u2265 3\n\u22a2 3 = 3 \u2228 3 = 4\n---\ncase \u00ab4\u00bb\nn : \u2115\nw\u2081 : 2 < 4\nw\u2082 : 4 \u2265 4\n\u22a2 4 = 3 \u2228 4 = 4"}, {"line": "  \u00b7 left; rfl", "tactic_state": "case \u00ab3\u00bb.h\nn : \u2115\nw\u2081 : 2 < 3\nw\u2082 : 4 \u2265 3\n\u22a2 3 = 3"}, {"line": "  \u00b7 right; rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (h1 : 4 < n) (h2 : n \u2264 6) : n < 20 := by\n  interval_cases n\n  \u00b7 guard_target =\u209b 5 < 20; norm_num\n  \u00b7 guard_target =\u209b 6 < 20; norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh1 : 4 < n\nh2 : n \u2264 6\n\u22a2 n < 20"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab5\u00bb\nn : \u2115\nh1 : 4 < 5\nh2 : 5 \u2264 6\n\u22a2 5 < 20\n---\ncase \u00ab6\u00bb\nn : \u2115\nh1 : 4 < 6\nh2 : 6 \u2264 6\n\u22a2 6 < 20"}, {"line": "  \u00b7 guard_target =\u209b 5 < 20; norm_num", "tactic_state": "case \u00ab5\u00bb\nn : \u2115\nh1 : 4 < 5\nh2 : 5 \u2264 6\n\u22a2 5 < 20"}, {"line": "  \u00b7 guard_target =\u209b 6 < 20; norm_num", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : n % 3 < 1) : n % 3 = 0 := by\n  interval_cases h : n % 3\n  \u00b7 guard_hyp h : n % 3 = 0\n    rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081 : n % 3 < 1\n\u22a2 n % 3 = 0"}, {"line": "  interval_cases h : n % 3", "tactic_state": "case \u00ab0\u00bb\nn : \u2115\nh : n % 3 = 0\nw\u2081 : 0 < 1\n\u22a2 0 = 0"}, {"line": "  \u00b7 guard_hyp h : n % 3 = 0", "tactic_state": "case \u00ab0\u00bb\nn : \u2115\nh : n % 3 = 0\nw\u2081 : 0 < 1\n\u22a2 0 = 0"}, {"line": "    rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : n % 3 < 1) : n % 3 = 0 := by\n  interval_cases n % 3\n  rfl\n  -- the Lean 3 version had a different goal state after the `interval_cases`\n  -- the `n % 3` was not substituted, instead there was a hypothesis `h : n % 3 = 0` provided\n  -- so the proof was:\n  -- assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081 : n % 3 < 1\n\u22a2 n % 3 = 0"}, {"line": "  interval_cases n % 3", "tactic_state": "case \u00ab0\u00bb\nn : \u2115\nw\u2081 : 0 < 1\n\u22a2 0 = 0"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (h1 : 4 \u2264 n) (h2 : n < 10) : n < 20 := by\n  interval_cases using h1, h2\n  all_goals { norm_num }\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh1 : 4 \u2264 n\nh2 : n < 10\n\u22a2 n < 20"}, {"line": "  interval_cases using h1, h2", "tactic_state": "case \u00ab4\u00bb\nn : \u2115\nh1 : 4 \u2264 4\nh2 : 4 < 10\n\u22a2 4 < 20\n---\ncase \u00ab5\u00bb\nn : \u2115\nh1 : 4 \u2264 5\nh2 : 5 < 10\n\u22a2 5 < 20\n---\ncase \u00ab6\u00bb\nn : \u2115\nh1 : 4 \u2264 6\nh2 : 6 < 10\n\u22a2 6 < 20\n---\ncase \u00ab7\u00bb\nn : \u2115\nh1 : 4 \u2264 7\nh2 : 7 < 10\n\u22a2 7 < 20\n---\ncase \u00ab8\u00bb\nn : \u2115\nh1 : 4 \u2264 8\nh2 : 8 < 10\n\u22a2 8 < 20\n---\ncase \u00ab9\u00bb\nn : \u2115\nh1 : 4 \u2264 9\nh2 : 9 < 10\n\u22a2 9 < 20"}, {"line": "  all_goals { norm_num }", "tactic_state": ""}]}
{"declaration": "example (z : \u2124) (h1 : z \u2265 -3) (h2 : z < 2) : z < 20 := by\n  interval_cases using h1, h2\n  all_goals { norm_num }\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\nh1 : z \u2265 -3\nh2 : z < 2\n\u22a2 z < 20"}, {"line": "  interval_cases using h1, h2", "tactic_state": "case \u00ab-3\u00bb\nz : \u2124\nh1 : -3 \u2265 -3\nh2 : -3 < 2\n\u22a2 -3 < 20\n---\ncase \u00ab-2\u00bb\nz : \u2124\nh1 : -2 \u2265 -3\nh2 : -2 < 2\n\u22a2 -2 < 20\n---\ncase \u00ab-1\u00bb\nz : \u2124\nh1 : -1 \u2265 -3\nh2 : -1 < 2\n\u22a2 -1 < 20\n---\ncase \u00ab0\u00bb\nz : \u2124\nh1 : 0 \u2265 -3\nh2 : 0 < 2\n\u22a2 0 < 20\n---\ncase \u00ab1\u00bb\nz : \u2124\nh1 : 1 \u2265 -3\nh2 : 1 < 2\n\u22a2 1 < 20"}, {"line": "  all_goals { norm_num }", "tactic_state": ""}]}
{"declaration": "example (z : \u2124) (h1 : z \u2265 -3) (h2 : z < 2) : z < 20 := by\n  interval_cases z\n  \u00b7 guard_target =\u209b (-3 : \u2124) < 20\n    norm_num\n  \u00b7 guard_target =\u209b (-2 : \u2124) < 20\n    norm_num\n  \u00b7 guard_target =\u209b (-1 : \u2124) < 20\n    norm_num\n  \u00b7 guard_target =\u209b (0 : \u2124) < 20\n    norm_num\n  \u00b7 guard_target =\u209b (1 : \u2124) < 20\n    norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\nh1 : z \u2265 -3\nh2 : z < 2\n\u22a2 z < 20"}, {"line": "  interval_cases z", "tactic_state": "case \u00ab-3\u00bb\nz : \u2124\nh1 : -3 \u2265 -3\nh2 : -3 < 2\n\u22a2 -3 < 20\n---\ncase \u00ab-2\u00bb\nz : \u2124\nh1 : -2 \u2265 -3\nh2 : -2 < 2\n\u22a2 -2 < 20\n---\ncase \u00ab-1\u00bb\nz : \u2124\nh1 : -1 \u2265 -3\nh2 : -1 < 2\n\u22a2 -1 < 20\n---\ncase \u00ab0\u00bb\nz : \u2124\nh1 : 0 \u2265 -3\nh2 : 0 < 2\n\u22a2 0 < 20\n---\ncase \u00ab1\u00bb\nz : \u2124\nh1 : 1 \u2265 -3\nh2 : 1 < 2\n\u22a2 1 < 20"}, {"line": "  \u00b7 guard_target =\u209b (-3 : \u2124) < 20", "tactic_state": "case \u00ab-3\u00bb\nz : \u2124\nh1 : -3 \u2265 -3\nh2 : -3 < 2\n\u22a2 -3 < 20"}, {"line": "    norm_num", "tactic_state": ""}, {"line": "  \u00b7 guard_target =\u209b (-2 : \u2124) < 20", "tactic_state": "case \u00ab-2\u00bb\nz : \u2124\nh1 : -2 \u2265 -3\nh2 : -2 < 2\n\u22a2 -2 < 20"}, {"line": "    norm_num", "tactic_state": ""}, {"line": "  \u00b7 guard_target =\u209b (-1 : \u2124) < 20", "tactic_state": "case \u00ab-1\u00bb\nz : \u2124\nh1 : -1 \u2265 -3\nh2 : -1 < 2\n\u22a2 -1 < 20"}, {"line": "    norm_num", "tactic_state": ""}, {"line": "  \u00b7 guard_target =\u209b (0 : \u2124) < 20", "tactic_state": "case \u00ab0\u00bb\nz : \u2124\nh1 : 0 \u2265 -3\nh2 : 0 < 2\n\u22a2 0 < 20"}, {"line": "    norm_num", "tactic_state": ""}, {"line": "  \u00b7 guard_target =\u209b (1 : \u2124) < 20", "tactic_state": "case \u00ab1\u00bb\nz : \u2124\nh1 : 1 \u2265 -3\nh2 : 1 < 2\n\u22a2 1 < 20"}, {"line": "    norm_num", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) : n % 2 = 0 \u2228 n % 2 = 1 := by\n  set r := n % 2 with hr\n  have h2 : r < 2 := by\n    exact Nat.mod_lt _ (by decide)\n  interval_cases hrv : r\n  \u00b7 left; exact hrv.symm.trans hrv\n               --^ hover says `hrv : r = 0` and jumps to `hrv :` above\n  \u00b7 right; exact hrv.symm.trans hrv\n               --^ hover says `hrv : r = 1` and jumps to `hrv :` above\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n % 2 = 0 \u2228 n % 2 = 1"}, {"line": "  set r := n % 2 with hr", "tactic_state": "n : \u2115\nr : \u2115 := n % 2\nhr : r = n % 2\n\u22a2 r = 0 \u2228 r = 1"}, {"line": "  have h2 : r < 2 := by", "tactic_state": "n : \u2115\nr : \u2115 := n % 2\nhr : r = n % 2\nh2 : r < 2\n\u22a2 r = 0 \u2228 r = 1"}, {"line": "    exact Nat.mod_lt _ (by decide)", "tactic_state": "case \u00ab0\u00bb\nn : \u2115\nr : \u2115 := n % 2\nhrv : r = 0\nhr : 0 = n % 2\nh2 : 0 < 2\n\u22a2 0 = 0 \u2228 0 = 1\n---\ncase \u00ab1\u00bb\nn : \u2115\nr : \u2115 := n % 2\nhrv : r = 1\nhr : 1 = n % 2\nh2 : 1 < 2\n\u22a2 1 = 0 \u2228 1 = 1"}, {"line": "  interval_cases hrv : r", "tactic_state": "case \u00ab0\u00bb.h\nn : \u2115\nr : \u2115 := n % 2\nhrv : r = 0\nhr : 0 = n % 2\nh2 : 0 < 2\n\u22a2 0 = 0"}, {"line": "  \u00b7 left; exact hrv.symm.trans hrv", "tactic_state": ""}, {"line": "               --^ hover says `hrv : r = 0` and jumps to `hrv :` above", "tactic_state": "case \u00ab1\u00bb.h\nn : \u2115\nr : \u2115 := n % 2\nhrv : r = 1\nhr : 1 = n % 2\nh2 : 1 < 2\n\u22a2 1 = 1"}, {"line": "  \u00b7 right; exact hrv.symm.trans hrv", "tactic_state": ""}]}
{"declaration": "example {x : \u2115} (hx2 : x < 2) (h : False) : False := by\n  have _this : x \u2264 1 := by\n    -- `interval_cases` deliberately not focussed,\n    -- this is testing that the `interval_cases` only acts on `have` side goal, not on both\n    interval_cases x\n    \u00b7 exact zero_le_one\n    \u00b7 rfl -- done for free in the mathlib3 version\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nhx2 : x < 2\nh : False\n\u22a2 False"}, {"line": "  have _this : x \u2264 1 := by", "tactic_state": "x : \u2115\nhx2 : x < 2\nh : False\n_this : x \u2264 1\n\u22a2 False"}, {"line": "    -- `interval_cases` deliberately not focussed,", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (w\u2081 : n > 1000000) (w\u2081 : n < 1000002) : n < 2000000 := by\n  interval_cases n\n  norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nw\u2081\u271d : n > 1000000\nw\u2081 : n < 1000002\n\u22a2 n < 2000000"}, {"line": "  interval_cases n", "tactic_state": "case \u00ab1000001\u00bb\nn : \u2115\nw\u2081\u271d : 1000001 > 1000000\nw\u2081 : 1000001 < 1000002\n\u22a2 1000001 < 2000000"}, {"line": "  norm_num", "tactic_state": ""}]}
{"declaration": "example (h : d \u2264 0) : d = 0 := by\n  interval_cases d\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/interval_cases.lean", "context": {"open": [], "variables": ["(d : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2115\nh : d \u2264 0\n\u22a2 d = 0"}, {"line": "  interval_cases d", "tactic_state": "case \u00ab0\u00bb\nd : \u2115\nh : 0 \u2264 0\n\u22a2 0 = 0"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : True := by\n  run_tac do\n    let f : Bool \u2192 Nat | false => 0 | true => 1\n    let e := toExpr <| Bar.func f\n    Meta.check e\n    guard <| \u2190 Meta.isDefEq (\u2190 Meta.inferType e) (toTypeExpr Bar)\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeriveToExpr.lean", "context": {"open": ["Lean"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  run_tac do", "tactic_state": "\u22a2 True"}]}
{"declaration": "example (_delete_this : Nat) : Nat := by\n  clear_\n  fail_if_success assumption\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : \u2115\n\u22a2 \u2115"}, {"line": "  clear_", "tactic_state": "\u22a2 \u2115"}, {"line": "  fail_if_success assumption", "tactic_state": "\u22a2 \u2115"}, {"line": "  exact 0", "tactic_state": ""}]}
{"declaration": "example [_dont_delete_this : Inhabited Nat] : Inhabited Nat := by\n  clear_\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_dont_delete_this : Inhabited \u2115\n\u22a2 Inhabited \u2115"}, {"line": "  clear_", "tactic_state": "_dont_delete_this : Inhabited \u2115\n\u22a2 Inhabited \u2115"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (_delete_this : Nat) (dont_delete_this : Int) : Nat := by\n  clear_\n  fail_if_success assumption\n  exact dont_delete_this.toNat\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : \u2115\ndont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  clear_", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  fail_if_success assumption", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  exact dont_delete_this.toNat", "tactic_state": ""}]}
{"declaration": "example (_delete_this : Type) (_delete_this_dep : _delete_this)\n    (_delete_this_rw : _delete_this = Nat)\n    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat := by\n  clear_\n  fail_if_success\n    rw [\u2190 _delete_this_rw]\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : Type\n_delete_this_dep : _delete_this\n_delete_this_rw : _delete_this = \u2115\n_delete_this_dep_dep : _delete_this_dep = _delete_this_dep\n\u22a2 \u2115"}, {"line": "  clear_", "tactic_state": "\u22a2 \u2115"}, {"line": "  fail_if_success", "tactic_state": "\u22a2 \u2115"}, {"line": "    rw [\u2190 _delete_this_rw]", "tactic_state": ""}]}
{"declaration": "example (_dont_delete_this : Type) (dep : _dont_delete_this) : _dont_delete_this := by\n  clear_\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_dont_delete_this : Type\ndep : _dont_delete_this\n\u22a2 _dont_delete_this"}, {"line": "  clear_", "tactic_state": "_dont_delete_this : Type\ndep : _dont_delete_this\n\u22a2 _dont_delete_this"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this := by\n  clear_\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_dont_delete_this : Type\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "  clear_", "tactic_state": "_dont_delete_this : Type\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (_dont_delete_this : Type) (_delete_this : _dont_delete_this = _dont_delete_this) :\n  _dont_delete_this = _dont_delete_this := by\n  clear_\n  fail_if_success assumption\n  rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_dont_delete_this : Type\n_delete_this : _dont_delete_this = _dont_delete_this\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "  clear_", "tactic_state": "_dont_delete_this : Type\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "  fail_if_success assumption", "tactic_state": "_dont_delete_this : Type\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (a b c x y z : \u2115) (h : \u00ac x*y*z < 0) : c < a + 3*b := by\n  zify\n  guard_target =~ (c : \u2124) < (a : \u2124) + 3 * (b : \u2124)\n  zify at h\n  guard_hyp h :~ \u00ac(x : \u2124) * (y : \u2124) * (z : \u2124) < (0 : \u2124)\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Zify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c x y z : \u2115\nh : \u00acx * y * z < 0\n\u22a2 c < a + 3 * b"}, {"line": "  zify", "tactic_state": "a b c x y z : \u2115\nh : \u00acx * y * z < 0\n\u22a2 \u2191c < \u2191a + 3 * \u2191b"}, {"line": "  guard_target =~ (c : \u2124) < (a : \u2124) + 3 * (b : \u2124)", "tactic_state": "a b c x y z : \u2115\nh : \u00acx * y * z < 0\n\u22a2 \u2191c < \u2191a + 3 * \u2191b"}, {"line": "  zify at h", "tactic_state": "a b c x y z : \u2115\nh : \u00ac\u2191x * \u2191y * \u2191z < 0\n\u22a2 \u2191c < \u2191a + 3 * \u2191b"}, {"line": "  guard_hyp h :~ \u00ac(x : \u2124) * (y : \u2124) * (z : \u2124) < (0 : \u2124)", "tactic_state": "a b c x y z : \u2115\nh : \u00ac\u2191x * \u2191y * \u2191z < 0\n\u22a2 \u2191c < \u2191a + 3 * \u2191b"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (a b c x y z : \u2115) (h : \u00ac x*y*z < 0) (h2 : (c : \u2124) < a + 3 * b) : a + 3*b > c := by\n  zify at h \u22a2\n  guard_hyp h :~ \u00ac\u2191x * \u2191y * \u2191z < (0 : \u2124) -- TODO: canonize instances?\n  guard_target =~ \u2191c < (\u2191a : \u2124) + 3 * \u2191b\n  exact h2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Zify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c x y z : \u2115\nh : \u00acx * y * z < 0\nh2 : \u2191c < \u2191a + 3 * \u2191b\n\u22a2 a + 3 * b > c"}, {"line": "  zify at h \u22a2", "tactic_state": "a b c x y z : \u2115\nh2 : \u2191c < \u2191a + 3 * \u2191b\nh : \u00ac\u2191x * \u2191y * \u2191z < 0\n\u22a2 \u2191c < \u2191a + 3 * \u2191b"}, {"line": "  guard_hyp h :~ \u00ac\u2191x * \u2191y * \u2191z < (0 : \u2124) -- TODO: canonize instances?", "tactic_state": "a b c x y z : \u2115\nh2 : \u2191c < \u2191a + 3 * \u2191b\nh : \u00ac\u2191x * \u2191y * \u2191z < 0\n\u22a2 \u2191c < \u2191a + 3 * \u2191b"}, {"line": "  guard_target =~ \u2191c < (\u2191a : \u2124) + 3 * \u2191b", "tactic_state": "a b c x y z : \u2115\nh2 : \u2191c < \u2191a + 3 * \u2191b\nh : \u00ac\u2191x * \u2191y * \u2191z < 0\n\u22a2 \u2191c < \u2191a + 3 * \u2191b"}, {"line": "  exact h2", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : (a : \u2124) \u2264 b) : a \u2264 b := by\n  zify\n  guard_target = (a : \u2124) \u2264 b\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Zify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : \u2191a \u2264 \u2191b\n\u22a2 a \u2264 b"}, {"line": "  zify", "tactic_state": "a b : \u2115\nh : \u2191a \u2264 \u2191b\n\u22a2 \u2191a \u2264 \u2191b"}, {"line": "  guard_target = (a : \u2124) \u2264 b", "tactic_state": "a b : \u2115\nh : \u2191a \u2264 \u2191b\n\u22a2 \u2191a \u2264 \u2191b"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2115) (h : a - b < c) (hab : b \u2264 a) : True := by\n  zify [hab] at h\n  guard_hyp h : (a : \u2124) - b < c\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Zify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a - b < c\nhab : b \u2264 a\n\u22a2 True"}, {"line": "  zify [hab] at h", "tactic_state": "a b c : \u2115\nhab : b \u2264 a\nh : \u2191a - \u2191b < \u2191c\n\u22a2 True"}, {"line": "  guard_hyp h : (a : \u2124) - b < c", "tactic_state": "a b c : \u2115\nhab : b \u2264 a\nh : \u2191a - \u2191b < \u2191c\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2115) (h : a + b \u2260 c) : True := by\n  zify at h\n  guard_hyp h : (a + b : \u2124) \u2260 c\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Zify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a + b \u2260 c\n\u22a2 True"}, {"line": "  zify at h", "tactic_state": "a b c : \u2115\nh : \u2191a + \u2191b \u2260 \u2191c\n\u22a2 True"}, {"line": "  guard_hyp h : (a + b : \u2124) \u2260 c", "tactic_state": "a b c : \u2115\nh : \u2191a + \u2191b \u2260 \u2191c\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2115) (h : a - b \u2223 c) (h2 : b \u2264 a) : True := by\n  zify [h2] at h\n  guard_hyp h : (a : \u2124) - b \u2223 c\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Zify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a - b \u2223 c\nh2 : b \u2264 a\n\u22a2 True"}, {"line": "  zify [h2] at h", "tactic_state": "a b c : \u2115\nh2 : b \u2264 a\nh : \u2191a - \u2191b \u2223 \u2191c\n\u22a2 True"}, {"line": "  guard_hyp h : (a : \u2124) - b \u2223 c", "tactic_state": "a b c : \u2115\nh2 : b \u2264 a\nh : \u2191a - \u2191b \u2223 \u2191c\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : False \u2192 \u03b1 := by nofun", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/nomatch.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort ?u.9\n\u22a2 False \u2192 \u03b1"}]}
{"declaration": "example : \u00ac False := by nofun", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/nomatch.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acFalse"}]}
{"declaration": "example (_delete_this : Nat) (dont_delete_this : Int) : Nat := by\n  clear * - dont_delete_this\n  fail_if_success assumption\n  exact dont_delete_this.toNat\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : \u2115\ndont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  clear * - dont_delete_this", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  fail_if_success assumption", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  exact dont_delete_this.toNat", "tactic_state": ""}]}
{"declaration": "example [dont_delete_this : Inhabited Nat] (dont_delete_this2 : Prop) : Inhabited Nat := by\n  clear * - dont_delete_this2\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "dont_delete_this : Inhabited \u2115\ndont_delete_this2 : Prop\n\u22a2 Inhabited \u2115"}, {"line": "  clear * - dont_delete_this2", "tactic_state": "dont_delete_this : Inhabited \u2115\ndont_delete_this2 : Prop\n\u22a2 Inhabited \u2115"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (delete_this : Nat) (_delete_this2 : delete_this = delete_this) (dont_delete_this : Int) :\n    Nat := by\n  clear * - dont_delete_this\n  fail_if_success assumption\n  exact dont_delete_this.toNat\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "delete_this : \u2115\n_delete_this2 : delete_this = delete_this\ndont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  clear * - dont_delete_this", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  fail_if_success assumption", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "  exact dont_delete_this.toNat", "tactic_state": ""}]}
{"declaration": "example (dont_delete_this : Nat) (dont_delete_this2 : dont_delete_this = dont_delete_this) :\n    Nat := by\n  clear * - dont_delete_this2\n  exact dont_delete_this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "dont_delete_this : \u2115\ndont_delete_this2 : dont_delete_this = dont_delete_this\n\u22a2 \u2115"}, {"line": "  clear * - dont_delete_this2", "tactic_state": "dont_delete_this : \u2115\ndont_delete_this2 : dont_delete_this = dont_delete_this\n\u22a2 \u2115"}, {"line": "  exact dont_delete_this", "tactic_state": ""}]}
{"declaration": "example (_delete_this : Nat) (dont_delete_this : Int) (dont_delete_this2 : Int) : Nat := by\n  clear * - dont_delete_this dont_delete_this2\n  fail_if_success assumption\n  exact dont_delete_this.toNat + dont_delete_this2.toNat", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : \u2115\ndont_delete_this dont_delete_this2 : \u2124\n\u22a2 \u2115"}, {"line": "  clear * - dont_delete_this dont_delete_this2", "tactic_state": "dont_delete_this dont_delete_this2 : \u2124\n\u22a2 \u2115"}, {"line": "  fail_if_success assumption", "tactic_state": "dont_delete_this dont_delete_this2 : \u2124\n\u22a2 \u2115"}, {"line": "  exact dont_delete_this.toNat + dont_delete_this2.toNat", "tactic_state": ""}]}
{"declaration": "example : True := by\n  by_cases 0 = 0\n  exact .intro\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  by_cases 0 = 0", "tactic_state": "case pos\nh\u271d : 0 = 0\n\u22a2 True\n---\ncase neg\nh\u271d : \u00ac0 = 0\n\u22a2 True"}, {"line": "  exact .intro", "tactic_state": "case neg\nh\u271d : \u00ac0 = 0\n\u22a2 True"}, {"line": "  exact .intro", "tactic_state": ""}]}
{"declaration": "example : True := by\n  by_cases 0 = 0\n  exact .intro\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  by_cases 0 = 0", "tactic_state": "case pos\nh\u271d : 0 = 0\n\u22a2 True\n---\ncase neg\nh\u271d : \u00ac0 = 0\n\u22a2 True"}, {"line": "  exact .intro", "tactic_state": "case neg\nh\u271d : \u00ac0 = 0\n\u22a2 True"}, {"line": "  exact .intro", "tactic_state": ""}]}
{"declaration": "example {n : Nat} (hn : n = 0) : n + 0 = 0 := by\n  conv =>\n    congr\n    rw [\u2190 Nat.add_zero 0]\n  conv_lhs =>\n    congr\n    rw [\u2190 Nat.add_zero n]\n    rfl\n  conv_rhs =>\n    rw [\u2190 Nat.add_zero 0]\n    congr\n    rfl\n    rfl\n  by_cases 0 = 0\n  assumption\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : n = 0\n\u22a2 n + 0 = 0"}, {"line": "  conv =>", "tactic_state": "n : \u2115\nhn : n = 0\n\u22a2 n + (0 + 0) = 0"}, {"line": "    congr", "tactic_state": "n : \u2115\nhn : n = 0\n\u22a2 n + 0 + (0 + 0) = 0"}, {"line": "    rw [\u2190 Nat.add_zero 0]", "tactic_state": "n : \u2115\nhn : n = 0\n\u22a2 n + 0 + (0 + 0) = 0 + 0"}, {"line": "  conv_lhs =>", "tactic_state": "case pos\nn : \u2115\nhn : n = 0\nh\u271d : 0 = 0\n\u22a2 n + 0 + (0 + 0) = 0 + 0\n---\ncase neg\nn : \u2115\nhn : n = 0\nh\u271d : \u00ac0 = 0\n\u22a2 n + 0 + (0 + 0) = 0 + 0"}, {"line": "    congr", "tactic_state": "case neg\nn : \u2115\nhn : n = 0\nh\u271d : \u00ac0 = 0\n\u22a2 n + 0 + (0 + 0) = 0 + 0"}, {"line": "    rw [\u2190 Nat.add_zero n]", "tactic_state": ""}]}
{"declaration": "example (p : Prop) (hp : p) : (0 = 0 \u2227 p) \u2228 0 = 0 := by\n  iterate left; decide\n  repeat' left; decide\n  refine Or.inl \u27e8?_, ?_\u27e9\n  rfl\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\nhp : p\n\u22a2 0 = 0 \u2227 p \u2228 0 = 0"}, {"line": "  iterate left; decide", "tactic_state": "p : Prop\nhp : p\n\u22a2 0 = 0 \u2227 p \u2228 0 = 0"}, {"line": "  repeat' left; decide", "tactic_state": "p : Prop\nhp : p\n\u22a2 0 = 0 \u2227 p \u2228 0 = 0"}, {"line": "  refine Or.inl \u27e8?_, ?_\u27e9", "tactic_state": "case refine_1\np : Prop\nhp : p\n\u22a2 0 = 0\n---\ncase refine_2\np : Prop\nhp : p\n\u22a2 p"}, {"line": "  rfl", "tactic_state": "case refine_2\np : Prop\nhp : p\n\u22a2 p"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example : 0 = 0 \u2227 0 = 0 \u2227 0 = 0 := by\n  refine \u27e8?_, ?_, ?_\u27e9\n  rfl\n  trivial\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 = 0 \u2227 0 = 0 \u2227 0 = 0"}, {"line": "  refine \u27e8?_, ?_, ?_\u27e9", "tactic_state": "case refine_1\n\u22a2 0 = 0\n---\ncase refine_2\n\u22a2 0 = 0\n---\ncase refine_3\n\u22a2 0 = 0"}, {"line": "  rfl", "tactic_state": "case refine_2\n\u22a2 0 = 0\n---\ncase refine_3\n\u22a2 0 = 0"}, {"line": "  trivial", "tactic_state": "case refine_3\n\u22a2 0 = 0"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (p : Bool) : 0 = 0 := by\n  cases p\n  case' false => rfl\n  case' true => rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Bool\n\u22a2 0 = 0"}, {"line": "  cases p", "tactic_state": "case false\n\u22a2 0 = 0\n---\ncase true\n\u22a2 0 = 0"}, {"line": "  case' false => rfl", "tactic_state": "case true\n\u22a2 0 = 0"}, {"line": "  case' true => rfl", "tactic_state": ""}]}
{"declaration": "example (p : Bool) (f : False) {h : 0 = 0} : 0 = 0 \u2227 0 = 1 := by\n  cases p <;>\n  constructor\n  assumption'\n  any_goals cases f\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Bool\nf : False\nh : 0 = 0\n\u22a2 0 = 0 \u2227 0 = 1"}, {"line": "  cases p <;>", "tactic_state": "case false.left\nf : False\nh : 0 = 0\n\u22a2 0 = 0\n---\ncase false.right\nf : False\nh : 0 = 0\n\u22a2 0 = 1\n---\ncase true.left\nf : False\nh : 0 = 0\n\u22a2 0 = 0\n---\ncase true.right\nf : False\nh : 0 = 0\n\u22a2 0 = 1"}, {"line": "  constructor", "tactic_state": "case false.right\nf : False\nh : 0 = 0\n\u22a2 0 = 1\n---\ncase true.right\nf : False\nh : 0 = 0\n\u22a2 0 = 1"}, {"line": "  assumption'", "tactic_state": ""}]}
{"declaration": "example : True \u2227 True := by\n  constructor\n  focus\n    exact .intro\n  focus\n    exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True \u2227 True"}, {"line": "  constructor", "tactic_state": "case left\n\u22a2 True\n---\ncase right\n\u22a2 True"}, {"line": "  focus", "tactic_state": "case right\n\u22a2 True"}, {"line": "    exact .intro", "tactic_state": ""}]}
{"declaration": "example : 1 = 1 := by\n  sleep_heartbeats 1000\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 = 1"}, {"line": "  sleep_heartbeats 1000", "tactic_state": "\u22a2 1 = 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : True \u2227 True := by\n  constructor\n  bi_trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True \u2227 True"}, {"line": "  constructor", "tactic_state": "case left\n\u22a2 True\n---\ncase right\n\u22a2 True"}, {"line": "  bi_trivial", "tactic_state": "case left\n\u22a2 True\n---\ncase right\n\u22a2 True"}]}
{"declaration": "example : True := by\n  fail_if_success done\n  success_if_fail_with_msg \"internal exception #5\" done\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Multigoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  fail_if_success done", "tactic_state": "\u22a2 True"}, {"line": "  success_if_fail_with_msg \"internal exception #5\" done", "tactic_state": "\u22a2 True"}, {"line": "  exact .intro", "tactic_state": ""}]}
{"declaration": "example : 0 \u2264 2 + 2 := by\n  fail_if_success infer_param\n  decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/InferParam.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 \u2264 2 + 2"}, {"line": "  fail_if_success infer_param", "tactic_state": "\u22a2 0 \u2264 2 + 2"}, {"line": "  decide", "tactic_state": ""}]}
{"declaration": "example : 0 \u2264 2 + 2 := by\n  apply zero_le_add\n  infer_param\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/InferParam.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 \u2264 2 + 2"}, {"line": "  apply zero_le_add", "tactic_state": ""}, {"line": "  infer_param", "tactic_state": ""}]}
{"declaration": "example : 0 \u2264 2 + 2 := by\n  apply zero_le_add'\n  infer_param\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/InferParam.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 \u2264 2 + 2"}, {"line": "  apply zero_le_add'", "tactic_state": ""}, {"line": "  infer_param", "tactic_state": ""}]}
{"declaration": "lemma uses_norm_num : (0 + 1 : \u2115) = 1 := by norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/MinImports.lean", "context": {"open": ["Lean.Elab.Command Mathlib.Command.MinImports in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 + 1 = 1"}]}
{"declaration": "lemma hi (n : \u2115) : n = n := by extract_goal; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/MinImports.lean", "context": {"open": ["Lean.Elab.Command Mathlib.Command.MinImports in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n = n"}]}
{"declaration": "example (h : 1 < 0) : False := by hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 1 < 0\n\u22a2 False"}]}
{"declaration": "example {P Q : Prop} (p : P) (f : P \u2192 Q) : Q := by hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 Q"}]}
{"declaration": "example {P Q R : Prop} (x : P \u2227 Q \u2227 R \u2227 R) : Q \u2227 P \u2227 R := by hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q R : Prop\nx : P \u2227 Q \u2227 R \u2227 R\n\u22a2 Q \u2227 P \u2227 R"}]}
{"declaration": "example {a b : \u211a} (h : a < b) : \u00ac b < a := by hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\nh : a < b\n\u22a2 \u00acb < a"}]}
{"declaration": "example : 37^2 - 35^2 = 72 * 2 := by hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 37 ^ 2 - 35 ^ 2 = 72 * 2"}]}
{"declaration": "example : Nat.Prime 37 := by hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Nat.Prime 37"}]}
{"declaration": "example {P : Nat \u2192 Prop} (h : { x // P x }) : \u2203 x, P x \u2227 0 \u2264 x := by hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Prop\nh : { x // P x }\n\u22a2 \u2203 x, P x \u2227 0 \u2264 x"}]}
{"declaration": "example : True := by\n  hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  hint", "tactic_state": ""}]}
{"declaration": "example {\u03b1} (A B C : Set \u03b1) (h1 : A \u2286 B \u222a C) : (A \u2229 B) \u222a (A \u2229 C) = A := by hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nA B C : Set \u03b1\nh1 : A \u2286 B \u222a C\n\u22a2 A \u2229 B \u222a A \u2229 C = A"}]}
{"declaration": "example : 2 \u2264 1 := by hint\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/hint.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 \u2264 1"}]}
{"declaration": "example {n : \u2115} {k : \u2124} (hn : 8 \u2264 n) (hk : 2 * k \u2264 n + 2) :\n    (0 : \u211d) < n - k - 1 := by\n  rify at hn hk\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : \u2124\nhn : 8 \u2264 n\nhk : 2 * k \u2264 \u2191n + 2\n\u22a2 0 < \u2191n - \u2191k - 1"}, {"line": "  rify at hn hk", "tactic_state": "n : \u2115\nk : \u2124\nhn : 8 \u2264 \u2191n\nhk : 2 * \u2191k \u2264 \u2191n + 2\n\u22a2 0 < \u2191n - \u2191k - 1"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example {n : \u2115} {k : \u2124} (hn : 8 \u2264 n) (hk : (2 : \u211a) * k \u2264 n + 2) :\n    (0 : \u211d) < n - k - 1 := by\n  rify at hn hk\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : \u2124\nhn : 8 \u2264 n\nhk : 2 * \u2191k \u2264 \u2191n + 2\n\u22a2 0 < \u2191n - \u2191k - 1"}, {"line": "  rify at hn hk", "tactic_state": "n : \u2115\nk : \u2124\nhn : 8 \u2264 \u2191n\nhk : 2 * \u2191k \u2264 \u2191n + 2\n\u22a2 0 < \u2191n - \u2191k - 1"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2115) (h : a - b < c) (hab : b \u2264 a) : a < b + c := by\n  rify [hab] at h \u22a2\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a - b < c\nhab : b \u2264 a\n\u22a2 a < b + c"}, {"line": "  rify [hab] at h \u22a2", "tactic_state": "a b c : \u2115\nhab : b \u2264 a\nh : \u2191a - \u2191b < \u2191c\n\u22a2 \u2191a < \u2191b + \u2191c"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example {n : \u2115} (h : 8 \u2264 n) : (0 : \u211d) < n - 1 := by\n  rify at h\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : 8 \u2264 n\n\u22a2 0 < \u2191n - 1"}, {"line": "  rify at h", "tactic_state": "n : \u2115\nh : 8 \u2264 \u2191n\n\u22a2 0 < \u2191n - 1"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example {n k : \u2115} (h : 2 * k \u2264 n + 2) (h' : 8 \u2264 n) : (0 : \u211d) \u2264 3 * n - 4 - 4 * k := by\n  rify at *\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nh : 2 * k \u2264 n + 2\nh' : 8 \u2264 n\n\u22a2 0 \u2264 3 * \u2191n - 4 - 4 * \u2191k"}, {"line": "  rify at *", "tactic_state": "n k : \u2115\nh : 2 * \u2191k \u2264 \u2191n + 2\nh' : 8 \u2264 \u2191n\n\u22a2 0 \u2264 3 * \u2191n - 4 - 4 * \u2191k"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example {n k : \u2115} (h\u2081 : 8 \u2264 n) (h\u2082 : 2 * k > n) (h\u2083 : k + 1 < n) :\n    n - (k + 1) + 3 \u2264 n := by\n  rify [h\u2083] at *\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nh\u2081 : 8 \u2264 n\nh\u2082 : 2 * k > n\nh\u2083 : k + 1 < n\n\u22a2 n - (k + 1) + 3 \u2264 n"}, {"line": "  rify [h\u2083] at *", "tactic_state": "n k : \u2115\nh\u2081 : 8 \u2264 \u2191n\nh\u2082 : \u2191n < 2 * \u2191k\nh\u2083 : True\n\u22a2 \u2191n - (\u2191k + 1) + 3 \u2264 \u2191n"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example {n k : \u2115} (h\u2081 : 8 \u2264 n) (h\u2082 : 2 * k > n) (h\u2083 : k + 1 < n) :\n    n - (n - (k + 1)) = k + 1 := by\n  have f\u2081 : k + 1 \u2264 n := by linarith\n  have f\u2082 : n - (k + 1) \u2264 n := by rify [f\u2081]; linarith\n  rify [f\u2081, f\u2082] at *\n  linarith", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nh\u2081 : 8 \u2264 n\nh\u2082 : 2 * k > n\nh\u2083 : k + 1 < n\n\u22a2 n - (n - (k + 1)) = k + 1"}, {"line": "  have f\u2081 : k + 1 \u2264 n := by linarith", "tactic_state": "n k : \u2115\nh\u2081 : 8 \u2264 n\nh\u2082 : 2 * k > n\nh\u2083 : k + 1 < n\nf\u2081 : k + 1 \u2264 n\n\u22a2 n - (n - (k + 1)) = k + 1"}, {"line": "  have f\u2082 : n - (k + 1) \u2264 n := by rify [f\u2081]; linarith", "tactic_state": "n k : \u2115\nh\u2081 : 8 \u2264 n\nh\u2082 : 2 * k > n\nh\u2083 : k + 1 < n\nf\u2081 : k + 1 \u2264 n\nf\u2082 : n - (k + 1) \u2264 n\n\u22a2 n - (n - (k + 1)) = k + 1"}, {"line": "  rify [f\u2081, f\u2082] at *", "tactic_state": "n k : \u2115\nh\u2081 : 8 \u2264 \u2191n\nh\u2082 : \u2191n < 2 * \u2191k\nh\u2083 : \u2191k + 1 < \u2191n\nf\u2081 f\u2082 : True\n\u22a2 \u2191n - (\u2191n - (\u2191k + 1)) = \u2191k + 1"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b c : Nat) : a + b + c = c + a + b := by\n  conv =>\n    conv in a + b =>\n      rw [Nat.add_comm]\n    guard_target = b + a + c = c + a + b\n    rw [Nat.add_comm, Nat.add_assoc]\n    conv in (occs := 4) _ + _ =>\n      guard_target = a + b\n      rw [Nat.add_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/conv.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 a + b + c = c + a + b"}, {"line": "  conv =>", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) : (a + b) + (a + b) = (b + a) + (b + a) := by\n  conv =>\n    lhs\n    conv in (occs := *) a + b =>\n      rw [Nat.add_comm]\n    guard_target = b + a + (b + a)", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/conv.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a + b + (a + b) = b + a + (b + a)"}, {"line": "  conv =>", "tactic_state": ""}]}
{"declaration": "example (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k := by\n  extract_goal\n  exact h\u2080.trans h\u2081\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "i j k : \u2115\nh\u2080 : i \u2264 j\nh\u2081 : j \u2264 k\n\u22a2 i \u2264 k"}, {"line": "  extract_goal", "tactic_state": "i j k : \u2115\nh\u2080 : i \u2264 j\nh\u2081 : j \u2264 k\n\u22a2 i \u2264 k"}, {"line": "  exact h\u2080.trans h\u2081", "tactic_state": ""}]}
{"declaration": "example (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k := by\n  extract_goal h\u2081\n  exact h\u2080.trans h\u2081\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "i j k : \u2115\nh\u2080 : i \u2264 j\nh\u2081 : j \u2264 k\n\u22a2 i \u2264 k"}, {"line": "  extract_goal h\u2081", "tactic_state": "i j k : \u2115\nh\u2080 : i \u2264 j\nh\u2081 : j \u2264 k\n\u22a2 i \u2264 k"}, {"line": "  exact h\u2080.trans h\u2081", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type u} {\u03b2 : Type v} [Add \u03b1] [h : Sub \u03b2] (f : \u03b1 \u2192 \u03b2) \u2983_g : \u2124\u2984 (a : \u03b1) {b : \u03b2} :\n    f a - b = f a - b := by\n  extract_goal\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Add \u03b1\nh : Sub \u03b2\nf : \u03b1 \u2192 \u03b2\n_g : \u2124\na : \u03b1\nb : \u03b2\n\u22a2 f a - b = f a - b"}, {"line": "  extract_goal", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Add \u03b1\nh : Sub \u03b2\nf : \u03b1 \u2192 \u03b2\n_g : \u2124\na : \u03b1\nb : \u03b2\n\u22a2 f a - b = f a - b"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) : n = n := by\n  cases n\n  rfl\n  extract_goal\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n = n"}, {"line": "  cases n", "tactic_state": "case zero\n\u22a2 0 = 0\n---\ncase succ\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = n\u271d + 1"}, {"line": "  rfl", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = n\u271d + 1"}, {"line": "  extract_goal", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = n\u271d + 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : n = n := by\n  extract_goal\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\nn : \u03b1\u271d\n\u22a2 n = n"}, {"line": "  extract_goal", "tactic_state": "\u03b1\u271d : Sort u_1\nn : \u03b1\u271d\n\u22a2 n = n"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example {z : Int} : \u2203 n : Nat, \u2191n = z := by\n  set_option pp.all true in\n  extract_goal\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\n\u22a2 \u2203 n, \u2191n = z"}, {"line": "  set_option pp.all true in", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) : True := by\n  extract_goal using foo\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  extract_goal using foo", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) : True := by\n  extract_goal n using foo\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  extract_goal n using foo", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) : True := by\n  extract_goal k\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  extract_goal k", "tactic_state": "n : \u2115\n\u22a2 True"}]}
{"declaration": "example (n : \u2115) : True := by\n  extract_goal *\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  extract_goal *", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (i : Fin n) : True := by\n  extract_goal n\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 True"}, {"line": "  extract_goal n", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 True"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (i : Fin n) : True := by\n  extract_goal i\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 True"}, {"line": "  extract_goal i", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 True"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example (h : 1 = 2) : False := by\n  extract_goal\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "  extract_goal", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example : False := by\n  have h : 1 = 2 := sorry\n  extract_goal\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}, {"line": "  have h : 1 = 2 := sorry", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "  extract_goal", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example : 1 = 2 \u2192 False := by\n  intro h\n  extract_goal h\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 = 2 \u2192 False"}, {"line": "  intro h", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "  extract_goal h", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example : \u2200 n, n < n + 1 := by\n  intro m\n  extract_goal\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (n : \u2115), n < n + 1"}, {"line": "  intro m", "tactic_state": "m : \u2115\n\u22a2 m < m + 1"}, {"line": "  extract_goal", "tactic_state": "m : \u2115\n\u22a2 m < m + 1"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example : \u2200 n, n < n + 1 := by\n  intro m\n  show _\n  have : m < _ := Nat.lt.step (Nat.lt.base m)\n  extract_goal\n  sorry", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (n : \u2115), n < n + 1"}, {"line": "  intro m", "tactic_state": "m : \u2115\n\u22a2 m < m + 1"}, {"line": "  show _", "tactic_state": "m : \u2115\n\u22a2 m < m + 1"}, {"line": "  have : m < _ := Nat.lt.step (Nat.lt.base m)", "tactic_state": "m : \u2115\nthis : m < m.succ.succ\n\u22a2 m < m + 1"}, {"line": "  extract_goal", "tactic_state": "m : \u2115\nthis : m < m.succ.succ\n\u22a2 m < m + 1"}, {"line": "  sorry", "tactic_state": ""}]}
{"declaration": "example {R S : MonCat} (i : R \u27f6 S) (r : R) (h : r = 1) : i r = 1 := by simp [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/MonCat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : MonCat\ni : R \u27f6 S\nr : \u2191R\nh : r = 1\n\u22a2 (CategoryTheory.ConcreteCategory.hom i) r = 1"}]}
{"declaration": "example {R S : CommMonCat} (i : R \u27f6 S) (r : R) (h : r = 1) : i r = 1 := by simp [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/MonCat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : CommMonCat\ni : R \u27f6 S\nr : \u2191R\nh : r = 1\n\u22a2 (CategoryTheory.ConcreteCategory.hom i) r = 1"}]}
{"declaration": "example (R : CommMonCat.{u}) : R \u27f6 R := CommMonCat.ofHom\n  { toFun := fun x => by\n      match_target (R : Type u)\n      guard_hyp x : (R : Type u)\n      exact x * x\n    map_one' := by simp\n    map_mul' := fun x y => by\n      rw [mul_assoc x y (x * y), \u2190 mul_assoc y x y, mul_comm y x, mul_assoc, mul_assoc] }", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/MonCat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : CommMonCat\nx : \u2191R\n\u22a2 \u2191R"}, {"line": "  { toFun := fun x => by", "tactic_state": "R : CommMonCat\nx : \u2191R\n\u22a2 \u2191R"}, {"line": "      match_target (R : Type u)", "tactic_state": "R : CommMonCat\nx : \u2191R\n\u22a2 \u2191R"}, {"line": "      guard_hyp x : (R : Type u)", "tactic_state": ""}, {"line": "      exact x * x", "tactic_state": ""}, {"line": "    map_one' := by simp", "tactic_state": ""}]}
{"declaration": "example (p q : Prop) (h : \u00acq \u2192 \u00acp) : p \u2192 q := by\n  contrapose\n  guard_target = \u00acq \u2192 \u00acp\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : \u00acq \u2192 \u00acp\n\u22a2 p \u2192 q"}, {"line": "  contrapose", "tactic_state": "p q : Prop\nh : \u00acq \u2192 \u00acp\n\u22a2 \u00acq \u2192 \u00acp"}, {"line": "  guard_target = \u00acq \u2192 \u00acp", "tactic_state": "p q : Prop\nh : \u00acq \u2192 \u00acp\n\u22a2 \u00acq \u2192 \u00acp"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (p q : Prop) (h : p) (hpq : \u00acq \u2192 \u00acp) : q := by\n  contrapose h\n  guard_target = \u00acp\n  exact hpq h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : p\nhpq : \u00acq \u2192 \u00acp\n\u22a2 q"}, {"line": "  contrapose h", "tactic_state": "p q : Prop\nhpq : \u00acq \u2192 \u00acp\nh : \u00acq\n\u22a2 \u00acp"}, {"line": "  guard_target = \u00acp", "tactic_state": "p q : Prop\nhpq : \u00acq \u2192 \u00acp\nh : \u00acq\n\u22a2 \u00acp"}, {"line": "  exact hpq h", "tactic_state": ""}]}
{"declaration": "example (p q : Prop) (h : p) (hpq : \u00acq \u2192 \u00acp) : q := by\n  contrapose h with h'\n  guard_target = \u00acp\n  exact hpq h'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : p\nhpq : \u00acq \u2192 \u00acp\n\u22a2 q"}, {"line": "  contrapose h with h'", "tactic_state": "p q : Prop\nhpq : \u00acq \u2192 \u00acp\nh' : \u00acq\n\u22a2 \u00acp"}, {"line": "  guard_target = \u00acp", "tactic_state": "p q : Prop\nhpq : \u00acq \u2192 \u00acp\nh' : \u00acq\n\u22a2 \u00acp"}, {"line": "  exact hpq h'", "tactic_state": ""}]}
{"declaration": "example (p q : Prop) (h : q \u2192 p) : \u00acp \u2192 \u00acq := by\n  contrapose!\n  guard_target = q \u2192 p\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : q \u2192 p\n\u22a2 \u00acp \u2192 \u00acq"}, {"line": "  contrapose!", "tactic_state": "p q : Prop\nh : q \u2192 p\n\u22a2 q \u2192 p"}, {"line": "  guard_target = q \u2192 p", "tactic_state": "p q : Prop\nh : q \u2192 p\n\u22a2 q \u2192 p"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (p q : Prop) (h : \u00acp) (hpq : q \u2192 p) : \u00acq := by\n  contrapose! h\n  guard_target = p\n  exact hpq h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : \u00acp\nhpq : q \u2192 p\n\u22a2 \u00acq"}, {"line": "  contrapose! h", "tactic_state": "p q : Prop\nhpq : q \u2192 p\nh : q\n\u22a2 p"}, {"line": "  guard_target = p", "tactic_state": "p q : Prop\nhpq : q \u2192 p\nh : q\n\u22a2 p"}, {"line": "  exact hpq h", "tactic_state": ""}]}
{"declaration": "example (p q : Prop) (h : \u00acp) (hpq : q \u2192 p) : \u00acq := by\n  contrapose! h with h'\n  guard_target = p\n  exact hpq h'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : \u00acp\nhpq : q \u2192 p\n\u22a2 \u00acq"}, {"line": "  contrapose! h with h'", "tactic_state": "p q : Prop\nhpq : q \u2192 p\nh' : q\n\u22a2 p"}, {"line": "  guard_target = p", "tactic_state": "p q : Prop\nhpq : q \u2192 p\nh' : q\n\u22a2 p"}, {"line": "  exact hpq h'", "tactic_state": ""}]}
{"declaration": "example (p : Prop) (h : p) : p := by\n  fail_if_success { contrapose }\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\nh : p\n\u22a2 p"}, {"line": "  fail_if_success { contrapose }", "tactic_state": "p : Prop\nh : p\n\u22a2 p"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (p q : Type) (h : p \u2192 q) : p \u2192 q := by\n  fail_if_success { contrapose }\n  exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Type\nh : p \u2192 q\n\u22a2 p \u2192 q"}, {"line": "  fail_if_success { contrapose }", "tactic_state": "p q : Type\nh : p \u2192 q\n\u22a2 p \u2192 q"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (x y z k : \u2115)\n    (h : 3 \u2264 (4 : \u2115))\n    (h' : z \u2264 y) :\n    (k + 3 + x) - y \u2264 (k + 4 + x) - z := by\n  mono\n  -- norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z k : \u2115\nh : 3 \u2264 4\nh' : z \u2264 y\n\u22a2 k + 3 + x - y \u2264 k + 4 + x - z"}, {"line": "  mono", "tactic_state": ""}]}
{"declaration": "example (x y z k : \u2124)\n    (h : 3 \u2264 (4 : \u2124))\n    (h' : z \u2264 y) :\n    (k + 3 + x) - y \u2264 (k + 4 + x) - z := by\n  mono\n  -- norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z k : \u2124\nh : 3 \u2264 4\nh' : z \u2264 y\n\u22a2 k + 3 + x - y \u2264 k + 4 + x - z"}, {"line": "  mono", "tactic_state": ""}]}
{"declaration": "example (x y z a b : \u2115)\n    (h : a \u2264 (b : \u2115))\n    (h' : z \u2264 y) :\n    (1 + a + x) - y \u2264 (1 + b + x) - z := by\n  transitivity (1 + a + x - z)\n  \u00b7 mono\n  \u00b7 mono\n    -- mono\n    -- mono\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z a b : \u2115\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - y \u2264 1 + b + x - z"}, {"line": "  transitivity (1 + a + x - z)", "tactic_state": "x y z a b : \u2115\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - y \u2264 1 + a + x - z\n---\nx y z a b : \u2115\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - z \u2264 1 + b + x - z"}, {"line": "  \u00b7 mono", "tactic_state": ""}, {"line": "  \u00b7 mono", "tactic_state": ""}]}
{"declaration": "example (x y z a b : \u2124)\n    (h : a \u2264 (b : \u2124))\n    (h' : z \u2264 y) :\n    (1 + a + x) - y \u2264 (1 + b + x) - z := by\n  apply @le_trans \u2124 _ _ (1 + a + x - z)\n  -- transitivity (1 + a + x - z)\n  \u00b7 mono\n  \u00b7 mono\n    -- mono\n    -- mono\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z a b : \u2124\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - y \u2264 1 + b + x - z"}, {"line": "  apply @le_trans \u2124 _ _ (1 + a + x - z)", "tactic_state": "case a\nx y z a b : \u2124\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - y \u2264 1 + a + x - z\n---\ncase a\nx y z a b : \u2124\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - z \u2264 1 + b + x - z"}, {"line": "  -- transitivity (1 + a + x - z)", "tactic_state": ""}, {"line": "  \u00b7 mono", "tactic_state": ""}]}
{"declaration": "example (x y z : \u2124)\n    (h' : z \u2264 y) :\n    (1 + 3 + x) - y \u2264 (1 + 4 + x) - z := by\n  apply @le_trans \u2124 _ _ (1 + 3 + x - z)\n  -- transitivity (1 + 3 + x - z)\n  \u00b7 mono\n  \u00b7 mono\n    -- mono\n    norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2124\nh' : z \u2264 y\n\u22a2 1 + 3 + x - y \u2264 1 + 4 + x - z"}, {"line": "  apply @le_trans \u2124 _ _ (1 + 3 + x - z)", "tactic_state": "case a\nx y z : \u2124\nh' : z \u2264 y\n\u22a2 1 + 3 + x - y \u2264 1 + 3 + x - z\n---\ncase a\nx y z : \u2124\nh' : z \u2264 y\n\u22a2 1 + 3 + x - z \u2264 1 + 4 + x - z"}, {"line": "  -- transitivity (1 + 3 + x - z)", "tactic_state": ""}, {"line": "  \u00b7 mono", "tactic_state": "case a.hab.h\u2081.h\u2082\nx y z : \u2124\nh' : z \u2264 y\n\u22a2 3 \u2264 4"}, {"line": "  \u00b7 mono", "tactic_state": ""}]}
{"declaration": "example {x y z : \u2115} : true := by\n  have : y + x \u2264 y + z := by\n    mono\n    guard_target = x \u2264 z\n    exact test_sorry\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2115\n\u22a2 true = true"}, {"line": "  have : y + x \u2264 y + z := by", "tactic_state": "x y z : \u2115\nthis : y + x \u2264 y + z\n\u22a2 true = true"}, {"line": "    mono", "tactic_state": ""}]}
{"declaration": "example {x y z : \u2115} : true := by\n  suffices _this : x + y \u2264 z + y by trivial\n  mono\n  guard_target = x \u2264 z\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2115\n\u22a2 true = true"}, {"line": "  suffices _this : x + y \u2264 z + y by trivial", "tactic_state": "x y z : \u2115\n\u22a2 x + y \u2264 z + y"}, {"line": "  mono", "tactic_state": "case h\u2081\nx y z : \u2115\n\u22a2 x \u2264 z"}, {"line": "  guard_target = x \u2264 z", "tactic_state": "case h\u2081\nx y z : \u2115\n\u22a2 x \u2264 z"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example {x y z w : \u2115} : true := by\n  have : x + y \u2264 z + w := by\n    mono\n    guard_target = x \u2264 z; exact test_sorry\n    guard_target = y \u2264 w; exact test_sorry\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z w : \u2115\n\u22a2 true = true"}, {"line": "  have : x + y \u2264 z + w := by", "tactic_state": "x y z w : \u2115\nthis : x + y \u2264 z + w\n\u22a2 true = true"}, {"line": "    mono", "tactic_state": ""}]}
{"declaration": "example : 3 \u2264 (3:\u2115) := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 3 \u2264 3"}]}
{"declaration": "example : 1 \u2264 (3:\u2115) := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 1 \u2264 3"}]}
{"declaration": "example : 0 \u2264 (3:\u2115) + 1 := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 0 \u2264 3 + 1"}]}
{"declaration": "example : x \u2264 x := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x \u2264 x"}]}
{"declaration": "example : x \u2264 x + 3 := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x \u2264 x + 3"}]}
{"declaration": "example : x \u2264 1 + x := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x \u2264 1 + x"}]}
{"declaration": "example : x + y + 1 \u2264 y + x + 3 := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + y + 1 \u2264 y + x + 3"}]}
{"declaration": "example : x + y \u2264 y + x + 3 := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + y \u2264 y + x + 3"}]}
{"declaration": "example : x + y + 1 \u2264 y + 4 + x := by ring_le\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + y + 1 \u2264 y + 4 + x"}]}
{"declaration": "example : 1 < (3:\u2115) := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 1 < 3"}]}
{"declaration": "example : 0 < (3:\u2115) + 1 := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 0 < 3 + 1"}]}
{"declaration": "example : x < x + 3 := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x < x + 3"}]}
{"declaration": "example : x < 1 + x := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x < 1 + x"}]}
{"declaration": "example : x + y + 1 < y + x + 3 := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + y + 1 < y + x + 3"}]}
{"declaration": "example : x + y < y + x + 3 := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + y < y + x + 3"}]}
{"declaration": "example : x + y + 1 < y + 4 + x := by ring_lt\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + y + 1 < y + 4 + x"}]}
{"declaration": "example : (0:K) \u2264 0 := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 0 \u2264 0"}]}
{"declaration": "example : 3 \u2264 (3:K) := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 3 \u2264 3"}]}
{"declaration": "example : 1 \u2264 (3:K) := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 1 \u2264 3"}]}
{"declaration": "example : -1 \u2264 (3:K) := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 -1 \u2264 3"}]}
{"declaration": "example : 1.5 \u2264 (3:K) := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 1.5 \u2264 3"}]}
{"declaration": "example : 0 \u2264 x + 3 - x := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 0 \u2264 x + 3 - x"}]}
{"declaration": "example : -1 \u2264 x - x := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 -1 \u2264 x - x"}]}
{"declaration": "example : x + y + 1 \u2264 y + x + 3 := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y + 1 \u2264 y + x + 3"}]}
{"declaration": "example : x + y + 1 \u2264 y + x + 1 := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y + 1 \u2264 y + x + 1"}]}
{"declaration": "example : x + y \u2264 y + x + 3 := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y \u2264 y + x + 3"}]}
{"declaration": "example : x + y - 3 \u2264 y + x := by ring_le", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y - 3 \u2264 y + x"}]}
{"declaration": "example : x + y - x + 1 \u2264 y + (4:K) := by ring_le\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y - x + 1 \u2264 y + 4"}]}
{"declaration": "example : 1 < (3:K) := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 1 < 3"}]}
{"declaration": "example : -1 < (3:K) := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 -1 < 3"}]}
{"declaration": "example : 1.5 < (3:K) := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 1.5 < 3"}]}
{"declaration": "example : 0 < x + 3 - x := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 0 < x + 3 - x"}]}
{"declaration": "example : -1 < x - x := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 -1 < x - x"}]}
{"declaration": "example : x + y + 1 < y + x + 3 := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y + 1 < y + x + 3"}]}
{"declaration": "example : x + y < y + x + 3 := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y < y + x + 3"}]}
{"declaration": "example : x + y - 3 < y + x := by ring_lt", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y - 3 < y + x"}]}
{"declaration": "example : x + y - x + 1 < y + (4:K) := by ring_lt\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y - x + 1 < y + 4"}]}
{"declaration": "example : x + y - x + 1 \u2264 y + (4:K) := by ring_le\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y - x + 1 \u2264 y + 4"}]}
{"declaration": "example : x + y - x + 1 < y + (4:K) := by ring_lt\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y - x + 1 < y + 4"}]}
{"declaration": "example : x + y + 1 \u2264 y + 3 := by ring_le\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y + 1 \u2264 y + 3"}]}
{"declaration": "example : x + y + 4 \u2264 y + x + 3 := by ring_le\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y + 4 \u2264 y + x + 3"}]}
{"declaration": "example : x + y + 1 < y + 3 := by ring_lt\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y + 1 < y + 3"}]}
{"declaration": "example : x + y + 4 < y + x + 4 := by ring_lt\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring_compare.lean", "context": {"open": ["Lean Elab Tactic"], "variables": ["{x y : \u2115}", "{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] {x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d y\u271d : \u2115\nK : Type u_1\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : IsStrictOrderedRing K\nx y : K\n\u22a2 x + y + 4 < y + x + 4"}]}
{"declaration": "example : \u2200 a b : Nat, a = b \u2192 b = a := by\n  introv h\n  exact h.symm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (a b : \u2115), a = b \u2192 b = a"}, {"line": "  introv h", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 b = a"}, {"line": "  exact h.symm", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : n = n := by\n  induction n\n  exacts [rfl, rfl]\n  exacts []\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n = n"}, {"line": "  induction n", "tactic_state": "case zero\n\u22a2 0 = 0\n---\ncase succ\nn\u271d : \u2115\na\u271d : n\u271d = n\u271d\n\u22a2 n\u271d + 1 = n\u271d + 1"}, {"line": "  exacts [rfl, rfl]", "tactic_state": ""}, {"line": "  exacts []", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : Nat := by\n  guard_hyp n : Nat\n  let m : Nat := 1\n  guard_hyp m := 1\n  guard_hyp m : Nat := 1\n  guard_target = Nat\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2115"}, {"line": "  guard_hyp n : Nat", "tactic_state": "n : \u2115\n\u22a2 \u2115"}, {"line": "  let m : Nat := 1", "tactic_state": "n : \u2115\nm : \u2115 := 1\n\u22a2 \u2115"}, {"line": "  guard_hyp m := 1", "tactic_state": "n : \u2115\nm : \u2115 := 1\n\u22a2 \u2115"}, {"line": "  guard_hyp m : Nat := 1", "tactic_state": "n : \u2115\nm : \u2115 := 1\n\u22a2 \u2115"}, {"line": "  guard_target = Nat", "tactic_state": "n : \u2115\nm : \u2115 := 1\n\u22a2 \u2115"}, {"line": "  exact 0", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) : a \u2260 b \u2192 \u00ac a = b := by\n  intros\n  by_contra H\n  contradiction\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a \u2260 b \u2192 \u00aca = b"}, {"line": "  intros", "tactic_state": "a b : \u2115\na\u271d : a \u2260 b\n\u22a2 \u00aca = b"}, {"line": "  by_contra H", "tactic_state": "a b : \u2115\na\u271d : a \u2260 b\nH : a = b\n\u22a2 False"}, {"line": "  contradiction", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) : \u00ac\u00ac a = b \u2192 a = b := by\n  intros\n  by_contra H\n  contradiction\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u00ac\u00aca = b \u2192 a = b"}, {"line": "  intros", "tactic_state": "a b : \u2115\na\u271d : \u00ac\u00aca = b\n\u22a2 a = b"}, {"line": "  by_contra H", "tactic_state": "a b : \u2115\na\u271d : \u00ac\u00aca = b\nH : \u00aca = b\n\u22a2 False"}, {"line": "  contradiction", "tactic_state": ""}]}
{"declaration": "example (p _q : Prop) : \u00ac\u00ac p \u2192 p := by\n  intros\n  by_contra H\n  contradiction\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p _q : Prop\n\u22a2 \u00ac\u00acp \u2192 p"}, {"line": "  intros", "tactic_state": "p _q : Prop\na\u271d : \u00ac\u00acp\n\u22a2 p"}, {"line": "  by_contra H", "tactic_state": "p _q : Prop\na\u271d : \u00ac\u00acp\nH : \u00acp\n\u22a2 False"}, {"line": "  contradiction", "tactic_state": ""}]}
{"declaration": "example (n m : Nat) : Unit := by\n  cases n\n  cases m\n  iterate 3 exact ()\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 Unit"}, {"line": "  cases n", "tactic_state": "case zero\nm : \u2115\n\u22a2 Unit\n---\ncase succ\nm n\u271d : \u2115\n\u22a2 Unit"}, {"line": "  cases m", "tactic_state": "case zero.zero\n\u22a2 Unit\n---\ncase zero.succ\nn\u271d : \u2115\n\u22a2 Unit\n---\ncase succ\nm n\u271d : \u2115\n\u22a2 Unit"}, {"line": "  iterate 3 exact ()", "tactic_state": ""}]}
{"declaration": "example (n m : Nat) : Unit := by\n  cases n\n  cases m\n  iterate exact ()\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 Unit"}, {"line": "  cases n", "tactic_state": "case zero\nm : \u2115\n\u22a2 Unit\n---\ncase succ\nm n\u271d : \u2115\n\u22a2 Unit"}, {"line": "  cases m", "tactic_state": "case zero.zero\n\u22a2 Unit\n---\ncase zero.succ\nn\u271d : \u2115\n\u22a2 Unit\n---\ncase succ\nm n\u271d : \u2115\n\u22a2 Unit"}, {"line": "  iterate exact ()", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : Nat := by\n  iterate exact () -- silently succeeds, after iterating 0 times\n  iterate exact n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2115"}, {"line": "  iterate exact () -- silently succeeds, after iterating 0 times", "tactic_state": "n : \u2115\n\u22a2 \u2115"}, {"line": "  iterate exact n", "tactic_state": ""}]}
{"declaration": "example (p q r s : Prop) : p \u2192 q \u2192 r \u2192 s \u2192 (p \u2227 q) \u2227 (r \u2227 s \u2227 p) \u2227 (p \u2227 r \u2227 q) := by\n  intros\n  repeat' constructor\n  repeat' assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r s : Prop\n\u22a2 p \u2192 q \u2192 r \u2192 s \u2192 (p \u2227 q) \u2227 (r \u2227 s \u2227 p) \u2227 p \u2227 r \u2227 q"}, {"line": "  intros", "tactic_state": "p q r s : Prop\na\u271d\u00b3 : p\na\u271d\u00b2 : q\na\u271d\u00b9 : r\na\u271d : s\n\u22a2 (p \u2227 q) \u2227 (r \u2227 s \u2227 p) \u2227 p \u2227 r \u2227 q"}, {"line": "  repeat' constructor", "tactic_state": "case left.left\np q r s : Prop\na\u271d\u00b3 : p\na\u271d\u00b2 : q\na\u271d\u00b9 : r\na\u271d : s\n\u22a2 p\n---\ncase left.right\np q r s : Prop\na\u271d\u00b3 : p\na\u271d\u00b2 : q\na\u271d\u00b9 : r\na\u271d : s\n\u22a2 q\n---\ncase right.left.left\np q r s : Prop\na\u271d\u00b3 : p\na\u271d\u00b2 : q\na\u271d\u00b9 : r\na\u271d : s\n\u22a2 r\n---\ncase right.left.right.left\np q r s : Prop\na\u271d\u00b3 : p\na\u271d\u00b2 : q\na\u271d\u00b9 : r\na\u271d : s\n\u22a2 s\n---\ncase right.left.right.right\np q r s : Prop\na\u271d\u00b3 : p\na\u271d\u00b2 : q\na\u271d\u00b9 : r\na\u271d : s\n\u22a2 p\n---\ncase right.right.left\np q r s : Prop\na\u271d\u00b3 : p\na\u271d\u00b2 : q\na\u271d\u00b9 : r\na\u271d : s\n\u22a2 p\n---\ncase right.right.right.left\np q r s : Prop\na\u271d\u00b3 : p\na\u271d\u00b2 : q\na\u271d\u00b9 : r\na\u271d : s\n\u22a2 r\n---\ncase right.right.right.right\np q r s : Prop\na\u271d\u00b3 : p\na\u271d\u00b2 : q\na\u271d\u00b9 : r\na\u271d : s\n\u22a2 q"}, {"line": "  repeat' assumption", "tactic_state": ""}]}
{"declaration": "example (p q : Prop) : p \u2192 q \u2192 (p \u2227 q) \u2227 (p \u2227 q \u2227 p) := by\n  intros\n  constructor\n  fail_if_success any_goals assumption\n  all_goals constructor\n  any_goals assumption\n  constructor\n  any_goals assumption", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/basicTactics.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\n\u22a2 p \u2192 q \u2192 (p \u2227 q) \u2227 p \u2227 q \u2227 p"}, {"line": "  intros", "tactic_state": "p q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 (p \u2227 q) \u2227 p \u2227 q \u2227 p"}, {"line": "  constructor", "tactic_state": "case left\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 p \u2227 q\n---\ncase right\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 p \u2227 q \u2227 p"}, {"line": "  fail_if_success any_goals assumption", "tactic_state": "case left\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 p \u2227 q\n---\ncase right\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 p \u2227 q \u2227 p"}, {"line": "  all_goals constructor", "tactic_state": "case left.left\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 p\n---\ncase left.right\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 q\n---\ncase right.left\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 p\n---\ncase right.right\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 q \u2227 p"}, {"line": "  any_goals assumption", "tactic_state": "case right.right\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 q \u2227 p"}, {"line": "  constructor", "tactic_state": "case right.right.left\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 q\n---\ncase right.right.right\np q : Prop\na\u271d\u00b9 : p\na\u271d : q\n\u22a2 p"}, {"line": "  any_goals assumption", "tactic_state": ""}]}
{"declaration": "example {P Q : Prop} (q : P) (p : Q) : P \u2227 Q := by\n  swap_var p \u2194 q\n  exact \u27e8p, q\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SwapVar.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\nq : P\np : Q\n\u22a2 P \u2227 Q"}, {"line": "  swap_var p \u2194 q", "tactic_state": "P Q : Prop\np : P\nq : Q\n\u22a2 P \u2227 Q"}, {"line": "  exact \u27e8p, q\u27e9", "tactic_state": ""}]}
{"declaration": "example {a b : Nat} (h : a = b) : a = b \u2227 a = a := by\n  swap_var a \u2194 b\n  guard_hyp h : b = a\n  guard_target = b = a \u2227 b = b\n  exact \u27e8h, Eq.refl b\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SwapVar.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b \u2227 a = a"}, {"line": "  swap_var a \u2194 b", "tactic_state": "b a : \u2115\nh : b = a\n\u22a2 b = a \u2227 b = b"}, {"line": "  guard_hyp h : b = a", "tactic_state": "b a : \u2115\nh : b = a\n\u22a2 b = a \u2227 b = b"}, {"line": "  guard_target = b = a \u2227 b = b", "tactic_state": "b a : \u2115\nh : b = a\n\u22a2 b = a \u2227 b = b"}, {"line": "  exact \u27e8h, Eq.refl b\u27e9", "tactic_state": ""}]}
{"declaration": "example {a b c d : Nat} (h : a = b \u2227 c = d) : a = b \u2227 c = d := by\n  swap_var a \u2194 b, b c\n  guard_target = c = a \u2227 b = d\n  exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SwapVar.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nh : a = b \u2227 c = d\n\u22a2 a = b \u2227 c = d"}, {"line": "  swap_var a \u2194 b, b c", "tactic_state": "c a b d : \u2115\nh : c = a \u2227 b = d\n\u22a2 c = a \u2227 b = d"}, {"line": "  guard_target = c = a \u2227 b = d", "tactic_state": "c a b d : \u2115\nh : c = a \u2227 b = d\n\u22a2 c = a \u2227 b = d"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example : \u00ac (4 / 2 : \u211a) = 3 := by cancel_denoms\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\n\u22a2 \u00ac4 / 2 = 3"}]}
{"declaration": "example (h : a / 5 + b / 4 < c) : 4*a + 5*b < 20*c := by\n  cancel_denoms at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a / 5 + b / 4 < c\n\u22a2 4 * a + 5 * b < 20 * c"}, {"line": "  cancel_denoms at h", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : 4 * a + 5 * b < 20 * c\n\u22a2 4 * a + 5 * b < 20 * c"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a > 0) : a / 5 > 0 := by\n  cancel_denoms\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a > 0\n\u22a2 a / 5 > 0"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a > 0\n\u22a2 0 < a"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a + b = c) : a/5 + d*(b/4) = c - 4*a/5 + b*2*d/8 - b := by\n  cancel_denoms\n  rw [\u2190 h]\n  ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a + b = c\n\u22a2 a / 5 + d * (b / 4) = c - 4 * a / 5 + b * 2 * d / 8 - b"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a + b = c\n\u22a2 2 * (4 * a + d * 5 * b) = 40 * c - 32 * a + b * 2 * 5 * d - 40 * b"}, {"line": "  rw [\u2190 h]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a + b = c\n\u22a2 2 * (4 * a + d * 5 * b) = 40 * (a + b) - 32 * a + b * 2 * 5 * d - 40 * b"}, {"line": "  ring", "tactic_state": ""}]}
{"declaration": "example (h : 0 < a) : a / (3/2) > 0 := by\n  cancel_denoms\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : 0 < a\n\u22a2 a / (3 / 2) > 0"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : 0 < a\n\u22a2 0 < a"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : 0 < a): 0 < a / 1 := by\n  cancel_denoms\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : 0 < a\n\u22a2 0 < a / 1"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : 0 < a\n\u22a2 0 < a"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a < 0): 0 < a / -1 := by\n  cancel_denoms\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a < 0\n\u22a2 0 < a / -1"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a < 0\n\u22a2 a < 0"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : -a < 2 * b): a / -2 < b := by\n  cancel_denoms\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : -a < 2 * b\n\u22a2 a / -2 < b"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : -a < 2 * b\n\u22a2 -a < 2 * b"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a < 6 * a) : a / 2 / 3 < a := by\n  cancel_denoms\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a < 6 * a\n\u22a2 a / 2 / 3 < a"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a < 6 * a\n\u22a2 a < 6 * a"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a < 9 * a) : a / 3 / 3 < a := by\n  cancel_denoms\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a < 9 * a\n\u22a2 a / 3 / 3 < a"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a < 9 * a\n\u22a2 a < 9 * a"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a / 5 + b / 4 < c) : 4*a + 5*b < 20*c := by\n  cancel_denoms at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u\ninst\u271d\u2075 : Field \u03b1\u271d\ninst\u271d\u2074 : LinearOrder \u03b1\u271d\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\u271d\na\u271d b\u271d c\u271d d\u271d : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a / 5 + b / 4 < c\n\u22a2 4 * a + 5 * b < 20 * c"}, {"line": "  cancel_denoms at h", "tactic_state": "\u03b1\u271d : Type u\ninst\u271d\u2075 : Field \u03b1\u271d\ninst\u271d\u2074 : LinearOrder \u03b1\u271d\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\u271d\na\u271d b\u271d c\u271d d\u271d : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : 4 * a + 5 * b < 20 * c\n\u22a2 4 * a + 5 * b < 20 * c"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a > 0) : a / 5 > 0 := by\n  cancel_denoms\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u\ninst\u271d\u2075 : Field \u03b1\u271d\ninst\u271d\u2074 : LinearOrder \u03b1\u271d\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\u271d\na\u271d b\u271d c\u271d d\u271d : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a > 0\n\u22a2 a / 5 > 0"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d : Type u\ninst\u271d\u2075 : Field \u03b1\u271d\ninst\u271d\u2074 : LinearOrder \u03b1\u271d\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\u271d\na\u271d b\u271d c\u271d d\u271d : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c d : \u03b1\nh : a > 0\n\u22a2 0 < a"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a + b = c) : a/5 + d*(b/4) = c - 4*a/5 + b*2*d/8 - b := by\n  cancel_denoms\n  rw [\u2190 h]\n  ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d b\u271d c\u271d d\u271d : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na b c d : \u03b1\nh : a + b = c\n\u22a2 a / 5 + d * (b / 4) = c - 4 * a / 5 + b * 2 * d / 8 - b"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d b\u271d c\u271d d\u271d : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na b c d : \u03b1\nh : a + b = c\n\u22a2 2 * (4 * a + d * 5 * b) = 40 * c - 32 * a + b * 2 * 5 * d - 40 * b"}, {"line": "  rw [\u2190 h]", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d b\u271d c\u271d d\u271d : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na b c d : \u03b1\nh : a + b = c\n\u22a2 2 * (4 * a + d * 5 * b) = 40 * (a + b) - 32 * a + b * 2 * 5 * d - 40 * b"}, {"line": "  ring", "tactic_state": ""}]}
{"declaration": "example : (1 : \u211a) > 0 := by\n  have := 0\n  cancel_denoms\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\n\u22a2 1 > 0"}, {"line": "  have := 0", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nthis : \u2115\n\u22a2 1 > 0"}, {"line": "  cancel_denoms", "tactic_state": ""}]}
{"declaration": "example (h : a / 5 + b / 4 < c) : 4*a + 5*b < 20*c := by\n  cancel_denoms at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a / 5 + b / 4 < c\n\u22a2 4 * a + 5 * b < 20 * c"}, {"line": "  cancel_denoms at h", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 4 * a + 5 * b < 20 * c\n\u22a2 4 * a + 5 * b < 20 * c"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a > 0) : a / 5 > 0 := by\n  cancel_denoms\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a > 0\n\u22a2 a / 5 > 0"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a > 0\n\u22a2 0 < a"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (h : a + b = c) : a/5 + d*(b/4) = c - 4*a/5 + b*2*d/8 - b := by\n  cancel_denoms\n  rw [\u2190 h]\n  ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a + b = c\n\u22a2 a / 5 + d * (b / 4) = c - 4 * a / 5 + b * 2 * d / 8 - b"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a + b = c\n\u22a2 2 * (4 * a + d * 5 * b) = 40 * c - 32 * a + b * 2 * 5 * d - 40 * b"}, {"line": "  rw [\u2190 h]", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a + b = c\n\u22a2 2 * (4 * a + d * 5 * b) = 40 * (a + b) - 32 * a + b * 2 * 5 * d - 40 * b"}, {"line": "  ring", "tactic_state": ""}]}
{"declaration": "example (h : 2 * (4 * a + d * 5 * b) \u2260 (40 * c - 32 * a + b * 2 * 5 * d - 40 * b)) :\n    a/5 + d*(b/4) \u2260 c - 4*a/5 + b*2*d/8 - b := by\n  cancel_denoms\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 2 * (4 * a + d * 5 * b) \u2260 40 * c - 32 * a + b * 2 * 5 * d - 40 * b\n\u22a2 a / 5 + d * (b / 4) \u2260 c - 4 * a / 5 + b * 2 * d / 8 - b"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 2 * (4 * a + d * 5 * b) \u2260 40 * c - 32 * a + b * 2 * 5 * d - 40 * b\n\u22a2 \u00ac2 * (4 * a + d * 5 * b) = 40 * c - 32 * a + b * 2 * 5 * d - 40 * b"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (h : 27 \u2264 (a + 3) ^ 3) : 1 \u2264 (a / 3 + 1) ^ 3 := by\n  cancel_denoms\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 27 \u2264 (a + 3) ^ 3\n\u22a2 1 \u2264 (a / 3 + 1) ^ 3"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 27 \u2264 (a + 3) ^ 3\n\u22a2 27 \u2264 (a + 3) ^ 3"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (h : a > 2) : 1 < 2\u207b\u00b9 * a := by\n  cancel_denoms\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a > 2\n\u22a2 1 < 2\u207b\u00b9 * a"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a > 2\n\u22a2 2 < a"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (h : 6 * b = a\u207b\u00b9 * 3 + c * 2): b = a\u207b\u00b9 * 2\u207b\u00b9 + c * 3\u207b\u00b9 := by\n  cancel_denoms\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 6 * b = a\u207b\u00b9 * 3 + c * 2\n\u22a2 b = a\u207b\u00b9 * 2\u207b\u00b9 + c * 3\u207b\u00b9"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 6 * b = a\u207b\u00b9 * 3 + c * 2\n\u22a2 6 * b = a\u207b\u00b9 * 3 + c * 2"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (h : a * 5 + b * 6 = 30 * c) : a * 2\u207b\u00b9 * 3\u207b\u00b9 + b * 5\u207b\u00b9 = c := by\n  cancel_denoms\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a * 5 + b * 6 = 30 * c\n\u22a2 a * 2\u207b\u00b9 * 3\u207b\u00b9 + b * 5\u207b\u00b9 = c"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : a * 5 + b * 6 = 30 * c\n\u22a2 a * 5 + b * 6 = 30 * c"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (h : 5 * a ^ 2 + 4 * b ^ 3 = 0) : a ^ 2 / 4 + b ^ 3 / 5 = 0 := by\n  cancel_denoms\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 5 * a ^ 2 + 4 * b ^ 3 = 0\n\u22a2 a ^ 2 / 4 + b ^ 3 / 5 = 0"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 5 * a ^ 2 + 4 * b ^ 3 = 0\n\u22a2 5 * a ^ 2 + 4 * b ^ 3 = 0"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (h : 5 * a ^ 3 * b ^ 2 = 72 * c) : (a / 2) ^ 3 * (b / 3) ^ 2 = c / 5 := by\n  cancel_denoms\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 5 * a ^ 3 * b ^ 2 = 72 * c\n\u22a2 (a / 2) ^ 3 * (b / 3) ^ 2 = c / 5"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : 5 * a ^ 3 * b ^ 2 = 72 * c\n\u22a2 5 * a ^ 3 * b ^ 2 = 72 * c"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (h : (5 * a ^ 3 + 8) ^ 2 = 1600 * c) : ((a / 2) ^ 3 + 1 / 5) ^ 2 = c := by\n  cancel_denoms\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : (5 * a ^ 3 + 8) ^ 2 = 1600 * c\n\u22a2 ((a / 2) ^ 3 + 1 / 5) ^ 2 = c"}, {"line": "  cancel_denoms", "tactic_state": "\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d b\u271d c\u271d d\u271d : \u03b1\na b c d : \u211a\nh : (5 * a ^ 3 + 8) ^ 2 = 1600 * c\n\u22a2 (5 * a ^ 3 + 8) ^ 2 = 1600 * c"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (h : a + b = c) : a/5 + d*(b/4) = c - 4*a/5 + b*2*d/8 - b := by\n  cancel_denoms\n  rw [\u2190 h]\n  ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/cancel_denoms.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c d : \u03b1)", "{\u03b1 : Type} [Field \u03b1] [CharZero \u03b1] (a b c d : \u03b1)", "(a b c d : \u211a)", "(a b c d : C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_5\n\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b3 b\u271d\u00b3 c\u271d\u00b3 d\u271d\u00b3 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\na\u271d b\u271d c\u271d d\u271d : \u211a\na b c d : C\nh : sorry\n\u22a2 a / 5 + d * (b / 4) = c - 4 * a / 5 + b * 2 * d / 8 - b"}, {"line": "  cancel_denoms", "tactic_state": "C : Type u_5\n\u03b1\u271d\u00b9 : Type u\ninst\u271d\u2077 : Field \u03b1\u271d\u00b9\ninst\u271d\u2076 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2075 : IsStrictOrderedRing \u03b1\u271d\u00b9\na\u271d\u00b3 b\u271d\u00b3 c\u271d\u00b3 d\u271d\u00b3 : \u03b1\u271d\u00b9\n\u03b1\u271d : Type\ninst\u271d\u2074 : Field \u03b1\u271d\ninst\u271d\u00b3 : LinearOrder \u03b1\u271d\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 d\u271d\u00b2 : \u03b1\u271d\n\u03b1 : Type\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 d\u271d\u00b9 : \u03b1\na\u271d b\u271d c\u271d d\u271d : \u211a\na b c d : C\nh : sorry\n\u22a2 a / 5 + d * (b / 4) = c - 4 * a / 5 + b * 2 * d / 8 - b"}]}
{"declaration": "example {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : \u03b2 := by\n  apply f at a\n  guard_hyp a :\u209b \u03b2\n  exact a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}, {"line": "  apply f at a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na : \u03b2\n\u22a2 \u03b2"}, {"line": "  guard_hyp a :\u209b \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na : \u03b2\n\u22a2 \u03b2"}, {"line": "  exact a", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} (\u03b3 : \u03b1 \u2192 Type) (a : \u03b1) (f : \u03b1 \u2192 \u03b3 a) : \u03b3 a := by\n  apply f at a\n  rename_i a\u2082\n  guard_hyp a :\u209b \u03b3 a\u2082\n  exact a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\n\u03b3 : \u03b1 \u2192 Type\na : \u03b1\nf : \u03b1 \u2192 \u03b3 a\n\u22a2 \u03b3 a"}, {"line": "  apply f at a", "tactic_state": "\u03b1 : Type\n\u03b3 : \u03b1 \u2192 Type\na\u271d : \u03b1\nf : \u03b1 \u2192 \u03b3 a\u271d\na : \u03b3 a\u271d\n\u22a2 \u03b3 a\u271d"}, {"line": "  rename_i a\u2082", "tactic_state": "\u03b1 : Type\n\u03b3 : \u03b1 \u2192 Type\na\u2082 : \u03b1\nf : \u03b1 \u2192 \u03b3 a\u2082\na : \u03b3 a\u2082\n\u22a2 \u03b3 a\u2082"}, {"line": "  guard_hyp a :\u209b \u03b3 a\u2082", "tactic_state": "\u03b1 : Type\n\u03b3 : \u03b1 \u2192 Type\na\u2082 : \u03b1\nf : \u03b1 \u2192 \u03b3 a\u2082\na : \u03b3 a\u2082\n\u22a2 \u03b3 a\u2082"}, {"line": "  exact a", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (a b : \u03b1) (h : a = b) : f a = f b := by\n  apply congr_arg f at h\n  guard_hyp h :\u209b f a = f b\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\nh : a = b\n\u22a2 f a = f b"}, {"line": "  apply congr_arg f at h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\nh : f a = f b\n\u22a2 f a = f b"}, {"line": "  guard_hyp h :\u209b f a = f b", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\nh : f a = f b\n\u22a2 f a = f b"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : a + 1 = b + 1) : a = b := by\n  apply Nat.succ.inj at h\n  guard_hyp h :\u209b a = b\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a + 1 = b + 1\n\u22a2 a = b"}, {"line": "  apply Nat.succ.inj at h", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "  guard_hyp h :\u209b a = b", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example {G : Type*} [Group G] (a b c : G) (h : a * c = b * c) : a = b := by\n  apply mul_right_cancel at h\n  guard_hyp h :\u209b a = b\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na b c : G\nh : a * c = b * c\n\u22a2 a = b"}, {"line": "  apply mul_right_cancel at h", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na b c : G\nh : a = b\n\u22a2 a = b"}, {"line": "  guard_hyp h :\u209b a = b", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na b c : G\nh : a = b\n\u22a2 a = b"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example {G : Type*} [Monoid G] (a b c : G) (h : a * c = b * c)\n    (hh : \u2200 x y z : G, x * z = y * z \u2192 x = y): a = b := by\n  apply mul_right_cancel at h\n  guard_hyp h :\u209b a = b\n  \u00b7 exact h\n  \u00b7 guard_target = IsRightCancelMul G\n    constructor\n    intros a b c\n    apply hh\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na b c : G\nh : a * c = b * c\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\n\u22a2 a = b"}, {"line": "  apply mul_right_cancel at h", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na b c : G\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\nh : a = b\n\u22a2 a = b\n---\ncase inst\nG : Type u_1\ninst\u271d : Monoid G\na b c : G\nh : a * c = b * c\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\n\u22a2 IsRightCancelMul G"}, {"line": "  guard_hyp h :\u209b a = b", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na b c : G\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\nh : a = b\n\u22a2 a = b\n---\ncase inst\nG : Type u_1\ninst\u271d : Monoid G\na b c : G\nh : a * c = b * c\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\n\u22a2 IsRightCancelMul G"}, {"line": "  \u00b7 exact h", "tactic_state": ""}, {"line": "  \u00b7 guard_target = IsRightCancelMul G", "tactic_state": "case inst\nG : Type u_1\ninst\u271d : Monoid G\na b c : G\nh : a * c = b * c\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\n\u22a2 IsRightCancelMul G"}, {"line": "    constructor", "tactic_state": "case inst.mul_right_cancel\nG : Type u_1\ninst\u271d : Monoid G\na b c : G\nh : a * c = b * c\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\n\u22a2 \u2200 (a b c : G), a * b = c * b \u2192 a = c"}, {"line": "    intros a b c", "tactic_state": "case inst.mul_right_cancel\nG : Type u_1\ninst\u271d : Monoid G\na\u271d b\u271d c\u271d : G\nh : a\u271d * c\u271d = b\u271d * c\u271d\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\na b c : G\n\u22a2 a * b = c * b \u2192 a = c"}, {"line": "    apply hh", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4) (a : \u03b1) (b : \u03b2) (g : \u03b3) : \u03b4 := by\n  apply f at g\n  guard_hyp g :\u209b \u03b4\n  assumption'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b4"}, {"line": "  apply f at g", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b1\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b2"}, {"line": "  guard_hyp g :\u209b \u03b4", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b1\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b2"}, {"line": "  assumption'", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b3 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {a : \u03b1}\n    (f : {a : \u03b1} \u2192 \u03b2 a \u2192 \u03b3) (b : \u03b2 a) : \u03b3 := by\n  apply f at b\n  guard_hyp b :\u209b \u03b3\n  exact b\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_3\na : \u03b1\nf : {a : \u03b1} \u2192 \u03b2 a \u2192 \u03b3\nb : \u03b2 a\n\u22a2 \u03b3"}, {"line": "  apply f at b", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_3\na : \u03b1\nf : {a : \u03b1} \u2192 \u03b2 a \u2192 \u03b3\nb : \u03b3\n\u22a2 \u03b3"}, {"line": "  guard_hyp b :\u209b \u03b3", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_3\na : \u03b1\nf : {a : \u03b1} \u2192 \u03b2 a \u2192 \u03b3\nb : \u03b3\n\u22a2 \u03b3"}, {"line": "  exact b", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (f : {_ : \u03b1} \u2192 \u03b2 \u2192 {_ : \u03b3} \u2192 \u03b4) (g : \u03b3) (a : \u03b1) (b : \u03b2) :\n    \u03b4 := by\n  apply f at g\n  guard_hyp g :\u209b \u03b4\n  assumption'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b4"}, {"line": "  apply f at g", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b2"}, {"line": "  guard_hyp g :\u209b \u03b4", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b2"}, {"line": "  assumption'", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (f : {_ : \u03b1} \u2192 {_ : \u03b2} \u2192 (g : \u03b3) \u2192 \u03b4) (g : \u03b3) (a : \u03b1) (b : \u03b2) :\n    \u03b4 := by\n  apply f at g\n  guard_hyp g :\u209b \u03b4\n  assumption'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b4"}, {"line": "  apply f at g", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b2"}, {"line": "  guard_hyp g :\u209b \u03b4", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b2"}, {"line": "  assumption'", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2) (_g : \u03b3) : \u03b2 \u00d7 \u03b3  := by\n  apply f at _g\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\n_g : \u03b3\n\u22a2 \u03b2 \u00d7 \u03b3"}, {"line": "  apply f at _g", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\n_g : \u03b3\n\u22a2 \u03b2 \u00d7 \u03b3"}]}
{"declaration": "example {\u03b1 \u03b2 : Type*} (a : \u03b1) (_b : \u03b2) : \u03b1 \u00d7 \u03b2 := by\n  apply a at _b\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\n_b : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}, {"line": "  apply a at _b", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\n_b : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2) (g : \u03b3) (a : \u03b1) : \u03b2 \u00d7 \u03b3  := by\n  fail_if_success apply f at g\n  apply f at a\n  guard_hyp a :\u209b \u03b2\n  exact (a, g)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b3\na : \u03b1\n\u22a2 \u03b2 \u00d7 \u03b3"}, {"line": "  fail_if_success apply f at g", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b3\na : \u03b1\n\u22a2 \u03b2 \u00d7 \u03b3"}, {"line": "  apply f at a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b3\na : \u03b2\n\u22a2 \u03b2 \u00d7 \u03b3"}, {"line": "  guard_hyp a :\u209b \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b3\na : \u03b2\n\u22a2 \u03b2 \u00d7 \u03b3"}, {"line": "  exact (a, g)", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 : Type*} (a : \u03b1) (b : \u03b2) : \u03b1 \u00d7 \u03b2 := by\n  fail_if_success apply a at b\n  exact (a, b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}, {"line": "  fail_if_success apply a at b", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}, {"line": "  exact (a, b)", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 : Type*} (a : \u03b1) (b : \u03b2) : \u03b1 \u00d7 \u03b2 := by\n  fail_if_success apply a at b\n  exact (a, b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}, {"line": "  fail_if_success apply a at b", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}, {"line": "  exact (a, b)", "tactic_state": ""}]}
{"declaration": "example {A B : Prop} (h : A \u2194 B) : A \u2192 B := by\n  intro hA\n  apply h.mp at hA\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : Prop\nh : A \u2194 B\n\u22a2 A \u2192 B"}, {"line": "  intro hA", "tactic_state": "A B : Prop\nh : A \u2194 B\nhA : A\n\u22a2 B"}, {"line": "  apply h.mp at hA", "tactic_state": "A B : Prop\nh : A \u2194 B\nhA : B\n\u22a2 B"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (a : \u211d) (h3 : a + 1 = 0) : a = -1 := by\n  apply (congrArg (fun x => x - 1)) at h3\n  simp at h3\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nh3 : a + 1 = 0\n\u22a2 a = -1"}, {"line": "  apply (congrArg (fun x => x - 1)) at h3", "tactic_state": "a : \u211d\nh3\u271d : a + 1 = 0\nh3 : a + 1 - 1 = 0 - 1\n\u22a2 a = -1"}, {"line": "  simp at h3", "tactic_state": "a : \u211d\nh3\u271d : a + 1 = 0\nh3 : a = -1\n\u22a2 a = -1"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (a b : \u211d) (h : -a * b = 0) : a = 0 \u2228 b = 0 := by\n  apply (congrArg (fun x => x / 1)) at h\n  simp at h\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : -a * b = 0\n\u22a2 a = 0 \u2228 b = 0"}, {"line": "  apply (congrArg (fun x => x / 1)) at h", "tactic_state": "a b : \u211d\nh\u271d : -a * b = 0\nh : -a * b / 1 = 0 / 1\n\u22a2 a = 0 \u2228 b = 0"}, {"line": "  simp at h", "tactic_state": "a b : \u211d\nh\u271d : -a * b = 0\nh : a = 0 \u2228 b = 0\n\u22a2 a = 0 \u2228 b = 0"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (h : True) : True := by\n  have H (h : True) : h = h := rfl\n  apply H at h\n  simp at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : True\n\u22a2 True"}, {"line": "  have H (h : True) : h = h := rfl", "tactic_state": "h : True\nH : \u2200 (h : True), h = h\n\u22a2 True"}, {"line": "  apply H at h", "tactic_state": "h\u271d : True\nH : \u2200 (h : True), h = h\nh : h\u271d = h\u271d\n\u22a2 True"}, {"line": "  simp at h", "tactic_state": "h\u271d : True\nH : \u2200 (h : True), h = h\nh : True\n\u22a2 True"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (a : List Nat) (k : Nat) (hk : k < a.length) : True := by\n  have H (k : Nat) {xs ys : List Nat} (hk: k < xs.length)\n    (h : xs = ys) : xs[k] = ys[k]'(h \u25b8 hk) := h \u25b8 rfl\n  have h : a = a.map id := by simp\n  apply H k hk at h\n  simp at h\n  exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\n\u22a2 True"}, {"line": "  have H (k : Nat) {xs ys : List Nat} (hk: k < xs.length)", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\nH : \u2200 (k : \u2115) {xs ys : List \u2115} (hk : k < xs.length) (h : xs = ys), xs[k] = ys[k]\n\u22a2 True"}, {"line": "    (h : xs = ys) : xs[k] = ys[k]'(h \u25b8 hk) := h \u25b8 rfl", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\nH : \u2200 (k : \u2115) {xs ys : List \u2115} (hk : k < xs.length) (h : xs = ys), xs[k] = ys[k]\nh : a = List.map id a\n\u22a2 True"}, {"line": "  have h : a = a.map id := by simp", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\nH : \u2200 (k : \u2115) {xs ys : List \u2115} (hk : k < xs.length) (h : xs = ys), xs[k] = ys[k]\nh\u271d : a = List.map id a\nh : a[k] = (List.map id a)[k]\n\u22a2 True"}, {"line": "  apply H k hk at h", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\nH : \u2200 (k : \u2115) {xs ys : List \u2115} (hk : k < xs.length) (h : xs = ys), xs[k] = ys[k]\nh\u271d : a = List.map id a\nh : True\n\u22a2 True"}, {"line": "  simp at h", "tactic_state": ""}]}
{"declaration": "example : Foo := by\n  fconstructor\n  exact Nat\n  exact [0,1,2]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Constructor.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Foo : Sort ?u.5\n\u22a2 Foo"}, {"line": "  fconstructor", "tactic_state": "Foo : Sort ?u.5\n\u22a2 Foo"}]}
{"declaration": "example : Foo := by\n  econstructor\n  exact [0,1,2]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Constructor.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Foo : Sort ?u.5\n\u22a2 Foo"}, {"line": "  econstructor", "tactic_state": "Foo : Sort ?u.5\n\u22a2 Foo"}]}
{"declaration": "example : (let x := 1; x) = 1 := by\n  lift_lets\n  guard_target =\u209b let x := 1; x = 1\n  intro _x\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 1;\n    x) =\n    1"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let x := 1;\n  x = 1"}, {"line": "  guard_target =\u209b let x := 1; x = 1", "tactic_state": "\u22a2 let x := 1;\n  x = 1"}, {"line": "  intro _x", "tactic_state": "_x : \u2115 := 1\n\u22a2 _x = 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (let x := 1; x) = (let y := 1; y) := by\n  lift_lets\n  guard_target =\u209b let x := 1; x = x\n  intro _x\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 1;\n    x) =\n    let y := 1;\n    y"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "  guard_target =\u209b let x := 1; x = x", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "  intro _x", "tactic_state": "_x : \u2115 := 1\n\u22a2 _x = _x"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (let x := 1; x) = (let y := 1; y) := by\n  lift_lets (config := {merge := false})\n  guard_target =\u209b let x := 1; let y := 1; x = y\n  intros _x _y\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 1;\n    x) =\n    let y := 1;\n    y"}, {"line": "  lift_lets (config := {merge := false})", "tactic_state": "\u22a2 let x := 1;\n  let y := 1;\n  x = y"}, {"line": "  guard_target =\u209b let x := 1; let y := 1; x = y", "tactic_state": "\u22a2 let x := 1;\n  let y := 1;\n  x = y"}, {"line": "  intros _x _y", "tactic_state": "_x : \u2115 := 1\n_y : \u2115 := 1\n\u22a2 _x = _y"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (let x := (let y := 1; y + 1); x + 1) = 3 := by\n  lift_lets\n  guard_target =\u209b let y := 1; let x := y + 1; x + 1 = 3\n  intros _y _x\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x :=\n      let y := 1;\n      y + 1;\n    x + 1) =\n    3"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let y := 1;\n  let x := y + 1;\n  x + 1 = 3"}, {"line": "  guard_target =\u209b let y := 1; let x := y + 1; x + 1 = 3", "tactic_state": "\u22a2 let y := 1;\n  let x := y + 1;\n  x + 1 = 3"}, {"line": "  intros _y _x", "tactic_state": "_y : \u2115 := 1\n_x : \u2115 := _y + 1\n\u22a2 _x + 1 = 3"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (fun x => let a := x; let y := 1; a + y) 2 = 2 + 1 := by\n  lift_lets\n  guard_target =\u209b let y := 1; (fun x \u21a6 let a := x; a + y) 2 = 2 + 1\n  intro _y\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x =>\n        let a := x;\n        let y := 1;\n        a + y)\n      2 =\n    2 + 1"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let y := 1;\n  (fun x =>\n        let a := x;\n        a + y)\n      2 =\n    2 + 1"}, {"line": "  guard_target =\u209b let y := 1; (fun x \u21a6 let a := x; a + y) 2 = 2 + 1", "tactic_state": "\u22a2 let y := 1;\n  (fun x =>\n        let a := x;\n        a + y)\n      2 =\n    2 + 1"}, {"line": "  intro _y", "tactic_state": "_y : \u2115 := 1\n\u22a2 (fun x =>\n        let a := x;\n        a + _y)\n      2 =\n    2 + 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (fun (_ : let ty := Nat; ty) => Nat) (2 : Nat) := by\n  lift_lets\n  guard_target =\u209b let ty := Nat; (fun (_ : ty) \u21a6 Nat) (2 : Nat)\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x => \u2115) 2"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let ty := \u2115;\n  (fun x => \u2115) 2"}, {"line": "  guard_target =\u209b let ty := Nat; (fun (_ : ty) \u21a6 Nat) (2 : Nat)", "tactic_state": "\u22a2 let ty := \u2115;\n  (fun x => \u2115) 2"}, {"line": "  exact 0", "tactic_state": ""}]}
{"declaration": "example : (fun (x : let ty := Nat; ty) => Fin x) (2 : Nat) := by\n  lift_lets\n  guard_target =\u209b let ty := Nat; (fun (x : ty) \u21a6 Fin x) (2 : Nat)\n  exact 0\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x => Fin x) 2"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let ty := \u2115;\n  (fun x => Fin x) 2"}, {"line": "  guard_target =\u209b let ty := Nat; (fun (x : ty) \u21a6 Fin x) (2 : Nat)", "tactic_state": "\u22a2 let ty := \u2115;\n  (fun x => Fin x) 2"}, {"line": "  exact 0", "tactic_state": ""}]}
{"declaration": "example : (id : Nat \u2192 Nat) = (fun (x : let ty := Nat; ty) => x) := by\n  lift_lets\n  guard_target =\u209b let ty := Nat; (id: Nat \u2192 Nat) = fun (x : ty) \u21a6 x\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 id = fun x => x"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let ty := \u2115;\n  id = fun x => x"}, {"line": "  guard_target =\u209b let ty := Nat; (id: Nat \u2192 Nat) = fun (x : ty) \u21a6 x", "tactic_state": "\u22a2 let ty := \u2115;\n  id = fun x => x"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (x : let ty := Nat; ty) \u2192 let y := (1 : Nat); Fin (y + Nat.succ x) := by\n  lift_lets\n  guard_target =\u209b let ty := Nat; let y := 1; (x : ty) \u2192 Fin (y + Nat.succ x)\n  intro ty y x\n  rw [Nat.add_succ, Nat.succ_eq_add_one]\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (x :\n      let ty := \u2115;\n      ty) \u2192\n    let y := 1;\n    Fin (y + Nat.succ x)"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let ty := \u2115;\n  let y := 1;\n  (x : ty) \u2192 Fin (y + Nat.succ x)"}, {"line": "  guard_target =\u209b let ty := Nat; let y := 1; (x : ty) \u2192 Fin (y + Nat.succ x)", "tactic_state": "\u22a2 let ty := \u2115;\n  let y := 1;\n  (x : ty) \u2192 Fin (y + Nat.succ x)"}, {"line": "  intro ty y x", "tactic_state": "ty : Type := \u2115\ny : \u2115 := 1\nx : ty\n\u22a2 Fin (y + Nat.succ x)"}, {"line": "  rw [Nat.add_succ, Nat.succ_eq_add_one]", "tactic_state": "ty : Type := \u2115\ny : \u2115 := 1\nx : ty\n\u22a2 Fin (y + x + 1)"}, {"line": "  exact 0", "tactic_state": ""}]}
{"declaration": "example : (x : Nat) \u2192 (y : Nat) \u2192 let z := x + 1; let w := 3; Fin (z + w) := by\n  lift_lets\n  guard_target =\u209b let w := 3; (x : Nat) \u2192 let z := x + 1; Nat \u2192 Fin (z + w)\n  intro w x z _y\n  simp [w, z]\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (x : \u2115) \u2192\n    \u2115 \u2192\n      let z := x + 1;\n      let w := 3;\n      Fin (z + w)"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let w := 3;\n  (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192 Fin (z + w)"}, {"line": "  guard_target =\u209b let w := 3; (x : Nat) \u2192 let z := x + 1; Nat \u2192 Fin (z + w)", "tactic_state": "\u22a2 let w := 3;\n  (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192 Fin (z + w)"}, {"line": "  intro w x z _y", "tactic_state": "w : \u2115 := 3\nx : \u2115\nz : \u2115 := x + 1\n_y : \u2115\n\u22a2 Fin (z + w)"}, {"line": "  simp [w, z]", "tactic_state": "w : \u2115 := 3\nx : \u2115\nz : \u2115 := x + 1\n_y : \u2115\n\u22a2 Fin (x + 1 + 3)"}, {"line": "  exact 0", "tactic_state": ""}]}
{"declaration": "example : (x : Nat) \u2192 let z := x + 1; (y : Nat) \u2192 let w := 3; Fin (z + w) := by\n  lift_lets\n  guard_target =\u209b let w := 3; (x : Nat) \u2192 let z := x + 1; Nat \u2192 Fin (z + w)\n  intro w x z _y\n  simp [w, z]\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192\n      let w := 3;\n      Fin (z + w)"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let w := 3;\n  (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192 Fin (z + w)"}, {"line": "  guard_target =\u209b let w := 3; (x : Nat) \u2192 let z := x + 1; Nat \u2192 Fin (z + w)", "tactic_state": "\u22a2 let w := 3;\n  (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192 Fin (z + w)"}, {"line": "  intro w x z _y", "tactic_state": "w : \u2115 := 3\nx : \u2115\nz : \u2115 := x + 1\n_y : \u2115\n\u22a2 Fin (z + w)"}, {"line": "  simp [w, z]", "tactic_state": "w : \u2115 := 3\nx : \u2115\nz : \u2115 := x + 1\n_y : \u2115\n\u22a2 Fin (x + 1 + 3)"}, {"line": "  exact 0", "tactic_state": ""}]}
{"declaration": "example : (let x := 1; x) = (let x := 1; x) := by\n  lift_lets\n  guard_target =\u209b let x := 1; x = x\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 1;\n    x) =\n    let x := 1;\n    x"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "  guard_target =\u209b let x := 1; x = x", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (let x := 2; x) = (let y := 1; y + 1) := by\n  lift_lets\n  guard_target =\u209b let x := 2; let y := 1; x = y + 1\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 2;\n    x) =\n    let y := 1;\n    y + 1"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let x := 2;\n  let y := 1;\n  x = y + 1"}, {"line": "  guard_target =\u209b let x := 2; let y := 1; x = y + 1", "tactic_state": "\u22a2 let x := 2;\n  let y := 1;\n  x = y + 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (h : (let x := 1; x) = y) : True := by\n  lift_lets at h\n  guard_hyp h :\u209b let x := 1; x = y\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh :\n  (let x := 1;\n    x) =\n    y\n\u22a2 True"}, {"line": "  lift_lets at h", "tactic_state": "y : \u2115\nh :\n  let x := 1;\n  x = y\n\u22a2 True"}, {"line": "  guard_hyp h :\u209b let x := 1; x = y", "tactic_state": "y : \u2115\nh :\n  let x := 1;\n  x = y\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : (let x := 1; x) = y) : True := by\n  revert h\n  lift_lets\n  intro x h\n  guard_hyp x : Nat := 1\n  guard_hyp h :\u209b x = y\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh :\n  (let x := 1;\n    x) =\n    y\n\u22a2 True"}, {"line": "  revert h", "tactic_state": "y : \u2115\n\u22a2 (let x := 1;\n      x) =\n      y \u2192\n    True"}, {"line": "  lift_lets", "tactic_state": "y : \u2115\n\u22a2 let x := 1;\n  x = y \u2192 True"}, {"line": "  intro x h", "tactic_state": "y : \u2115\nx : \u2115 := 1\nh : x = y\n\u22a2 True"}, {"line": "  guard_hyp x : Nat := 1", "tactic_state": "y : \u2115\nx : \u2115 := 1\nh : x = y\n\u22a2 True"}, {"line": "  guard_hyp h :\u209b x = y", "tactic_state": "y : \u2115\nx : \u2115 := 1\nh : x = y\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : let x := 1; \u2200 n, let y := 1; x + n = y + n := by\n  lift_lets\n  guard_target =\u209b let x := 1; \u2200 n, x + n = x + n\n  intros x n\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 1;\n  \u2200 (n : \u2115),\n    let y := 1;\n    x + n = y + n"}, {"line": "  lift_lets", "tactic_state": "\u22a2 let x := 1;\n  \u2200 (n : \u2115), x + n = x + n"}, {"line": "  guard_target =\u209b let x := 1; \u2200 n, x + n = x + n", "tactic_state": "\u22a2 let x := 1;\n  \u2200 (n : \u2115), x + n = x + n"}, {"line": "  intros x n", "tactic_state": "x : \u2115 := 1\nn : \u2115\n\u22a2 x + n = x + n"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (m : Nat) (h : \u2203 n, n + 1 = m) (x : Fin m) (y : Fin _) :\n    cast (let h' := h.choose_spec.symm; congrArg Fin h') x = y := by\n  lift_lets (config := {proofs := true})\n  intro h'\n  clear_value h'\n  guard_hyp h' : m = Exists.choose h + 1\n  exact test_sorry", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\n\u22a2 cast \u22ef x = y"}, {"line": "  lift_lets (config := {proofs := true})", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\n\u22a2 let h' := \u22ef;\n  cast \u22ef x = y"}, {"line": "  intro h'", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\nh' : m = h.choose + 1 := Eq.symm (Exists.choose_spec h)\n\u22a2 cast \u22ef x = y"}, {"line": "  clear_value h'", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\nh' : m = h.choose + 1\n\u22a2 cast \u22ef x = y"}, {"line": "  guard_hyp h' : m = Exists.choose h + 1", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\nh' : m = h.choose + 1\n\u22a2 cast \u22ef x = y"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : orderOf (-1 : \u2124\u02e3) = 2 :=\n  orderOf_eq_prime (Int.units_sq _) (by decide)", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Equiv.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 -1 \u2260 1"}, {"line": "  orderOf_eq_prime (Int.units_sq _) (by decide)", "tactic_state": ""}]}
{"declaration": "example : x + 0 = y \u2192 x = y := by simp_intro h\u2081", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/simp_intro.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + 0 = y \u2192 x = y"}]}
{"declaration": "example : x + 0 \u2260 y \u2192 x \u2260 y := by simp_intro h\u2081 h\u2082 -- h\u2082 is bound but not needed", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/simp_intro.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + 0 \u2260 y \u2192 x \u2260 y"}]}
{"declaration": "example : x + 0 \u2260 y \u2192 x \u2260 y := by simp_intro h\u2081 h\u2082 h\u2083 -- h\u2083 is not bound\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/simp_intro.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + 0 \u2260 y \u2192 x \u2260 y"}]}
{"declaration": "example (h : x = z) : x + 0 = y \u2192 x = z := by simp_intro [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/simp_intro.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x z y : \u2115\nh : x = z\n\u22a2 x + 0 = y \u2192 x = z"}]}
{"declaration": "example (h : y = z) : x + 0 = y \u2192 x = z := by\n  simp_intro\n  guard_target = x = y \u2192 x = z\n  simp_intro .. [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/simp_intro.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y z x : \u2115\nh : y = z\n\u22a2 x + 0 = y \u2192 x = z"}, {"line": "  simp_intro", "tactic_state": "y z x : \u2115\nh : y = z\n\u22a2 x = y \u2192 x = z"}, {"line": "  guard_target = x = y \u2192 x = z", "tactic_state": "y z x : \u2115\nh : y = z\n\u22a2 x = y \u2192 x = z"}, {"line": "  simp_intro .. [h]", "tactic_state": ""}]}
{"declaration": "example (h : y = z) : x + 0 = y \u2192 x = z := by simp_intro _; exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/simp_intro.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y z x : \u2115\nh : y = z\n\u22a2 x + 0 = y \u2192 x = z"}]}
{"declaration": "example : 1 = 1 := by fail_if_no_progress rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fail_if_no_progress.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 = 1"}]}
{"declaration": "example (h : 1 = 1) : True := by\n  fail_if_no_progress simp at h\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fail_if_no_progress.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 1 = 1\n\u22a2 True"}, {"line": "  fail_if_no_progress simp at h", "tactic_state": "h : True\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : let x := 1; x = x := by\n  intro x\n  fail_if_no_progress clear_value x\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fail_if_no_progress.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "  intro x", "tactic_state": "x : \u2115 := 1\n\u22a2 x = x"}, {"line": "  fail_if_no_progress clear_value x", "tactic_state": "x : \u2115\n\u22a2 x = x"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : let x := 1; x = x := by\n  intro x\n  fail_if_no_progress\n    revert x\n    intro x\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fail_if_no_progress.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "  intro x", "tactic_state": "x : \u2115 := 1\n\u22a2 x = x"}, {"line": "  fail_if_no_progress", "tactic_state": "x : \u2115 := 1\n\u22a2 x = x"}, {"line": "    revert x", "tactic_state": ""}]}
{"declaration": "example : let x := id 0; x = x := by\n  intro x\n  fail_if_no_progress\n    -- Reduce the value of `x` to `Nat.zero`\n    run_tac do\n      let g \u2190 getMainGoal\n      let decl \u2190 g.getDecl\n      let some d := decl.lctx.findFromUserName? `x | throwError \"no x\"\n      let lctx := decl.lctx.modifyLocalDecl d.fvarId fun d =>\n        d.setValue (.const ``Nat.zero [])\n      let g' \u2190 Meta.mkFreshExprMVarAt lctx decl.localInstances decl.type\n      g.assign g'\n      replaceMainGoal [g'.mvarId!]\n    guard_hyp x : Nat :=\u209b Nat.zero\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fail_if_no_progress.lean", "context": {"open": ["Lean Elab Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := id 0;\n  x = x"}, {"line": "  intro x", "tactic_state": "x : \u2115 := id 0\n\u22a2 x = x"}, {"line": "  fail_if_no_progress", "tactic_state": "x : \u2115 := Nat.zero\n\u22a2 x = x"}, {"line": "    -- Reduce the value of `x` to `Nat.zero`", "tactic_state": ""}]}
{"declaration": "example (x : Bool) (h : x = true) : x = true := by\n  fail_if_no_progress skip\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fail_if_no_progress.lean", "context": {"open": ["Lean Elab Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Bool\nh : x = true\n\u22a2 x = true"}, {"line": "  fail_if_no_progress skip", "tactic_state": "x : Bool\nh : x = true\n\u22a2 x = true"}]}
{"declaration": "example (x : Bool) (h : x = true) : x = true := by\n  fail_if_no_progress simp (config := {failIfUnchanged := false})\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fail_if_no_progress.lean", "context": {"open": ["Lean Elab Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Bool\nh : x = true\n\u22a2 x = true"}, {"line": "  fail_if_no_progress simp (config := {failIfUnchanged := false})", "tactic_state": "x : Bool\nh : x = true\n\u22a2 x = true"}]}
{"declaration": "example (x : Bool) (h : x = true) : True := by\n  fail_if_no_progress simp (config := {failIfUnchanged := false}) at h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fail_if_no_progress.lean", "context": {"open": ["Lean Elab Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Bool\nh : x = true\n\u22a2 True"}, {"line": "  fail_if_no_progress simp (config := {failIfUnchanged := false}) at h", "tactic_state": "x : Bool\nh : x = true\n\u22a2 True"}]}
{"declaration": "example : let x := (fun x => x) Nat.zero; x = x := by\n  intro x\n  fail_if_no_progress\n    -- Reduce the value of `x` to `Nat.zero`\n    run_tac do\n      let g \u2190 getMainGoal\n      let decl \u2190 g.getDecl\n      let some d := decl.lctx.findFromUserName? `x | throwError \"no x\"\n      let lctx := decl.lctx.modifyLocalDecl d.fvarId fun d =>\n        d.setValue (.const ``Nat.zero [])\n      let g' \u2190 Meta.mkFreshExprMVarAt lctx decl.localInstances decl.type\n      g.assign g'\n      replaceMainGoal [g'.mvarId!]\n    guard_hyp x : Nat :=\u209b Nat.zero\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fail_if_no_progress.lean", "context": {"open": ["Lean Elab Tactic in", "Lean Elab Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := (fun x => x) Nat.zero;\n  x = x"}, {"line": "  intro x", "tactic_state": "x : \u2115 := (fun x => x) Nat.zero\n\u22a2 x = x"}, {"line": "  fail_if_no_progress", "tactic_state": ""}]}
{"declaration": "example : (\u03b1 \u00d7 \u03b2) \u00d7 (\u03b3 \u00d7 \u03b4) \u2243 \u03b1 \u00d7 (\u03b2 \u00d7 \u03b3) \u00d7 \u03b4 := by\n  exact (prod_assoc% : (\u03b1 \u00d7 \u03b2) \u00d7 (\u03b3 \u00d7 \u03b4) \u2243 \u03b1 \u00d7 (\u03b2 \u00d7 \u03b3) \u00d7 \u03b4)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ProdAssoc.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u22a2 (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u00d7 \u03b4 \u2243 \u03b1 \u00d7 (\u03b2 \u00d7 \u03b3) \u00d7 \u03b4"}, {"line": "  exact (prod_assoc% : (\u03b1 \u00d7 \u03b2) \u00d7 (\u03b3 \u00d7 \u03b4) \u2243 \u03b1 \u00d7 (\u03b2 \u00d7 \u03b3) \u00d7 \u03b4)", "tactic_state": ""}]}
{"declaration": "example : natDegree (- C z * X ^ 5 + (monomial 2 5) ^ 2 - 0 + 1 + IntCast.intCast 1 +\n    NatCast.natCast 1 + (z : \u2124[X]) + (n : \u2124[X]) + f) \u2264 5 := by\n  compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (-C z * X ^ 5 + (monomial 2) 5 ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n + f).natDegree \u2264 5"}, {"line": "  compute_degree!", "tactic_state": ""}]}
{"declaration": "example [Semiring R] : natDegree (OfNat.ofNat (OfNat.ofNat 0) : R[X]) \u2264 0 := by\n  compute_degree\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d : Semiring R\n\u22a2 natDegree (OfNat.ofNat (OfNat.ofNat 0)) \u2264 0"}, {"line": "  compute_degree", "tactic_state": ""}]}
{"declaration": "example : degree (- C z * X ^ 5 + (C 0 + monomial 2 5) ^ 2 - 0 + 1 + IntCast.intCast 1 +\n    NatCast.natCast 1 + (z : \u2124[X]) + (n : \u2124[X]) + f) \u2264 5 := by\n  set k := f with _h\u2080\n  compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (-C z * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n + f).degree \u2264 5"}, {"line": "  set k := f with _h\u2080", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nk : \u2124[X] := f\nhn : k.natDegree \u2264 5\nhd : k.degree \u2264 5\n_h\u2080 : k = f\n\u22a2 (-C z * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n + k).degree \u2264 5"}, {"line": "  compute_degree!", "tactic_state": ""}]}
{"declaration": "example : natDegree (- C 1 * X ^ 5 + (C 0 + monomial 2 5) ^ 2 - 0 + 1 + IntCast.intCast 1 +\n    NatCast.natCast 1 + (z : \u2124[X]) + (n : \u2124[X])) = 5 := by\n  set k := f with _h\u2080\n  compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (-C 1 * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n).natDegree = 5"}, {"line": "  set k := f with _h\u2080", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nk : \u2124[X] := f\nhn : k.natDegree \u2264 5\nhd : k.degree \u2264 5\n_h\u2080 : k = f\n\u22a2 (-C 1 * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n).natDegree = 5"}, {"line": "  compute_degree!", "tactic_state": ""}]}
{"declaration": "example : degree (- C 1 * X ^ 5 + (C 0 + monomial 2 5) ^ 2 - 0 + 1 + IntCast.intCast 1 +\n    NatCast.natCast 1 + (z : \u2124[X]) + (n : \u2124[X])) = 5 := by\n  set k := f with _h\u2080\n  compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (-C 1 * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n).degree = 5"}, {"line": "  set k := f with _h\u2080", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nk : \u2124[X] := f\nhn : k.natDegree \u2264 5\nhd : k.degree \u2264 5\n_h\u2080 : k = f\n\u22a2 (-C 1 * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n).degree = 5"}, {"line": "  compute_degree!", "tactic_state": ""}]}
{"declaration": "example : degree\n    ((C 1 * X ^ 2 + C 2 * X + C 3) * (C 0 * X ^ 0 + C 2 * X ^ 1 + C 1 * X ^ 5) ^ 4) = 22 := by\n  compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 ((C 1 * X ^ 2 + C 2 * X + C 3) * (C 0 * X ^ 0 + C 2 * X ^ 1 + C 1 * X ^ 5) ^ 4).degree = 22"}, {"line": "  compute_degree!", "tactic_state": ""}]}
{"declaration": "example [Semiring R] [Nontrivial R] {n : \u2115} : degree (X ^ n : R[X]) = n := by compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn\u271d : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nn : \u2115\n\u22a2 (X ^ n).degree = \u2191n"}]}
{"declaration": "example [Nontrivial R] [Ring R] : degree\n    (1 + X + X ^ 2 - X ^ 5 - X ^ 6 - 2 * X ^ 7 - X ^ 8 - X ^ 9 + X ^ 12 + X ^ 13 + X ^ 14 +\n        X ^ 15 + X ^ 16 + X ^ 17 - X ^ 20 - X ^ 22 - X ^ 24 - X ^ 26 - X ^ 28 + X ^ 31 + X ^ 32 +\n        X ^ 33 + X ^ 34 + X ^ 35 + X ^ 36 - X ^ 39 - X ^ 40 - 2 * X ^ 41 - X ^ 42 - X ^ 43 +\n        X ^ 46 + X ^ 47 + X ^ 48 : R[X]) = 48 := by\n  compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Ring R\n\u22a2 (1 + X + X ^ 2 - X ^ 5 - X ^ 6 - 2 * X ^ 7 - X ^ 8 - X ^ 9 + X ^ 12 + X ^ 13 + X ^ 14 + X ^ 15 + X ^ 16 + X ^ 17 -\n                                            X ^ 20 -\n                                          X ^ 22 -\n                                        X ^ 24 -\n                                      X ^ 26 -\n                                    X ^ 28 +\n                                  X ^ 31 +\n                                X ^ 32 +\n                              X ^ 33 +\n                            X ^ 34 +\n                          X ^ 35 +\n                        X ^ 36 -\n                      X ^ 39 -\n                    X ^ 40 -\n                  2 * X ^ 41 -\n                X ^ 42 -\n              X ^ 43 +\n            X ^ 46 +\n          X ^ 47 +\n        X ^ 48).degree =\n    48"}, {"line": "  compute_degree!", "tactic_state": ""}]}
{"declaration": "example [Ring R] (g : R[X]) (hg : degree g \u2264 5) : degree (- C (z : R) * X ^ 5 + (monomial 2 5) ^ 2\n    - 0 + 1 + IntCast.intCast 1 + NatCast.natCast 1 + (z : R[X]) + (n : R[X]) + g) \u2264 5 := by\n  set k := g with _h\u2080\n  compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d : Ring R\ng : R[X]\nhg : g.degree \u2264 5\n\u22a2 (-C \u2191z * X ^ 5 + (monomial 2) 5 ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n + g).degree \u2264 5"}, {"line": "  set k := g with _h\u2080", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d : Ring R\ng : R[X]\nk : R[X] := g\nhg : k.degree \u2264 5\n_h\u2080 : k = g\n\u22a2 (-C \u2191z * X ^ 5 + (monomial 2) 5 ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n + k).degree \u2264 5"}, {"line": "  compute_degree!", "tactic_state": ""}]}
{"declaration": "example {N : WithBot \u2115} (nN : n \u2264 N) : degree (- C z * X ^ n) \u2264 N := by compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\nN : WithBot \u2115\nnN : \u2191n \u2264 N\n\u22a2 (-C z * X ^ n).degree \u2264 N"}]}
{"declaration": "example [Ring R] : coeff (1 : R[X]) 0 = 1 := by compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d : Ring R\n\u22a2 coeff 1 0 = 1"}]}
{"declaration": "example [Ring R] : coeff (1 : R[X]) 2 = 0 := by compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d : Ring R\n\u22a2 coeff 1 2 = 0"}]}
{"declaration": "example [Ring R] : coeff (1 : R[X]) n = if n = 0 then 1 else 0 := by compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d : Ring R\n\u22a2 coeff 1 n = if n = 0 then 1 else 0"}]}
{"declaration": "example [Ring R] (h : (0 : R) = 6) : coeff (1 : R[X]) 1 = 6 := by compute_degree!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : \u2124[X]\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d : Ring R\nh : 0 = 6\n\u22a2 coeff 1 1 = 6"}]}
{"declaration": "example (x : Nat) (p : Prop) [Decidable p] : x = if p then x else x := by\n  split_ifs with h1\n  \u00b7 rfl\n  \u00b7 rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\np : Prop\ninst\u271d : Decidable p\n\u22a2 x = if p then x else x"}, {"line": "  split_ifs with h1", "tactic_state": "case pos\nx : \u2115\np : Prop\ninst\u271d : Decidable p\nh1 : p\n\u22a2 x = x\n---\ncase neg\nx : \u2115\np : Prop\ninst\u271d : Decidable p\nh1 : \u00acp\n\u22a2 x = x"}, {"line": "  \u00b7 rfl", "tactic_state": ""}, {"line": "  \u00b7 rfl", "tactic_state": ""}]}
{"declaration": "example (x y : Nat) (p : Prop) [Decidable p] (h : if p then x = y else y = x) : x = y := by\n  split_ifs at h\n  \u00b7 exact h\n  \u00b7 exact h.symm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\np : Prop\ninst\u271d : Decidable p\nh : if p then x = y else y = x\n\u22a2 x = y"}, {"line": "  split_ifs at h", "tactic_state": "case pos\nx y : \u2115\np : Prop\ninst\u271d : Decidable p\nh\u271d : p\nh : x = y\n\u22a2 x = y\n---\ncase neg\nx y : \u2115\np : Prop\ninst\u271d : Decidable p\nh\u271d : \u00acp\nh : y = x\n\u22a2 x = y"}, {"line": "  \u00b7 exact h", "tactic_state": ""}, {"line": "  \u00b7 exact h.symm", "tactic_state": ""}]}
{"declaration": "example (x : Nat) (p q : Prop) [Decidable p] [Decidable q] :\n    x = if p then (if q then x else x) else x := by\n  split_ifs\n  \u00b7 rfl\n  \u00b7 rfl\n  \u00b7 rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\n\u22a2 x = if p then if q then x else x else x"}, {"line": "  split_ifs", "tactic_state": "case pos\nx : \u2115\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\nh\u271d\u00b9 : p\nh\u271d : q\n\u22a2 x = x\n---\ncase neg\nx : \u2115\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\nh\u271d\u00b9 : p\nh\u271d : \u00acq\n\u22a2 x = x\n---\ncase neg\nx : \u2115\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\nh\u271d : \u00acp\n\u22a2 x = x"}, {"line": "  \u00b7 rfl", "tactic_state": ""}, {"line": "  \u00b7 rfl", "tactic_state": ""}, {"line": "  \u00b7 rfl", "tactic_state": ""}]}
{"declaration": "example (x : Nat) (p : Prop) [Decidable p] :\n    x = if (if p then False else True) then x else x := by\n  split_ifs\n  \u00b7 rfl\n  \u00b7 rfl\n  \u00b7 rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\np : Prop\ninst\u271d : Decidable p\n\u22a2 x = if if p then False else True then x else x"}, {"line": "  split_ifs", "tactic_state": "case pos\nx : \u2115\np : Prop\ninst\u271d : Decidable p\nh\u271d\u00b9 : p\nh\u271d : False\n\u22a2 x = x\n---\ncase neg\nx : \u2115\np : Prop\ninst\u271d : Decidable p\nh\u271d\u00b9 : p\nh\u271d : \u00acFalse\n\u22a2 x = x\n---\ncase neg\nx : \u2115\np : Prop\ninst\u271d : Decidable p\nh\u271d : \u00acp\n\u22a2 x = x"}, {"line": "  \u00b7 rfl", "tactic_state": ""}, {"line": "  \u00b7 rfl", "tactic_state": ""}, {"line": "  \u00b7 rfl", "tactic_state": ""}]}
{"declaration": "example (p : Prop) [Decidable p] : if if \u00acp then p else True then p else \u00acp := by\n  split_ifs with h\n  \u00b7 exact h\n  \u00b7 exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\ninst\u271d : Decidable p\n\u22a2 if if \u00acp then p else True then p else \u00acp"}, {"line": "  split_ifs with h", "tactic_state": "case pos\np : Prop\ninst\u271d : Decidable p\nh : p\n\u22a2 p\n---\ncase neg\np : Prop\ninst\u271d : Decidable p\nh : \u00acp\n\u22a2 \u00acp"}, {"line": "  \u00b7 exact h", "tactic_state": ""}, {"line": "  \u00b7 exact h", "tactic_state": ""}]}
{"declaration": "theorem foo (p q : Prop) [Decidable p] [Decidable q] :\n    if if if p then \u00acp else q then p else q then q else \u00acp \u2228 \u00acq := by\n  split_ifs with h1 h2 h3\n  \u00b7 exact h2\n  \u00b7 exact Or.inr h2\n  \u00b7 exact Or.inl h1\n  \u00b7 exact Or.inr h3", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\n\u22a2 if if if p then \u00acp else q then p else q then q else \u00acp \u2228 \u00acq"}, {"line": "  split_ifs with h1 h2 h3", "tactic_state": "case pos\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\nh1 : p\nh2 : q\n\u22a2 q\n---\ncase neg\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\nh1 : p\nh2 : \u00acq\n\u22a2 \u00acp \u2228 \u00acq\n---\ncase pos\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\nh1 : \u00acp\nh3 : q\n\u22a2 \u00acp \u2228 \u00acq\n---\ncase neg\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\nh1 : \u00acp\nh3 : \u00acq\n\u22a2 \u00acp \u2228 \u00acq"}, {"line": "  \u00b7 exact h2", "tactic_state": ""}, {"line": "  \u00b7 exact Or.inr h2", "tactic_state": ""}, {"line": "  \u00b7 exact Or.inl h1", "tactic_state": ""}, {"line": "  \u00b7 exact Or.inr h3", "tactic_state": ""}]}
{"declaration": "example (p : Prop) [Decidable p] (h : (if p then 1 else 2) > 3) : False := by\n  split_ifs at h\n  cases h\n  \u00b7 case pos.step h => cases h\n  \u00b7 case neg h =>\n    cases h\n    case step h =>\n      cases h\n      case step h => cases h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\ninst\u271d : Decidable p\nh : (if p then 1 else 2) > 3\n\u22a2 False"}, {"line": "  split_ifs at h", "tactic_state": "case pos\np : Prop\ninst\u271d : Decidable p\nh\u271d : p\nh : 1 > 3\n\u22a2 False\n---\ncase neg\np : Prop\ninst\u271d : Decidable p\nh\u271d : \u00acp\nh : 2 > 3\n\u22a2 False"}, {"line": "  cases h", "tactic_state": "case pos.step\np : Prop\ninst\u271d : Decidable p\nh\u271d : p\na\u271d : (Nat.succ 3).le 0\n\u22a2 False\n---\ncase neg\np : Prop\ninst\u271d : Decidable p\nh\u271d : \u00acp\nh : 2 > 3\n\u22a2 False"}, {"line": "  \u00b7 case pos.step h => cases h", "tactic_state": ""}, {"line": "  \u00b7 case neg h =>", "tactic_state": ""}]}
{"declaration": "example (p : Prop) [Decidable p] (x : Nat) (h : (if p then 1 else 2) > x) :\n     x < (if \u00acp then 1 else 0) + 1 := by\n   split_ifs at * <;> assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\ninst\u271d : Decidable p\nx : \u2115\nh : (if p then 1 else 2) > x\n\u22a2 x < (if \u00acp then 1 else 0) + 1"}, {"line": "   split_ifs at * <;> assumption", "tactic_state": ""}]}
{"declaration": "example (p : Prop) [Decidable p] : if if \u00acp then p else True then p else \u00acp := by\n  split_ifs <;>\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\ninst\u271d : Decidable p\n\u22a2 if if \u00acp then p else True then p else \u00acp"}, {"line": "  split_ifs <;>", "tactic_state": ""}]}
{"declaration": "example (p q : Prop) [Decidable p] [Decidable q] :\n     if if if p then \u00acp else q then p else q then q else \u00acp \u2228 \u00acq := by\n  split_ifs <;>\n  simp [*]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\n\u22a2 if if if p then \u00acp else q then p else q then q else \u00acp \u2228 \u00acq"}, {"line": "  split_ifs <;>", "tactic_state": ""}]}
{"declaration": "example : True := by\n  fail_if_success { split_ifs }\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  fail_if_success { split_ifs }", "tactic_state": "\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (P Q : Prop) (w : if P then (if Q then true else true) else true = true) : true := by\n  split_ifs at w\n  -- check that we've fully split w into three subgoals\n  \u00b7 trivial\n  \u00b7 trivial\n  \u00b7 trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": ["scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\nw : if P then if Q then true = true else true = true else true = true\n\u22a2 true = true"}, {"line": "  split_ifs at w", "tactic_state": "case pos\nP Q : Prop\nh\u271d\u00b9 : P\nh\u271d : Q\nw : true = true\n\u22a2 true = true\n---\ncase neg\nP Q : Prop\nh\u271d\u00b9 : P\nh\u271d : \u00acQ\nw : true = true\n\u22a2 true = true\n---\ncase neg\nP Q : Prop\nh\u271d : \u00acP\nw : true = true\n\u22a2 true = true"}, {"line": "  -- check that we've fully split w into three subgoals", "tactic_state": ""}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 trivial", "tactic_state": ""}]}
{"declaration": "example (u : Nat) : (if u = u then 0 else 1) = 0 := by\n  have h : u = u := by rfl\n  split_ifs\n  -- only one goal here\n  rfl\n  done", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/SplitIfs.lean", "context": {"open": ["scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : \u2115\n\u22a2 (if u = u then 0 else 1) = 0"}, {"line": "  have h : u = u := by rfl", "tactic_state": "u : \u2115\nh : u = u\n\u22a2 (if u = u then 0 else 1) = 0"}, {"line": "  split_ifs", "tactic_state": "u : \u2115\nh : u = u\n\u22a2 0 = 0"}, {"line": "  -- only one goal here", "tactic_state": ""}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (x y : \u2115) : x + y = y + x := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + y = y + x"}]}
{"declaration": "example (x y : \u2115) : x + y + y = 2 * y + x := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + y + y = 2 * y + x"}]}
{"declaration": "example (x y : \u2115) : x + id y = y + id x := by ring!", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + id y = y + id x"}]}
{"declaration": "example (x y : \u2115+) : x + y = y + x := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115+\n\u22a2 x + y = y + x"}]}
{"declaration": "example {\u03b1} [CommRing \u03b1] (x y : \u03b1) : x + y + y - x = 2 * y := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommRing \u03b1\nx y : \u03b1\n\u22a2 x + y + y - x = 2 * y"}]}
{"declaration": "example {\u03b1} [CommSemiring \u03b1] (x y : \u03b1) : (x + y)^2 = x^2 + 2 \u2022 x * y + y^2 := by ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nx y : \u03b1\n\u22a2 (x + y) ^ 2 = x ^ 2 + 2 \u2022 x * y + y ^ 2"}]}
{"declaration": "example (x y : \u2115) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y) := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)"}]}
{"declaration": "example (x y : \u2115+) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y) := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115+\n\u22a2 (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)"}]}
{"declaration": "example (x y : \u211d) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y) := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)"}]}
{"declaration": "example {\u03b1} [CommSemiring \u03b1] (x : \u03b1) : (x + 1) ^ 6 = (1 + x) ^ 6 := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nx : \u03b1\n\u22a2 (x + 1) ^ 6 = (1 + x) ^ 6"}]}
{"declaration": "example (n : \u2115) : (n / 2) + (n / 2) = 2 * (n / 2) := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n / 2 + n / 2 = 2 * (n / 2)"}]}
{"declaration": "example {\u03b1} [Field \u03b1] [CharZero \u03b1] (a : \u03b1) : a / 2 = a / 2 := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na : \u03b1\n\u22a2 a / 2 = a / 2"}]}
{"declaration": "example {\u03b1} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c : \u03b1) :\n  a * (-c / b) * (-c / b) + -c + c = a * (c / b * (c / b)) := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\n\u22a2 a * (-c / b) * (-c / b) + -c + c = a * (c / b * (c / b))"}]}
{"declaration": "example {\u03b1} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c : \u03b1) :\n  b ^ 2 - 4 * c * a = -(4 * c * a) + b ^ 2 := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\n\u22a2 b ^ 2 - 4 * c * a = -(4 * c * a) + b ^ 2"}]}
{"declaration": "example {\u03b1} [CommSemiring \u03b1] (x : \u03b1) : x ^ (2 + 2) = x^4 := by ring1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nx : \u03b1\n\u22a2 x ^ (2 + 2) = x ^ 4"}]}
{"declaration": "example {\u03b1} [CommSemiring \u03b1] (x : \u03b1) : x ^ (2 + 2) = x^4 := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nx : \u03b1\n\u22a2 x ^ (2 + 2) = x ^ 4"}]}
{"declaration": "example {\u03b1} [CommRing \u03b1] (x : \u03b1) : x ^ 2 = x * x := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommRing \u03b1\nx : \u03b1\n\u22a2 x ^ 2 = x * x"}]}
{"declaration": "example {\u03b1} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c : \u03b1) :\n  b ^ 2 - 4 * c * a = -(4 * c * a) + b ^ 2 := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\n\u22a2 b ^ 2 - 4 * c * a = -(4 * c * a) + b ^ 2"}]}
{"declaration": "example {\u03b1} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b c : \u03b1) :\n  b ^ 2 - 4 * a * c = 4 * a * 0 + b * b - 4 * a * c := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\n\u22a2 b ^ 2 - 4 * a * c = 4 * a * 0 + b * b - 4 * a * c"}]}
{"declaration": "example {\u03b1} [CommSemiring \u03b1] (x y z : \u03b1) (n : \u2115) :\n  (x + y) * (z * (y * y) + (x * x ^ n + (1 + \u2191n) * x ^ n * y)) =\n  x * (x * x ^ n) + ((2 + \u2191n) * (x * x ^ n) * y +\n    (x * z + (z * y + (1 + \u2191n) * x ^ n)) * (y * y)) := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nx y z : \u03b1\nn : \u2115\n\u22a2 (x + y) * (z * (y * y) + (x * x ^ n + (1 + \u2191n) * x ^ n * y)) =\n    x * (x * x ^ n) + ((2 + \u2191n) * (x * x ^ n) * y + (x * z + (z * y + (1 + \u2191n) * x ^ n)) * (y * y))"}]}
{"declaration": "example {\u03b1} [CommRing \u03b1] (a b c d e : \u03b1) :\n  (-(a * b) + c + d) * e = (c + (d + -a * b)) * e := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommRing \u03b1\na b c d e : \u03b1\n\u22a2 (-(a * b) + c + d) * e = (c + (d + -a * b)) * e"}]}
{"declaration": "example (a n s : \u2115) : a * (n - s) = (n - s) * a := by ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a n s : \u2115\n\u22a2 a * (n - s) = (n - s) * a"}]}
{"declaration": "example (x : \u211a) : x / 2 + x / 2 = x := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.15\ninst\u271d : Field \u03b1\nx : \u211a\n\u22a2 x / 2 + x / 2 = x"}]}
{"declaration": "example (x : \u03b1) : x / 2 = x / 2 := by ring1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Field \u03b1\nx : \u03b1\n\u22a2 x / 2 = x / 2"}]}
{"declaration": "example : (1 + 1)\u207b\u00b9 = (2\u207b\u00b9 : \u03b1) := by ring1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Field \u03b1\n\u22a2 (1 + 1)\u207b\u00b9 = 2\u207b\u00b9"}]}
{"declaration": "example (x : \u03b1) : x\u207b\u00b9 ^ 2 = (x ^ 2)\u207b\u00b9 := by ring1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Field \u03b1\nx : \u03b1\n\u22a2 x\u207b\u00b9 ^ 2 = (x ^ 2)\u207b\u00b9"}]}
{"declaration": "example (x : \u03b1) : x\u207b\u00b9 ^ 2 = (x ^ 2)\u207b\u00b9 := by ring1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Field \u03b1\nx : \u03b1\n\u22a2 x\u207b\u00b9 ^ 2 = (x ^ 2)\u207b\u00b9"}]}
{"declaration": "example (x y : \u03b1) : x * y\u207b\u00b9 = y\u207b\u00b9 * x := by ring1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Field \u03b1\nx y : \u03b1\n\u22a2 x * y\u207b\u00b9 = y\u207b\u00b9 * x"}]}
{"declaration": "example (x y : \u03b1) : (x^2 * y)\u207b\u00b9 = (y * x^2)\u207b\u00b9 := by ring1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Field \u03b1\nx y : \u03b1\n\u22a2 (x ^ 2 * y)\u207b\u00b9 = (y * x ^ 2)\u207b\u00b9"}]}
{"declaration": "example (x y : \u03b1) : (x^2)\u207b\u00b9 / y = (y * x^2)\u207b\u00b9 := by ring1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Field \u03b1\nx y : \u03b1\n\u22a2 (x ^ 2)\u207b\u00b9 / y = (y * x ^ 2)\u207b\u00b9"}]}
{"declaration": "example (x y : \u03b1) : 3 / (x - x + y)\u207b\u00b9 = 3 * (x + y\u207b\u00b9 - x)\u207b\u00b9 := by ring1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Field \u03b1\nx y : \u03b1\n\u22a2 3 / (x - x + y)\u207b\u00b9 = 3 * (x + y\u207b\u00b9 - x)\u207b\u00b9"}]}
{"declaration": "example (x : \u03b1) : x / 2 = x / 2 := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u03b1\n\u22a2 x / 2 = x / 2"}]}
{"declaration": "example (x : \u03b1) : (x : \u03b1) = x * (5/3)*(3/5) := by ring1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u03b1\n\u22a2 x = x * (5 / 3) * (3 / 5)"}]}
{"declaration": "example (A : \u2115) : (2 * A) ^ 2 = (2 * A) ^ 2 := by ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nA : \u2115\n\u22a2 (2 * A) ^ 2 = (2 * A) ^ 2"}]}
{"declaration": "example (x y : \u211a) (hx : x \u2260 0) (hy : y \u2260 0) :\n    x / (y / z) + y \u207b\u00b9 + 1 / (y * -x) = -1/ (x * y) + (x * z + 1) / y := by\n  field_simp\n  ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nz x y : \u211a\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 x / (y / z) + y\u207b\u00b9 + 1 / (y * -x) = -1 / (x * y) + (x * z + 1) / y"}, {"line": "  field_simp", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nz x y : \u211a\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 (-((x * z + 1) * (y * x)) + y) * (x * y * y) = -((-y + (x * z + 1) * (x * y)) * (y * (y * x)))"}, {"line": "  ring", "tactic_state": ""}]}
{"declaration": "example (a b c d x y : \u211a) (hx : x \u2260 0) (hy : y \u2260 0) :\n    a + b / x - c / x^2 + d / x^3 = a + x\u207b\u00b9 * (y * b / y + (d / x - c) / x) := by\n  field_simp\n  ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na b c d x y : \u211a\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 a + b / x - c / x ^ 2 + d / x ^ 3 = a + x\u207b\u00b9 * (y * b / y + (d / x - c) / x)"}, {"line": "  field_simp", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na b c d x y : \u211a\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 (((a * x + b) * x ^ 2 - x * c) * x ^ 3 + d * (x * x ^ 2)) * (x * (x * x)) =\n    (a * (x * (x * x)) + (b * (x * x) + (d - x * c))) * (x * x ^ 2 * x ^ 3)"}, {"line": "  ring", "tactic_state": ""}]}
{"declaration": "example : (876544 : \u2124) * -1 + (1000000 - 123456) = 0 := by ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\n\u22a2 876544 * -1 + (1000000 - 123456) = 0"}]}
{"declaration": "example (x : \u211d) (hx : x \u2260 0) :\n    2 * x ^ 3 * 2 / (24 * x) = x ^ 2 / 6 := by\n  field_simp\n  ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u211d\nhx : x \u2260 0\n\u22a2 2 * x ^ 3 * 2 / (24 * x) = x ^ 2 / 6"}, {"line": "  field_simp", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u211d\nhx : x \u2260 0\n\u22a2 2 * x ^ 3 * 2 * 6 = x ^ 2 * (24 * x)"}, {"line": "  ring", "tactic_state": ""}]}
{"declaration": "example (x : \u2124) (h : x - x + x = 0) : x = 0 := by\n  ring_nf at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2124\nh : x - x + x = 0\n\u22a2 x = 0"}, {"line": "  ring_nf at h", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2124\nh : x = 0\n\u22a2 x = 0"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (A B : \u2115) (H : B * A = 2) : A * B = 2 := by ring_nf at H \u22a2; exact H\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nA B : \u2115\nH : B * A = 2\n\u22a2 A * B = 2"}]}
{"declaration": "example (f : \u2115 \u2192 \u2115) :\n  2 + f (2 * f 3 * f 3) + f 3 = 1 + f (f 3 ^ 2 + f 3 * f 3) + 1 + f (2 + 1) := by ring_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nf : \u2115 \u2192 \u2115\n\u22a2 2 + f (2 * f 3 * f 3) + f 3 = 1 + f (f 3 ^ 2 + f 3 * f 3) + 1 + f (2 + 1)"}]}
{"declaration": "example (n : \u2115) (m : \u2124) : 2^(n+1) * m = 2 * 2^n * m := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nn : \u2115\nm : \u2124\n\u22a2 2 ^ (n + 1) * m = 2 * 2 ^ n * m"}]}
{"declaration": "example (a b : \u2124) (n : \u2115) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na b : \u2124\nn : \u2115\n\u22a2 (a + b) ^ (n + 2) = (a ^ 2 + b ^ 2 + a * b + b * a) * (a + b) ^ n"}]}
{"declaration": "example (x y : \u2115) : x + id y = y + id x := by ring!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx y : \u2115\n\u22a2 x + id y = y + id x"}]}
{"declaration": "example : 22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 46 := by\n  conv => ring\n  trivial -- FIXME: not needed in lean 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\n\u22a2 22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 46"}, {"line": "  conv => ring", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\n\u22a2 True"}, {"line": "  trivial -- FIXME: not needed in lean 3", "tactic_state": ""}]}
{"declaration": "example : (22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 47) = (74 = 75) := by\n  conv => ring\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\n\u22a2 (22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 47) = (74 = 75)"}, {"line": "  conv => ring", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) : 22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 := by\n  conv => ring\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2115\n\u22a2 22 + 7 * x + 3 * 8 = 0 + 7 * x + 46"}, {"line": "  conv => ring", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) : (22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 + 1)\n                    = (7 * x + 46 = 7 * x + 47) := by\n  conv => ring\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2115\n\u22a2 (22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 + 1) = (7 * x + 46 = 7 * x + 47)"}, {"line": "  conv => ring", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (a : Nat) : 1 * f a * 1 = f (a + 0) := by\n  have ha : a + 0 = a := by ring\n  rw [ha] -- goal has mdata\n  ring1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nf : x\u271d\na : \u2115\n\u22a2 1 * sorry * 1 = sorry"}, {"line": "  have ha : a + 0 = a := by ring", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nf : x\u271d\na : \u2115\nha : a + 0 = a\n\u22a2 1 * sorry * 1 = sorry"}, {"line": "  rw [ha] -- goal has mdata", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nf : x\u271d\na : \u2115\nha : a + 0 = a\n\u22a2 1 * sorry * 1 = sorry"}]}
{"declaration": "example (a b : \u2124) : a+b=0 \u2194 b+a=0 := by\n  have : 3 = 3 := rfl\n  ring_nf -- reduced to `True` with mdata\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na b : \u2124\n\u22a2 a + b = 0 \u2194 b + a = 0"}, {"line": "  have : 3 = 3 := rfl", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\na b : \u2124\nthis : 3 = 3\n\u22a2 a + b = 0 \u2194 b + a = 0"}, {"line": "  ring_nf -- reduced to `True` with mdata", "tactic_state": ""}]}
{"declaration": "example (X : \u2124) : (X^5 + 1) * (X^2^3 + X) = X^13 + X^8 + X^6 + X := by ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nX : \u2124\n\u22a2 (X ^ 5 + 1) * (X ^ 2 ^ 3 + X) = X ^ 13 + X ^ 8 + X ^ 6 + X"}]}
{"declaration": "example (p : R PUnit.{u + 1} PUnit.{v + 1}) : p + 0 = p := by\n  ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nR : x\u271d\np : sorry\n\u22a2 p + 0 = p"}, {"line": "  ring", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nR : x\u271d\np : sorry\n\u22a2 p + 0 = p"}]}
{"declaration": "example (p q : R PUnit.{u + 1} PUnit.{v + 1}) : p + q = q + p := by\n  ring\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nR : x\u271d\np : sorry\nq : sorry\n\u22a2 p + q = q + p"}, {"line": "  ring", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nR : x\u271d\np : sorry\nq : sorry\n\u22a2 p + q = q + p"}]}
{"declaration": "example (p : R PUnit.{u + 1} PUnit.{v + 1}) : p + 0 = p := by\n  ring_nf", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nR : x\u271d\np : sorry\n\u22a2 p + 0 = p"}, {"line": "  ring_nf", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nR : x\u271d\np : sorry\n\u22a2 p + 0 = p"}]}
{"declaration": "example (p q : R PUnit.{u + 1} PUnit.{v + 1}) : p + q = q + p := by\n  ring_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nR : x\u271d\np : sorry\nq : sorry\n\u22a2 p + q = q + p"}, {"line": "  ring_nf", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx\u271d : Sort u_1\nR : x\u271d\np : sorry\nq : sorry\n\u22a2 p + q = q + p"}]}
{"declaration": "example {n : \u211d} :\n    (n + 1 / 2) ^ 2 * (n + 1 + 1 / 3) = 1 / 3 + n * (19 / 12) + n ^ 2 * (7 / 3) + n ^ 3 := by\n  -- `conv_lhs` prevents `ring_nf` picking a bad normalization for both sides.\n  conv_lhs => ring_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nn : \u211d\n\u22a2 (n + 1 / 2) ^ 2 * (n + 1 + 1 / 3) = 1 / 3 + n * (19 / 12) + n ^ 2 * (7 / 3) + n ^ 3"}, {"line": "  -- `conv_lhs` prevents `ring_nf` picking a bad normalization for both sides.", "tactic_state": ""}]}
{"declaration": "example {n : \u211d} (_hn : 0 \u2264 n) : (n + 1 / 2) ^ 2 * (n + 1 + 1 / 3) \u2264 (n + 1 / 3) * (n + 1) ^ 2 := by\n  ring_nf\n  trace_state\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nn : \u211d\n_hn : 0 \u2264 n\n\u22a2 (n + 1 / 2) ^ 2 * (n + 1 + 1 / 3) \u2264 (n + 1 / 3) * (n + 1) ^ 2"}, {"line": "  ring_nf", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nn : \u211d\n_hn : 0 \u2264 n\n\u22a2 1 / 3 + n * (19 / 12) + n ^ 2 * (7 / 3) + n ^ 3 \u2264 1 / 3 + n * (5 / 3) + n ^ 2 * (7 / 3) + n ^ 3"}, {"line": "  trace_state", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nn : \u211d\n_hn : 0 \u2264 n\n\u22a2 1 / 3 + n * (19 / 12) + n ^ 2 * (7 / 3) + n ^ 3 \u2264 1 / 3 + n * (5 / 3) + n ^ 2 * (7 / 3) + n ^ 3"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (x : \u2124) (R : \u2124 \u2192 \u2124 \u2192 Prop) : True := by\n  have h : R (myId x + x) (x + myId x) := test_sorry\n  ring_nf at h\n  trace_state\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2124\nR : \u2124 \u2192 \u2124 \u2192 Prop\n\u22a2 True"}, {"line": "  have h : R (myId x + x) (x + myId x) := test_sorry", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2124\nR : \u2124 \u2192 \u2124 \u2192 Prop\nh : R (sorry + x) (x + sorry)\n\u22a2 True"}, {"line": "  ring_nf at h", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2124\nR : \u2124 \u2192 \u2124 \u2192 Prop\nh : R (sorry + x) (sorry + x)\n\u22a2 True"}, {"line": "  trace_state", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u2124\nR : \u2124 \u2192 \u2124 \u2192 Prop\nh : R (sorry + x) (sorry + x)\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (x : \u211d) (f : \u211d \u2192 \u211d) : True := by\n  let y := x\n  have : x = y := by\n    ring_nf\n    ring_nf!\n  have : x - y = 0 := by\n    ring_nf\n    ring_nf!\n  have : f x = f y := by\n    ring_nf\n    ring_nf!\n  have : f x - f y = 0 := by\n    ring_nf\n    ring_nf!\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u211d\nf : \u211d \u2192 \u211d\n\u22a2 True"}, {"line": "  let y := x", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u211d\nf : \u211d \u2192 \u211d\ny : \u211d := x\n\u22a2 True"}, {"line": "  have : x = y := by", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u211d\nf : \u211d \u2192 \u211d\ny : \u211d := x\nthis : x = y\n\u22a2 True"}, {"line": "    ring_nf", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u211d\nf : \u211d \u2192 \u211d\ny : \u211d := x\nthis\u271d : x = y\nthis : x - y = 0\n\u22a2 True"}, {"line": "    ring_nf!", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u211d\nf : \u211d \u2192 \u211d\ny : \u211d := x\nthis\u271d\u00b9 : x = y\nthis\u271d : x - y = 0\nthis : f x = f y\n\u22a2 True"}, {"line": "  have : x - y = 0 := by", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\nx : \u211d\nf : \u211d \u2192 \u211d\ny : \u211d := x\nthis\u271d\u00b2 : x = y\nthis\u271d\u00b9 : x - y = 0\nthis\u271d : f x = f y\nthis : f x - f y = 0\n\u22a2 True"}, {"line": "    ring_nf", "tactic_state": ""}]}
{"declaration": "example : (fun x : \u211d => x * x^2) = (fun y => y^2 * y) := by\n  ring_nf", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ring.lean", "context": {"open": [], "variables": ["[Field \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.136\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : CharZero \u03b1\n\u22a2 (fun x => x * x ^ 2) = fun y => y ^ 2 * y"}, {"line": "  ring_nf", "tactic_state": ""}]}
{"declaration": "example {A B : Type} (h : A) (f : A \u2192 B) : B := by\n  replace h := f h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Replace.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : Type\nh : A\nf : A \u2192 B\n\u22a2 B"}, {"line": "  replace h := f h", "tactic_state": "A B : Type\nf : A \u2192 B\nh : B\n\u22a2 B"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (z : Int) : Nat := by\n  replace z : Nat\n  exact 0\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Replace.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\n\u22a2 \u2115"}, {"line": "  replace z : Nat", "tactic_state": "case z\nz : \u2124\n\u22a2 \u2115\n---\nz : \u2115\n\u22a2 \u2115"}, {"line": "  exact 0", "tactic_state": "z : \u2115\n\u22a2 \u2115"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example : True := by\n  have : 1 + 1 = 2 := by simp +arith\n  replace : 2 + 2 = 4\n  simp +arith\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Replace.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have : 1 + 1 = 2 := by simp +arith", "tactic_state": "this : 1 + 1 = 2\n\u22a2 True"}, {"line": "  replace : 2 + 2 = 4", "tactic_state": "case this\nthis : 1 + 1 = 2\n\u22a2 2 + 2 = 4\n---\nthis : 2 + 2 = 4\n\u22a2 True"}, {"line": "  simp +arith", "tactic_state": "this : 2 + 2 = 4\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : True) : False := by\n  guard_hyp h : True\n  replace h\n  \u00b7 exact true\n  guard_hyp h : Bool\n  rename_i h'\n  guard_hyp h' : True\n  exact test_sorry", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Replace.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : True\n\u22a2 False"}, {"line": "  guard_hyp h : True", "tactic_state": "h : True\n\u22a2 False"}, {"line": "  replace h", "tactic_state": "case h\nh : True\n\u22a2 ?m.8\n---\nh\u271d : True\nh : ?m.8\n\u22a2 False"}, {"line": "  \u00b7 exact true", "tactic_state": ""}, {"line": "  guard_hyp h : Bool", "tactic_state": "h\u271d : True\nh : Bool\n\u22a2 False"}, {"line": "  rename_i h'", "tactic_state": "h' : True\nh : Bool\n\u22a2 False"}, {"line": "  guard_hyp h' : True", "tactic_state": "h' : True\nh : Bool\n\u22a2 False"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (P : Prop) (h : P) : P := by convert h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Prop\nh : P\n\u22a2 P"}]}
{"declaration": "example (\u03b1 \u03b2 : Type) (h : \u03b1 = \u03b2) (b : \u03b2) : \u03b1 := by\n  convert b\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nh : \u03b1 = \u03b2\nb : \u03b2\n\u22a2 \u03b1"}, {"line": "  convert b", "tactic_state": ""}]}
{"declaration": "example (\u03b1 \u03b2 : Type) (h : \u2200 \u03b1 \u03b2 : Type, \u03b1 = \u03b2) (b : \u03b2) : \u03b1 := by\n  convert b\n  apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nh : \u2200 (\u03b1 \u03b2 : Type), \u03b1 = \u03b2\nb : \u03b2\n\u22a2 \u03b1"}, {"line": "  convert b", "tactic_state": "\u03b1 \u03b2 : Type\nh : \u2200 (\u03b1 \u03b2 : Type), \u03b1 = \u03b2\nb : \u03b2\n\u22a2 \u03b1 = \u03b2"}, {"line": "  apply h", "tactic_state": ""}]}
{"declaration": "example (m n : Nat) (h : m = n) (b : Fin n) : Nat \u00d7 Nat \u00d7 Nat \u00d7 Fin m := by\n  convert (37, 57, 2, b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nh : m = n\nb : Fin n\n\u22a2 \u2115 \u00d7 \u2115 \u00d7 \u2115 \u00d7 Fin m"}, {"line": "  convert (37, 57, 2, b)", "tactic_state": ""}]}
{"declaration": "example (\u03b1 \u03b2 : Type) (h : \u03b1 = \u03b2) (b : \u03b2) : Nat \u00d7 \u03b1 := by\n  -- type eq ok since arguments to `Prod` are explicit\n  convert (37, b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nh : \u03b1 = \u03b2\nb : \u03b2\n\u22a2 \u2115 \u00d7 \u03b1"}, {"line": "  -- type eq ok since arguments to `Prod` are explicit", "tactic_state": ""}]}
{"declaration": "example (\u03b1 \u03b2 : Type) (h : \u03b2 = \u03b1) (b : \u03b2) : Nat \u00d7 \u03b1 := by\n  convert \u2190 (37, b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nh : \u03b2 = \u03b1\nb : \u03b2\n\u22a2 \u2115 \u00d7 \u03b1"}, {"line": "  convert \u2190 (37, b)", "tactic_state": ""}]}
{"declaration": "example (\u03b1 \u03b2 : Type) (h : \u03b1 = \u03b2) (b : \u03b2) : Nat \u00d7 Nat \u00d7 Nat \u00d7 \u03b1 := by\n  convert (37, 57, 2, b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nh : \u03b1 = \u03b2\nb : \u03b2\n\u22a2 \u2115 \u00d7 \u2115 \u00d7 \u2115 \u00d7 \u03b1"}, {"line": "  convert (37, 57, 2, b)", "tactic_state": ""}]}
{"declaration": "example (\u03b1 \u03b2 : Type) (h : \u03b1 = \u03b2) (b : \u03b2) : Nat \u00d7 Nat \u00d7 Nat \u00d7 \u03b1 := by\n  convert (37, 57, 2, b) using 2\n  guard_target = (Nat \u00d7 \u03b1) = (Nat \u00d7 \u03b2)\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nh : \u03b1 = \u03b2\nb : \u03b2\n\u22a2 \u2115 \u00d7 \u2115 \u00d7 \u2115 \u00d7 \u03b1"}, {"line": "  convert (37, 57, 2, b) using 2", "tactic_state": "case h.e'_2.h.e'_2\n\u03b1 \u03b2 : Type\nh : \u03b1 = \u03b2\nb : \u03b2\n\u22a2 (\u2115 \u00d7 \u03b1) = (\u2115 \u00d7 \u03b2)"}, {"line": "  guard_target = (Nat \u00d7 \u03b1) = (Nat \u00d7 \u03b2)", "tactic_state": "case h.e'_2.h.e'_2\n\u03b1 \u03b2 : Type\nh : \u03b1 = \u03b2\nb : \u03b2\n\u22a2 (\u2115 \u00d7 \u03b1) = (\u2115 \u00d7 \u03b2)"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "example {f : \u03b2 \u2192 \u03b1} {x y : \u03b1} (h : x \u2260 y) : f \u207b\u00b9' {x} \u2229 f \u207b\u00b9' {y} = \u2205 := by\n  have : {x} \u2229 {y} = (\u2205 : Set \u03b1) := by simpa [ne_comm] using h\n  convert Set.preimage_empty\n  rw [\u2190 Set.preimage_inter, this]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1\nx y : \u03b1\nh : x \u2260 y\n\u22a2 f \u207b\u00b9' {x} \u2229 f \u207b\u00b9' {y} = \u2205"}, {"line": "  have : {x} \u2229 {y} = (\u2205 : Set \u03b1) := by simpa [ne_comm] using h", "tactic_state": "\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1\nx y : \u03b1\nh : x \u2260 y\nthis : {x} \u2229 {y} = \u2205\n\u22a2 f \u207b\u00b9' {x} \u2229 f \u207b\u00b9' {y} = \u2205"}, {"line": "  convert Set.preimage_empty", "tactic_state": "case h.e'_2\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1\nx y : \u03b1\nh : x \u2260 y\nthis : {x} \u2229 {y} = \u2205\n\u22a2 f \u207b\u00b9' {x} \u2229 f \u207b\u00b9' {y} = ?convert_3 \u207b\u00b9' \u2205\n---\ncase convert_2\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1\nx y : \u03b1\nh : x \u2260 y\nthis : {x} \u2229 {y} = \u2205\n\u22a2 Type ?u.1522\n---\ncase convert_3\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1\nx y : \u03b1\nh : x \u2260 y\nthis : {x} \u2229 {y} = \u2205\n\u22a2 \u03b2 \u2192 ?convert_2"}, {"line": "  rw [\u2190 Set.preimage_inter, this]", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [AddCommMonoid \u03b1] {a b c d : \u03b1} (H : a = c) (H' : b = d) : a + b = d + c := by\n  convert_to c + d = _ using 2\n  rw [add_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 a + b = d + c"}, {"line": "  convert_to c + d = _ using 2", "tactic_state": "case convert_2\n\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 c + d = d + c"}, {"line": "  rw [add_comm]", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [AddCommMonoid \u03b1] {a b c d : \u03b1} (H : a = c) (H' : b = d) : a + b = d + c := by\n  convert_to c + d = _ -- defaults to `using 1`\n  congr 2\n  rw [add_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 a + b = d + c"}, {"line": "  convert_to c + d = _ -- defaults to `using 1`", "tactic_state": "case h.e'_2\n\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 a + b = c + d\n---\ncase convert_2\n\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 c + d = d + c"}, {"line": "  congr 2", "tactic_state": "case convert_2\n\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 c + d = d + c"}, {"line": "  rw [add_comm]", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [AddCommMonoid \u03b1] {a b c d : \u03b1} (H : a = c) (H' : b = d) : a + b = d + c := by\n  convert_to c + d = _ using 1\n  congr 2\n  rw [add_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 a + b = d + c"}, {"line": "  convert_to c + d = _ using 1", "tactic_state": "case h.e'_2\n\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 a + b = c + d\n---\ncase convert_2\n\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 c + d = d + c"}, {"line": "  congr 2", "tactic_state": "case convert_2\n\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\na b c d : \u03b1\nH : a = c\nH' : b = d\n\u22a2 c + d = d + c"}, {"line": "  rw [add_comm]", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) (h : prime (2 * n + 1)) :\n    prime (n + n + 1) := by\n  convert h\n  \u00b7 guard_target = (HAdd.hAdd : Nat \u2192 Nat \u2192 Nat) = HMul.hMul\n    exact test_sorry\n  \u00b7 guard_target = n = 2\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\nh : prime (2 * n + 1)\n\u22a2 prime (n + n + 1)"}, {"line": "  convert h", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\nh : prime (2 * n + 1)\n\u22a2 HAdd.hAdd = HMul.hMul\n---\ncase h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\nh : prime (2 * n + 1)\n\u22a2 n = 2"}, {"line": "  \u00b7 guard_target = (HAdd.hAdd : Nat \u2192 Nat \u2192 Nat) = HMul.hMul", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\nh : prime (2 * n + 1)\n\u22a2 HAdd.hAdd = HMul.hMul"}, {"line": "    exact test_sorry", "tactic_state": ""}, {"line": "  \u00b7 guard_target = n = 2", "tactic_state": "case h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\nh : prime (2 * n + 1)\n\u22a2 n = 2"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) (h : prime (2 * n + 1)) :\n    prime (n + n + 1) := by\n  convert (config := .unfoldSameFun) h\n  guard_target = n + n = 2 * n\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\nh : prime (2 * n + 1)\n\u22a2 prime (n + n + 1)"}, {"line": "  convert (config := .unfoldSameFun) h", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\nh : prime (2 * n + 1)\n\u22a2 n + n = 2 * n"}, {"line": "  guard_target = n + n = 2 * n", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\nh : prime (2 * n + 1)\n\u22a2 n + n = 2 * n"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (p q : Nat \u2192 Prop) (h : \u2200 \u03b5 > 0, p \u03b5) :\n    \u2200 \u03b5 > 0, q \u03b5 := by\n  convert h using 2 with \u03b5 h\u03b5\n  guard_hyp h\u03b5 : \u03b5 > 0\n  guard_target = q \u03b5 \u2194 p \u03b5\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u2115 \u2192 Prop\nh : \u2200 \u03b5 > 0, p \u03b5\n\u22a2 \u2200 \u03b5 > 0, q \u03b5"}, {"line": "  convert h using 2 with \u03b5 h\u03b5", "tactic_state": "case h.h'.a\np q : \u2115 \u2192 Prop\nh : \u2200 \u03b5 > 0, p \u03b5\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 q \u03b5 \u2194 p \u03b5"}, {"line": "  guard_hyp h\u03b5 : \u03b5 > 0", "tactic_state": "case h.h'.a\np q : \u2115 \u2192 Prop\nh : \u2200 \u03b5 > 0, p \u03b5\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 q \u03b5 \u2194 p \u03b5"}, {"line": "  guard_target = q \u03b5 \u2194 p \u03b5", "tactic_state": "case h.h'.a\np q : \u2115 \u2192 Prop\nh : \u2200 \u03b5 > 0, p \u03b5\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 q \u03b5 \u2194 p \u03b5"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : @Fintype.card Bool instFintypeBool = 2 := by\n  convert Fintype.foo _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "instFintypeBool : Fintype Bool\n\u22a2 Fintype.card Bool = 2"}, {"line": "  convert Fintype.foo _", "tactic_state": ""}]}
{"declaration": "example : @Fintype.card Bool instFintypeBool = 2 := by\n  convert Fintype.foo' _ using 1\n  guard_target = Fintype (Option Bool)\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "instFintypeBool : Fintype Bool\n\u22a2 Fintype.card Bool = 2"}, {"line": "  convert Fintype.foo' _ using 1", "tactic_state": ""}, {"line": "  guard_target = Fintype (Option Bool)", "tactic_state": ""}]}
{"declaration": "example : True := by\n  convert_to ?x + ?y = ?z\n  case x => exact 1\n  case y => exact 2\n  case z => exact 3\n  all_goals try infer_instance\n  \u00b7 simp\n  \u00b7 simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  convert_to ?x + ?y = ?z", "tactic_state": "case a\n\u22a2 True \u2194 ?x + ?y = ?z\n---\ncase x\n\u22a2 ?convert_1\n---\ncase y\n\u22a2 ?convert_2\n---\ncase z\n\u22a2 ?convert_4\n---\ncase convert_1\n\u22a2 Type ?u.9\n---\ncase convert_2\n\u22a2 Type ?u.8\n---\ncase convert_3\n\u22a2 HAdd ?convert_1 ?convert_2 ?convert_4\n---\ncase convert_4\n\u22a2 Type ?u.7\n---\ncase convert_5\n\u22a2 ?x + ?y = ?z"}, {"line": "  case x => exact 1", "tactic_state": "case a\n\u22a2 True \u2194 1 + ?y = ?z\n---\ncase y\n\u22a2 ?convert_2\n---\ncase z\n\u22a2 ?convert_4\n---\ncase convert_2\n\u22a2 Type ?u.8\n---\ncase convert_3\n\u22a2 HAdd \u2115 ?convert_2 ?convert_4\n---\ncase convert_4\n\u22a2 Type ?u.7\n---\ncase convert_5\n\u22a2 1 + ?y = ?z"}, {"line": "  case y => exact 2", "tactic_state": "case a\n\u22a2 True \u2194 1 + 2 = ?z\n---\ncase z\n\u22a2 ?convert_4\n---\ncase convert_3\n\u22a2 HAdd \u2115 \u2115 ?convert_4\n---\ncase convert_4\n\u22a2 Type ?u.7\n---\ncase convert_5\n\u22a2 1 + 2 = ?z"}, {"line": "  case z => exact 3", "tactic_state": "case a\n\u22a2 True \u2194 1 + 2 = 3\n---\ncase convert_3\n\u22a2 HAdd \u2115 \u2115 \u2115\n---\ncase convert_5\n\u22a2 1 + 2 = 3"}, {"line": "  all_goals try infer_instance", "tactic_state": "case a\n\u22a2 True \u2194 1 + 2 = 3\n---\ncase convert_5\n\u22a2 1 + 2 = 3"}, {"line": "  \u00b7 simp", "tactic_state": ""}, {"line": "  \u00b7 simp", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 : Type u} [Fintype \u03b1] [Fintype \u03b2] : Fintype.card \u03b1 = Fintype.card \u03b2 := by\n  congr!\n  guard_target = Fintype.card \u03b1 = Fintype.card \u03b2\n  congr! (config := {typeEqs := true})\n  \u00b7 guard_target = \u03b1 = \u03b2\n    exact test_sorry\n  \u00b7 rename_i inst1 inst2 h\n    guard_target = HEq inst1 inst2\n    have : Subsingleton (Fintype \u03b1) := test_sorry\n    congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\n\u22a2 Fintype.card \u03b1 = Fintype.card \u03b2"}, {"line": "  congr!", "tactic_state": "case h\n\u03b1 \u03b2 : Type u\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\n\u22a2 \u03b1 = \u03b2"}, {"line": "  guard_target = Fintype.card \u03b1 = Fintype.card \u03b2", "tactic_state": "case h\n\u03b1 \u03b2 : Type u\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\n\u22a2 \u03b1 = \u03b2"}]}
{"declaration": "example (x y z : Nat) (h : x + y = z) : y + x = z := by\n  convert_to y + x = _ at h\n  \u00b7 rw [Nat.add_comm]\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/convert.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2115\nh : x + y = z\n\u22a2 y + x = z"}, {"line": "  convert_to y + x = _ at h", "tactic_state": "case h.e'_2\nx y z : \u2115\nh : x + y = z\n\u22a2 x + y = y + x\n---\nx y z : \u2115\nh\u271d : x + y = z\nh : y + x = z\n\u22a2 y + x = z"}, {"line": "  \u00b7 rw [Nat.add_comm]", "tactic_state": ""}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115) (h : f x = f y) : x = y := by\n  apply_fun f\n  \u00b7 guard_target = f x = f y\n    assumption\n  \u00b7 guard_target = Injective f\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115\nh : f x = f y\n\u22a2 x = y"}, {"line": "  apply_fun f", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115\nh : f x = f y\n\u22a2 f x = f y\n---\ncase inj\nx y : \u2115\nf : \u2115 \u2192 \u2115\nh : f x = f y\n\u22a2 Injective f"}, {"line": "  \u00b7 guard_target = f x = f y", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115\nh : f x = f y\n\u22a2 f x = f y"}, {"line": "    assumption", "tactic_state": ""}, {"line": "  \u00b7 guard_target = Injective f", "tactic_state": "case inj\nx y : \u2115\nf : \u2115 \u2192 \u2115\nh : f x = f y\n\u22a2 Injective f"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115 \u2192 \u2115) (h : f 1 x = f 1 y) (hinj : \u2200 n, Injective (f n)) : x = y := by\n  apply_fun f ?foo\n  guard_target = f ?foo x = f ?foo y\n  case foo => exact 1\n  \u00b7 exact h\n  \u00b7 apply hinj\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : \u2200 (n : \u2115), Injective (f n)\n\u22a2 x = y"}, {"line": "  apply_fun f ?foo", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : \u2200 (n : \u2115), Injective (f n)\n\u22a2 f ?foo x = f ?foo y\n---\ncase inj\nx y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : \u2200 (n : \u2115), Injective (f n)\n\u22a2 Injective (f ?foo)\n---\ncase foo\nx y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : \u2200 (n : \u2115), Injective (f n)\n\u22a2 \u2115"}, {"line": "  guard_target = f ?foo x = f ?foo y", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : \u2200 (n : \u2115), Injective (f n)\n\u22a2 f ?foo x = f ?foo y\n---\ncase inj\nx y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : \u2200 (n : \u2115), Injective (f n)\n\u22a2 Injective (f ?foo)\n---\ncase foo\nx y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : \u2200 (n : \u2115), Injective (f n)\n\u22a2 \u2115"}, {"line": "  case foo => exact 1", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : \u2200 (n : \u2115), Injective (f n)\n\u22a2 f 1 x = f 1 y\n---\ncase inj\nx y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : \u2200 (n : \u2115), Injective (f n)\n\u22a2 Injective (f 1)"}, {"line": "  \u00b7 exact h", "tactic_state": ""}, {"line": "  \u00b7 apply hinj", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115 \u2192 \u2115) : x = y := by\n  fail_if_success apply_fun f _\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\nx y : \u03b1\u271d\nf : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 x = y"}, {"line": "  fail_if_success apply_fun f _", "tactic_state": "\u03b1\u271d : Sort u_1\nx y : \u03b1\u271d\nf : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 x = y"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115 \u2192 \u2115) (h : f 1 x = f 1 y) (hinj : Injective (f 1)) : x = y := by\n  apply_fun f _ using hinj\n  -- Solves for the hole using unification since it makes use of the `using` clause.\n  guard_target = f 1 x = f 1 y\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : Injective (f 1)\n\u22a2 x = y"}, {"line": "  apply_fun f _ using hinj", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : Injective (f 1)\n\u22a2 f 1 x = f 1 y"}, {"line": "  -- Solves for the hole using unification since it makes use of the `using` clause.", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : Injective (f 1)\n\u22a2 f 1 x = f 1 y"}, {"line": "  guard_target = f 1 x = f 1 y", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115 \u2192 \u2115) (h : f 1 x = f 1 y) (hinj : Injective (f 1)) : x = y := by\n  apply_fun f _\n  -- Solves for the hole using unification since `hinj` is pulled in by `assumption`.\n  guard_target = f 1 x = f 1 y\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : Injective (f 1)\n\u22a2 x = y"}, {"line": "  apply_fun f _", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : Injective (f 1)\n\u22a2 f 1 x = f 1 y"}, {"line": "  -- Solves for the hole using unification since `hinj` is pulled in by `assumption`.", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x = f 1 y\nhinj : Injective (f 1)\n\u22a2 f 1 x = f 1 y"}, {"line": "  guard_target = f 1 x = f 1 y", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115) (h : f x = f y) (hinj : Injective f) : x = y := by\n  apply_fun _\n  guard_target = f x = f y\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115\nh : f x = f y\nhinj : Injective f\n\u22a2 x = y"}, {"line": "  apply_fun _", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115\nh : f x = f y\nhinj : Injective f\n\u22a2 f x = f y"}, {"line": "  guard_target = f x = f y", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115\nh : f x = f y\nhinj : Injective f\n\u22a2 f x = f y"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115 \u2192 \u2115) (h : f 1 x \u2260 f 1 y) : x \u2260 y := by\n  apply_fun f ?foo\n  guard_target = f ?foo x \u2260 f ?foo y\n  case foo => exact 1\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x \u2260 f 1 y\n\u22a2 x \u2260 y"}, {"line": "  apply_fun f ?foo", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x \u2260 f 1 y\n\u22a2 f ?foo x \u2260 f ?foo y\n---\ncase foo\nx y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x \u2260 f 1 y\n\u22a2 \u2115"}, {"line": "  guard_target = f ?foo x \u2260 f ?foo y", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x \u2260 f 1 y\n\u22a2 f ?foo x \u2260 f ?foo y\n---\ncase foo\nx y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x \u2260 f 1 y\n\u22a2 \u2115"}, {"line": "  case foo => exact 1", "tactic_state": "x y : \u2115\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nh : f 1 x \u2260 f 1 y\n\u22a2 f 1 x \u2260 f 1 y"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (X Y Z : Type) (f : X \u2192 Y) (g : Y \u2192 Z) (H : Injective <| g \u2218 f) : Injective f := by\n  intros x x' h\n  apply_fun g at h\n  exact H h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type\nf : X \u2192 Y\ng : Y \u2192 Z\nH : Injective (g \u2218 f)\n\u22a2 Injective f"}, {"line": "  intros x x' h", "tactic_state": "X Y Z : Type\nf : X \u2192 Y\ng : Y \u2192 Z\nH : Injective (g \u2218 f)\nx x' : X\nh : f x = f x'\n\u22a2 x = x'"}, {"line": "  apply_fun g at h", "tactic_state": "X Y Z : Type\nf : X \u2192 Y\ng : Y \u2192 Z\nH : Injective (g \u2218 f)\nx x' : X\nh : g (f x) = g (f x')\n\u22a2 x = x'"}, {"line": "  exact H h", "tactic_state": ""}]}
{"declaration": "example (x : Int) (h : x = 1) : 1 = 1 := by\n  apply_fun (fun p => p) at h\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2124\nh : x = 1\n\u22a2 1 = 1"}, {"line": "  apply_fun (fun p => p) at h", "tactic_state": "x : \u2124\nh : x = 1\n\u22a2 1 = 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (a b : Int) (h : a = b) : a + 1 = b + 1 := by\n  -- Make sure that we infer the type of the function only after we see the hypothesis:\n  apply_fun (fun n => n + 1) at h\n  -- check that `h` was \u03b2-reduced\n  guard_hyp h :\u209b a + 1 = b + 1\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh : a = b\n\u22a2 a + 1 = b + 1"}, {"line": "  -- Make sure that we infer the type of the function only after we see the hypothesis:", "tactic_state": "a b : \u2124\nh : a + 1 = b + 1\n\u22a2 a + 1 = b + 1"}, {"line": "  apply_fun (fun n => n + 1) at h", "tactic_state": "a b : \u2124\nh : a + 1 = b + 1\n\u22a2 a + 1 = b + 1"}, {"line": "  -- check that `h` was \u03b2-reduced", "tactic_state": ""}]}
{"declaration": "example (P : Nat \u2192 Type) (Q : (n : Nat) -> P n) (a b : Nat) (h : a = b) : True := by\n  fail_if_success apply_fun Q at h\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Type\nQ : (n : \u2115) \u2192 P n\na b : \u2115\nh : a = b\n\u22a2 True"}, {"line": "  fail_if_success apply_fun Q at h", "tactic_state": "P : \u2115 \u2192 Type\nQ : (n : \u2115) \u2192 P n\na b : \u2115\nh : a = b\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115) (a b : \u2115) (monof : Monotone f) (h : a \u2264 b) : f a \u2264 f b := by\n  apply_fun f at h using monof\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115\na b : \u2115\nmonof : Monotone f\nh : a \u2264 b\n\u22a2 f a \u2264 f b"}, {"line": "  apply_fun f at h using monof", "tactic_state": "f : \u2115 \u2192 \u2115\na b : \u2115\nmonof : Monotone f\nh : f a \u2264 f b\n\u22a2 f a \u2264 f b"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115) (a b : \u2115) (monof : Monotone f) (h : a \u2264 b) : f a \u2264 f b := by\n  apply_fun f at h\n  \u00b7 assumption\n  \u00b7 assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115\na b : \u2115\nmonof : Monotone f\nh : a \u2264 b\n\u22a2 f a \u2264 f b"}, {"line": "  apply_fun f at h", "tactic_state": "f : \u2115 \u2192 \u2115\na b : \u2115\nmonof : Monotone f\nh : f a \u2264 f b\n\u22a2 f a \u2264 f b\n---\nf : \u2115 \u2192 \u2115\na b : \u2115\nmonof : Monotone f\nh : a \u2264 b\n\u22a2 Monotone f"}, {"line": "  \u00b7 assumption", "tactic_state": ""}, {"line": "  \u00b7 assumption", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (f : \u2115 \u2192 \u2115) (h : f n \u2260 f m) : n \u2260 m := by\n  apply_fun f\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nf : \u2115 \u2192 \u2115\nh : f n \u2260 f m\n\u22a2 n \u2260 m"}, {"line": "  apply_fun f", "tactic_state": "n m : \u2115\nf : \u2115 \u2192 \u2115\nh : f n \u2260 f m\n\u22a2 f n \u2260 f m"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (f : \u2115 \u2243 \u2115) (h : f n \u2260 f m) : n \u2260 m := by\n  apply_fun f\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nf : \u2115 \u2243 \u2115\nh : f n \u2260 f m\n\u22a2 n \u2260 m"}, {"line": "  apply_fun f", "tactic_state": "n m : \u2115\nf : \u2115 \u2243 \u2115\nh : f n \u2260 f m\n\u22a2 f n \u2260 f m"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (f : \u2115 \u2192 \u2115) (w : Function.Injective f) (h : f n = f m) : n = m := by\n  apply_fun f\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nf : \u2115 \u2192 \u2115\nw : Injective f\nh : f n = f m\n\u22a2 n = m"}, {"line": "  apply_fun f", "tactic_state": "n m : \u2115\nf : \u2115 \u2192 \u2115\nw : Injective f\nh : f n = f m\n\u22a2 f n = f m"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (f : \u2115 \u2192 \u2115) (w : Function.Injective f) (h : f n = f m) : n = m := by\n  apply_fun f using w\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nf : \u2115 \u2192 \u2115\nw : Injective f\nh : f n = f m\n\u22a2 n = m"}, {"line": "  apply_fun f using w", "tactic_state": "n m : \u2115\nf : \u2115 \u2192 \u2115\nw : Injective f\nh : f n = f m\n\u22a2 f n = f m"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (f : \u2115 \u2192 \u2115) (w : Function.Injective f \u2227 true) (h : f n = f m) : n = m := by\n  apply_fun f using w.1\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nf : \u2115 \u2192 \u2115\nw : Injective f \u2227 true = true\nh : f n = f m\n\u22a2 n = m"}, {"line": "  apply_fun f using w.1", "tactic_state": "n m : \u2115\nf : \u2115 \u2192 \u2115\nw : Injective f \u2227 true = true\nh : f n = f m\n\u22a2 f n = f m"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2243 \u2115) (h : f x = f y) : x = y := by\n  apply_fun f\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nf : \u2115 \u2243 \u2115\nh : f x = f y\n\u22a2 x = y"}, {"line": "  apply_fun f", "tactic_state": "x y : \u2115\nf : \u2115 \u2243 \u2115\nh : f x = f y\n\u22a2 f x = f y"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2243 \u2115) (h : f x = f y) : x = y := by\n  apply_fun f using f.injective\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nf : \u2115 \u2243 \u2115\nh : f x = f y\n\u22a2 x = y"}, {"line": "  apply_fun f using f.injective", "tactic_state": "x y : \u2115\nf : \u2115 \u2243 \u2115\nh : f x = f y\n\u22a2 f x = f y"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example {x y : \u2115} (h : Equiv.refl \u2115 x = Equiv.refl \u2115 y) : x = y := by\n  apply_fun Equiv.refl \u2115\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nh : (Equiv.refl \u2115) x = (Equiv.refl \u2115) y\n\u22a2 x = y"}, {"line": "  apply_fun Equiv.refl \u2115", "tactic_state": "x y : \u2115\nh : (Equiv.refl \u2115) x = (Equiv.refl \u2115) y\n\u22a2 (Equiv.refl \u2115) x = (Equiv.refl \u2115) y"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (a b : List \u03b1) (P : a = b) : True := by\n  apply_fun List.length at P\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : List \u03b1\nP : a = b\n\u22a2 True"}, {"line": "  apply_fun List.length at P", "tactic_state": "\u03b1 : Type u_1\na b : List \u03b1\nP : a.length = b.length\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : a \u2264 b) : a + 1 \u2264 b + 1 := by\n  apply_fun (\u00b7 + 1 : \u2115 \u2192 \u2115) at h -- TODO shouldn't need type ascription here\n  \u00b7 exact h\n  \u00b7 exact Monotone.add_const monotone_id 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a \u2264 b\n\u22a2 a + 1 \u2264 b + 1"}, {"line": "  apply_fun (\u00b7 + 1 : \u2115 \u2192 \u2115) at h -- TODO shouldn't need type ascription here", "tactic_state": "a b : \u2115\nh : (fun x => x + 1) a \u2264 (fun x => x + 1) b\n\u22a2 a + 1 \u2264 b + 1\n---\na b : \u2115\nh : a \u2264 b\n\u22a2 Monotone fun x => x + 1"}, {"line": "  \u00b7 exact h", "tactic_state": ""}, {"line": "  \u00b7 exact Monotone.add_const monotone_id 1", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : a < b) : a + 1 < b + 1 := by\n  apply_fun (\u00b7 + 1 : \u2115 \u2192 \u2115) at h\n  \u00b7 exact h\n  \u00b7 exact StrictMono.add_const strictMono_id 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a < b\n\u22a2 a + 1 < b + 1"}, {"line": "  apply_fun (\u00b7 + 1 : \u2115 \u2192 \u2115) at h", "tactic_state": "a b : \u2115\nh : (fun x => x + 1) a < (fun x => x + 1) b\n\u22a2 a + 1 < b + 1\n---\na b : \u2115\nh : a < b\n\u22a2 StrictMono fun x => x + 1"}, {"line": "  \u00b7 exact h", "tactic_state": ""}, {"line": "  \u00b7 exact StrictMono.add_const strictMono_id 1", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : a < b) : a + 1 < b + 1 := by\n  apply_fun (\u00b7 + 1 : \u2115 \u2192 \u2115) at h using StrictMono.add_const strictMono_id 1\n  \u00b7 exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a < b\n\u22a2 a + 1 < b + 1"}, {"line": "  apply_fun (\u00b7 + 1 : \u2115 \u2192 \u2115) at h using StrictMono.add_const strictMono_id 1", "tactic_state": "a b : \u2115\nh : (fun x => id x + 1) a < (fun x => id x + 1) b\n\u22a2 a + 1 < b + 1"}, {"line": "  \u00b7 exact h", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : a \u2260 b) : a + 1 \u2260 b + 1 := by\n  apply_fun (\u00b7 + 1 : \u2115 \u2192 \u2115) at h\n  \u00b7 exact h\n  \u00b7 exact add_left_injective 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a \u2260 b\n\u22a2 a + 1 \u2260 b + 1"}, {"line": "  apply_fun (\u00b7 + 1 : \u2115 \u2192 \u2115) at h", "tactic_state": "a b : \u2115\nh : a + 1 \u2260 b + 1\n\u22a2 a + 1 \u2260 b + 1\n---\na b : \u2115\nh : a \u2260 b\n\u22a2 Injective fun x => x + 1"}, {"line": "  \u00b7 exact h", "tactic_state": ""}, {"line": "  \u00b7 exact add_left_injective 1", "tactic_state": ""}]}
{"declaration": "example {n : Type} [Fintype n] {X : Type} [Semiring X]\n  (f : Matrix n n X \u2192 Matrix n n X) (A B : Matrix n n X) (h : A * B = 0) : f (A * B) = f 0 := by\n  apply_fun f at h\n  -- check that our \u03b2-reduction didn't mess things up:\n  -- (previously `apply_fun` was producing `f (A.mul B) = f 0`)\n  guard_hyp h :\u209b f (A * B) = f 0\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type\ninst\u271d\u00b9 : Fintype n\nX : Type\ninst\u271d : Semiring X\nf : Matrix n n X \u2192 Matrix n n X\nA B : Matrix n n X\nh : A * B = 0\n\u22a2 f (A * B) = f 0"}, {"line": "  apply_fun f at h", "tactic_state": "n : Type\ninst\u271d\u00b9 : Fintype n\nX : Type\ninst\u271d : Semiring X\nf : Matrix n n X \u2192 Matrix n n X\nA B : Matrix n n X\nh : f (A * B) = f 0\n\u22a2 f (A * B) = f 0"}, {"line": "  -- check that our \u03b2-reduction didn't mess things up:", "tactic_state": "n : Type\ninst\u271d\u00b9 : Fintype n\nX : Type\ninst\u271d : Semiring X\nf : Matrix n n X \u2192 Matrix n n X\nA B : Matrix n n X\nh : f (A * B) = f 0\n\u22a2 f (A * B) = f 0"}, {"line": "  -- (previously `apply_fun` was producing `f (A.mul B) = f 0`)", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (f : \u2115 \u2243 \u2115) (h : f n = f m) : n = m := by\n  apply_fun f\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nf : \u2115 \u2243 \u2115\nh : f n = f m\n\u22a2 n = m"}, {"line": "  apply_fun f", "tactic_state": "n m : \u2115\nf : \u2115 \u2243 \u2115\nh : f n = f m\n\u22a2 f n = f m"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (f : \u2115 \u2243o \u2115) (h : f n \u2264 f m) : n \u2264 m := by\n  apply_fun f\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nf : \u2115 \u2243o \u2115\nh : f n \u2264 f m\n\u22a2 n \u2264 m"}, {"line": "  apply_fun f", "tactic_state": "n m : \u2115\nf : \u2115 \u2243o \u2115\nh : f n \u2264 f m\n\u22a2 f n \u2264 f m"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) (f : \u2115 \u2243o \u2115) (h : f n < f m) : n < m := by\n  apply_fun f\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nf : \u2115 \u2243o \u2115\nh : f n < f m\n\u22a2 n < m"}, {"line": "  apply_fun f", "tactic_state": "n m : \u2115\nf : \u2115 \u2243o \u2115\nh : f n < f m\n\u22a2 f n < f m"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example : \u2200 m n : \u2115, m = n \u2192 (m < 2) = (n < 2) := by\n  refine fun m n h => ?_\n  apply_fun (\u00b7 < 2) at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (m n : \u2115), m = n \u2192 (m < 2) = (n < 2)"}, {"line": "  refine fun m n h => ?_", "tactic_state": "m n : \u2115\nh : m = n\n\u22a2 (m < 2) = (n < 2)"}, {"line": "  apply_fun (\u00b7 < 2) at h", "tactic_state": "m n : \u2115\nh : (m < 2) = (n < 2)\n\u22a2 (m < 2) = (n < 2)"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example : \u2200 m n : \u2115, m = n \u2192 (m < 2) = (n < 2) := by\n  intro m n h\n  apply_fun (\u00b7 < 2) at h\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (m n : \u2115), m = n \u2192 (m < 2) = (n < 2)"}, {"line": "  intro m n h", "tactic_state": "m n : \u2115\nh : m = n\n\u22a2 (m < 2) = (n < 2)"}, {"line": "  apply_fun (\u00b7 < 2) at h", "tactic_state": "m n : \u2115\nh : (m < 2) = (n < 2)\n\u22a2 (m < 2) = (n < 2)"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2243 \u2115) (a b : \u2115) (h : a = b) : True := by\n  apply_fun f at h\n  guard_hyp h : f a = f b\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2243 \u2115\na b : \u2115\nh : a = b\n\u22a2 True"}, {"line": "  apply_fun f at h", "tactic_state": "f : \u2115 \u2243 \u2115\na b : \u2115\nh : f a = f b\n\u22a2 True"}, {"line": "  guard_hyp h : f a = f b", "tactic_state": "f : \u2115 \u2243 \u2115\na b : \u2115\nh : f a = f b\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (f : \u2124 \u2243 \u2124) (a b : \u2115) (h : a = b) : True := by\n  apply_fun f at h\n  guard_hyp h : f a = f b\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2124 \u2243 \u2124\na b : \u2115\nh : a = b\n\u22a2 True"}, {"line": "  apply_fun f at h", "tactic_state": "f : \u2124 \u2243 \u2124\na b : \u2115\nh : f \u2191a = f \u2191b\n\u22a2 True"}, {"line": "  guard_hyp h : f a = f b", "tactic_state": "f : \u2124 \u2243 \u2124\na b : \u2115\nh : f \u2191a = f \u2191b\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (f : \u2124 \u2243 \u2124) (a b : \u03b1) (h : a = b) : True := by\n  fail_if_success apply_fun f at h\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nf : \u2124 \u2243 \u2124\na b : \u03b1\nh : a = b\n\u22a2 True"}, {"line": "  fail_if_success apply_fun f at h", "tactic_state": "\u03b1 : Sort u_1\nf : \u2124 \u2243 \u2124\na b : \u03b1\nh : a = b\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (f : \u2115 \u2192 \u2115) (a b : \u2115) (h : a = b) : True := by\n  apply_fun f at h\n  guard_hyp h : f a = f b\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115\na b : \u2115\nh : a = b\n\u22a2 True"}, {"line": "  apply_fun f at h", "tactic_state": "f : \u2115 \u2192 \u2115\na b : \u2115\nh : f a = f b\n\u22a2 True"}, {"line": "  guard_hyp h : f a = f b", "tactic_state": "f : \u2115 \u2192 \u2115\na b : \u2115\nh : f a = f b\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (f : {i : Nat} \u2192 Fin i \u2192 \u2115) (a b : Fin 37) (h : a = b) : True := by\n  apply_fun f at h\n  guard_hyp h : f a = f b\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : {i : \u2115} \u2192 Fin i \u2192 \u2115\na b : Fin 37\nh : a = b\n\u22a2 True"}, {"line": "  apply_fun f at h", "tactic_state": "f : {i : \u2115} \u2192 Fin i \u2192 \u2115\na b : Fin 37\nh : f a = f b\n\u22a2 True"}, {"line": "  guard_hyp h : f a = f b", "tactic_state": "f : {i : \u2115} \u2192 Fin i \u2192 \u2115\na b : Fin 37\nh : f a = f b\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (f : (p : Prop) \u2192 [Decidable p] \u2192 Nat) (p q : Prop) (h : p = q)\n    (h' : {n m : Nat} \u2192 n = m \u2192 True) : True := by\n  classical\n  apply_fun f at h\n  apply h'\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : (p : Prop) \u2192 [inst : Decidable p] \u2192 \u2115\np q : Prop\nh : p = q\nh' : \u2200 {n m : \u2115}, n = m \u2192 True\n\u22a2 True"}, {"line": "  classical", "tactic_state": ""}]}
{"declaration": "example (f : (p : Prop) \u2192 [Decidable p] \u2192 Nat) (p q : Prop) (h : p = q)\n    (h' : {n m : Nat} \u2192 n = m \u2192 True) : True := by\n  classical\n  apply_fun (fun x [Decidable x] => f x) at h\n  apply h'\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : (p : Prop) \u2192 [inst : Decidable p] \u2192 \u2115\np q : Prop\nh : p = q\nh' : \u2200 {n m : \u2115}, n = m \u2192 True\n\u22a2 True"}, {"line": "  classical", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : a = b) : True := by\n  apply_fun (fun i => i + ?_) at h\n  \u00b7 trivial\n  \u00b7 exact 37\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 True"}, {"line": "  apply_fun (fun i => i + ?_) at h", "tactic_state": "a b : \u2115\nh : a + ?m.23 = b + ?m.23\n\u22a2 True\n---\na b : \u2115\nh : a = b\ni : \u2115\n\u22a2 \u2115"}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 exact 37", "tactic_state": ""}]}
{"declaration": "example (\u03b1 \u03b2 : Type u) [Fintype \u03b1] [Fintype \u03b2] (h : \u03b1 = \u03b2) : True := by\n  apply_fun Fintype.card at h\n  guard_hyp h : Fintype.card \u03b1 = Fintype.card \u03b2\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nh : \u03b1 = \u03b2\n\u22a2 True"}, {"line": "  apply_fun Fintype.card at h", "tactic_state": "\u03b1 \u03b2 : Type u\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nh : Fintype.card \u03b1 = Fintype.card \u03b2\n\u22a2 True"}, {"line": "  guard_hyp h : Fintype.card \u03b1 = Fintype.card \u03b2", "tactic_state": "\u03b1 \u03b2 : Type u\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nh : Fintype.card \u03b1 = Fintype.card \u03b2\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (f : \u03b1 \u2243 \u03b2) (x y : \u03b1) (h : f x = f y) : x = y := by\n  change _\n  -- now the goal is a metavariable\n  apply_fun f\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2243 \u03b2\nx y : \u03b1\nh : f x = f y\n\u22a2 x = y"}, {"line": "  change _", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2243 \u03b2\nx y : \u03b1\nh : f x = f y\n\u22a2 x = y"}, {"line": "  -- now the goal is a metavariable", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2243 \u03b2\nx y : \u03b1\nh : f x = f y\n\u22a2 f x = f y"}, {"line": "  apply_fun f", "tactic_state": ""}]}
{"declaration": "example (f : \u03b1 \u2243 \u03b2) (x y : \u03b1) (h : f x = f y) : (fun s => s) (x = y) := by\n  apply_fun f\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2243 \u03b2\nx y : \u03b1\nh : f x = f y\n\u22a2 (fun s => s) (x = y)"}, {"line": "  apply_fun f", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2243 \u03b2\nx y : \u03b1\nh : f x = f y\n\u22a2 f x = f y"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) : x = x := by\n  apply_fun (Nat.cast : \u2115 \u2192 \u211a) using Nat.cast_injective\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 x = x"}, {"line": "  apply_fun (Nat.cast : \u2115 \u2192 \u211a) using Nat.cast_injective", "tactic_state": "x : \u2115\n\u22a2 \u2191x = \u2191x"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : 1 = 1 := by\n  let f := fun (x : Nat) => x + 1\n  -- clearly false but for demo purposes only\n  have g : \u2200 (f : \u2115 \u2192 \u2115), Function.Injective f := test_sorry\n  apply_fun f using (g f)\n  rfl\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 = 1"}, {"line": "  let f := fun (x : Nat) => x + 1", "tactic_state": "f : \u2115 \u2192 \u2115 := fun x => x + 1\n\u22a2 1 = 1"}, {"line": "  -- clearly false but for demo purposes only", "tactic_state": "f : \u2115 \u2192 \u2115 := fun x => x + 1\ng : \u2200 (f : \u2115 \u2192 \u2115), Injective f\n\u22a2 1 = 1"}, {"line": "  have g : \u2200 (f : \u2115 \u2192 \u2115), Function.Injective f := test_sorry", "tactic_state": "f : \u2115 \u2192 \u2115 := fun x => x + 1\ng : \u2200 (f : \u2115 \u2192 \u2115), Injective f\n\u22a2 f 1 = f 1"}, {"line": "  apply_fun f using (g f)", "tactic_state": ""}]}
{"declaration": "example (_h\u2081 : Function.Injective (funFamily ((List.range 128).map (fun _ => 0)).sum)) :\n    true = true := by\n  apply_fun funFamily 0", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_fun.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfunFamily : x\u271d\n_h\u2081 : Injective sorry\n\u22a2 true = true"}, {"line": "  apply_fun funFamily 0", "tactic_state": "x\u271d : Sort u_1\nfunFamily : x\u271d\n_h\u2081 : Injective sorry\n\u22a2 true = true"}]}
{"declaration": "example (n : \u2124) : 3 \u2223 n ^ 3 - n := by\n  mod_cases n % 3\n  \u00b7 guard_hyp H :\u209b n \u2261 0 [ZMOD 3]; guard_target = 3 \u2223 n ^ 3 - n; exact test_sorry\n  \u00b7 guard_hyp H :\u209b n \u2261 1 [ZMOD 3]; guard_target = 3 \u2223 n ^ 3 - n; exact test_sorry\n  \u00b7 guard_hyp H :\u209b n \u2261 2 [ZMOD 3]; guard_target = 3 \u2223 n ^ 3 - n; exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/mod_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 3 \u2223 n ^ 3 - n"}, {"line": "  mod_cases n % 3", "tactic_state": "n : \u2124\nH : n \u2261 0 [ZMOD 3]\n\u22a2 3 \u2223 n ^ 3 - n\n---\nn : \u2124\nH : n \u2261 1 [ZMOD 3]\n\u22a2 3 \u2223 n ^ 3 - n\n---\nn : \u2124\nH : n \u2261 2 [ZMOD 3]\n\u22a2 3 \u2223 n ^ 3 - n"}, {"line": "  \u00b7 guard_hyp H :\u209b n \u2261 0 [ZMOD 3]; guard_target = 3 \u2223 n ^ 3 - n; exact test_sorry", "tactic_state": "n : \u2124\nH : n \u2261 0 [ZMOD 3]\n\u22a2 3 \u2223 n ^ 3 - n"}, {"line": "  \u00b7 guard_hyp H :\u209b n \u2261 1 [ZMOD 3]; guard_target = 3 \u2223 n ^ 3 - n; exact test_sorry", "tactic_state": "n : \u2124\nH : n \u2261 0 [ZMOD 3]\n\u22a2 3 \u2223 n ^ 3 - n"}, {"line": "  \u00b7 guard_hyp H :\u209b n \u2261 2 [ZMOD 3]; guard_target = 3 \u2223 n ^ 3 - n; exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) : 3 \u2223 n ^ 3 + n := by\n  mod_cases n % 3\n  \u00b7 guard_hyp H :~ n \u2261 0 [MOD 3]; guard_target = 3 \u2223 n ^ 3 + n; exact test_sorry\n  \u00b7 guard_hyp H :~ n \u2261 1 [MOD 3]; guard_target = 3 \u2223 n ^ 3 + n; exact test_sorry\n  \u00b7 guard_hyp H :~ n \u2261 2 [MOD 3]; guard_target = 3 \u2223 n ^ 3 + n; exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/mod_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 3 \u2223 n ^ 3 + n"}, {"line": "  mod_cases n % 3", "tactic_state": "n : \u2115\nH : n \u2261 0 [MOD 3]\n\u22a2 3 \u2223 n ^ 3 + n\n---\nn : \u2115\nH : n \u2261 1 [MOD 3]\n\u22a2 3 \u2223 n ^ 3 + n\n---\nn : \u2115\nH : n \u2261 2 [MOD 3]\n\u22a2 3 \u2223 n ^ 3 + n"}, {"line": "  \u00b7 guard_hyp H :~ n \u2261 0 [MOD 3]; guard_target = 3 \u2223 n ^ 3 + n; exact test_sorry", "tactic_state": "n : \u2115\nH : n \u2261 0 [MOD 3]\n\u22a2 3 \u2223 n ^ 3 + n"}, {"line": "  \u00b7 guard_hyp H :~ n \u2261 1 [MOD 3]; guard_target = 3 \u2223 n ^ 3 + n; exact test_sorry", "tactic_state": "n : \u2115\nH : n \u2261 0 [MOD 3]\n\u22a2 3 \u2223 n ^ 3 + n"}, {"line": "  \u00b7 guard_hyp H :~ n \u2261 2 [MOD 3]; guard_target = 3 \u2223 n ^ 3 + n; exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (z : \u2124) : n = n := by\n  induction n with\n  | zero => rfl\n  | succ n _ih =>\n     mod_cases _h : z % 2\n     \u00b7 exact test_sorry\n     \u00b7 exact test_sorry", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/mod_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nz : \u2124\n\u22a2 n = n"}, {"line": "  induction n with", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]\n    {a b : \u03b1} (h : a < b) (w : b < a) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nh : a < b\nw : b < a\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} (_inst : (a : Prop) \u2192 Decidable a)\n    [CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]\n    {a b c : \u03b1}\n    (ha : a < 0)\n    (hb : \u00acb = 0)\n    (hc' : c = 0)\n    (h : (1 - a) * (b * b) \u2264 0)\n    (hc : 0 \u2264 0)\n    (w : -(a * -b * -b + b * -b + 0) = (1 - a) * (b * b))\n    (h : (1 - a) * (b * b) \u2264 0) :\n    0 < 1 - a := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\n_inst : (a : Prop) \u2192 Decidable a\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\nha : a < 0\nhb : \u00acb = 0\nhc' : c = 0\nh\u271d : (1 - a) * (b * b) \u2264 0\nhc : 0 \u2264 0\nw : -(a * -b * -b + b * -b + 0) = (1 - a) * (b * b)\nh : (1 - a) * (b * b) \u2264 0\n\u22a2 0 < 1 - a"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (e b c a v0 v1 : Rat) (h1 : v0 = 5 * a) (h2 : v1 = 3 * b) (h3 : v0 + v1 + c = 10) :\n    v0 + 5 + (v1 - 3) + (c - 2) = 10 := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "e b c a v0 v1 : \u211a\nh1 : v0 = 5 * a\nh2 : v1 = 3 * b\nh3 : v0 + v1 + c = 10\n\u22a2 v0 + 5 + (v1 - 3) + (c - 2) = 10"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]\n    (e b c a v0 v1 : \u03b1) (h1 : v0 = 5 * a) (h2 : v1 = 3 * b)\n    (h3 : v0 + v1 + c = 10) : v0 + 5 + (v1 - 3) + (c - 2) = 10 := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\ne b c a v0 v1 : \u03b1\nh1 : v0 = 5 * a\nh2 : v1 = 3 * b\nh3 : v0 + v1 + c = 10\n\u22a2 v0 + 5 + (v1 - 3) + (c - 2) = 10"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (h : (1 : \u2124) < 0) (g : \u00ac (37 : \u2124) < 42) (_k : True) (l : (-7 : \u2124) < 5): (3 : \u2124) < 7 := by\n  linarith [(rfl : 0 = 0)]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 1 < 0\ng : \u00ac37 < 42\n_k : True\nl : -7 < 5\n\u22a2 3 < 7"}, {"line": "  linarith [(rfl : 0 = 0)]", "tactic_state": ""}]}
{"declaration": "example (u v r s t : Rat) (h : 0 < u * (t * v + t * r + s)) : 0 < (t * (r + v) + s) * 3 * u := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "u v r s t : \u211a\nh : 0 < u * (t * v + t * r + s)\n\u22a2 0 < (t * (r + v) + s) * 3 * u"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (A B : Rat) (h : 0 < A * B) : 0 < 8*A*B := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : \u211a\nh : 0 < A * B\n\u22a2 0 < 8 * A * B"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (A B : Rat) (h : 0 < A * B) : 0 < A*8*B := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : \u211a\nh : 0 < A * B\n\u22a2 0 < A * 8 * B"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (x : \u03b1) : 0 \u2264 x := by\n  have h : 0 \u2264 x := test_sorry\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx : \u03b1\n\u22a2 0 \u2264 x"}, {"line": "  have h : 0 \u2264 x := test_sorry", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx : \u03b1\nh : 0 \u2264 x\n\u22a2 0 \u2264 x"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (x : \u03b1) : 0 \u2264 x := by\n  have h : 0 \u2264 x := test_sorry\n  linarith [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx : \u03b1\n\u22a2 0 \u2264 x"}, {"line": "  have h : 0 \u2264 x := test_sorry", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx : \u03b1\nh : 0 \u2264 x\n\u22a2 0 \u2264 x"}, {"line": "  linarith [h]", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]\n    (u v r s t : \u03b1) (h : 0 < u * (t * v + t * r + s)) :\n    0 < (t*(r + v) + s)*3*u := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nu v r s t : \u03b1\nh : 0 < u * (t * v + t * r + s)\n\u22a2 0 < (t * (r + v) + s) * 3 * u"}]}
{"declaration": "example {\u03b1} [CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]\n    (A B : \u03b1) (h : 0 < A * B) : 0 < 8*A*B := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nA B : \u03b1\nh : 0 < A * B\n\u22a2 0 < 8 * A * B"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (s : Set \u2115) (_h : s = \u2205) : 0 \u2264 1 := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u2115\n_h : s = \u2205\n\u22a2 0 \u2264 1"}]}
{"declaration": "example (A B : Rat) (h : 0 < A * B) : 0 < A*B/8 := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : \u211a\nh : 0 < A * B\n\u22a2 0 < A * B / 8"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (A B : Rat) (h : 0 < A * B) : 0 < A/8*B := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : \u211a\nh : 0 < A * B\n\u22a2 0 < A / 8 * B"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (\u03b5 : Rat) (h1 : \u03b5 > 0) : \u03b5 / 2 + \u03b5 / 3 + \u03b5 / 7 < \u03b5 :=\n by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b5 : \u211a\nh1 : \u03b5 > 0\n\u22a2 \u03b5 / 2 + \u03b5 / 3 + \u03b5 / 7 < \u03b5"}, {"line": " by linarith", "tactic_state": ""}]}
{"declaration": "example (x y z : Rat) (h1 : 2 * x < 3 * y) (h2 : -4 * x + z / 2 < 0)\n    (h3 : 12 * y - z < 0) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211a\nh1 : 2 * x < 3 * y\nh2 : -4 * x + z / 2 < 0\nh3 : 12 * y - z < 0\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (\u03b5 : Rat) (h1 : 0 < \u03b5) : \u03b5 / 2 < \u03b5 := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b5 : \u211a\nh1 : 0 < \u03b5\n\u22a2 \u03b5 / 2 < \u03b5"}]}
{"declaration": "example (\u03b5 : Rat) (h1 : 0 < \u03b5) : \u03b5 / 3 + \u03b5 / 3 + \u03b5 / 3 = \u03b5 := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b5 : \u211a\nh1 : 0 < \u03b5\n\u22a2 \u03b5 / 3 + \u03b5 / 3 + \u03b5 / 3 = \u03b5"}]}
{"declaration": "example (x : Rat) (h : 0 < x) : 0 < x/1 := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211a\nh : 0 < x\n\u22a2 0 < x / 1"}]}
{"declaration": "example (x : Rat) (h : x < 0) : 0 < x/(-1) := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211a\nh : x < 0\n\u22a2 0 < x / -1"}]}
{"declaration": "example (x : Rat) (h : x < 0) : 0 < x/(-2) := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211a\nh : x < 0\n\u22a2 0 < x / -2"}]}
{"declaration": "example (x : Rat) (h : x < 0) : 0 < x/(-4/5) := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211a\nh : x < 0\n\u22a2 0 < x / (-4 / 5)"}]}
{"declaration": "example (x : Rat) (h : 0 < x) : 0 < x/2/3 := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211a\nh : 0 < x\n\u22a2 0 < x / 2 / 3"}]}
{"declaration": "example (x : Rat) (h : 0 < x) : 0 < x/(2/3) := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211a\nh : 0 < x\n\u22a2 0 < x / (2 / 3)"}]}
{"declaration": "example (a : K) (ha : 10 / (8 + 2) \u2264 a) : 1 \u2264 a := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type ?u.301\na : K\nha : sorry\n\u22a2 sorry"}]}
{"declaration": "example (a : K) (ha : 10 / 10 ^ 1 \u2264 a) : 1 \u2264 a := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type ?u.301\na : K\nha : sorry\n\u22a2 sorry"}]}
{"declaration": "example (a : K) (ha : 10\u207b\u00b9 * 10 \u2264 a) : 1 \u2264 a := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type ?u.301\na : K\nha : sorry\n\u22a2 sorry"}]}
{"declaration": "example (a : K) (ha : 1.0 \u2264 a) : 1 \u2264 a := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type ?u.304\na : K\nha : sorry\n\u22a2 sorry"}]}
{"declaration": "example (a b c : Rat) (h2 : b + 2 > 3 + b) : False := by\n  linarith (config := {discharger := do Lean.Elab.Tactic.evalTactic (\u2190`(tactic| ring1))})\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\nh2 : b + 2 > 3 + b\n\u22a2 False"}, {"line": "  linarith (config := {discharger := do Lean.Elab.Tactic.evalTactic (\u2190`(tactic| ring1))})", "tactic_state": ""}]}
{"declaration": "example (a b c : Rat) (h2 : b + 2 > 3 + b) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\nh2 : b + 2 > 3 + b\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (g v V c h : Rat) (h1 : h = 0) (h2 : v = V) (h3 : V > 0) (h4 : g > 0)\n    (h5 : 0 \u2264 c) (h6 : c < 1) : v \u2264 V := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g v V c h : \u211a\nh1 : h = 0\nh2 : v = V\nh3 : V > 0\nh4 : g > 0\nh5 : 0 \u2264 c\nh6 : c < 1\n\u22a2 v \u2264 V"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y z : \u2124) (h1 : 2 * x < 3 * y) (h2 : -4 * x + 2 * z < 0) (h3 : 12 * y - 4 * z < 0) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2124\nh1 : 2 * x < 3 * y\nh2 : -4 * x + 2 * z < 0\nh3 : 12 * y - 4 * z < 0\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y z : \u2124) (h1 : 2 * x < 3 * y) (h2 : -4 * x + 2 * z < 0) (h3 : x * y < 5) (h3 : 12 * y - 4 * z < 0) :\n    False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2124\nh1 : 2 * x < 3 * y\nh2 : -4 * x + 2 * z < 0\nh3\u271d : x * y < 5\nh3 : 12 * y - 4 * z < 0\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b c : Rat) (h1 : a > 0) (h2 : b > 5) (h3 : c < -10) (h4 : a + b - c < 3) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\nh1 : a > 0\nh2 : b > 5\nh3 : c < -10\nh4 : a + b - c < 3\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b c : Rat) (h2 : b > 0) (h3 : \u00ac b \u2265 0) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\nh2 : b > 0\nh3 : \u00acb \u2265 0\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y z : Rat) (hx : x \u2264 3 * y) (h2 : y \u2264 2 * z) (h3 : x \u2265 6 * z) : x = 3*y := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211a\nhx : x \u2264 3 * y\nh2 : y \u2264 2 * z\nh3 : x \u2265 6 * z\n\u22a2 x = 3 * y"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y z : \u2124) (h1 : 2 * x < 3 * y) (h2 : -4 * x + 2 * z < 0) (h3 : x * y < 5) : \u00ac 12*y - 4* z < 0 := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2124\nh1 : 2 * x < 3 * y\nh2 : -4 * x + 2 * z < 0\nh3 : x * y < 5\n\u22a2 \u00ac12 * y - 4 * z < 0"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y z : Rat) (hx : \u00ac x > 3 * y) (h2 : \u00ac y > 2 * z) (h3 : x \u2265 6 * z) : x = 3 * y := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211a\nhx : \u00acx > 3 * y\nh2 : \u00acy > 2 * z\nh3 : x \u2265 6 * z\n\u22a2 x = 3 * y"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y : Rat) (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3) (h' : (x + 4) * x \u2265 0)\n    (h'' : (6 + 3 * y) * y \u2265 0) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211a\nh : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3\nh' : (x + 4) * x \u2265 0\nh'' : (6 + 3 * y) * y \u2265 0\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a : Rat) (ha : 0 \u2264 a) : 0 * 0 \u2264 2 * a := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211a\nha : 0 \u2264 a\n\u22a2 0 * 0 \u2264 2 * a"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y : Rat) (h : x < y) : x \u2260 y := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211a\nh : x < y\n\u22a2 x \u2260 y"}]}
{"declaration": "example (x y : Rat) (h : x < y) : \u00ac x = y := by linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211a\nh : x < y\n\u22a2 \u00acx = y"}]}
{"declaration": "example (x : Rat) : id x \u2265 x := by\n  fail_if_success\n    linarith\n  linarith!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211a\n\u22a2 id x \u2265 x"}, {"line": "  fail_if_success", "tactic_state": "x : \u211a\n\u22a2 id x \u2265 x"}, {"line": "    linarith", "tactic_state": ""}]}
{"declaration": "example (x y z : Rat) (h1 : 2 * x + ((-3) * y) < 0) (h2 : (-4) * x + 2 * z < 0) (h3 : 12 * y + (-4) * z < 0)\n    (h4 : Nat.prime 7) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211a\nh1 : 2 * x + -3 * y < 0\nh2 : -4 * x + 2 * z < 0\nh3 : 12 * y + -4 * z < 0\nh4 : sorry\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y z : Rat) (h1 : 2 * 1 * x + (3) * (y * (-1)) < 0) (h2 : (-2) * x * 2 < -(z + z))\n    (h3 : 12 * y + (-4) * z < 0) (h4 : Nat.prime 7) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211a\nh1 : 2 * 1 * x + 3 * (y * -1) < 0\nh2 : -2 * x * 2 < -(z + z)\nh3 : 12 * y + -4 * z < 0\nh4 : sorry\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (w x y z : \u2124) (h1 : 4 * x + (-3) * y + 6 * w \u2264 0) (h2 : (-1) * x < 0) (h3 : y < 0) (h4 : w \u2265 0)\n    (h5 : Nat.prime x.natAbs) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "w x y z : \u2124\nh1 : 4 * x + -3 * y + 6 * w \u2264 0\nh2 : -1 * x < 0\nh3 : y < 0\nh4 : w \u2265 0\nh5 : sorry\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x : Rat) (hx : x > 0) (h : x.num < 0) : False := by\n  linarith [Rat.num_pos.mpr hx, h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211a\nhx : x > 0\nh : x.num < 0\n\u22a2 False"}, {"line": "  linarith [Rat.num_pos.mpr hx, h]", "tactic_state": ""}]}
{"declaration": "example (x : Rat) (hx : x > 0) (h : x.num < 0) : False := by\n  fail_if_success\n    linarith\n  fail_if_success\n    linarith only [h]\n  fail_if_success\n    linarith only [Rat.num_pos.mpr hx]\n  linarith only [Rat.num_pos.mpr hx, h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211a\nhx : x > 0\nh : x.num < 0\n\u22a2 False"}, {"line": "  fail_if_success", "tactic_state": "x : \u211a\nhx : x > 0\nh : x.num < 0\n\u22a2 False"}, {"line": "    linarith", "tactic_state": "x : \u211a\nhx : x > 0\nh : x.num < 0\n\u22a2 False"}, {"line": "  fail_if_success", "tactic_state": "x : \u211a\nhx : x > 0\nh : x.num < 0\n\u22a2 False"}, {"line": "    linarith only [h]", "tactic_state": ""}]}
{"declaration": "example (i n : \u2115) (h : (2 : \u2124) ^ i \u2264 2 ^ n) : (0 : \u2124) \u2264 2 ^ n - 2 ^ i := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "i n : \u2115\nh : 2 ^ i \u2264 2 ^ n\n\u22a2 0 \u2264 2 ^ n - 2 ^ i"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b c : Rat) (h2 : b > 0) (h3 : b < 0) : Nat.prime 10 := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\nh2 : b > 0\nh3 : b < 0\n\u22a2 sorry"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b c : Rat) (h2 : (2 : Rat) > 3) : a + b - c \u2265 3 := by\n  linarith (config := {exfalso := false})\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\nh2 : 2 > 3\n\u22a2 a + b - c \u2265 3"}, {"line": "  linarith (config := {exfalso := false})", "tactic_state": ""}]}
{"declaration": "example (x y : Rat)\n    (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 \u2227 (x + 4) * x \u2265 0 \u2227 (6 + 3 * y) * y \u2265 0) :\n    False := by\n  fail_if_success\n    linarith (config := {splitHypotheses := false})\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211a\nh : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 \u2227 (x + 4) * x \u2265 0 \u2227 (6 + 3 * y) * y \u2265 0\n\u22a2 False"}, {"line": "  fail_if_success", "tactic_state": "x y : \u211a\nh : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 \u2227 (x + 4) * x \u2265 0 \u2227 (6 + 3 * y) * y \u2265 0\n\u22a2 False"}, {"line": "    linarith (config := {splitHypotheses := false})", "tactic_state": ""}]}
{"declaration": "example (h : 1 < 0) (g : \u00ac 37 < 42) (k : True) (l : (-7 : \u2124) < 5) : 3 < 7 := by\n  linarith [(rfl : 0 = 0)]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 1 < 0\ng : \u00ac37 < 42\nk : True\nl : -7 < 5\n\u22a2 3 < 7"}, {"line": "  linarith [(rfl : 0 = 0)]", "tactic_state": ""}]}
{"declaration": "example (h : 1 < 0) : 3 = 7 := by\n  linarith [Int.zero_lt_one]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 1 < 0\n\u22a2 3 = 7"}, {"line": "  linarith [Int.zero_lt_one]", "tactic_state": ""}]}
{"declaration": "example (h1 : (1 : \u2115) < 1) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "h1 : 1 < 1\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2115) : a + b \u2265 a := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 a + b \u2265 a"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b i : \u2115) (h1 : \u00ac a < i) (h2 : b < i) (h3 : a \u2264 b) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b i : \u2115\nh1 : \u00aca < i\nh2 : b < i\nh3 : a \u2264 b\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y : \u2115) (h : x < 3 * y) : True := by\n  zify at h\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\nh : x < 3 * y\n\u22a2 True"}, {"line": "  zify at h", "tactic_state": "x y : \u2115\nh : \u2191x < 3 * \u2191y\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (x y z : \u2115) (hx : x \u2264 3 * y) (h2 : y \u2264 2 * z) (h3 : x \u2265 6 * z) : x = 3 * y := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2115\nhx : x \u2264 3 * y\nh2 : y \u2264 2 * z\nh3 : x \u2265 6 * z\n\u22a2 x = 3 * y"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2115) : \u00ac a + b < a := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 \u00aca + b < a"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) (h1 : n \u2264 3) (h2 : n > 2) : n = 3 := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh1 : n \u2264 3\nh2 : n > 2\n\u22a2 n = 3"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (z : \u2115) (hz : \u00ac z \u2265 2) (h2 : \u00ac z + 1 \u2264 2) : False := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2115\nhz : \u00acz \u2265 2\nh2 : \u00acz + 1 \u2264 2\n\u22a2 False"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (z : \u2115) (hz : \u00ac z \u2265 2) : z + 1 \u2264 2 := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2115\nhz : \u00acz \u2265 2\n\u22a2 z + 1 \u2264 2"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (i : \u2124) (hi : i > 5) : 2 * i + 3 > 11 := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "i : \u2124\nhi : i > 5\n\u22a2 2 * i + 3 > 11"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (m : \u2115) : m * m + m + (2 * m + 2) = m * m + m + (m + 1) + (m + 1) := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 m * m + m + (2 * m + 2) = m * m + m + (m + 1) + (m + 1)"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (mess : \u2115 \u2192 \u2115) (S n : \u2115) :\n    mess S + (n * mess S + n * 2 + 1) < n * mess S + mess S + (n * 2 + 2) := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "mess : \u2115 \u2192 \u2115\nS n : \u2115\n\u22a2 mess S + (n * mess S + n * 2 + 1) < n * mess S + mess S + (n * 2 + 2)"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (p n p' n' : \u2115) (h : p + n' = p' + n) : n + p' = n' + p := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n p' n' : \u2115\nh : p + n' = p' + n\n\u22a2 n + p' = n' + p"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (a b c : \u211a) (h1 : 1 / a < b) (h2 : b < c) : 1 / a < c := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\nh1 : 1 / a < b\nh2 : b < c\n\u22a2 1 / a < c"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (N : \u2115) (n : \u2115) (Hirrelevant : n > N) (A : Rat) (l : Rat) (h : A - l \u2264 -(A - l))\n    (h_1 : \u00acA \u2264 -A) (h_2 : \u00acl \u2264 -l) (h_3 : -(A - l) < 1) : A < l + 1 := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N n : \u2115\nHirrelevant : n > N\nA l : \u211a\nh : A - l \u2264 -(A - l)\nh_1 : \u00acA \u2264 -A\nh_2 : \u00acl \u2264 -l\nh_3 : -(A - l) < 1\n\u22a2 A < l + 1"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (d : Rat) (q n : \u2115) (h1 : ((q : Rat) - 1) * n \u2265 0) (h2 : d = 2 / 3 * (((q : Rat) - 1) * n)) :\n    d \u2264 ((q : Rat) - 1) * n := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u211a\nq n : \u2115\nh1 : (\u2191q - 1) * \u2191n \u2265 0\nh2 : d = 2 / 3 * ((\u2191q - 1) * \u2191n)\n\u22a2 d \u2264 (\u2191q - 1) * \u2191n"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (d : Rat) (q n : \u2115) (h1 : ((q : Rat) - 1) * n \u2265 0) (h2 : d = 2 / 3 * (((q : Rat) - 1) * n)) :\n    ((q : Rat) - 1)*n - d = 1/3 * (((q : Rat) - 1) * n) := by\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u211a\nq n : \u2115\nh1 : (\u2191q - 1) * \u2191n \u2265 0\nh2 : d = 2 / 3 * ((\u2191q - 1) * \u2191n)\n\u22a2 (\u2191q - 1) * \u2191n - d = 1 / 3 * ((\u2191q - 1) * \u2191n)"}, {"line": "  linarith", "tactic_state": ""}]}
{"declaration": "example (x y z : \u211a) (hx : x < 5) (hx2 : x > 5) (hy : y < 5000000000) (hz : z > 34 * y) : false := by\n  linarith only [hx, hx2]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211a\nhx : x < 5\nhx2 : x > 5\nhy : y < 5000000000\nhz : z > 34 * y\n\u22a2 false = true"}, {"line": "  linarith only [hx, hx2]", "tactic_state": ""}]}
{"declaration": "example (x y z : \u211a) (hx : x < 5) (hy : y < 5000000000) (hz : z > 34 * y) : x \u2264 5 := by\n  linarith only [hx]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/linarith.lean", "context": {"open": ["Lean.Elab.Tactic in"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211a\nhx : x < 5\nhy : y < 5000000000\nhz : z > 34 * y\n\u22a2 x \u2264 5"}, {"line": "  linarith only [hx]", "tactic_state": ""}]}
{"declaration": "example (b : Y) : Continuous (@Prod.mk Y X b) := by continuity\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Continuity.lean", "context": {"open": ["Real"], "variables": ["[TopologicalSpace W] [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{I : Type _} {X' : I \u2192 Type _} [\u2200 i, TopologicalSpace (X' i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "W : Type ?u.156\nX : Type u_1\nY : Type u_2\nZ : Type ?u.165\ninst\u271d\u2074 : TopologicalSpace W\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\nI : Type ?u.168\nX' : I \u2192 Type ?u.173\ninst\u271d : (i : I) \u2192 TopologicalSpace (X' i)\nb : Y\n\u22a2 Continuous (Prod.mk b)"}]}
{"declaration": "example (h : 0 + 0 = 0) : True := by\n  simp at h\n  try exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 + 0 = 0\n\u22a2 True"}, {"line": "  simp at h", "tactic_state": "h : True\n\u22a2 True"}, {"line": "  try exact h", "tactic_state": ""}]}
{"declaration": "example {a b : Nat} (h : a = b) : a + 0 = b := by\n  simp\n  subst h\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + 0 = b"}, {"line": "  simp", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "  subst h", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example {a b : Nat} (h : a = b) : a + 0 = b := by\n  simp\n  by_cases a = b\n  subst h; rfl\n  subst h; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + 0 = b"}, {"line": "  simp", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "  by_cases a = b", "tactic_state": "case pos\na b : \u2115\nh h\u271d : a = b\n\u22a2 a = b\n---\ncase neg\na b : \u2115\nh : a = b\nh\u271d : \u00aca = b\n\u22a2 a = b"}, {"line": "  subst h; rfl", "tactic_state": "case pos\na : \u2115\nh\u271d : a = a\n\u22a2 a = a\n---\ncase neg\na b : \u2115\nh : a = b\nh\u271d : \u00aca = b\n\u22a2 a = b"}, {"line": "  subst h; rfl", "tactic_state": "case neg\na b : \u2115\nh : a = b\nh\u271d : \u00aca = b\n\u22a2 a = b"}]}
{"declaration": "example {a b : Nat} (h : a = b) : a + 0 = b := by\n  simp\n  induction a <;> assumption\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + 0 = b"}, {"line": "  simp", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "  induction a <;> assumption", "tactic_state": ""}]}
{"declaration": "example (h : 0 = 0 \u2228 0 = 0) : True := by\n  cases h <;>\n    rename_i h <;>\n    simp at h\n  \u00b7 exact h\n  \u00b7 assumption --exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 0 \u2228 0 = 0\n\u22a2 True"}, {"line": "  cases h <;>", "tactic_state": "case inl\nh : True\n\u22a2 True\n---\ncase inr\nh : True\n\u22a2 True"}, {"line": "    rename_i h <;>", "tactic_state": ""}, {"line": "    simp at h", "tactic_state": ""}]}
{"declaration": "example (h : 0 = 1 \u2228 0 = 1) : 0 = 1 \u2227 0 = 1 := by\n  cases h <;> simp\n  on_goal 2 => \u00b7 contradiction\n  \u00b7 contradiction\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 1 \u2228 0 = 1\n\u22a2 0 = 1 \u2227 0 = 1"}, {"line": "  cases h <;> simp", "tactic_state": "case inl\nh\u271d : 0 = 1\n\u22a2 False\n---\ncase inr\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "  on_goal 2 => \u00b7 contradiction", "tactic_state": "case inl\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "  \u00b7 contradiction", "tactic_state": ""}]}
{"declaration": "example {a : Nat} : a + 1 + 0 = 1 + a := by simp; all_goals omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a + 1 + 0 = 1 + a"}]}
{"declaration": "example (h : 0 = 1 \u2228 0 = 1) : 0 = 1 \u2227 0 = 1 := by\n  cases h <;> simp\n  \u00b7 contradiction\n  \u00b7 contradiction\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 1 \u2228 0 = 1\n\u22a2 0 = 1 \u2227 0 = 1"}, {"line": "  cases h <;> simp", "tactic_state": "case inl\nh\u271d : 0 = 1\n\u22a2 False\n---\ncase inr\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "  \u00b7 contradiction", "tactic_state": ""}, {"line": "  \u00b7 contradiction", "tactic_state": ""}]}
{"declaration": "example {h : 0 = 0} {k : 1 = 1} : True := by\n  simp at h k;\n  rw [\u2190 Classical.not_not (a := True)]\n  -- flag the two below vvv do not above ^^^\n  rw [\u2190 Classical.not_not (a := True)] at k\n  rw [\u2190 Classical.not_not (a := True)] at h\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 0\nk : 1 = 1\n\u22a2 True"}, {"line": "  simp at h k;", "tactic_state": "h k : True\n\u22a2 True"}, {"line": "  rw [\u2190 Classical.not_not (a := True)]", "tactic_state": "h k : True\n\u22a2 \u00ac\u00acTrue"}, {"line": "  -- flag the two below vvv do not above ^^^", "tactic_state": "h : True\nk : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "  rw [\u2190 Classical.not_not (a := True)] at k", "tactic_state": "h k : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "  rw [\u2190 Classical.not_not (a := True)] at h", "tactic_state": ""}]}
{"declaration": "example {a b : Nat} (h : \u2200 c, c + a + b = a + c) : (0 + 2 + 1 + a + b) = a + 3 := by\n  simp\n  specialize h 3\n  simp_all\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : \u2200 (c : \u2115), c + a + b = a + c\n\u22a2 0 + 2 + 1 + a + b = a + 3"}, {"line": "  simp", "tactic_state": "a b : \u2115\nh : \u2200 (c : \u2115), c + a + b = a + c\n\u22a2 3 + a + b = a + 3"}, {"line": "  specialize h 3", "tactic_state": "a b : \u2115\nh : 3 + a + b = a + 3\n\u22a2 3 + a + b = a + 3"}, {"line": "  simp_all", "tactic_state": ""}]}
{"declaration": "example : (0 + 2 : Rat) + 1 = 3 := by\n  simp\n  norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 + 2 + 1 = 3"}, {"line": "  simp", "tactic_state": "\u22a2 2 + 1 = 3"}, {"line": "  norm_num", "tactic_state": ""}]}
{"declaration": "example {a : Rat} : a + (0 + 2 + 1 : Rat) = 3 + a := by\n  simp\n  norm_num\n  rw [add_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211a\n\u22a2 a + (0 + 2 + 1) = 3 + a"}, {"line": "  simp", "tactic_state": "a : \u211a\n\u22a2 a + (2 + 1) = 3 + a"}, {"line": "  norm_num", "tactic_state": "a : \u211a\n\u22a2 a + 3 = 3 + a"}, {"line": "  rw [add_comm]", "tactic_state": ""}]}
{"declaration": "example {a b : Nat} (h : a = b) : a + b + 0 = b + a := by\n  simp\n  congr\n  exact h.symm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + b + 0 = b + a"}, {"line": "  simp", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + b = b + a"}, {"line": "  congr", "tactic_state": "case e_a\na b : \u2115\nh : a = b\n\u22a2 b = a"}, {"line": "  exact h.symm", "tactic_state": ""}]}
{"declaration": "example (h : False) : 0 \u2260 0 := by\n  try (simp; done)\n  exact h.elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : False\n\u22a2 0 \u2260 0"}, {"line": "  try (simp; done)", "tactic_state": "h : False\n\u22a2 0 \u2260 0"}, {"line": "  exact h.elim", "tactic_state": ""}]}
{"declaration": "example {a b : Nat} (h : a + b = a + (b + 1)) : a + b = b + a + 0 + 1 := by\n  simp\n  abel_nf\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a + b = a + (b + 1)\n\u22a2 a + b = b + a + 0 + 1"}, {"line": "  simp", "tactic_state": "a b : \u2115\nh : a + b = a + (b + 1)\n\u22a2 a + b = b + a + 1"}, {"line": "  abel_nf", "tactic_state": "a b : \u2115\nh : a + b = a + (b + 1)\n\u22a2 a + b = a + (b + 1)"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example {a b : Nat} : a + b = b + a + 0 := by\n  simp\n  abel\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a + b = b + a + 0"}, {"line": "  simp", "tactic_state": "a b : \u2115\n\u22a2 a + b = b + a"}, {"line": "  abel", "tactic_state": ""}]}
{"declaration": "example {a b : Nat} (h : a + b = 1 + a + b) : a + b = b + a + 0 + 1 := by\n  simp\n  ring_nf\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a + b = 1 + a + b\n\u22a2 a + b = b + a + 0 + 1"}, {"line": "  simp", "tactic_state": "a b : \u2115\nh : a + b = 1 + a + b\n\u22a2 a + b = b + a + 1"}, {"line": "  ring_nf", "tactic_state": "a b : \u2115\nh : a + b = 1 + a + b\n\u22a2 a + b = 1 + a + b"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example {a b : Nat} : a + b = b + a + 0 := by\n  simp\n  ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a + b = b + a + 0"}, {"line": "  simp", "tactic_state": "a b : \u2115\n\u22a2 a + b = b + a"}, {"line": "  ring", "tactic_state": ""}]}
{"declaration": "example (h : 0 = 1 \u2228 0 = 1) : 0 = 1 \u2227 0 = 1 := by\n  cases h <;> simp\n  \u00b7 simp_all\n  \u00b7 contradiction\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 1 \u2228 0 = 1\n\u22a2 0 = 1 \u2227 0 = 1"}, {"line": "  cases h <;> simp", "tactic_state": "case inl\nh\u271d : 0 = 1\n\u22a2 False\n---\ncase inr\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "  \u00b7 simp_all", "tactic_state": ""}, {"line": "  \u00b7 contradiction", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : n + 1 = 1 + n := by\n  by_cases 0 = 0\n  \u00b7 simp_all\n    omega\n  \u00b7 have : 0 \u2260 1 := by\n      intro h\n      -- should not flag `cases`!\n      cases h\n    -- should not flag `exact`!\n    exact Nat.add_comm ..\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n + 1 = 1 + n"}, {"line": "  by_cases 0 = 0", "tactic_state": "case pos\nn : \u2115\nh\u271d : 0 = 0\n\u22a2 n + 1 = 1 + n\n---\ncase neg\nn : \u2115\nh\u271d : \u00ac0 = 0\n\u22a2 n + 1 = 1 + n"}, {"line": "  \u00b7 simp_all", "tactic_state": "case pos\nn : \u2115\n\u22a2 n + 1 = 1 + n"}, {"line": "    omega", "tactic_state": ""}, {"line": "  \u00b7 have : 0 \u2260 1 := by", "tactic_state": "case neg\nn : \u2115\nh\u271d : \u00ac0 = 0\nthis : 0 \u2260 1\n\u22a2 n + 1 = 1 + n"}, {"line": "      intro h", "tactic_state": ""}]}
{"declaration": "example {h : 0 = 0} {k : 1 = 1} : \u00ac \u00ac True := by\n  simp at h\n  rw [\u2190 Nat.add_zero 1] at k\n  -- flag below vvv do not flag above ^^^\n  rw [\u2190 Classical.not_not (a := True)] at h\n  --exact h -- <-- flagged\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 0\nk : 1 = 1\n\u22a2 \u00ac\u00acTrue"}, {"line": "  simp at h", "tactic_state": "k : 1 = 1\nh : True\n\u22a2 \u00ac\u00acTrue"}, {"line": "  rw [\u2190 Nat.add_zero 1] at k", "tactic_state": "k : 1 + 0 = 1 + 0\nh : True\n\u22a2 \u00ac\u00acTrue"}, {"line": "  -- flag below vvv do not flag above ^^^", "tactic_state": "k : 1 + 0 = 1 + 0\nh : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "  rw [\u2190 Classical.not_not (a := True)] at h", "tactic_state": ""}]}
{"declaration": "example {h : 0 = 0} {k : 1 = 1} : True := by\n  simp at h k\n  rw [\u2190 Classical.not_not (a := True)]\n  -- flag the two below vvv do not above ^^^\n  rw [\u2190 Classical.not_not (a := True)] at k\n  rw [\u2190 Classical.not_not (a := True)] at h\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 0\nk : 1 = 1\n\u22a2 True"}, {"line": "  simp at h k", "tactic_state": "h k : True\n\u22a2 True"}, {"line": "  rw [\u2190 Classical.not_not (a := True)]", "tactic_state": "h k : True\n\u22a2 \u00ac\u00acTrue"}, {"line": "  -- flag the two below vvv do not above ^^^", "tactic_state": "h : True\nk : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "  rw [\u2190 Classical.not_not (a := True)] at k", "tactic_state": "h k : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "  rw [\u2190 Classical.not_not (a := True)] at h", "tactic_state": ""}]}
{"declaration": "example {h : 0 = 0} : True := by\n  simp at h\n  rw [\u2190 Classical.not_not (a := True)]\n  -- flag below vvv do not flag above ^^^\n  rw [\u2190 Classical.not_not (a := True)] at h\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 0\n\u22a2 True"}, {"line": "  simp at h", "tactic_state": "h : True\n\u22a2 True"}, {"line": "  rw [\u2190 Classical.not_not (a := True)]", "tactic_state": "h : True\n\u22a2 \u00ac\u00acTrue"}, {"line": "  -- flag below vvv do not flag above ^^^", "tactic_state": "h : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "  rw [\u2190 Classical.not_not (a := True)] at h", "tactic_state": ""}]}
{"declaration": "example {h : False} : 0 = 1 := by\n  simp\n  rw [\u2190 Classical.not_not (a := False)] at h\n  -- flag below vvv do not flag above ^^^\n  rwa [\u2190 Classical.not_not (a := False)]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : False\n\u22a2 0 = 1"}, {"line": "  simp", "tactic_state": "h : False\n\u22a2 False"}, {"line": "  rw [\u2190 Classical.not_not (a := False)] at h", "tactic_state": "h : \u00ac\u00acFalse\n\u22a2 False"}, {"line": "  -- flag below vvv do not flag above ^^^", "tactic_state": ""}]}
{"declaration": "example {h : False} : 0 = 1 \u2227 0 = 1 := by\n  constructor\n  \u00b7 simpa\n  . simp\n    rw [\u2190 Classical.not_not (a := False)] at h\n    rwa [\u2190 Classical.not_not (a := False)]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : False\n\u22a2 0 = 1 \u2227 0 = 1"}, {"line": "  constructor", "tactic_state": "case left\nh : False\n\u22a2 0 = 1\n---\ncase right\nh : False\n\u22a2 0 = 1"}, {"line": "  \u00b7 simpa", "tactic_state": ""}, {"line": "  . simp", "tactic_state": "case right\nh : False\n\u22a2 False"}, {"line": "    rw [\u2190 Classical.not_not (a := False)] at h", "tactic_state": "case right\nh : \u00ac\u00acFalse\n\u22a2 False"}, {"line": "    rwa [\u2190 Classical.not_not (a := False)]", "tactic_state": ""}]}
{"declaration": "example : p \u2227 p := by itauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\nh : p \u2227 q \u2228 p \u2227 r\n\u22a2 p \u2227 p"}]}
{"declaration": "example (p : Prop) : \u00ac(p \u2194 \u00acp) := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\n\u22a2 \u00ac(p \u2194 \u00acp)"}]}
{"declaration": "example (p : Prop) : \u00acp = \u00acp := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\n\u22a2 \u00acp = \u00acp"}]}
{"declaration": "example (p : Prop) : p \u2260 \u00acp := by itauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\n\u22a2 p \u2260 \u00acp"}]}
{"declaration": "example (p : Prop) : p \u2227 True \u2194 p := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\n\u22a2 p \u2227 True \u2194 p"}]}
{"declaration": "example (p : Prop) : p \u2228 False \u2194 p := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\n\u22a2 p \u2228 False \u2194 p"}]}
{"declaration": "example (p q : Prop) (h0 : q) : p \u2192 q := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\np q : Prop\nh0 : q\n\u22a2 p \u2192 q"}]}
{"declaration": "example (p q r : Prop) : p \u2228 q \u2227 r \u2192 (p \u2228 q) \u2227 (r \u2228 p \u2228 r) := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\n\u22a2 p \u2228 q \u2227 r \u2192 (p \u2228 q) \u2227 (r \u2228 p \u2228 r)"}]}
{"declaration": "example (p q r : Prop) : p \u2228 q \u2227 r \u2192 (p \u2228 q) \u2227 (r \u2228 p \u2228 r) := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\n\u22a2 p \u2228 q \u2227 r \u2192 (p \u2228 q) \u2227 (r \u2228 p \u2228 r)"}]}
{"declaration": "example (p q r : Prop) (h : p) : (p \u2192 q \u2228 r) \u2192 q \u2228 r := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\nh : p\n\u22a2 (p \u2192 q \u2228 r) \u2192 q \u2228 r"}]}
{"declaration": "example (p q : Prop) (h : \u00ac(p \u2194 q)) (h' : p) : \u00acq := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : p\n\u22a2 \u00acq"}]}
{"declaration": "example (p q : Prop) (h : \u00ac(p \u2194 q)) (h' : q) : \u00acp := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : q\n\u22a2 \u00acp"}]}
{"declaration": "example (p q : Prop) (h : \u00ac(p \u2194 q)) (h' : \u00acq) (h'' : \u00acp) : False := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acq\nh'' : \u00acp\n\u22a2 False"}]}
{"declaration": "example (p q r : Prop) (h : p \u2194 q) (h' : r \u2194 q) (h'' : \u00acr) : \u00acp := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\nh : p \u2194 q\nh' : r \u2194 q\nh'' : \u00acr\n\u22a2 \u00acp"}]}
{"declaration": "example (p q r : Prop) (h : p \u2194 q) (h' : r \u2194 q) : p \u2194 r := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\nh : p \u2194 q\nh' : r \u2194 q\n\u22a2 p \u2194 r"}]}
{"declaration": "example (p q : Prop) : Xor' p q \u2192 (p \u2194 \u00acq) := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\np q : Prop\n\u22a2 Xor' p q \u2192 (p \u2194 \u00acq)"}]}
{"declaration": "example (p q : Prop) : Xor' p q \u2192 Xor' q p := by itauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\np q : Prop\n\u22a2 Xor' p q \u2192 Xor' q p"}]}
{"declaration": "example (p q r : Prop) (h : \u00ac(p \u2194 q)) (h' : r \u2194 q) : \u00ac(p \u2194 r) := by itauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\nh : \u00ac(p \u2194 q)\nh' : r \u2194 q\n\u22a2 \u00ac(p \u2194 r)"}]}
{"declaration": "example (p : Prop) : p \u2192 \u00ac(p \u2192 \u00acp) := by itauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\n\u22a2 p \u2192 \u00ac(p \u2192 \u00acp)"}]}
{"declaration": "example (p : Prop) (em : p \u2228 \u00acp) : \u00ac(p \u2194 \u00acp) := by itauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\nem : p \u2228 \u00acp\n\u22a2 \u00ac(p \u2194 \u00acp)"}]}
{"declaration": "example (p : Prop) [Decidable p] : p \u2228 \u00acp := by itauto *", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\ninst\u271d : Decidable p\n\u22a2 p \u2228 \u00acp"}]}
{"declaration": "example (p : Prop) [Decidable p] : \u00ac(p \u2194 \u00acp) := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\ninst\u271d : Decidable p\n\u22a2 \u00ac(p \u2194 \u00acp)"}]}
{"declaration": "example (p q r : Prop) [Decidable p] : (p \u2192 q \u2228 r) \u2192 (p \u2192 q) \u2228 (p \u2192 r) := by itauto *", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\ninst\u271d : Decidable p\n\u22a2 (p \u2192 q \u2228 r) \u2192 (p \u2192 q) \u2228 (p \u2192 r)"}]}
{"declaration": "example (p q r : Prop) [Decidable q] : (p \u2192 q \u2228 r) \u2192 (p \u2192 q) \u2228 (p \u2192 r) := by itauto [q]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\ninst\u271d : Decidable q\n\u22a2 (p \u2192 q \u2228 r) \u2192 (p \u2192 q) \u2228 (p \u2192 r)"}]}
{"declaration": "example (xl yl zl xr yr zr : Prop) :\n    (xl \u2227 yl \u2228 xr \u2227 yr) \u2227 zl \u2228 (xl \u2227 yr \u2228 xr \u2227 yl) \u2227 zr \u2194\n      xl \u2227 (yl \u2227 zl \u2228 yr \u2227 zr) \u2228 xr \u2227 (yl \u2227 zr \u2228 yr \u2227 zl) := by itauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\nh : p \u2227 q \u2228 p \u2227 r\nxl yl zl xr yr zr : Prop\n\u22a2 (xl \u2227 yl \u2228 xr \u2227 yr) \u2227 zl \u2228 (xl \u2227 yr \u2228 xr \u2227 yl) \u2227 zr \u2194 xl \u2227 (yl \u2227 zl \u2228 yr \u2227 zr) \u2228 xr \u2227 (yl \u2227 zr \u2228 yr \u2227 zl)"}]}
{"declaration": "example : 0 < 1 \u2228 \u00ac0 < 1 := by itauto *", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\nh : p \u2227 q \u2228 p \u2227 r\n\u22a2 0 < 1 \u2228 \u00ac0 < 1"}]}
{"declaration": "example (p : Prop) (h : 0 < 1 \u2192 p) (h2 : \u00ac0 < 1 \u2192 p) : p := by itauto *\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh\u271d : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\nh : 0 < 1 \u2192 p\nh2 : \u00ac0 < 1 \u2192 p\n\u22a2 p"}]}
{"declaration": "example (b : Bool) : \u00acb \u2228 b := by itauto *", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\nh : p \u2227 q \u2228 p \u2227 r\nb : Bool\n\u22a2 \u00acb = true \u2228 b = true"}]}
{"declaration": "example (p : Prop) : \u00acp \u2228 p := by itauto! [p]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\n\u22a2 \u00acp \u2228 p"}]}
{"declaration": "example (p : Prop) : \u00acp \u2228 p := by itauto! *\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q r : Prop\nh : p\u271d \u2227 q \u2228 p\u271d \u2227 r\np : Prop\n\u22a2 \u00acp \u2228 p"}]}
{"declaration": "example (p q r : Prop) : True := by\n  haveI : p \u2228 \u00acp := by (fail_if_success itauto); sorry\n  clear this; haveI : \u00ac(p \u2194 q) \u2192 \u00acp \u2192 q := by (fail_if_success itauto); sorry\n  clear this; haveI : \u00ac(p \u2194 q) \u2192 (r \u2194 q) \u2192 (p \u2194 \u00acr) := by (fail_if_success itauto); sorry\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\n\u22a2 True"}, {"line": "  haveI : p \u2228 \u00acp := by (fail_if_success itauto); sorry", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\nthis : p \u2228 \u00acp\n\u22a2 True"}, {"line": "  clear this; haveI : \u00ac(p \u2194 q) \u2192 \u00acp \u2192 q := by (fail_if_success itauto); sorry", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\n\u22a2 True"}, {"line": "  clear this; haveI : \u00ac(p \u2194 q) \u2192 (r \u2194 q) \u2192 (p \u2194 \u00acr) := by (fail_if_success itauto); sorry", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\nthis : \u00ac(p \u2194 q) \u2192 \u00acp \u2192 q\n\u22a2 True"}, {"line": "  trivial", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\n\u22a2 True"}]}
{"declaration": "example (P : Nat \u2192 Prop) (n : Nat)\n    (h : \u00ac(n = 7 \u2228 n = 0) \u2227 P n) : \u00ac(P n \u2192 n = 7 \u2228 n = 0) := by itauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\nh\u271d : p \u2227 q \u2228 p \u2227 r\nP : \u2115 \u2192 Prop\nn : \u2115\nh : \u00ac(n = 7 \u2228 n = 0) \u2227 P n\n\u22a2 \u00ac(P n \u2192 n = 7 \u2228 n = 0)"}]}
{"declaration": "example (h' : \u00acx = y) : p \u2227 q := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\nh' : \u00acx = y\n\u22a2 p \u2227 q"}]}
{"declaration": "example : x = y := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u22a2 x = y"}]}
{"declaration": "example (p1 p2 p3 p4 p5 p6 f : Prop)\n    (h : (\n      (p1 \u2227 p2 \u2227 p3 \u2227 p4 \u2227 p5 \u2227 p6 \u2227 True) \u2228\n      (((p1 \u2192 f) \u2192 f) \u2192 f) \u2228\n      (p2 \u2192 f) \u2228\n      (p3 \u2192 f) \u2228\n      (p4 \u2192 f) \u2228\n      (p5 \u2192 f) \u2228\n      (p6 \u2192 f) \u2228\n      False\n    ) \u2192 f) : f := by itauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/itauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d\u00b9 : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh\u271d : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\np1 p2 p3 p4 p5 p6 f : Prop\nh :\n  p1 \u2227 p2 \u2227 p3 \u2227 p4 \u2227 p5 \u2227 p6 \u2227 True \u2228\n      (((p1 \u2192 f) \u2192 f) \u2192 f) \u2228 (p2 \u2192 f) \u2228 (p3 \u2192 f) \u2228 (p4 \u2192 f) \u2228 (p5 \u2192 f) \u2228 (p6 \u2192 f) \u2228 False \u2192\n    f\n\u22a2 f"}]}
{"declaration": "example : (fun\u2080 | 1 => 3) 1 = 3 := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finsupp_notation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun\u2080 | 1 => 3) 1 = 3"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example : (fun\u2080 | 1 | 2 | 3 => 3 | 3 => 4) 1 = 3 := by\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finsupp_notation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun\u2080 | 1 => 3 | 2 => 3 | 3 => 3 | 3 => 4) 1 = 3"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example : (fun\u2080 | 1 | 2 | 3 => 3 | 3 => 4) 2 = 3 := by\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finsupp_notation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun\u2080 | 1 => 3 | 2 => 3 | 3 => 3 | 3 => 4) 2 = 3"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example : (fun\u2080 | 1 | 2 | 3 => 3 | 3 => 4) 3 = 4 := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/finsupp_notation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun\u2080 | 1 => 3 | 2 => 3 | 3 => 3 | 3 => 4) 3 = 4"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "theorem withClean : 2 + 2 = 4 := clean% by exact id rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clean.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 + 2 = 4"}]}
{"declaration": "theorem withoutClean : 2 + 2 = 4 := by exact id rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clean.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 + 2 = 4"}]}
{"declaration": "example : True := by\n  let x : id Nat := by dsimp; exact 1\n  guard_hyp x :\u209b id Nat := id (1 : Nat)\n  let x' : id Nat := clean% by dsimp; exact 1\n  guard_hyp x' :\u209b id Nat := (1 : Nat)\n\n  let y := show Nat from 1\n  guard_hyp y :\u209b Nat := let_fun this := 1; this\n  let y' := clean% show Nat from 1\n  guard_hyp y' :\u209b Nat := 1\n\n  -- Not a tautological let_fun:\n  let z := clean% let_fun x := 1; x + x\n  guard_hyp z :\u209b Nat := let_fun x := 1; x + x\n\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Clean.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  let x : id Nat := by dsimp; exact 1", "tactic_state": "x : id \u2115 := id 1\n\u22a2 True"}, {"line": "  guard_hyp x :\u209b id Nat := id (1 : Nat)", "tactic_state": "x : id \u2115 := id 1\n\u22a2 True"}, {"line": "  let x' : id Nat := clean% by dsimp; exact 1", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\n\u22a2 True"}, {"line": "  guard_hyp x' :\u209b id Nat := (1 : Nat)", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\n\u22a2 True"}, {"line": "", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\n\u22a2 True"}, {"line": "  let y := show Nat from 1", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\n\u22a2 True"}, {"line": "  guard_hyp y :\u209b Nat := let_fun this := 1; this", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\ny' : \u2115 := 1\n\u22a2 True"}, {"line": "  let y' := clean% show Nat from 1", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\ny' : \u2115 := 1\n\u22a2 True"}, {"line": "  guard_hyp y' :\u209b Nat := 1", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\ny' : \u2115 := 1\nz : \u2115 :=\n  let_fun x := 1;\n  x + x\n\u22a2 True"}, {"line": "", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\ny' : \u2115 := 1\nz : \u2115 :=\n  let_fun x := 1;\n  x + x\n\u22a2 True"}, {"line": "  -- Not a tautological let_fun:", "tactic_state": ""}]}
{"declaration": "example (A B : Type*) [CommRing A] [CommRing B] (f : A \u2192+* B) : True := by\n  fail_if_success -- Check that this instance is not available by default\n    have h : Algebra A B := inferInstance\n  algebraize [f]\n  guard_hyp algInst := f.toAlgebra\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/algebraize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\n\u22a2 True"}, {"line": "  fail_if_success -- Check that this instance is not available by default", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\n\u22a2 True"}, {"line": "    have h : Algebra A B := inferInstance", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}, {"line": "  algebraize [f]", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}]}
{"declaration": "example (A B : Type*) [CommRing A] [CommRing B] (f : A \u2192+* B) : True := by\n  let f' : A \u2192+* B := f\n  fail_if_success -- Check that this instance is not available by default\n    have h : Algebra A B := inferInstance\n  algebraize [f']\n  guard_hyp algInst := f'.toAlgebra\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/algebraize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\n\u22a2 True"}, {"line": "  let f' : A \u2192+* B := f", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nf' : A \u2192+* B := f\n\u22a2 True"}, {"line": "  fail_if_success -- Check that this instance is not available by default", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nf' : A \u2192+* B := f\n\u22a2 True"}, {"line": "    have h : Algebra A B := inferInstance", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nf' : A \u2192+* B := f\nalgInst\u271d : Algebra A B := f'.toAlgebra\n\u22a2 True"}, {"line": "  algebraize [f']", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nf' : A \u2192+* B := f\nalgInst\u271d : Algebra A B := f'.toAlgebra\n\u22a2 True"}]}
{"declaration": "example (A B C : Type*) [CommRing A] [CommRing B] [CommRing C] (f : A \u2192+* B) (g : B \u2192+* C) :\n    True := by\n  fail_if_success -- Check that this instance is not available by default\n    have h : Algebra A C := inferInstance\n  algebraize [g.comp f]\n  guard_hyp algInst := (g.comp f).toAlgebra\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/algebraize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\n\u22a2 True"}, {"line": "  fail_if_success -- Check that this instance is not available by default", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\n\u22a2 True"}, {"line": "    have h : Algebra A C := inferInstance", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nalgInst\u271d : Algebra A C := (g.comp f).toAlgebra\n\u22a2 True"}, {"line": "  algebraize [g.comp f]", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nalgInst\u271d : Algebra A C := (g.comp f).toAlgebra\n\u22a2 True"}]}
{"declaration": "example (A B C : Type*) [CommRing A] [CommRing B] [CommRing C] (f : A \u2192+* B) (g : B \u2192+* C) :\n    True := by\n  fail_if_success -- Check that this instance is not available by default\n    have h : IsScalarTower A B C := inferInstance\n  algebraize [f, g, g.comp f]\n  guard_hyp scalarTowerInst := IsScalarTower.of_algebraMap_eq' rfl\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/algebraize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\n\u22a2 True"}, {"line": "  fail_if_success -- Check that this instance is not available by default", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\n\u22a2 True"}, {"line": "    have h : IsScalarTower A B C := inferInstance", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nalgInst\u271d\u00b2 : Algebra A B := f.toAlgebra\nalgInst\u271d\u00b9 : Algebra B C := g.toAlgebra\nalgInst\u271d : Algebra A C := (g.comp f).toAlgebra\nscalarTowerInst\u271d : IsScalarTower A B C := IsScalarTower.of_algebraMap_eq' (Eq.refl (algebraMap A C))\n\u22a2 True"}, {"line": "  algebraize [f, g, g.comp f]", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nalgInst\u271d\u00b2 : Algebra A B := f.toAlgebra\nalgInst\u271d\u00b9 : Algebra B C := g.toAlgebra\nalgInst\u271d : Algebra A C := (g.comp f).toAlgebra\nscalarTowerInst\u271d : IsScalarTower A B C := IsScalarTower.of_algebraMap_eq' (Eq.refl (algebraMap A C))\n\u22a2 True"}]}
{"declaration": "example (A B : Type*) [CommRing A] [CommRing B] (f : A \u2192+* B) (hf : f.testProperty1) : True := by\n  algebraize [f]\n  guard_hyp algebraizeInst : Algebra.testProperty1 A B\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/algebraize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\n\u22a2 True"}, {"line": "  algebraize [f]", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}, {"line": "  guard_hyp algebraizeInst : Algebra.testProperty1 A B", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}]}
{"declaration": "example (A B : Type*) [CommRing A] [CommRing B] (f : A \u2192+* B) (hf : f.testProperty2) : True := by\n  algebraize [f]\n  guard_hyp algebraizeInst : Module.testProperty2 A B\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/algebraize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\n\u22a2 True"}, {"line": "  algebraize [f]", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}, {"line": "  guard_hyp algebraizeInst : Module.testProperty2 A B", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}]}
{"declaration": "example (A B : Type*) [CommRing A] [CommRing B] (f : A \u2192+* B) (hf : f.testProperty3) : True := by\n  algebraize [f]\n  guard_hyp algebraizeInst : Algebra.testProperty3 A B\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/algebraize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\n\u22a2 True"}, {"line": "  algebraize [f]", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}, {"line": "  guard_hyp algebraizeInst : Algebra.testProperty3 A B", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}]}
{"declaration": "example (n : \u2115) (A B : Type*) [CommRing A] [CommRing B] (f : A \u2192+* B) (hf : f.testProperty4 n) :\n    True := by\n  algebraize [f]\n  guard_hyp algebraizeInst : Algebra.testProperty4 n A B\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/algebraize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nA : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\n\u22a2 True"}, {"line": "  algebraize [f]", "tactic_state": "n : \u2115\nA : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}, {"line": "  guard_hyp algebraizeInst : Algebra.testProperty4 n A B", "tactic_state": "n : \u2115\nA : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : sorry\nalgInst\u271d : Algebra A B := f.toAlgebra\n\u22a2 True"}]}
{"declaration": "example (A B C : Type*) [CommRing A] [CommRing B] [CommRing C] (f : A \u2192+* B) (g : B \u2192+* C)\n    (hfg : (g.comp f).testProperty1) : True := by\n  fail_if_success -- Check that this instance is not available by default\n    have h : Algebra.Flat A C := inferInstance\n  fail_if_success\n    have h : IsScalarTower A B C := inferInstance\n  algebraize [f, g, g.comp f]\n  guard_hyp algebraizeInst : Algebra.testProperty1 A C\n  guard_hyp scalarTowerInst := IsScalarTower.of_algebraMap_eq' rfl\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/algebraize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nhfg : sorry\n\u22a2 True"}, {"line": "  fail_if_success -- Check that this instance is not available by default", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nhfg : sorry\n\u22a2 True"}, {"line": "    have h : Algebra.Flat A C := inferInstance", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nhfg : sorry\n\u22a2 True"}, {"line": "  fail_if_success", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nhfg : sorry\nalgInst\u271d\u00b2 : Algebra A B := f.toAlgebra\nalgInst\u271d\u00b9 : Algebra B C := g.toAlgebra\nalgInst\u271d : Algebra A C := (g.comp f).toAlgebra\nscalarTowerInst\u271d : IsScalarTower A B C := IsScalarTower.of_algebraMap_eq' (Eq.refl (algebraMap A C))\n\u22a2 True"}, {"line": "    have h : IsScalarTower A B C := inferInstance", "tactic_state": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nhfg : sorry\nalgInst\u271d\u00b2 : Algebra A B := f.toAlgebra\nalgInst\u271d\u00b9 : Algebra B C := g.toAlgebra\nalgInst\u271d : Algebra A C := (g.comp f).toAlgebra\nscalarTowerInst\u271d : IsScalarTower A B C := IsScalarTower.of_algebraMap_eq' (Eq.refl (algebraMap A C))\n\u22a2 True"}]}
{"declaration": "example (y : \u211d) (hy : y \u2260 0) : ContinuousAt (fun x => x * (Real.log x) ^ 2 - Real.exp x / x) y := by\n  fun_prop (disch:=aesop)\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\nhy : y \u2260 0\n\u22a2 ContinuousAt (fun x => x * Real.log x ^ 2 - Real.exp x / x) y"}, {"line": "  fun_prop (disch:=aesop)", "tactic_state": ""}]}
{"declaration": "example : DifferentiableOn \u211d foo {0}\u1d9c := by\n  unfold foo; fun_prop (disch:=aesop)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F\u271d : Type u_1\nfoo : \u2115 \u2192 F\u271d\n\u22a2 DifferentiableOn \u211d foo {0}\u1d9c"}, {"line": "  unfold foo; fun_prop (disch:=aesop)", "tactic_state": "F\u271d : Type u_1\nfoo : \u2115 \u2192 F\u271d\n\u22a2 DifferentiableOn \u211d foo {0}\u1d9c"}]}
{"declaration": "example {n} : ContDiffOn \u211d n foo {0}\u1d9c := by\n  unfold foo; fun_prop (disch:=aesop)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F\u271d : Type u_1\nfoo : \u2115 \u2192 F\u271d\nn : WithTop \u2115\u221e\n\u22a2 ContDiffOn \u211d n foo {0}\u1d9c"}, {"line": "  unfold foo; fun_prop (disch:=aesop)", "tactic_state": "F\u271d : Type u_1\nfoo : \u2115 \u2192 F\u271d\nn : WithTop \u2115\u221e\n\u22a2 ContDiffOn \u211d n foo {0}\u1d9c"}]}
{"declaration": "example : Continuous fun ((x, _, _) : \u211d \u00d7 \u211d \u00d7 \u211d) \u21a6 x := by fun_prop", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Continuous fun x =>\n    match x with\n    | (x, fst, snd) => x"}]}
{"declaration": "example : Continuous fun ((_, y, _) : \u211d \u00d7 \u211d \u00d7 \u211d) \u21a6 y := by fun_prop", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Continuous fun x =>\n    match x with\n    | (fst, y, snd) => y"}]}
{"declaration": "example : Continuous fun ((_, _, z) : \u211d \u00d7 \u211d \u00d7 \u211d) \u21a6 z := by fun_prop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Continuous fun x =>\n    match x with\n    | (fst, fst_1, z) => z"}]}
{"declaration": "theorem ContinuousOn.log' : ContinuousOn Real.log {0}\u1d9c := ContinuousOn.log (by fun_prop) (by aesop)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ContinuousOn (fun x => x) {0}\u1d9c"}]}
{"declaration": "example : Measurable (fun x => x * (Real.log x) ^ 2 - Real.exp x / x) := by\n  fun_prop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Measurable fun x => x * Real.log x ^ 2 - Real.exp x / x"}, {"line": "  fun_prop", "tactic_state": ""}]}
{"declaration": "example : AEMeasurable (fun x => x * (Real.log x) ^ 2 - Real.exp x / x) := by\n  fun_prop (config:={maxTransitionDepth:=2})\n\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 MeasureTheory.Measure \u211d"}, {"line": "  fun_prop (config:={maxTransitionDepth:=2})", "tactic_state": ""}, {"line": "", "tactic_state": ""}]}
{"declaration": "example : DifferentiableOn \u211d T (Set.Icc 0 1) := by\n  unfold T S\n  fun_prop (disch:=(rintro x \u27e8a,b\u27e9; nlinarith))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F\u271d : Type u_1\nT : \u2115 \u2192 F\u271d\n\u22a2 DifferentiableOn \u211d T (Set.Icc 0 1)"}, {"line": "  unfold T S", "tactic_state": "F\u271d : Type u_1\nT : \u2115 \u2192 F\u271d\n\u22a2 DifferentiableOn \u211d T (Set.Icc 0 1)"}]}
{"declaration": "example {n}: ContDiffOn \u211d n T (Set.Icc 0 1) := by\n  unfold T S\n  fun_prop (disch:=(rintro x \u27e8a,b\u27e9; nlinarith))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F\u271d : Type u_1\nT : \u2115 \u2192 F\u271d\nn : WithTop \u2115\u221e\n\u22a2 ContDiffOn \u211d n T (Set.Icc 0 1)"}, {"line": "  unfold T S", "tactic_state": "F\u271d : Type u_1\nT : \u2115 \u2192 F\u271d\nn : WithTop \u2115\u221e\n\u22a2 ContDiffOn \u211d n T (Set.Icc 0 1)"}]}
{"declaration": "example : AEMeasurable T := by\n  unfold T S\n  fun_prop\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : ?m.110 \u2192 ?m.111\n\u22a2 MeasureTheory.Measure ?m.110"}, {"line": "  unfold T S", "tactic_state": "T : ?m.357 \u2192 ?m.111\n\u22a2 MeasureTheory.Measure ?m.357"}, {"line": "  fun_prop", "tactic_state": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\nT : \u03b1\u271d \u2192 \u03b2\u271d\n\u22a2 AEMeasurable T sorry"}]}
{"declaration": "private theorem t1 : (5: \u2115) + (1 : \u2115\u221e) \u2264 (12 : WithTop \u2115\u221e) := by norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u21915 + \u21911 \u2264 12"}]}
{"declaration": "example {f : \u211d \u2192 \u211d} (hf : ContDiff \u211d 12 f) :\n    Differentiable \u211d (iteratedDeriv 5 (fun x => f (2*(f (x + x))) + x)) := by\n  fun_prop (disch:=(exact t1))", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nhf : ContDiff \u211d 12 f\n\u22a2 Differentiable \u211d (iteratedDeriv 5 fun x => f (2 * f (x + x)) + x)"}, {"line": "  fun_prop (disch:=(exact t1))", "tactic_state": ""}]}
{"declaration": "example (P : \u2115 \u2192 \u2115 \u2192 Prop) (h : \u2200 n, \u2203 m, P n m) : \u2200 l, \u2203 m, P l m := by\n  trace_state\n  rename_bvar n \u2192 q at h\n  trace_state\n  rename_bvar m \u2192 n\n  trace_state\n  rename_bvar l \u2192 m\n  trace_state\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/renameBvar.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (n : \u2115), \u2203 m, P n m\n\u22a2 \u2200 (l : \u2115), \u2203 m, P l m"}, {"line": "  trace_state", "tactic_state": "P : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (n : \u2115), \u2203 m, P n m\n\u22a2 \u2200 (l : \u2115), \u2203 m, P l m"}, {"line": "  rename_bvar n \u2192 q at h", "tactic_state": "P : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (q : \u2115), \u2203 m, P q m\n\u22a2 \u2200 (l : \u2115), \u2203 m, P l m"}, {"line": "  trace_state", "tactic_state": "P : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (q : \u2115), \u2203 m, P q m\n\u22a2 \u2200 (l : \u2115), \u2203 m, P l m"}, {"line": "  rename_bvar m \u2192 n", "tactic_state": "P : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (q : \u2115), \u2203 m, P q m\n\u22a2 \u2200 (l : \u2115), \u2203 n, P l n"}, {"line": "  trace_state", "tactic_state": "P : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (q : \u2115), \u2203 m, P q m\n\u22a2 \u2200 (l : \u2115), \u2203 n, P l n"}, {"line": "  rename_bvar l \u2192 m", "tactic_state": "P : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (q : \u2115), \u2203 m, P q m\n\u22a2 \u2200 (m : \u2115), \u2203 n, P m n"}, {"line": "  trace_state", "tactic_state": "P : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (q : \u2115), \u2203 m, P q m\n\u22a2 \u2200 (m : \u2115), \u2203 n, P m n"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (a b c : Int) (h1 : a \u2223 b) (h2 : b \u2223 c) : a \u2223 c := by\n  rcases h1 with \u27e8k, hk\u27e9\n  show \u2203 k, c = a * k\n  trace_state\n  rename_bvar k \u2192 m\n  trace_state\n  exact test_sorry", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/renameBvar.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2124\nh1 : a \u2223 b\nh2 : b \u2223 c\n\u22a2 a \u2223 c"}, {"line": "  rcases h1 with \u27e8k, hk\u27e9", "tactic_state": "case intro\na b c : \u2124\nh2 : b \u2223 c\nk : \u2124\nhk : b = a * k\n\u22a2 a \u2223 c"}, {"line": "  show \u2203 k, c = a * k", "tactic_state": "case intro\na b c : \u2124\nh2 : b \u2223 c\nk : \u2124\nhk : b = a * k\n\u22a2 \u2203 k, c = a * k"}, {"line": "  trace_state", "tactic_state": "case intro\na b c : \u2124\nh2 : b \u2223 c\nk : \u2124\nhk : b = a * k\n\u22a2 \u2203 k, c = a * k"}, {"line": "  rename_bvar k \u2192 m", "tactic_state": "case intro\na b c : \u2124\nh2 : b \u2223 c\nk : \u2124\nhk : b = a * k\n\u22a2 \u2203 m, c = a * m"}, {"line": "  trace_state", "tactic_state": "case intro\na b c : \u2124\nh2 : b \u2223 c\nk : \u2124\nhk : b = a * k\n\u22a2 \u2203 m, c = a * m"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : TFAE []  := by tfae_finish", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 [].TFAE"}]}
{"declaration": "example : TFAE [P] := by tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Prop\n\u22a2 [P].TFAE"}]}
{"declaration": "example : TFAE [P, Q] := by\n  tfae_have 1 \u2192 2 := pq\n  tfae_have 2 \u2192 1 := qp\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 1 \u2192 2 := pq", "tactic_state": "P Q : Prop\ntfae_1_to_2 : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 2 \u2192 1 := qp", "tactic_state": "P Q : Prop\ntfae_1_to_2 : P \u2192 Q\ntfae_2_to_1 : Q \u2192 P\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example : TFAE [P, Q] := by\n  tfae_have 1 \u2194 2 := Iff.intro pq qp\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 1 \u2194 2 := Iff.intro pq qp", "tactic_state": "P Q : Prop\ntfae_1_iff_2 : P \u2194 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example : TFAE [P, Q] := by\n  tfae_have 2 \u2190 1 := pq\n  guard_hyp tfae_2_from_1 : P \u2192 Q\n  tfae_have 1 \u2190 2 := qp\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 2 \u2190 1 := pq", "tactic_state": "P Q : Prop\ntfae_2_from_1 : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  guard_hyp tfae_2_from_1 : P \u2192 Q", "tactic_state": "P Q : Prop\ntfae_2_from_1 : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 1 \u2190 2 := qp", "tactic_state": "P Q : Prop\ntfae_2_from_1 : P \u2192 Q\ntfae_1_from_2 : Q \u2192 P\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example : TFAE [P, Q, R] := by\n  tfae_have 1 \u2192 2 := pq\n  tfae_have 2 \u2192 3 := qr\n  tfae_have 3 \u2192 1 := rp\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q R : Prop\n\u22a2 [P, Q, R].TFAE"}, {"line": "  tfae_have 1 \u2192 2 := pq", "tactic_state": "P Q R : Prop\ntfae_1_to_2 : P \u2192 Q\n\u22a2 [P, Q, R].TFAE"}, {"line": "  tfae_have 2 \u2192 3 := qr", "tactic_state": "P Q R : Prop\ntfae_1_to_2 : P \u2192 Q\ntfae_2_to_3 : Q \u2192 R\n\u22a2 [P, Q, R].TFAE"}, {"line": "  tfae_have 3 \u2192 1 := rp", "tactic_state": "P Q R : Prop\ntfae_1_to_2 : P \u2192 Q\ntfae_2_to_3 : Q \u2192 R\ntfae_3_to_1 : R \u2192 P\n\u22a2 [P, Q, R].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example : TFAE [P, Q, R] := by\n  tfae_have 1 \u2194 2 := Iff.intro pq (rp \u2218 qr)\n  tfae_have 3 \u2194 2 := Iff.intro (pq \u2218 rp) qr\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q R : Prop\n\u22a2 [P, Q, R].TFAE"}, {"line": "  tfae_have 1 \u2194 2 := Iff.intro pq (rp \u2218 qr)", "tactic_state": "P Q R : Prop\n\u22a2 [P, Q, R].TFAE"}]}
{"declaration": "example : TFAE [P, Q, R] := by\n  tfae_have 1 \u2192 2 := pq\n  tfae_have 2 \u2192 1 := rp \u2218 qr\n  tfae_have 2 \u2194 3 := Iff.intro qr (pq \u2218 rp)\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q R : Prop\n\u22a2 [P, Q, R].TFAE"}, {"line": "  tfae_have 1 \u2192 2 := pq", "tactic_state": "P Q R : Prop\ntfae_1_to_2 : P \u2192 Q\n\u22a2 [P, Q, R].TFAE"}, {"line": "  tfae_have 2 \u2192 1 := rp \u2218 qr", "tactic_state": "P Q R : Prop\ntfae_1_to_2 : P \u2192 Q\n\u22a2 [P, Q, R].TFAE"}]}
{"declaration": "example : TFAE [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087] := by\n  tfae_have test : 1 \u2194 2 := h\u2081\n  guard_hyp test : _\n  tfae_have 1 \u2192 6 := h\u2082\n  tfae_have 6 \u2192 7 := h\u2083\n  tfae_have 7 \u2192 4 := h\u2084\n  tfae_have 4 \u2192 5 := h\u2085\n  tfae_have 5 \u2192 3 := h\u2086\n  tfae_have 3 \u2192 2 := h\u2087\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P\u2081 P\u2082 P\u2083 P\u2084 P\u2085 P\u2086 P\u2087 : Prop\n\u22a2 [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087].TFAE"}, {"line": "  tfae_have test : 1 \u2194 2 := h\u2081", "tactic_state": "P\u2081 P\u2082 P\u2083 P\u2084 P\u2085 P\u2086 P\u2087 : Prop\ntest : P\u2081 \u2194 P\u2082\n\u22a2 [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087].TFAE"}, {"line": "  guard_hyp test : _", "tactic_state": "P\u2081 P\u2082 P\u2083 P\u2084 P\u2085 P\u2086 P\u2087 : Prop\ntest : P\u2081 \u2194 P\u2082\n\u22a2 [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087].TFAE"}, {"line": "  tfae_have 1 \u2192 6 := h\u2082", "tactic_state": "P\u2081 P\u2082 P\u2083 P\u2084 P\u2085 P\u2086 P\u2087 : Prop\ntest : P\u2081 \u2194 P\u2082\ntfae_1_to_6 : P\u2081 \u2192 P\u2086\n\u22a2 [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087].TFAE"}, {"line": "  tfae_have 6 \u2192 7 := h\u2083", "tactic_state": "P\u2081 P\u2082 P\u2083 P\u2084 P\u2085 P\u2086 P\u2087 : Prop\ntest : P\u2081 \u2194 P\u2082\ntfae_1_to_6 : P\u2081 \u2192 P\u2086\ntfae_6_to_7 : P\u2086 \u2192 P\u2087\n\u22a2 [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087].TFAE"}, {"line": "  tfae_have 7 \u2192 4 := h\u2084", "tactic_state": "P\u2081 P\u2082 P\u2083 P\u2084 P\u2085 P\u2086 P\u2087 : Prop\ntest : P\u2081 \u2194 P\u2082\ntfae_1_to_6 : P\u2081 \u2192 P\u2086\ntfae_6_to_7 : P\u2086 \u2192 P\u2087\ntfae_7_to_4 : P\u2087 \u2192 P\u2084\n\u22a2 [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087].TFAE"}, {"line": "  tfae_have 4 \u2192 5 := h\u2085", "tactic_state": "P\u2081 P\u2082 P\u2083 P\u2084 P\u2085 P\u2086 P\u2087 : Prop\ntest : P\u2081 \u2194 P\u2082\ntfae_1_to_6 : P\u2081 \u2192 P\u2086\ntfae_6_to_7 : P\u2086 \u2192 P\u2087\ntfae_7_to_4 : P\u2087 \u2192 P\u2084\ntfae_4_to_5 : P\u2084 \u2192 P\u2085\n\u22a2 [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087].TFAE"}, {"line": "  tfae_have 5 \u2192 3 := h\u2086", "tactic_state": "P\u2081 P\u2082 P\u2083 P\u2084 P\u2085 P\u2086 P\u2087 : Prop\ntest : P\u2081 \u2194 P\u2082\ntfae_1_to_6 : P\u2081 \u2192 P\u2086\ntfae_6_to_7 : P\u2086 \u2192 P\u2087\ntfae_7_to_4 : P\u2087 \u2192 P\u2084\ntfae_4_to_5 : P\u2084 \u2192 P\u2085\ntfae_5_to_3 : P\u2085 \u2192 P\u2083\n\u22a2 [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087].TFAE"}, {"line": "  tfae_have 3 \u2192 2 := h\u2087", "tactic_state": "P\u2081 P\u2082 P\u2083 P\u2084 P\u2085 P\u2086 P\u2087 : Prop\ntest : P\u2081 \u2194 P\u2082\ntfae_1_to_6 : P\u2081 \u2192 P\u2086\ntfae_6_to_7 : P\u2086 \u2192 P\u2087\ntfae_7_to_4 : P\u2087 \u2192 P\u2084\ntfae_4_to_5 : P\u2084 \u2192 P\u2085\ntfae_5_to_3 : P\u2085 \u2192 P\u2083\ntfae_3_to_2 : P\u2083 \u2192 P\u2082\n\u22a2 [P\u2081, P\u2082, P\u2083, P\u2084, P\u2085, P\u2086, P\u2087].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) : List.TFAE [n = 1, n + 1 = 2] := by\n  generalize n = m\n  tfae_have 1 \u2194 2 := by simp\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 [n = 1, n + 1 = 2].TFAE"}, {"line": "  generalize n = m", "tactic_state": "n m : \u2115\n\u22a2 [m = 1, m + 1 = 2].TFAE"}, {"line": "  tfae_have 1 \u2194 2 := by simp", "tactic_state": "n m : \u2115\ntfae_1_iff_2 : m = 1 \u2194 m + 1 = 2\n\u22a2 [m = 1, m + 1 = 2].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example (h\u2081 : P \u2192 Q) (h\u2082 : Q \u2192 P) : TFAE [P, Q] := by\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\nh\u2081 : P \u2192 Q\nh\u2082 : Q \u2192 P\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example : TFAE [P, Q] := by\n  tfae_have h : 1 \u2192 2 := pq\n  guard_hyp h : P \u2192 Q\n  tfae_have _ : 1 \u2190 2 := qp\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have h : 1 \u2192 2 := pq", "tactic_state": "P Q : Prop\nh : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  guard_hyp h : P \u2192 Q", "tactic_state": "P Q : Prop\nh : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have _ : 1 \u2190 2 := qp", "tactic_state": "P Q : Prop\nh : P \u2192 Q\nx\u271d : Q \u2192 P\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example : TFAE [P, Q] := by\n  have n : \u2115 := 4\n  tfae_have 1 \u2192 2 := by\n    guard_hyp n : \u2115 -- hypotheses are accessible (context is correct)\n    guard_target =\u209b P \u2192 Q -- expected type is known\n    exact pq\n  tfae_have 1 \u2190 2 := qp\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 [P, Q].TFAE"}, {"line": "  have n : \u2115 := 4", "tactic_state": "P Q : Prop\nn : \u2115\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 1 \u2192 2 := by", "tactic_state": "P Q : Prop\nn : \u2115\ntfae_1_to_2 : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "    guard_hyp n : \u2115 -- hypotheses are accessible (context is correct)", "tactic_state": "P Q : Prop\nn : \u2115\ntfae_1_to_2 : P \u2192 Q\ntfae_1_from_2 : Q \u2192 P\n\u22a2 [P, Q].TFAE"}, {"line": "    guard_target =\u209b P \u2192 Q -- expected type is known", "tactic_state": ""}]}
{"declaration": "example : TFAE [P, Q] := by\n  have n : \u2115 := 3\n  tfae_have 2 \u2190 1 := fun p => ?Qgoal\n  case Qgoal => exact pq p\n  refine ?a\n  fail_if_success (tfae_have 1 \u2190 2 := ((?a).out 1 2 sorry sorry).mpr)\n  tfae_have 2 \u2192 1 := qp\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 [P, Q].TFAE"}, {"line": "  have n : \u2115 := 3", "tactic_state": "P Q : Prop\nn : \u2115\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 2 \u2190 1 := fun p => ?Qgoal", "tactic_state": "P Q : Prop\nn : \u2115\ntfae_2_from_1 : P \u2192 Q\n\u22a2 [P, Q].TFAE\n---\ncase Qgoal\nP Q : Prop\nn : \u2115\np : P\n\u22a2 Q"}, {"line": "  case Qgoal => exact pq p", "tactic_state": "P Q : Prop\nn : \u2115\ntfae_2_from_1 : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  refine ?a", "tactic_state": "case a\nP Q : Prop\nn : \u2115\ntfae_2_from_1 : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  fail_if_success (tfae_have 1 \u2190 2 := ((?a).out 1 2 sorry sorry).mpr)", "tactic_state": "case a\nP Q : Prop\nn : \u2115\ntfae_2_from_1 : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 2 \u2192 1 := qp", "tactic_state": "case a\nP Q : Prop\nn : \u2115\ntfae_2_from_1 : P \u2192 Q\ntfae_2_to_1 : Q \u2192 P\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example : TFAE [P, Q] := by\n  tfae_have 1 \u2192 2\n  | p => pq p\n  tfae_have 2 \u2192 1\n  | q => qp q\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 1 \u2192 2", "tactic_state": "P Q : Prop\ntfae_1_to_2 : P \u2192 Q\n\u22a2 [P, Q].TFAE"}, {"line": "  | p => pq p", "tactic_state": "P Q : Prop\ntfae_1_to_2 : P \u2192 Q\ntfae_2_to_1 : Q \u2192 P\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have 2 \u2192 1", "tactic_state": ""}]}
{"declaration": "example : TFAE [P, Q] := by\n  tfae_have \u27e8mp, mpr\u27e9 : 1 \u2194 2 := \u27e8pq, qp\u27e9\n  tfae_finish\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/tfae.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_have \u27e8mp, mpr\u27e9 : 1 \u2194 2 := \u27e8pq, qp\u27e9", "tactic_state": "P Q : Prop\nmp : P \u2192 Q\nmpr : Q \u2192 P\n\u22a2 [P, Q].TFAE"}, {"line": "  tfae_finish", "tactic_state": ""}]}
{"declaration": "example (a b c : G) : c*(a*b)*(b\u207b\u00b9*a\u207b\u00b9)*c = c*c := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na b c : G\n\u22a2 c * (a * b) * (b\u207b\u00b9 * a\u207b\u00b9) * c = c * c"}]}
{"declaration": "example (a b c : G) : (b*c\u207b\u00b9)*c*(a*b)*(b\u207b\u00b9*a\u207b\u00b9)*c = b*c := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na b c : G\n\u22a2 b * c\u207b\u00b9 * c * (a * b) * (b\u207b\u00b9 * a\u207b\u00b9) * c = b * c"}]}
{"declaration": "example (a b c : G) : c\u207b\u00b9*(b*c\u207b\u00b9)*c*(a*b)*(b\u207b\u00b9*a\u207b\u00b9*b\u207b\u00b9)*c = 1 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na b c : G\n\u22a2 c\u207b\u00b9 * (b * c\u207b\u00b9) * c * (a * b) * (b\u207b\u00b9 * a\u207b\u00b9 * b\u207b\u00b9) * c = 1"}]}
{"declaration": "example (g h k : G) : g*\u2045\u2045g\u207b\u00b9,h\u2046,k\u2046*g\u207b\u00b9*k*\u2045\u2045k\u207b\u00b9,g\u2046,h\u2046*k\u207b\u00b9*h*\u2045\u2045h\u207b\u00b9,k\u2046,g\u2046*h\u207b\u00b9 = 1 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\ng h k : G\n\u22a2 g * \u2045\u2045g\u207b\u00b9, h\u2046, k\u2046 * g\u207b\u00b9 * k * \u2045\u2045k\u207b\u00b9, g\u2046, h\u2046 * k\u207b\u00b9 * h * \u2045\u2045h\u207b\u00b9, k\u2046, g\u2046 * h\u207b\u00b9 = 1"}]}
{"declaration": "example (a : G) : a^2*a = a^3 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na : G\n\u22a2 a ^ 2 * a = a ^ 3"}]}
{"declaration": "example (n m : \u2115) (a : G) : a^n*a^m = a^(n+m) := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn m : \u2115\na : G\n\u22a2 a ^ n * a ^ m = a ^ (n + m)"}]}
{"declaration": "example (a b c : G) : c*(a*b^2)*((b*b)\u207b\u00b9*a\u207b\u00b9)*c = c*c := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na b c : G\n\u22a2 c * (a * b ^ 2) * ((b * b)\u207b\u00b9 * a\u207b\u00b9) * c = c * c"}]}
{"declaration": "example (n : \u2115) (a : G) : a^n*(a\u207b\u00b9)^n = 1 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn : \u2115\na : G\n\u22a2 a ^ n * a\u207b\u00b9 ^ n = 1"}]}
{"declaration": "example (a : G) : a^2*a\u207b\u00b9*a\u207b\u00b9 = 1 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na : G\n\u22a2 a ^ 2 * a\u207b\u00b9 * a\u207b\u00b9 = 1"}]}
{"declaration": "example (n m : \u2115) (a : G) : a^n*a^m = a^(m+n) := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn m : \u2115\na : G\n\u22a2 a ^ n * a ^ m = a ^ (m + n)"}]}
{"declaration": "example (n : \u2115) (a : G) : a^(n-n) = 1 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn : \u2115\na : G\n\u22a2 a ^ (n - n) = 1"}]}
{"declaration": "example (n : \u2124) (a : G) : a^(n-n) = 1 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn : \u2124\na : G\n\u22a2 a ^ (n - n) = 1"}]}
{"declaration": "example (n : \u2124) (a : G) (h : a ^ (n * (n + 1) - n - n ^ 2) = a) : a = 1 := by\n  group at h\n  exact h.symm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn : \u2124\na : G\nh : a ^ (n * (n + 1) - n - n ^ 2) = a\n\u22a2 a = 1"}, {"line": "  group at h", "tactic_state": "G : Type\ninst\u271d : Group G\nn : \u2124\na : G\nh : 1 = a\n\u22a2 a = 1"}, {"line": "  exact h.symm", "tactic_state": ""}]}
{"declaration": "example (a b c d : G) (h : c = (a * b ^ 2) * ((b * b)\u207b\u00b9 * a\u207b\u00b9) * d) : a*c*d\u207b\u00b9 = a := by\n  group at h\n  rw [h]\n  group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na b c d : G\nh : c = a * b ^ 2 * ((b * b)\u207b\u00b9 * a\u207b\u00b9) * d\n\u22a2 a * c * d\u207b\u00b9 = a"}, {"line": "  group at h", "tactic_state": "G : Type\ninst\u271d : Group G\na b c d : G\nh : c = d\n\u22a2 a * c * d\u207b\u00b9 = a"}, {"line": "  rw [h]", "tactic_state": "G : Type\ninst\u271d : Group G\na b c d : G\nh : c = d\n\u22a2 a * d * d\u207b\u00b9 = a"}, {"line": "  group", "tactic_state": ""}]}
{"declaration": "example (n m : \u2124) (a b : G) : a^(m-n)*b^(m-n)*b^(n-m)*a^(n-m) = 1 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn m : \u2124\na b : G\n\u22a2 a ^ (m - n) * b ^ (m - n) * b ^ (n - m) * a ^ (n - m) = 1"}]}
{"declaration": "example (n : \u2124) (a b : G) : a^n*b^n*a^n*a^n*a^(-n)*a^(-n)*b^(-n)*a^(-n) = 1 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn : \u2124\na b : G\n\u22a2 a ^ n * b ^ n * a ^ n * a ^ n * a ^ (-n) * a ^ (-n) * b ^ (-n) * a ^ (-n) = 1"}]}
{"declaration": "example (x y : G) : (x\u207b\u00b9 * (x * y) * y\u207b\u00b9)\u207b\u00b9 = 1 := by group\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nx y : G\n\u22a2 (x\u207b\u00b9 * (x * y) * y\u207b\u00b9)\u207b\u00b9 = 1"}]}
{"declaration": "example (x : G) (h : x = 1) : x = 1 := by\n  group\n  exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nx : G\nh : x = 1\n\u22a2 x = 1"}, {"line": "  group", "tactic_state": "G : Type\ninst\u271d : Group G\nx : G\nh : x = 1\n\u22a2 x = 1"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example (n : \u2115) : foo.rfl.toFun n = n := by rw [foo.rfl_toFun, id]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry = n"}]}
{"declaration": "example (n : \u2115) : foo.rfl.invFun n = n := by rw [foo.rfl_invFun]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry = n"}]}
{"declaration": "example : bar.1 = 1 := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar : x\u271d\n\u22a2 sorry = 1"}]}
{"declaration": "example {a : \u2115} {h : 1 = a} : bar.1 = a := by rw [bar_fst, h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar : x\u271d\na : \u2115\nh : 1 = a\n\u22a2 sorry = a"}]}
{"declaration": "example {a : \u2115} {h : 1 = a} : bar.1 = a := by simp; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar : x\u271d\na : \u2115\nh : 1 = a\n\u22a2 sorry = a"}]}
{"declaration": "example {a : \u2124} {h : 2 = a} : bar.2 = a := by simp; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar : x\u271d\na : \u2124\nh : 2 = a\n\u22a2 sorry = a"}]}
{"declaration": "example {a : \u2115} {h : 1 = a} : bar.1 = a := by dsimp; rw [h] -- check that dsimp also unfolds", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar : x\u271d\na : \u2115\nh : 1 = a\n\u22a2 sorry = a"}]}
{"declaration": "example {a : \u2124} {h : 2 = a} : bar.2 = a := by dsimp; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar : x\u271d\na : \u2124\nh : 2 = a\n\u22a2 sorry = a"}]}
{"declaration": "example {\u03b1} (x y : \u03b1) (h : x = y) : foo.rfl.toFun x = y := by simp; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx y : \u03b1\nh : x = y\n\u22a2 sorry = y"}]}
{"declaration": "example {\u03b1} (x y : \u03b1) (h : x = y) : foo.rfl.invFun x = y := by simp; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx y : \u03b1\nh : x = y\n\u22a2 sorry = y"}]}
{"declaration": "example {\u03b1} (x : \u03b1) : rfl2.toFun x = x \u2227 rfl2.invFun x = x := by\n  dsimp\n  guard_target = x = x \u2227 x = x\n  exact \u27e8rfl, rfl\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx : \u03b1\n\u22a2 sorry = x \u2227 sorry = x"}, {"line": "  dsimp", "tactic_state": "\u03b1 : Sort u_1\nx : \u03b1\n\u22a2 sorry () = x \u2227 sorry () = x"}, {"line": "  guard_target = x = x \u2227 x = x", "tactic_state": "\u03b1 : Sort u_1\nx : \u03b1\n\u22a2 sorry () = x \u2227 sorry () = x"}]}
{"declaration": "example {\u03b1} (x : \u03b1) : rfl2.toFun x = x \u2227 rfl2.invFun x = x := by\n  dsimp only [rfl2_toFun, rfl2_invFun]\n  guard_target = x = x \u2227 x = x\n  exact \u27e8rfl, rfl\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx : \u03b1\n\u22a2 sorry = x \u2227 sorry = x"}, {"line": "  dsimp only [rfl2_toFun, rfl2_invFun]", "tactic_state": "\u03b1 : Sort u_1\nx : \u03b1\n\u22a2 sorry = x \u2227 sorry = x"}]}
{"declaration": "example {\u03b1} {b : Bool} {x} (h : (\u27e83, 5\u27e9 : MyProd _ _) = x) : (@test \u03b1).extra b = x := by\n  dsimp\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nMyProd : x\u271d\u00b9\nx\u271d : Sort u_2\ntest : x\u271d\n\u03b1 : ?m.951\nb : Bool\nx : sorry\nh : sorry = x\n\u22a2 sorry = x"}, {"line": "  dsimp", "tactic_state": "x\u271d\u00b9 : Sort u_1\nMyProd : x\u271d\u00b9\nx\u271d : Sort u_2\ntest : x\u271d\n\u03b1 : ?m.951\nb : Bool\nx : sorry\nh : sorry = x\n\u22a2 sorry () = x"}, {"line": "  rw [h]", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type} (f : \u03b1 \u2243 \u03b2) (g : \u03b2 \u2243 \u03b3) (x : \u03b1) {z : \u03b3} (h : g.toFun (f.toFun x) = z) :\n  (f.trans g).toFun x = z := by\n  dsimp only [Equiv'.trans_toFun]\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\nf : \u03b1 \u2243 \u03b2\ng : \u03b2 \u2243 \u03b3\nx : \u03b1\nz : \u03b3\nh : g.toFun (f.toFun x) = z\n\u22a2 (f.trans g).toFun x = z"}, {"line": "  dsimp only [Equiv'.trans_toFun]", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\nf : \u03b1 \u2243 \u03b2\ng : \u03b2 \u2243 \u03b3\nx : \u03b1\nz : \u03b3\nh : g.toFun (f.toFun x) = z\n\u22a2 (f.trans g).toFun x = z"}]}
{"declaration": "example (n : \u2115) : myNatEquiv.toFun (myNatEquiv.toFun <| myNatEquiv.invFun n) = n := by\n  { /-successIfFail { rfl },-/ simp only [myNatEquiv_toFun, myNatEquiv_invFun] }\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry = n"}, {"line": "  { /-successIfFail { rfl },-/ simp only [myNatEquiv_toFun, myNatEquiv_invFun] }", "tactic_state": ""}]}
{"declaration": "example (X : Type u) {x : Type u} (h : (X \u2192 X) = x) : (X \u27f6 X) = x := by simp; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X x : Type u\nh : (X \u2192 X) = x\n\u22a2 (X \u27f6 X) = x"}]}
{"declaration": "example {x : Type} (h : \u2115 = x) : foo = x := by simp only [foo_c]; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo x : Type\nh : \u2115 = x\n\u22a2 foo = x"}]}
{"declaration": "example {x : \u2115} (h : (3 : \u2115) = x) : foo.x = x := by simp only [foo_x]; rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : 3 = x\n\u22a2 sorry = x"}]}
{"declaration": "example {x : Type} (h : \u2115 = x) : voo = x := by simp only [voo_c]; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "voo x : Type\nh : \u2115 = x\n\u22a2 voo = x"}]}
{"declaration": "example {x : \u2115} (h : (3 : \u2115) = x) : voo.x = x := by simp only [voo_x]; rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : 3 = x\n\u22a2 sorry = x"}]}
{"declaration": "example {\u03b1} (x x' : \u03b1) (h : x = x') : coercing.rfl2 x = x' := by rw [coercing.rfl2_toFun, h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx x' : \u03b1\nh : x = x'\n\u22a2 sorry = x'"}]}
{"declaration": "example {\u03b1} (x x' : \u03b1) (h : x = x') : coercing.rfl2 x = x' := by simp; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx x' : \u03b1\nh : x = x'\n\u22a2 sorry = x'"}]}
{"declaration": "example {\u03b1} (x x' : \u03b1) (h : x = x') : coercing.rfl2.invFun x = x' := by simp; rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx x' : \u03b1\nh : x = x'\n\u22a2 sorry = x'"}]}
{"declaration": "example {\u03b1 \u03b2} (f : Equiv2 \u03b1 \u03b2) (y : \u03b2) {x} (h : f.invFun y = x) : f.symm y = x := by simp; rw [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nEquiv2 : x\u271d\n\u03b1 : ?m.452\n\u03b2 : Sort u_2\nf : sorry\ny : \u03b2\nx : ?m.453 f y\nh : sorry = x\n\u22a2 sorry = x"}]}
{"declaration": "example {\u03b1 \u03b2} (f : Equiv2 \u03b1 \u03b2) (x : \u03b1) {z} (h : f x = z) : f.symm.invFun x = z := by simp; rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nEquiv2 : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : ?m.690\nf : sorry\nx : \u03b1\nz : ?m.691 f x\nh : sorry = z\n\u22a2 sorry = z"}]}
{"declaration": "example {\u03b1 \u03b2} (f : Equiv2 \u03b1 \u03b2) {x} (h : f = x) : f.symm3.invFun = x := by simp; rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nEquiv2 : x\u271d\n\u03b1 : ?m.444\n\u03b2 : ?m.445\nf x : sorry\nh : f = x\n\u22a2 sorry = x"}]}
{"declaration": "example {\u03b1 \u03b2} [Semigroup \u03b1] [Semigroup \u03b2] (x y : \u03b1 \u00d7 \u03b2) : x * y = (x.1 * y.1, x.2 * y.2) := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Semigroup \u03b1\ninst\u271d : Semigroup \u03b2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 x * y = (x.1 * y.1, x.2 * y.2)"}]}
{"declaration": "example {\u03b1 \u03b2} [Semigroup \u03b1] [Semigroup \u03b2] (x y : \u03b1 \u00d7 \u03b2) : (x * y).1 = x.1 * y.1 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Semigroup \u03b1\ninst\u271d : Semigroup \u03b2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 (x * y).1 = x.1 * y.1"}]}
{"declaration": "example (x : \u2115) : x * - 0 \u2286 - x := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 sorry \u2286 sorry"}]}
{"declaration": "example (x : \u2115) : x * - 0 \u2286 - x := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 sorry \u2286 sorry"}]}
{"declaration": "example (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) (x : \u03b3) {z} (h : e\u2081.symm (e\u2082.symm x) = z) :\n    (e\u2081.trans e\u2082).symm x = z := by\n  simp only [Equiv.trans_invFun]; rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b3\nz : \u03b1\nh : e\u2081.symm (e\u2082.symm x) = z\n\u22a2 (e\u2081.trans e\u2082).symm x = z"}, {"line": "  simp only [Equiv.trans_invFun]; rw [h]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b3\nz : \u03b1\nh : e\u2081.symm (e\u2082.symm x) = z\n\u22a2 (e\u2081.trans e\u2082).symm x = z"}]}
{"declaration": "example (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) (x : \u03b3) {z} (h : e\u2081.symm (e\u2082.symm x) = z) :\n    (e\u2081.trans e\u2082).symm x = z := by\n  simp only [Equiv.trans_invFun]; rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Sort ?u.56\n\u03b2\u271d\u00b9 : Sort ?u.59\n\u03b3\u271d\u00b9 : Sort ?u.62\n\u03b1\u271d : Sort ?u.65\n\u03b2\u271d : Sort ?u.68\n\u03b3\u271d : Sort ?u.71\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b3\nz : \u03b1\nh : e\u2081.symm (e\u2082.symm x) = z\n\u22a2 (e\u2081.trans e\u2082).symm x = z"}, {"line": "  simp only [Equiv.trans_invFun]; rw [h]", "tactic_state": "\u03b1\u271d\u00b9 : Sort ?u.56\n\u03b2\u271d\u00b9 : Sort ?u.59\n\u03b3\u271d\u00b9 : Sort ?u.62\n\u03b1\u271d : Sort ?u.65\n\u03b2\u271d : Sort ?u.68\n\u03b3\u271d : Sort ?u.71\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b3\nz : \u03b1\nh : e\u2081.symm (e\u2082.symm x) = z\n\u22a2 (e\u2081.trans e\u2082).symm x = z"}]}
{"declaration": "example (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) (x : \u03b1) {z} (h : e\u2082 (e\u2081 x) = z) : (e\u2081.trans e\u2082) x = z := by\n  simp only [Equiv.trans_apply]; rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2074 : Sort ?u.191\n\u03b2\u271d\u2074 : Sort ?u.194\n\u03b3\u271d\u2074 : Sort ?u.197\n\u03b1\u271d\u00b3 : Sort ?u.200\n\u03b2\u271d\u00b3 : Sort ?u.203\n\u03b3\u271d\u00b3 : Sort ?u.206\n\u03b1\u271d\u00b2 : Sort ?u.209\n\u03b2\u271d\u00b2 : Sort ?u.212\n\u03b3\u271d\u00b2 : Sort ?u.215\n\u03b1\u271d\u00b9 : Sort ?u.218\n\u03b2\u271d\u00b9 : Sort ?u.221\n\u03b3\u271d\u00b9 : Sort ?u.224\n\u03b1\u271d : Sort ?u.227\n\u03b2\u271d : Sort ?u.230\n\u03b3\u271d : Sort ?u.233\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b1\nz : \u03b3\nh : e\u2082 (e\u2081 x) = z\n\u22a2 (e\u2081.trans e\u2082) x = z"}, {"line": "  simp only [Equiv.trans_apply]; rw [h]", "tactic_state": "\u03b1\u271d\u2074 : Sort ?u.191\n\u03b2\u271d\u2074 : Sort ?u.194\n\u03b3\u271d\u2074 : Sort ?u.197\n\u03b1\u271d\u00b3 : Sort ?u.200\n\u03b2\u271d\u00b3 : Sort ?u.203\n\u03b3\u271d\u00b3 : Sort ?u.206\n\u03b1\u271d\u00b2 : Sort ?u.209\n\u03b2\u271d\u00b2 : Sort ?u.212\n\u03b3\u271d\u00b2 : Sort ?u.215\n\u03b1\u271d\u00b9 : Sort ?u.218\n\u03b2\u271d\u00b9 : Sort ?u.221\n\u03b3\u271d\u00b9 : Sort ?u.224\n\u03b1\u271d : Sort ?u.227\n\u03b2\u271d : Sort ?u.230\n\u03b3\u271d : Sort ?u.233\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b1\nz : \u03b3\nh : e\u2082 (e\u2081 x) = z\n\u22a2 e\u2082 (e\u2081 x) = z"}]}
{"declaration": "example (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) (x : \u03b3) {z} (h : e\u2081.symm (e\u2082.symm x) = z) :\n    (e\u2081.trans e\u2082).symm x = z := by\n  simp only [Equiv.trans_symm_apply]; rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2074 : Sort ?u.191\n\u03b2\u271d\u2074 : Sort ?u.194\n\u03b3\u271d\u2074 : Sort ?u.197\n\u03b1\u271d\u00b3 : Sort ?u.200\n\u03b2\u271d\u00b3 : Sort ?u.203\n\u03b3\u271d\u00b3 : Sort ?u.206\n\u03b1\u271d\u00b2 : Sort ?u.209\n\u03b2\u271d\u00b2 : Sort ?u.212\n\u03b3\u271d\u00b2 : Sort ?u.215\n\u03b1\u271d\u00b9 : Sort ?u.218\n\u03b2\u271d\u00b9 : Sort ?u.221\n\u03b3\u271d\u00b9 : Sort ?u.224\n\u03b1\u271d : Sort ?u.227\n\u03b2\u271d : Sort ?u.230\n\u03b3\u271d : Sort ?u.233\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b3\nz : \u03b1\nh : e\u2081.symm (e\u2082.symm x) = z\n\u22a2 (e\u2081.trans e\u2082).symm x = z"}, {"line": "  simp only [Equiv.trans_symm_apply]; rw [h]", "tactic_state": "\u03b1\u271d\u2074 : Sort ?u.191\n\u03b2\u271d\u2074 : Sort ?u.194\n\u03b3\u271d\u2074 : Sort ?u.197\n\u03b1\u271d\u00b3 : Sort ?u.200\n\u03b2\u271d\u00b3 : Sort ?u.203\n\u03b3\u271d\u00b3 : Sort ?u.206\n\u03b1\u271d\u00b2 : Sort ?u.209\n\u03b2\u271d\u00b2 : Sort ?u.212\n\u03b3\u271d\u00b2 : Sort ?u.215\n\u03b1\u271d\u00b9 : Sort ?u.218\n\u03b2\u271d\u00b9 : Sort ?u.221\n\u03b3\u271d\u00b9 : Sort ?u.224\n\u03b1\u271d : Sort ?u.227\n\u03b2\u271d : Sort ?u.230\n\u03b3\u271d : Sort ?u.233\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b3\nz : \u03b1\nh : e\u2081.symm (e\u2082.symm x) = z\n\u22a2 (e\u2081.trans e\u2082).symm x = z"}]}
{"declaration": "example (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) (x : \u03b1) {z} (h : e\u2082 (e\u2081 x) = z) : (e\u2081.trans e\u2082) x = z := by\n  simp only [Equiv.coe_trans]\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b1\nz : \u03b3\nh : e\u2082 (e\u2081 x) = z\n\u22a2 (e\u2081.trans e\u2082) x = z"}, {"line": "  simp only [Equiv.coe_trans]", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b1\nz : \u03b3\nh : e\u2082 (e\u2081 x) = z\n\u22a2 (\u21d1e\u2082 \u2218 \u21d1e\u2081) x = z"}, {"line": "  rw [h]", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b2 \u2243 \u03b3\nx : \u03b1\nz : \u03b3\nh : e\u2082 (e\u2081 x) = z\n\u22a2 (\u21d1e\u2082 \u2218 \u21d1e\u2081) x = z"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4 : Type _} (x : \u03b1) (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b3 \u2243 \u03b4) (z : \u03b1 \u00d7 \u03b3) {y} (h : e\u2081 z.1 = y) :\n    ((foo x e\u2081 e\u2082).2 z).1 = y := by\n  simp only [coe_foo_snd_fst]\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.254\n\u03b2\u271d\u2076 : Sort ?u.257\n\u03b3\u271d\u2076 : Sort ?u.260\n\u03b1\u271d\u2075 : Sort ?u.263\n\u03b2\u271d\u2075 : Sort ?u.266\n\u03b3\u271d\u2075 : Sort ?u.269\n\u03b1\u271d\u2074 : Sort ?u.272\n\u03b2\u271d\u2074 : Sort ?u.275\n\u03b3\u271d\u2074 : Sort ?u.278\n\u03b1\u271d\u00b3 : Sort ?u.281\n\u03b2\u271d\u00b3 : Sort ?u.284\n\u03b3\u271d\u00b3 : Sort ?u.287\n\u03b1\u271d\u00b2 : Sort ?u.290\n\u03b2\u271d\u00b2 : Sort ?u.293\n\u03b3\u271d\u00b2 : Sort ?u.296\n\u03b1\u271d\u00b9 : Sort ?u.299\n\u03b2\u271d\u00b9 : Sort ?u.302\n\u03b3\u271d\u00b9 : Sort ?u.305\n\u03b1\u271d : Sort ?u.308\n\u03b2\u271d : Sort ?u.311\n\u03b3\u271d : Sort ?u.314\nx\u271d : Sort u_1\nfoo : x\u271d\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nx : \u03b1\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b3 \u2243 \u03b4\nz : \u03b1 \u00d7 \u03b3\ny : \u03b2\nh : e\u2081 z.1 = y\n\u22a2 sorry = y"}, {"line": "  simp only [coe_foo_snd_fst]", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.254\n\u03b2\u271d\u2076 : Sort ?u.257\n\u03b3\u271d\u2076 : Sort ?u.260\n\u03b1\u271d\u2075 : Sort ?u.263\n\u03b2\u271d\u2075 : Sort ?u.266\n\u03b3\u271d\u2075 : Sort ?u.269\n\u03b1\u271d\u2074 : Sort ?u.272\n\u03b2\u271d\u2074 : Sort ?u.275\n\u03b3\u271d\u2074 : Sort ?u.278\n\u03b1\u271d\u00b3 : Sort ?u.281\n\u03b2\u271d\u00b3 : Sort ?u.284\n\u03b3\u271d\u00b3 : Sort ?u.287\n\u03b1\u271d\u00b2 : Sort ?u.290\n\u03b2\u271d\u00b2 : Sort ?u.293\n\u03b3\u271d\u00b2 : Sort ?u.296\n\u03b1\u271d\u00b9 : Sort ?u.299\n\u03b2\u271d\u00b9 : Sort ?u.302\n\u03b3\u271d\u00b9 : Sort ?u.305\n\u03b1\u271d : Sort ?u.308\n\u03b2\u271d : Sort ?u.311\n\u03b3\u271d : Sort ?u.314\nx\u271d : Sort u_1\nfoo : x\u271d\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nx : \u03b1\ne\u2081 : \u03b1 \u2243 \u03b2\ne\u2082 : \u03b3 \u2243 \u03b4\nz : \u03b1 \u00d7 \u03b3\ny : \u03b2\nh : e\u2081 z.1 = y\n\u22a2 sorry = y"}]}
{"declaration": "example {x : Set \u2115} (h : Set.univ = x) : Nat.SetPlus1.s = x := by\n  dsimp only [Nat.SetPlus1_s]\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort ?u.308\n\u03b2 : Sort ?u.311\n\u03b3 : Sort ?u.314\nx : Set \u2115\nh : Set.univ = x\n\u22a2 sorry = x"}, {"line": "  dsimp only [Nat.SetPlus1_s]", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort ?u.308\n\u03b2 : Sort ?u.311\n\u03b3 : Sort ?u.314\nx : Set \u2115\nh : Set.univ = x\n\u22a2 sorry = x"}]}
{"declaration": "example {x : Set \u2115} (h : Set.univ = x) : Nat.SetPlus2.s = x := by\n  fail_if_success { rw [h] }\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort ?u.308\n\u03b2 : Sort ?u.311\n\u03b3 : Sort ?u.314\nx : Set \u2115\nh : Set.univ = x\n\u22a2 sorry = x"}, {"line": "  fail_if_success { rw [h] }", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort ?u.308\n\u03b2 : Sort ?u.311\n\u03b3 : Sort ?u.314\nx : Set \u2115\nh : Set.univ = x\n\u22a2 sorry = x"}, {"line": "  exact h", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort ?u.308\n\u03b2 : Sort ?u.311\n\u03b3 : Sort ?u.314\nx : Set \u2115\nh : Set.univ = x\n\u22a2 sorry = x"}]}
{"declaration": "example {x : Set \u2115} (h : Set.univ = x) : Nat.SetPlus3.s = x := by\n  dsimp only [Nat.SetPlus3_s]\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort ?u.308\n\u03b2 : Sort ?u.311\n\u03b3 : Sort ?u.314\nx : Set \u2115\nh : Set.univ = x\n\u22a2 sorry = x"}, {"line": "  dsimp only [Nat.SetPlus3_s]", "tactic_state": "\u03b1\u271d\u2075 : Sort ?u.254\n\u03b2\u271d\u2075 : Sort ?u.257\n\u03b3\u271d\u2075 : Sort ?u.260\n\u03b1\u271d\u2074 : Sort ?u.263\n\u03b2\u271d\u2074 : Sort ?u.266\n\u03b3\u271d\u2074 : Sort ?u.269\n\u03b1\u271d\u00b3 : Sort ?u.272\n\u03b2\u271d\u00b3 : Sort ?u.275\n\u03b3\u271d\u00b3 : Sort ?u.278\n\u03b1\u271d\u00b2 : Sort ?u.281\n\u03b2\u271d\u00b2 : Sort ?u.284\n\u03b3\u271d\u00b2 : Sort ?u.287\n\u03b1\u271d\u00b9 : Sort ?u.290\n\u03b2\u271d\u00b9 : Sort ?u.293\n\u03b3\u271d\u00b9 : Sort ?u.296\n\u03b1\u271d : Sort ?u.299\n\u03b2\u271d : Sort ?u.302\n\u03b3\u271d : Sort ?u.305\n\u03b1 : Sort ?u.308\n\u03b2 : Sort ?u.311\n\u03b3 : Sort ?u.314\nx : Set \u2115\nh : Set.univ = x\n\u22a2 sorry = x"}]}
{"declaration": "example (e : \u03b1 \u2243 \u03b2) {x : \u03b2 \u2192 \u03b1} (h : e.invFun = x) : (Equiv.symm2.invFun e).toFun = x := by\n  dsimp only [Equiv.symm2_invFun_toFun]\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort ?u.395\ne : \u03b1 \u2243 \u03b2\nx : \u03b2 \u2192 \u03b1\nh : e.invFun = x\n\u22a2 sorry = x"}, {"line": "  dsimp only [Equiv.symm2_invFun_toFun]", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort ?u.395\ne : \u03b1 \u2243 \u03b2\nx : \u03b2 \u2192 \u03b1\nh : e.invFun = x\n\u22a2 sorry = x"}]}
{"declaration": "example (x : Bool) {z} (h : id x = z) : myAlgHom x = z := by\n  simp only [myAlgHom_toFun]\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nx\u271d : Sort u_1\nmyAlgHom : x\u271d\nx z : Bool\nh : id x = z\n\u22a2 sorry = z"}, {"line": "  simp only [myAlgHom_toFun]", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nx\u271d : Sort u_1\nmyAlgHom : x\u271d\nx z : Bool\nh : id x = z\n\u22a2 sorry = z"}]}
{"declaration": "example (x : Bool) {z} (h : id x = z) : myRingHom x = z := by\n  simp only [myRingHom_toFun]\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nx\u271d : Sort u_1\nmyRingHom : x\u271d\nx z : Bool\nh : id x = z\n\u22a2 sorry = z"}, {"line": "  simp only [myRingHom_toFun]", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nx\u271d : Sort u_1\nmyRingHom : x\u271d\nx z : Bool\nh : id x = z\n\u22a2 sorry = z"}]}
{"declaration": "example {M N} [Mul M] [Mul N] (p q : M \u00d7 N) : p * q = \u27e8p.1 * q.1, p.2 * q.2\u27e9 := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : Mul M\ninst\u271d : Mul N\np q : M \u00d7 N\n\u22a2 p * q = (p.1 * q.1, p.2 * q.2)"}]}
{"declaration": "example {M N} [Add M] [Add N] (p q : M \u00d7 N) : p + q = \u27e8p.1 + q.1, p.2 + q.2\u27e9 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : Add M\ninst\u271d : Add N\np q : M \u00d7 N\n\u22a2 p + q = (p.1 + q.1, p.2 + q.2)"}]}
{"declaration": "example {M N} [One M] [One N] : (1 : M \u00d7 N) = \u27e81, 1\u27e9 := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : One M\ninst\u271d : One N\n\u22a2 1 = (1, 1)"}]}
{"declaration": "example {M N} [Zero M] [Zero N] : (0 : M \u00d7 N) = \u27e80, 0\u27e9 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : Zero M\ninst\u271d : Zero N\n\u22a2 0 = (0, 0)"}]}
{"declaration": "example (f : \u03b1 \u2192 \u03b2) (L M : List \u03b1) : (L ++ M).map f = L.map f ++ M.map f := by\n  rw?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nL M : List \u03b1\n\u22a2 List.map f (L ++ M) = List.map f L ++ List.map f M"}, {"line": "  rw?", "tactic_state": ""}]}
{"declaration": "example [Category C] {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) : f \u226b \ud835\udfd9 _ \u226b g = f \u226b g := by\n  rw?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 f \u226b \ud835\udfd9 Y \u226b g = f \u226b g"}, {"line": "  rw?", "tactic_state": ""}]}
{"declaration": "example [Group G] (h : G) : 1 * h = h := by\n  rw? [-mul_left_eq_self] -- exclude deprecated name for mul_eq_right, it is found first otherwise\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nh : G\n\u22a2 1 * h = h"}, {"line": "  rw? [-mul_left_eq_self] -- exclude deprecated name for mul_eq_right, it is found first otherwise", "tactic_state": ""}]}
{"declaration": "example [Group G] (h : G) (hyp : g * 1 = h) : g = h := by\n  rw? at hyp\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ng : G\ninst\u271d : Group G\nh : G\nhyp : g * 1 = h\n\u22a2 g = h"}, {"line": "  rw? at hyp", "tactic_state": "G : Type u_1\ng : G\ninst\u271d : Group G\nh : G\nhyp : g = h\n\u22a2 g = h"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example : \u2200 (x y : \u2115), x \u2264 y := by\n  intros x y\n  rw? -- Used to be an error here https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/panic.20and.20error.20with.20rw.3F/near/370495531\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (x y : \u2115), x \u2264 y"}, {"line": "  intros x y", "tactic_state": "x y : \u2115\n\u22a2 x \u2264 y"}, {"line": "  rw? -- Used to be an error here https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/panic.20and.20error.20with.20rw.3F/near/370495531", "tactic_state": "x y : \u2115\n\u22a2 \u2191x \u2264 \u2191y"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : \u2200 (x y : \u2115), x \u2264 y := by\n  -- Used to be a panic here https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/panic.20and.20error.20with.20rw.3F/near/370495531\n  success_if_fail_with_msg \"Could not find any lemmas which can rewrite the goal\" rw?\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (x y : \u2115), x \u2264 y"}, {"line": "  -- Used to be a panic here https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/panic.20and.20error.20with.20rw.3F/near/370495531", "tactic_state": "\u22a2 \u2200 (x y : \u2115), x \u2264 y"}, {"line": "  success_if_fail_with_msg \"Could not find any lemmas which can rewrite the goal\" rw?", "tactic_state": ""}]}
{"declaration": "example : foo x = 1 \u2194 \u2203 k : \u2124, x = k := by\n  rw? -- Used to panic, see https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/panic.20and.20error.20with.20rw.3F/near/370598036\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfoo : x\u271d\nx : \u2124\n\u22a2 sorry = 1 \u2194 \u2203 k, x = k"}, {"line": "  rw? -- Used to panic, see https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/panic.20and.20error.20with.20rw.3F/near/370598036", "tactic_state": "x\u271d : Sort u_1\nfoo : x\u271d\nx : \u2124\n\u22a2 (\u2200 (p : \u2115), Nat.Prime p \u2192 \u00acp \u2223 sorry) \u2194 \u2203 k, x = k"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : \u2200 (x : \u2115), x \u2264 6 := by\n  rw?\n  guard_target = \u2200 (x : \u2115), x \u2264 7\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (x : \u2115), x \u2264 6"}, {"line": "  rw?", "tactic_state": "\u22a2 \u2200 (x : \u2115), x \u2264 6.num"}, {"line": "  guard_target = \u2200 (x : \u2115), x \u2264 7", "tactic_state": "\u22a2 \u2200 (x : \u2115), x \u2264 6.num"}]}
{"declaration": "example : \u2200 (x : \u2115) (_w : x \u2264 6), x \u2264 8 := by\n  rw?\n  guard_target = \u2200 (x : \u2115) (_w : x \u2264 7), x \u2264 8\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 x \u2264 6, x \u2264 8"}, {"line": "  rw?", "tactic_state": "\u22a2 \u2200 x \u2264 6.num, x \u2264 8"}, {"line": "  guard_target = \u2200 (x : \u2115) (_w : x \u2264 7), x \u2264 8", "tactic_state": "\u22a2 \u2200 x \u2264 6.num, x \u2264 8"}]}
{"declaration": "example (n : \u2115) : let y := 3; n + y = 3 + n := by\n  rw?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 let y := 3;\n  n + y = 3 + n"}, {"line": "  rw?", "tactic_state": ""}]}
{"declaration": "lemma test : f n = f m := by\n  fail_if_success rw? [-f_eq] -- Check that we can forbid lemmas.\n  rw?\n  rw [f_eq]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\n\u22a2 sorry = sorry"}, {"line": "  fail_if_success rw? [-f_eq] -- Check that we can forbid lemmas.", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\n\u22a2 sorry = sorry"}, {"line": "  rw?", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\n\u22a2 sorry = sorry"}]}
{"declaration": "example (h : 1 = 2) : 2 = 1 := by\n  rw?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 1 = 2\n\u22a2 2 = 1"}, {"line": "  rw?", "tactic_state": ""}]}
{"declaration": "example : testConst = 4 := by\n  rw?\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "testConst : \u2115\n\u22a2 testConst = 4"}, {"line": "  rw?", "tactic_state": "testConst : \u2115\n\u22a2 \u2191testConst = \u21914"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example {P : Prop} (p : P) (h : P \u2192 1 = 2) : 2 = 1 := by\n  rw?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Prop\np : P\nh : P \u2192 1 = 2\n\u22a2 2 = 1"}, {"line": "  rw?", "tactic_state": ""}]}
{"declaration": "example {P Q : Prop} (p : P) (f : P \u2192 Q) (h : Q \u2192 1 = 2) : 2 = 1 := by\n  rw?\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\nh : Q \u2192 1 = 2\n\u22a2 2 = 1"}, {"line": "  rw?", "tactic_state": ""}]}
{"declaration": "example {P : Prop} (p : P) (Q : \u03b1 \u2192 Prop) (a b : \u03b1) (h\u2081 : P \u2192 a = b) (w : Q a) : Q b := by\n  rw?\n  exact w", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rewrites.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nP : Prop\np : P\nQ : \u03b1 \u2192 Prop\na b : \u03b1\nh\u2081 : P \u2192 a = b\nw : Q a\n\u22a2 Q b"}, {"line": "  rw?", "tactic_state": "\u03b1 : Sort u_1\nP : Prop\np : P\nQ : \u03b1 \u2192 Prop\na b : \u03b1\nh\u2081 : P \u2192 a = b\nw : Q a\n\u22a2 Q a"}, {"line": "  exact w", "tactic_state": ""}]}
{"declaration": "example (a b : Nat) : a = b \u2192 b = a := by intros; symm; assumption", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/symm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a = b \u2192 b = a"}]}
{"declaration": "example (a b : Nat) : a = b \u2192 True \u2192 b = a := by intro h _; symm at h; assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/symm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a = b \u2192 True \u2192 b = a"}]}
{"declaration": "example (a b : Nat) : sameParity a b \u2192 sameParity b a := by intros; symm; assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/symm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.7\nsameParity : x\u271d\na b : \u2115\n\u22a2 sorry \u2192 sorry"}]}
{"declaration": "example (a b c : Nat) (ab : a = b) (bc : b = c) : c = a := by\n  symm_saturate\n  -- Run twice to check that we don't add repeated copies.\n  -- Unfortunately `guard_hyp_nums` doesn't seem to work so I haven't made an assertion.\n  symm_saturate\n  apply Eq.trans <;> assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/symm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nab : a = b\nbc : b = c\n\u22a2 c = a"}, {"line": "  symm_saturate", "tactic_state": "a b c : \u2115\nab : a = b\nbc : b = c\nab_symm : b = a\nbc_symm : c = b\n\u22a2 c = a"}, {"line": "  -- Run twice to check that we don't add repeated copies.", "tactic_state": "a b c : \u2115\nab : a = b\nbc : b = c\nab_symm : b = a\nbc_symm : c = b\n\u22a2 c = a"}, {"line": "  -- Unfortunately `guard_hyp_nums` doesn't seem to work so I haven't made an assertion.", "tactic_state": ""}]}
{"declaration": "example {n m : Nat} (h : MyEq n m) : MyEq m n := by\n  symm\n  assumption", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/symm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.6\nMyEq : x\u271d\nn m : \u2115\nh : sorry\n\u22a2 sorry"}, {"line": "  symm", "tactic_state": "x\u271d : Sort ?u.6\nMyEq : x\u271d\nn m : \u2115\nh : sorry\n\u22a2 sorry"}]}
{"declaration": "example (h : 0 + 1 = 0) : False := by\n  change 1 = 0 at h\n  simp at h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnusedTactic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 + 1 = 0\n\u22a2 False"}, {"line": "  change 1 = 0 at h", "tactic_state": "h : 1 = 0\n\u22a2 False"}, {"line": "  simp at h", "tactic_state": ""}]}
{"declaration": "example : 0 + 1 = 1 := by\n  change 1 = 1\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnusedTactic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 + 1 = 1"}, {"line": "  change 1 = 1", "tactic_state": "\u22a2 1 = 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : 1 = 1 := by\n  change 1 = 1\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnusedTactic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 = 1"}, {"line": "  change 1 = 1", "tactic_state": "\u22a2 1 = 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : True := by\n  #adaptation_note /-- hi -/\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnusedTactic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  #adaptation_note /-- hi -/", "tactic_state": "\u22a2 True"}, {"line": "  exact .intro", "tactic_state": ""}]}
{"declaration": "example : True \u2227 True := by\n  constructor <;> trivial;\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnusedTactic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True \u2227 True"}, {"line": "  constructor <;> trivial;", "tactic_state": ""}]}
{"declaration": "example : True := by\n  congr\n  constructor\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnusedTactic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  congr", "tactic_state": "\u22a2 True"}, {"line": "  constructor", "tactic_state": ""}, {"line": "  done", "tactic_state": ""}]}
{"declaration": "example : True := by\n  skip\n  constructor\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnusedTactic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  skip", "tactic_state": "\u22a2 True"}, {"line": "  constructor", "tactic_state": ""}, {"line": "  done", "tactic_state": ""}]}
{"declaration": "example {R : Type u} [Semiring R] {p : Polynomial R} [Subsingleton R] :\n    Polynomial.degree p = \u22a5 := by\n  rw_search [-Polynomial.degree_of_subsingleton]\n  -- Mathlib proof:\n  -- rw [Subsingleton.elim p 0, degree_zero]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\np : R[X]\ninst\u271d : Subsingleton R\n\u22a2 p.degree = \u22a5"}, {"line": "  rw_search [-Polynomial.degree_of_subsingleton]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\np : R[X]\ninst\u271d : Subsingleton R\n\u22a2 p.degree = \u22a5"}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example {R : Type u} {a : R} [Semiring R] (n : \u2115) (ha : a \u2260 0) :\n    Polynomial.degree (Polynomial.C a * Polynomial.X ^ n) = n := by\n  rw_search [-Polynomial.degree_C_mul_X_pow]\n  -- Mathlib proof:\n  -- rw [C_mul_X_pow_eq_monomial, degree_monomial n ha]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na : R\ninst\u271d : Semiring R\nn : \u2115\nha : a \u2260 0\n\u22a2 (C a * X ^ n).degree = \u2191n"}, {"line": "  rw_search [-Polynomial.degree_C_mul_X_pow]", "tactic_state": ""}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example {R : Type u} [Semiring R] {p q : Polynomial R}\n    (h : Polynomial.degree p < Polynomial.degree q) :\n    Polynomial.degree (p + q) = Polynomial.degree q := by\n  rw_search [-Polynomial.degree_add_eq_right_of_degree_lt]\n  -- Mathlib proof:\n  -- rw [add_comm, degree_add_eq_left_of_degree_lt h]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : R[X]\nh : p.degree < q.degree\n\u22a2 (p + q).degree = q.degree"}, {"line": "  rw_search [-Polynomial.degree_add_eq_right_of_degree_lt]", "tactic_state": ""}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example {R : Type u} [Semiring R] (a : R) (n : \u2115) :\n    Polynomial.leadingCoeff (Polynomial.C a * Polynomial.X ^ n) = a := by\n  rw_search [-Polynomial.leadingCoeff_C_mul_X_pow]\n  -- Mathlib proof:\n  -- rw [C_mul_X_pow_eq_monomial, leadingCoeff_monomial]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 (C a * X ^ n).leadingCoeff = a"}, {"line": "  rw_search [-Polynomial.leadingCoeff_C_mul_X_pow]", "tactic_state": ""}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example {R : Type u} [Semiring R] {p : Polynomial R}\n    (h : Finset.card (Polynomial.support p) \u2264 1) :\n    Polynomial.C (Polynomial.leadingCoeff p) * Polynomial.X ^ Polynomial.natDegree p = p := by\n  rw_search [-Polynomial.C_mul_X_pow_eq_self]\n  -- Mathlib proof:\n  -- rw [C_mul_X_pow_eq_monomial, monomial_natDegree_leadingCoeff_eq_self h]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : R[X]\nh : p.support.card \u2264 1\n\u22a2 C p.leadingCoeff * X ^ p.natDegree = p"}, {"line": "  rw_search [-Polynomial.C_mul_X_pow_eq_self]", "tactic_state": ""}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example {R : Type u} {a b : R} [Semiring R] (ha : a \u2260 0) :\n    Polynomial.natDegree (Polynomial.C a * Polynomial.X + Polynomial.C b) = 1 := by\n  rw_search [-Polynomial.natDegree_linear]\n  -- Mathlib proof:\n  -- rw [natDegree_add_C, natDegree_C_mul_X a ha]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na b : R\ninst\u271d : Semiring R\nha : a \u2260 0\n\u22a2 (C a * X + C b).natDegree = 1"}, {"line": "  rw_search [-Polynomial.natDegree_linear]", "tactic_state": ""}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example {R : Type u} [Ring R] [Nontrivial R] (x : R) :\n    Polynomial.natDegree (Polynomial.X - Polynomial.C x) = 1 := by\n  rw_search [-Polynomial.natDegree_X_sub_C]\n  -- Mathlib proof:\n  -- rw [natDegree_sub_C, natDegree_X]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\ninst\u271d : Nontrivial R\nx : R\n\u22a2 (X - C x).natDegree = 1"}, {"line": "  rw_search [-Polynomial.natDegree_X_sub_C]", "tactic_state": ""}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example {S : Type v} [Ring S] (c : S) :\n    Polynomial.nextCoeff (Polynomial.X - Polynomial.C c) = -c := by\n  rw_search\n  -- Mathlib proof:\n  -- rw [sub_eq_add_neg, \u2190 map_neg C c, nextCoeff_X_add_C]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type v\ninst\u271d : Ring S\nc : S\n\u22a2 (X - C c).nextCoeff = -c"}, {"line": "  rw_search", "tactic_state": ""}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example {R : Type u} [Ring R] [Nontrivial R] {n : \u2115} (hn : 0 < n) (a : R) :\n    Polynomial.degree (Polynomial.X ^ n - Polynomial.C a) = n := by\n  rw_search [-Polynomial.degree_X_pow_sub_C]\n  -- Mathlib proof:\n  -- rw [sub_eq_add_neg, \u2190 map_neg C a, degree_X_pow_add_C hn]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\ninst\u271d : Nontrivial R\nn : \u2115\nhn : 0 < n\na : R\n\u22a2 (X ^ n - C a).degree = \u2191n"}, {"line": "  rw_search [-Polynomial.degree_X_pow_sub_C]", "tactic_state": ""}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example {R : Type u} [Ring R] [Nontrivial R] {n : \u2115} {r : R} :\n    Polynomial.natDegree (Polynomial.X ^ n - Polynomial.C r) = n := by\n  rw_search [-Polynomial.natDegree_X_pow_sub_C]\n  -- Mathlib proof:\n  -- rw [sub_eq_add_neg, \u2190 map_neg C r, natDegree_X_pow_add_C]\n  done\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Polynomial.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\ninst\u271d : Nontrivial R\nn : \u2115\nr : R\n\u22a2 (X ^ n - C r).natDegree = n"}, {"line": "  rw_search [-Polynomial.natDegree_X_pow_sub_C]", "tactic_state": ""}, {"line": "  -- Mathlib proof:", "tactic_state": ""}]}
{"declaration": "example (xs ys : List \u03b1) : (xs ++ ys).length = ys.length + xs.length := by\n  rw_search\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/RewriteSearch/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nxs ys : List \u03b1\n\u22a2 (xs ++ ys).length = ys.length + xs.length"}, {"line": "  rw_search", "tactic_state": ""}]}
{"declaration": "example : 0 < 1 := by exact?", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/mathlib.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 < 1"}]}
{"declaration": "example (x y : Nat) : True := by\n  observe? h : x + y = y + x\n  guard_hyp h : x + y = y + x\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/observe.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 True"}, {"line": "  observe? h : x + y = y + x", "tactic_state": "x y : \u2115\nh : x + y = y + x\n\u22a2 True"}, {"line": "  guard_hyp h : x + y = y + x", "tactic_state": "x y : \u2115\nh : x + y = y + x\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (x : Nat) : x \u2260 x.succ := ne_of_lt (by apply?)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 x < x.succ"}]}
{"declaration": "example : 0 \u2260 1 + 1 := ne_of_lt (by apply?)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 < 1 + 1"}]}
{"declaration": "example (x y : Nat) : x + y = y + x := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x + y = y + x"}]}
{"declaration": "example (n m k : Nat) : n \u2264 m \u2192 n + k \u2264 m + k := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m k : \u2115\n\u22a2 n \u2264 m \u2192 n + k \u2264 m + k"}]}
{"declaration": "example (_ha : a > 0) (w : b \u2223 c) : a * b \u2223 a * c := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n_ha : a > 0\nw : b \u2223 c\n\u22a2 a * b \u2223 a * c"}]}
{"declaration": "example : Int := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2124"}]}
{"declaration": "example (P : Prop) (p : P) : P := by apply?", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Prop\np : P\n\u22a2 P"}]}
{"declaration": "example (P : Prop) (p : P) (np : \u00acP) : false := by apply?", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Prop\np : P\nnp : \u00acP\n\u22a2 false = true"}]}
{"declaration": "example (X : Type) (P : Prop) (x : X) (h : \u2200 x : X, x = x \u2192 P) : P := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type\nP : Prop\nx : X\nh : \u2200 (x : X), x = x \u2192 P\n\u22a2 P"}]}
{"declaration": "example (\u03b1 : Prop) : \u03b1 \u2192 \u03b1 := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Prop\n\u22a2 \u03b1 \u2192 \u03b1"}]}
{"declaration": "example (a b : \u2115) : a + b = b + a := by\n  apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a + b = b + a"}, {"line": "  apply?", "tactic_state": ""}]}
{"declaration": "example (n m k : \u2115) : n * (m - k) = n * m - n * k := by\n  apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m k : \u2115\n\u22a2 n * (m - k) = n * m - n * k"}, {"line": "  apply?", "tactic_state": ""}]}
{"declaration": "example (n m k : \u2115) : n * m - n * k = n * (m - k) := by\n  apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m k : \u2115\n\u22a2 n * m - n * k = n * (m - k)"}, {"line": "  apply?", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} (x y : \u03b1) : x = y \u2194 y = x := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nx y : \u03b1\n\u22a2 x = y \u2194 y = x"}]}
{"declaration": "example (a b : \u2115) (_ha : 0 < a) (_hb : 0 < b) : 0 < a + b := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n_ha : 0 < a\n_hb : 0 < b\n\u22a2 0 < a + b"}]}
{"declaration": "example (a b : \u2115) (_ha : 0 < a) (_hb : 0 < b) : 0 < a + b := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n_ha : 0 < a\n_hb : 0 < b\n\u22a2 0 < a + b"}]}
{"declaration": "example (a b : \u2115) (_ha : a > 0) (_hb : 0 < b) : 0 < a + b := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n_ha : a > 0\n_hb : 0 < b\n\u22a2 0 < a + b"}]}
{"declaration": "example (a b : \u2115) (h : a \u2223 b) (w : b > 0) : a \u2264 b := by\n  apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a \u2223 b\nw : b > 0\n\u22a2 a \u2264 b"}, {"line": "  apply?", "tactic_state": ""}]}
{"declaration": "example (a b : \u2115) (h : a \u2223 b) (w : b > 0) : b \u2265 a := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a \u2223 b\nw : b > 0\n\u22a2 b \u2265 a"}]}
{"declaration": "example (a : \u2115) : \u00ac (a < 0) := by apply?", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 \u00aca < 0"}]}
{"declaration": "example (a : \u2115) (h : a < 0) : False := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\nh : a < 0\n\u22a2 False"}]}
{"declaration": "theorem lemma_with_gt_in_head (a : \u2115) (h : P a) : 0 > a := by cases h; assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nP : x\u271d\na : \u2115\nh : sorry\n\u22a2 0 > a"}]}
{"declaration": "theorem lemma_with_false_in_head (a b : \u2115) (_h1 : a < b) (h2 : P a) : False := by\n  apply Nat.not_lt_zero; cases h2; assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nP : x\u271d\na b : \u2115\n_h1 : a < b\nh2 : sorry\n\u22a2 False"}, {"line": "  apply Nat.not_lt_zero; cases h2; assumption", "tactic_state": "case a\nx\u271d : Sort u_1\nP : x\u271d\na b : \u2115\n_h1 : a < b\nh2 : sorry\n\u22a2 ?n < 0\n---\ncase n\nx\u271d : Sort u_1\nP : x\u271d\na b : \u2115\n_h1 : a < b\nh2 : sorry\n\u22a2 \u2115"}]}
{"declaration": "example (a : \u2115) (h : P a) : 0 > a := by apply?", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nP : x\u271d\na : \u2115\nh : sorry\n\u22a2 0 > a"}]}
{"declaration": "example (a : \u2115) (h : P a) : a < 0 := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nP : x\u271d\na : \u2115\nh : sorry\n\u22a2 a < 0"}]}
{"declaration": "example (a b : \u2115) (h1 : a < b) (h2 : P a) : False := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nP : x\u271d\na b : \u2115\nh1 : a < b\nh2 : sorry\n\u22a2 False"}]}
{"declaration": "example : \u2200 P : Prop, \u00ac(P \u2194 \u00acP) := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (P : Prop), \u00ac(P \u2194 \u00acP)"}]}
{"declaration": "example {a b c : \u2115} (h\u2081 : a \u2223 c) (h\u2082 : a \u2223 b + c) : a \u2223 b := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh\u2081 : a \u2223 c\nh\u2082 : a \u2223 b + c\n\u22a2 a \u2223 b"}]}
{"declaration": "example (a b : \u2115) (h : a \u2264 b) : f a \u2264 f b := by apply?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\na b : \u2115\nh : a \u2264 b\n\u22a2 sorry \u2264 sorry"}]}
{"declaration": "example (L _M : List (List \u2115)) : List \u2115 := by apply? using L\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "L _M : List (List \u2115)\n\u22a2 List \u2115"}]}
{"declaration": "example (P _Q : List \u2115) (h : \u2115) : List \u2115 := by apply? using h, P\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P _Q : List \u2115\nh : \u2115\n\u22a2 List \u2115"}]}
{"declaration": "example (l : List \u03b1) (f : \u03b1 \u2192 \u03b2 \u2295 \u03b3) : List \u03b2 \u00d7 List \u03b3 := by\n  apply? using f -- partitionMap f l\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.29\n\u03b2 : Type ?u.35\n\u03b3 : Type ?u.34\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2295 \u03b3\n\u22a2 List \u03b2 \u00d7 List \u03b3"}, {"line": "  apply? using f -- partitionMap f l", "tactic_state": ""}]}
{"declaration": "example (n m : \u2115) : \u2115 := by apply? using n, m\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 \u2115"}]}
{"declaration": "example (P Q : List \u2115) (_h : \u2115) : List \u2115 := by apply? using P, Q\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : List \u2115\n_h : \u2115\n\u22a2 List \u2115"}]}
{"declaration": "theorem Bool_eq_iff {A B : Bool} : (A = B) = (A \u2194 B) := by\n  (cases A <;> cases B <;> simp)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : Bool\n\u22a2 (A = B) = (A = true \u2194 B = true)"}, {"line": "  (cases A <;> cases B <;> simp)", "tactic_state": ""}]}
{"declaration": "theorem Bool_eq_iff2 {A B : Bool} : (A = B) = (A \u2194 B) := by\n  apply? -- exact Bool_eq_iff\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : Bool\n\u22a2 (A = B) = (A = true \u2194 B = true)"}, {"line": "  apply? -- exact Bool_eq_iff", "tactic_state": ""}]}
{"declaration": "example {r : \u03b1 \u2192 \u03b1 \u2192 Prop} : Function.Surjective (Quot.mk r) := by exact?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 Function.Surjective (Quot.mk r)"}]}
{"declaration": "lemma prime_of_prime (n : \u2115) : Prime n \u2194 Nat.Prime n := by\n  exact?\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Prime n \u2194 Nat.Prime n"}, {"line": "  exact?", "tactic_state": ""}]}
{"declaration": "example (P Q : Prop) (h : P \u2192 Q) (h' : \u00acQ) : \u00acP := by\n  exact? says exact fun a \u21a6 h' (h a)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\nh : P \u2192 Q\nh' : \u00acQ\n\u22a2 \u00acP"}, {"line": "  exact? says exact fun a \u21a6 h' (h a)", "tactic_state": ""}]}
{"declaration": "example (_h : List.range 10000 = List.range 10000) (n m : Nat) : n + m = m + n := by\n  with_reducible exact?", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_h : List.range 10000 = List.range 10000\nn m : \u2115\n\u22a2 n + m = m + n"}, {"line": "  with_reducible exact?", "tactic_state": ""}]}
{"declaration": "example (f : \u211d \u2192 \u211d) {K : Set \u211d} (_hK : IsCompact K) : \u2203 x \u2208 K, \u2200 y \u2208 K, f x \u2264 f y := by\n  fail_if_success exact?\n  apply? -- Verify that this includes: `refine IsCompact.exists_forall_le _hK ?_ ?_`", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/LibrarySearch/IsCompact.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nK : Set \u211d\n_hK : IsCompact K\n\u22a2 \u2203 x \u2208 K, \u2200 y \u2208 K, f x \u2264 f y"}, {"line": "  fail_if_success exact?", "tactic_state": "f : \u211d \u2192 \u211d\nK : Set \u211d\n_hK : IsCompact K\n\u22a2 \u2203 x \u2208 K, \u2200 y \u2208 K, f x \u2264 f y"}, {"line": "  apply? -- Verify that this includes: `refine IsCompact.exists_forall_le _hK ?_ ?_`", "tactic_state": ""}]}
{"declaration": "example :\n    (NonUnitalNormedRing.toNormedAddCommGroup : NormedAddCommGroup \u2102) =\n      Complex.instNormedAddCommGroup := by\n  with_reducible_and_instances rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds/normed.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 NonUnitalNormedRing.toNormedAddCommGroup = Complex.instNormedAddCommGroup"}, {"line": "  with_reducible_and_instances rfl", "tactic_state": ""}]}
{"declaration": "example : (Complex.SMul.instSMulRealComplex : SMul \u211a \u2102) = (Algebra.toSMul : SMul \u211a \u2102) := by\n  with_reducible_and_instances rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds/Data/Complex/Module.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Complex.SMul.instSMulRealComplex = Algebra.toSMul"}, {"line": "  with_reducible_and_instances rfl", "tactic_state": ""}]}
{"declaration": "example : (AddCommGroup.toNatModule : Module \u2115 (AlgebraicClosure k)) =\n      @Algebra.toModule _ _ _ _ (AlgebraicClosure.instAlgebra k) := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds/FieldTheory/IsAlgClosed/AlgebraicClosure.lean", "context": {"open": [], "variables": ["{k : Type*} [Field k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\ninst\u271d : Field k\n\u22a2 AddCommGroup.toNatModule = Algebra.toModule"}, {"line": "  with_reducible_and_instances rfl", "tactic_state": ""}]}
{"declaration": "example : (AddCommGroup.toIntModule _ : Module \u2124 (AlgebraicClosure k)) =\n      @Algebra.toModule _ _ _ _ (AlgebraicClosure.instAlgebra k) := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds/FieldTheory/IsAlgClosed/AlgebraicClosure.lean", "context": {"open": [], "variables": ["{k : Type*} [Field k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\ninst\u271d : Field k\n\u22a2 AddCommGroup.toIntModule (AlgebraicClosure k) = Algebra.toModule"}, {"line": "  with_reducible_and_instances rfl", "tactic_state": ""}]}
{"declaration": "example :\n    (AddCommGroup.toNatModule : Module \u2115 (SplittingField f)) =\n      @Algebra.toModule _ _ _ _ (SplittingField.algebra' f) := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds/FieldTheory/SplittingField/Construction.lean", "context": {"open": ["Polynomial"], "variables": ["{F : Type u} {K : Type v} {L : Type w}", "[Field K] [Field L] [Field F]", "(f : K[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\nf : K[X]\n\u22a2 AddCommGroup.toNatModule = Algebra.toModule"}, {"line": "  with_reducible_and_instances rfl", "tactic_state": ""}]}
{"declaration": "example :\n    (AddCommGroup.toIntModule _ : Module \u2124 (SplittingField f)) =\n      @Algebra.toModule _ _ _ _ (SplittingField.algebra' f) := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds/FieldTheory/SplittingField/Construction.lean", "context": {"open": ["Polynomial"], "variables": ["{F : Type u} {K : Type v} {L : Type w}", "[Field K] [Field L] [Field F]", "(f : K[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\nf : K[X]\n\u22a2 AddCommGroup.toIntModule f.SplittingField = Algebra.toModule"}, {"line": "  with_reducible_and_instances rfl", "tactic_state": ""}]}
{"declaration": "example {R S : \ud835\udcae} {a b : \ud835\udcb3} (f : R \u27f6 S) (\u03c6 : a \u27f6 b) [p.IsHomLift f \u03c6] : f = f := by\n  subst_hom_lift p f \u03c6\n  rename_i h\n  guard_hyp h : p.IsHomLift (p.map \u03c6) \u03c6\n  guard_target = p.map \u03c6 = p.map \u03c6\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/SubstHomLift.lean", "context": {"open": ["CategoryTheory Category"], "variables": ["{\ud835\udcae : Type u\u2081} {\ud835\udcb3 : Type u\u2082} [Category.{v\u2081} \ud835\udcb3] [Category.{v\u2082} \ud835\udcae] (p : \ud835\udcb3 \u2964 \ud835\udcae)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d\u00b9 : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\nR S : \ud835\udcae\na b : \ud835\udcb3\nf : R \u27f6 S\n\u03c6 : a \u27f6 b\ninst\u271d : p.IsHomLift f \u03c6\n\u22a2 f = f"}, {"line": "  subst_hom_lift p f \u03c6", "tactic_state": "case map\n\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d\u00b9 : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\na\u271d b\u271d : \ud835\udcb3\n\u03c6 : a\u271d \u27f6 b\u271d\nR S : \ud835\udcae\na b : \ud835\udcb3\ninst\u271d : p.IsHomLift (p.map \u03c6) \u03c6\n\u22a2 p.map \u03c6 = p.map \u03c6"}, {"line": "  rename_i h", "tactic_state": "case map\n\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\na\u271d b\u271d : \ud835\udcb3\n\u03c6 : a\u271d \u27f6 b\u271d\nR S : \ud835\udcae\na b : \ud835\udcb3\nh : p.IsHomLift (p.map \u03c6) \u03c6\n\u22a2 p.map \u03c6 = p.map \u03c6"}, {"line": "  guard_hyp h : p.IsHomLift (p.map \u03c6) \u03c6", "tactic_state": "case map\n\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\na\u271d b\u271d : \ud835\udcb3\n\u03c6 : a\u271d \u27f6 b\u271d\nR S : \ud835\udcae\na b : \ud835\udcb3\nh : p.IsHomLift (p.map \u03c6) \u03c6\n\u22a2 p.map \u03c6 = p.map \u03c6"}, {"line": "  guard_target = p.map \u03c6 = p.map \u03c6", "tactic_state": "case map\n\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\na\u271d b\u271d : \ud835\udcb3\n\u03c6 : a\u271d \u27f6 b\u271d\nR S : \ud835\udcae\na b : \ud835\udcb3\nh : p.IsHomLift (p.map \u03c6) \u03c6\n\u22a2 p.map \u03c6 = p.map \u03c6"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example {R S T : \ud835\udcae} {a b c : \ud835\udcb3} (f : R \u27f6 S) (g : S \u27f6 T) (\u03c6 : a \u27f6 b) (\u03c8 : b \u27f6 c)\n    [p.IsHomLift f (\u03c6 \u226b \u03c8)] : f = f := by\n  subst_hom_lift p f (\u03c6 \u226b \u03c8)\n  rename_i h\n  guard_hyp h : p.IsHomLift (p.map (\u03c6 \u226b \u03c8)) (\u03c6 \u226b \u03c8)\n  guard_target = p.map (\u03c6 \u226b \u03c8) = p.map (\u03c6 \u226b \u03c8)\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/SubstHomLift.lean", "context": {"open": ["CategoryTheory Category"], "variables": ["{\ud835\udcae : Type u\u2081} {\ud835\udcb3 : Type u\u2082} [Category.{v\u2081} \ud835\udcb3] [Category.{v\u2082} \ud835\udcae] (p : \ud835\udcb3 \u2964 \ud835\udcae)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d\u00b9 : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\nR S T : \ud835\udcae\na b c : \ud835\udcb3\nf : R \u27f6 S\ng : S \u27f6 T\n\u03c6 : a \u27f6 b\n\u03c8 : b \u27f6 c\ninst\u271d : p.IsHomLift f (\u03c6 \u226b \u03c8)\n\u22a2 f = f"}, {"line": "  subst_hom_lift p f (\u03c6 \u226b \u03c8)", "tactic_state": "case map\n\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d\u00b9 : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\nT : \ud835\udcae\na\u271d b\u271d c : \ud835\udcb3\n\u03c6 : a\u271d \u27f6 b\u271d\n\u03c8 : b\u271d \u27f6 c\nR S : \ud835\udcae\na b : \ud835\udcb3\ng : p.obj c \u27f6 T\ninst\u271d : p.IsHomLift (p.map (\u03c6 \u226b \u03c8)) (\u03c6 \u226b \u03c8)\n\u22a2 p.map (\u03c6 \u226b \u03c8) = p.map (\u03c6 \u226b \u03c8)"}, {"line": "  rename_i h", "tactic_state": "case map\n\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\nT : \ud835\udcae\na\u271d b\u271d c : \ud835\udcb3\n\u03c6 : a\u271d \u27f6 b\u271d\n\u03c8 : b\u271d \u27f6 c\nR S : \ud835\udcae\na b : \ud835\udcb3\ng : p.obj c \u27f6 T\nh : p.IsHomLift (p.map (\u03c6 \u226b \u03c8)) (\u03c6 \u226b \u03c8)\n\u22a2 p.map (\u03c6 \u226b \u03c8) = p.map (\u03c6 \u226b \u03c8)"}, {"line": "  guard_hyp h : p.IsHomLift (p.map (\u03c6 \u226b \u03c8)) (\u03c6 \u226b \u03c8)", "tactic_state": "case map\n\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\nT : \ud835\udcae\na\u271d b\u271d c : \ud835\udcb3\n\u03c6 : a\u271d \u27f6 b\u271d\n\u03c8 : b\u271d \u27f6 c\nR S : \ud835\udcae\na b : \ud835\udcb3\ng : p.obj c \u27f6 T\nh : p.IsHomLift (p.map (\u03c6 \u226b \u03c8)) (\u03c6 \u226b \u03c8)\n\u22a2 p.map (\u03c6 \u226b \u03c8) = p.map (\u03c6 \u226b \u03c8)"}, {"line": "  guard_target = p.map (\u03c6 \u226b \u03c8) = p.map (\u03c6 \u226b \u03c8)", "tactic_state": "case map\n\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : \ud835\udcb3 \u2964 \ud835\udcae\nT : \ud835\udcae\na\u271d b\u271d c : \ud835\udcb3\n\u03c6 : a\u271d \u27f6 b\u271d\n\u03c8 : b\u271d \u27f6 c\nR S : \ud835\udcae\na b : \ud835\udcb3\ng : p.obj c \u27f6 T\nh : p.IsHomLift (p.map (\u03c6 \u226b \u03c8)) (\u03c6 \u226b \u03c8)\n\u22a2 p.map (\u03c6 \u226b \u03c8) = p.map (\u03c6 \u226b \u03c8)"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (hyp : f\u2081 \u226b g\u2081 = f\u2082 \u226b g\u2082) : f\u2081 \u226b g\u2081 \u226b h \u226b l = (f\u2082 \u226b g\u2082) \u226b (h \u226b l) := by\n  conv =>\n    rhs\n    slice 2 3\n  show f\u2081 \u226b g\u2081 \u226b h \u226b l = f\u2082 \u226b (g\u2082 \u226b h) \u226b l\n  conv =>\n    lhs\n    slice 1 2\n    rw [hyp]\n  show ((f\u2082 \u226b g\u2082) \u226b h) \u226b l = f\u2082 \u226b (g\u2082 \u226b h) \u226b l\n  conv =>\n    lhs\n    slice 2 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Slice.lean", "context": {"open": ["CategoryTheory"], "variables": ["(C : Type) [Category C] (X Y Z W U : C)", "(f\u2081 f\u2082 : X \u27f6 Y) (g g\u2081 g\u2082 : Y \u27f6 Z) (h : Z \u27f6 W) (l : W \u27f6 U)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type\ninst\u271d : Category.{u_1, 0} C\nX Y Z W U : C\nf\u2081 f\u2082 : X \u27f6 Y\ng g\u2081 g\u2082 : Y \u27f6 Z\nh : Z \u27f6 W\nl : W \u27f6 U\nhyp : f\u2081 \u226b g\u2081 = f\u2082 \u226b g\u2082\n\u22a2 f\u2081 \u226b g\u2081 \u226b h \u226b l = (f\u2082 \u226b g\u2082) \u226b h \u226b l"}, {"line": "  conv =>", "tactic_state": "C : Type\ninst\u271d : Category.{u_1, 0} C\nX Y Z W U : C\nf\u2081 f\u2082 : X \u27f6 Y\ng g\u2081 g\u2082 : Y \u27f6 Z\nh : Z \u27f6 W\nl : W \u27f6 U\nhyp : f\u2081 \u226b g\u2081 = f\u2082 \u226b g\u2082\n\u22a2 f\u2081 \u226b g\u2081 \u226b h \u226b l = f\u2082 \u226b (g\u2082 \u226b h) \u226b l"}, {"line": "    rhs", "tactic_state": "C : Type\ninst\u271d : Category.{u_1, 0} C\nX Y Z W U : C\nf\u2081 f\u2082 : X \u27f6 Y\ng g\u2081 g\u2082 : Y \u27f6 Z\nh : Z \u27f6 W\nl : W \u27f6 U\nhyp : f\u2081 \u226b g\u2081 = f\u2082 \u226b g\u2082\n\u22a2 f\u2081 \u226b g\u2081 \u226b h \u226b l = f\u2082 \u226b (g\u2082 \u226b h) \u226b l"}, {"line": "    slice 2 3", "tactic_state": "C : Type\ninst\u271d : Category.{u_1, 0} C\nX Y Z W U : C\nf\u2081 f\u2082 : X \u27f6 Y\ng g\u2081 g\u2082 : Y \u27f6 Z\nh : Z \u27f6 W\nl : W \u27f6 U\nhyp : f\u2081 \u226b g\u2081 = f\u2082 \u226b g\u2082\n\u22a2 ((f\u2082 \u226b g\u2082) \u226b h) \u226b l = f\u2082 \u226b (g\u2082 \u226b h) \u226b l"}, {"line": "  show f\u2081 \u226b g\u2081 \u226b h \u226b l = f\u2082 \u226b (g\u2082 \u226b h) \u226b l", "tactic_state": "C : Type\ninst\u271d : Category.{u_1, 0} C\nX Y Z W U : C\nf\u2081 f\u2082 : X \u27f6 Y\ng g\u2081 g\u2082 : Y \u27f6 Z\nh : Z \u27f6 W\nl : W \u27f6 U\nhyp : f\u2081 \u226b g\u2081 = f\u2082 \u226b g\u2082\n\u22a2 ((f\u2082 \u226b g\u2082) \u226b h) \u226b l = f\u2082 \u226b (g\u2082 \u226b h) \u226b l"}, {"line": "  conv =>", "tactic_state": ""}]}
{"declaration": "example (hyp : f\u2081 \u226b g\u2081 = f\u2082 \u226b g\u2082) : f\u2081 \u226b g\u2081 \u226b h \u226b l = (f\u2082 \u226b g\u2082) \u226b (h \u226b l) := by\n  slice_lhs 1 2 => { rw [hyp] }; slice_rhs 1 2 => skip\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Slice.lean", "context": {"open": ["CategoryTheory"], "variables": ["(C : Type) [Category C] (X Y Z W U : C)", "(f\u2081 f\u2082 : X \u27f6 Y) (g g\u2081 g\u2082 : Y \u27f6 Z) (h : Z \u27f6 W) (l : W \u27f6 U)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type\ninst\u271d : Category.{u_1, 0} C\nX Y Z W U : C\nf\u2081 f\u2082 : X \u27f6 Y\ng g\u2081 g\u2082 : Y \u27f6 Z\nh : Z \u27f6 W\nl : W \u27f6 U\nhyp : f\u2081 \u226b g\u2081 = f\u2082 \u226b g\u2082\n\u22a2 f\u2081 \u226b g\u2081 \u226b h \u226b l = (f\u2082 \u226b g\u2082) \u226b h \u226b l"}, {"line": "  slice_lhs 1 2 => { rw [hyp] }; slice_rhs 1 2 => skip", "tactic_state": "C : Type\ninst\u271d : Category.{u_1, 0} C\nX Y Z W U : C\nf\u2081 f\u2082 : X \u27f6 Y\ng g\u2081 g\u2082 : Y \u27f6 Z\nh : Z \u27f6 W\nl : W \u27f6 U\nhyp : f\u2081 \u226b g\u2081 = f\u2082 \u226b g\u2082\n\u22a2 ((f\u2082 \u226b g\u2082) \u226b h) \u226b l = (f\u2082 \u226b g\u2082) \u226b h \u226b l"}]}
{"declaration": "example (h\u2081 : f\u2081 = f\u2082) : f\u2081 \u226b g \u226b h \u226b l = ((f\u2082 \u226b g) \u226b h) \u226b l := by\n  slice_lhs 1 1 => rw [h\u2081]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Slice.lean", "context": {"open": ["CategoryTheory"], "variables": ["(C : Type) [Category C] (X Y Z W U : C)", "(f\u2081 f\u2082 : X \u27f6 Y) (g g\u2081 g\u2082 : Y \u27f6 Z) (h : Z \u27f6 W) (l : W \u27f6 U)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type\ninst\u271d : Category.{u_1, 0} C\nX Y Z W U : C\nf\u2081 f\u2082 : X \u27f6 Y\ng g\u2081 g\u2082 : Y \u27f6 Z\nh : Z \u27f6 W\nl : W \u27f6 U\nh\u2081 : f\u2081 = f\u2082\n\u22a2 f\u2081 \u226b g \u226b h \u226b l = ((f\u2082 \u226b g) \u226b h) \u226b l"}, {"line": "  slice_lhs 1 1 => rw [h\u2081]", "tactic_state": ""}]}
{"declaration": "example (h\u2081 : f\u2081 = f\u2082) : ((f\u2082 \u226b g) \u226b h) \u226b l = f\u2081 \u226b g \u226b h \u226b l := by\n  slice_rhs 1 1 => rw [h\u2081]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Slice.lean", "context": {"open": ["CategoryTheory"], "variables": ["(C : Type) [Category C] (X Y Z W U : C)", "(f\u2081 f\u2082 : X \u27f6 Y) (g g\u2081 g\u2082 : Y \u27f6 Z) (h : Z \u27f6 W) (l : W \u27f6 U)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type\ninst\u271d : Category.{u_1, 0} C\nX Y Z W U : C\nf\u2081 f\u2082 : X \u27f6 Y\ng g\u2081 g\u2082 : Y \u27f6 Z\nh : Z \u27f6 W\nl : W \u27f6 U\nh\u2081 : f\u2081 = f\u2082\n\u22a2 ((f\u2082 \u226b g) \u226b h) \u226b l = f\u2081 \u226b g \u226b h \u226b l"}, {"line": "  slice_rhs 1 1 => rw [h\u2081]", "tactic_state": ""}]}
{"declaration": "example (j : J) :\n    colimit.\u03b9 ((F \u22d9 G) \u22d9 H) j \u226b (preservesColimitIso (G \u22d9 H) F).inv =\n      H.map (G.map (colimit.\u03b9 F j)) := by\n\n  -- We know which lemma we want to use, and it's even a simp lemma, but `rw` won't let us apply it\n  fail_if_success rw [\u03b9_preservesColimitIso_inv]\n  fail_if_success rw [\u03b9_preservesColimitIso_inv (G \u22d9 H)]\n  fail_if_success simp only [\u03b9_preservesColimitIso_inv]\n\n  -- This would work:\n  -- erw [\u03b9_preservesColimitIso_inv (G \u22d9 H)]\n\n  -- `check_compositions` checks if the two morphisms we're composing are composed by abusing defeq,\n  -- and indeed it tells us that we are abusing definitional associativity of composition of\n  -- functors here!\n  check_compositions\n\n  -- In this case, we can \"fix\" this by reassociating in the goal, but usually at this point the\n  -- right thing to do is to back off and check how we ended up with a bad goal in the first place.\n  dsimp only [Functor.assoc]\n\n  -- This would work now, but it is not needed, because simp works as well\n  -- rw [\u03b9_preservesColimitIso_inv]\n\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/CheckCompositions.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{J : Type u} [Category.{v} J] {C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]", "[HasColimitsOfShape J C] [HasColimitsOfShape J E] [PreservesColimit F (G \u22d9 H)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u\ninst\u271d\u2075 : Category.{v, u} J\nC : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nobj\u271d\u00b2 : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} obj\u271d\u00b2\nF : J \u2964 obj\u271d\u00b2\nobj\u271d\u00b9 : Type u_3\ninst\u271d\u00b9 : Category.{u_4, u_3} obj\u271d\u00b9\nG : obj\u271d\u00b2 \u2964 obj\u271d\u00b9\nobj\u271d : Type u_5\ninst\u271d : Category.{u_6, u_5} obj\u271d\nH : obj\u271d\u00b9 \u2964 obj\u271d\nj : J\n\u22a2 colimit.\u03b9 ((F \u22d9 G) \u22d9 H) j \u226b sorry = H.map (G.map (colimit.\u03b9 F j))"}, {"line": "", "tactic_state": "J : Type u\ninst\u271d\u2075 : Category.{v, u} J\nC : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nobj\u271d\u00b2 : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} obj\u271d\u00b2\nF : J \u2964 obj\u271d\u00b2\nobj\u271d\u00b9 : Type u_3\ninst\u271d\u00b9 : Category.{u_4, u_3} obj\u271d\u00b9\nG : obj\u271d\u00b2 \u2964 obj\u271d\u00b9\nobj\u271d : Type u_5\ninst\u271d : Category.{u_6, u_5} obj\u271d\nH : obj\u271d\u00b9 \u2964 obj\u271d\nj : J\n\u22a2 colimit.\u03b9 ((F \u22d9 G) \u22d9 H) j \u226b sorry = H.map (G.map (colimit.\u03b9 F j))"}, {"line": "  -- We know which lemma we want to use, and it's even a simp lemma, but `rw` won't let us apply it", "tactic_state": "J : Type u\ninst\u271d\u2075 : Category.{v, u} J\nC : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nobj\u271d\u00b2 : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} obj\u271d\u00b2\nF : J \u2964 obj\u271d\u00b2\nobj\u271d\u00b9 : Type u_3\ninst\u271d\u00b9 : Category.{u_4, u_3} obj\u271d\u00b9\nG : obj\u271d\u00b2 \u2964 obj\u271d\u00b9\nobj\u271d : Type u_5\ninst\u271d : Category.{u_6, u_5} obj\u271d\nH : obj\u271d\u00b9 \u2964 obj\u271d\nj : J\n\u22a2 colimit.\u03b9 ((F \u22d9 G) \u22d9 H) j \u226b sorry = H.map (G.map (colimit.\u03b9 F j))"}, {"line": "  fail_if_success rw [\u03b9_preservesColimitIso_inv]", "tactic_state": "J : Type u\ninst\u271d\u2075 : Category.{v, u} J\nC : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nobj\u271d\u00b2 : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} obj\u271d\u00b2\nF : J \u2964 obj\u271d\u00b2\nobj\u271d\u00b9 : Type u_3\ninst\u271d\u00b9 : Category.{u_4, u_3} obj\u271d\u00b9\nG : obj\u271d\u00b2 \u2964 obj\u271d\u00b9\nobj\u271d : Type u_5\ninst\u271d : Category.{u_6, u_5} obj\u271d\nH : obj\u271d\u00b9 \u2964 obj\u271d\nj : J\n\u22a2 colimit.\u03b9 ((F \u22d9 G) \u22d9 H) j \u226b sorry = H.map (G.map (colimit.\u03b9 F j))"}, {"line": "  fail_if_success rw [\u03b9_preservesColimitIso_inv (G \u22d9 H)]", "tactic_state": "J : Type u\ninst\u271d\u2075 : Category.{v, u} J\nC : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nobj\u271d\u00b2 : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} obj\u271d\u00b2\nF : J \u2964 obj\u271d\u00b2\nobj\u271d\u00b9 : Type u_3\ninst\u271d\u00b9 : Category.{u_4, u_3} obj\u271d\u00b9\nG : obj\u271d\u00b2 \u2964 obj\u271d\u00b9\nobj\u271d : Type u_5\ninst\u271d : Category.{u_6, u_5} obj\u271d\nH : obj\u271d\u00b9 \u2964 obj\u271d\nj : J\n\u22a2 colimit.\u03b9 ((F \u22d9 G) \u22d9 H) j \u226b sorry = H.map (G.map (colimit.\u03b9 F j))"}, {"line": "  fail_if_success simp only [\u03b9_preservesColimitIso_inv]", "tactic_state": "J : Type u\ninst\u271d\u2075 : Category.{v, u} J\nC : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nobj\u271d\u00b2 : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} obj\u271d\u00b2\nF : J \u2964 obj\u271d\u00b2\nobj\u271d\u00b9 : Type u_3\ninst\u271d\u00b9 : Category.{u_4, u_3} obj\u271d\u00b9\nG : obj\u271d\u00b2 \u2964 obj\u271d\u00b9\nobj\u271d : Type u_5\ninst\u271d : Category.{u_6, u_5} obj\u271d\nH : obj\u271d\u00b9 \u2964 obj\u271d\nj : J\n\u22a2 colimit.\u03b9 (F \u22d9 G \u22d9 H) j \u226b sorry = H.map (G.map (colimit.\u03b9 F j))"}, {"line": "", "tactic_state": "J : Type u\ninst\u271d\u2075 : Category.{v, u} J\nC : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nobj\u271d\u00b2 : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} obj\u271d\u00b2\nF : J \u2964 obj\u271d\u00b2\nobj\u271d\u00b9 : Type u_3\ninst\u271d\u00b9 : Category.{u_4, u_3} obj\u271d\u00b9\nG : obj\u271d\u00b2 \u2964 obj\u271d\u00b9\nobj\u271d : Type u_5\ninst\u271d : Category.{u_6, u_5} obj\u271d\nH : obj\u271d\u00b9 \u2964 obj\u271d\nj : J\n\u22a2 colimit.\u03b9 (F \u22d9 G \u22d9 H) j \u226b sorry () = H.map (G.map (colimit.\u03b9 F j))"}]}
{"declaration": "example (X\u2081 X\u2082 : C) :\n    ((\u03bb_ (\ud835\udfd9_ C)).inv \u2297 \ud835\udfd9 (X\u2081 \u2297 X\u2082)) \u226b (\u03b1_ (\ud835\udfd9_ C) (\ud835\udfd9_ C) (X\u2081 \u2297 X\u2082)).hom \u226b\n      (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03b1_ (\ud835\udfd9_ C) X\u2081 X\u2082).inv) =\n    \ud835\udfd9 (\ud835\udfd9_ C) \u2297 ((\u03bb_ X\u2081).inv \u2297 \ud835\udfd9 X\u2082) := by\n  pure_coherence\n  -- This is just running:\n  -- change projectMap id _ _ (LiftHom.lift (((\u03bb_ (\ud835\udfd9_ C)).inv \u2297 \ud835\udfd9 (X\u2081 \u2297 X\u2082)) \u226b\n  --     (\u03b1_ (\ud835\udfd9_ C) (\ud835\udfd9_ C) (X\u2081 \u2297 X\u2082)).hom \u226b (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03b1_ (\ud835\udfd9_ C) X\u2081 X\u2082).inv))) =\n  --   projectMap id _ _ (LiftHom.lift (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 ((\u03bb_ X\u2081).inv \u2297 \ud835\udfd9 X\u2082)))\n  -- exact congrArg _ (Subsingleton.elim _ _)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX\u2081 X\u2082 : C\n\u22a2 ((\u03bb_ (\ud835\udfd9_ C)).inv \u2297 \ud835\udfd9 (X\u2081 \u2297 X\u2082)) \u226b (\u03b1_ (\ud835\udfd9_ C) (\ud835\udfd9_ C) (X\u2081 \u2297 X\u2082)).hom \u226b (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03b1_ (\ud835\udfd9_ C) X\u2081 X\u2082).inv) =\n    \ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03bb_ X\u2081).inv \u2297 \ud835\udfd9 X\u2082"}, {"line": "  pure_coherence", "tactic_state": ""}]}
{"declaration": "example {Y Z : C} (f : Y \u27f6 Z) (g) (w : false) : (\u03bb_ _).hom \u226b f = g := by\n  liftable_prefixes\n  guard_target = (\ud835\udfd9 _ \u226b (\u03bb_ _).hom) \u226b f = (\ud835\udfd9 _) \u226b g\n  cases w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nY Z : C\nf : Y \u27f6 Z\ng : \ud835\udfd9_ C \u2297 Y \u27f6 Z\nw : false = true\n\u22a2 (\u03bb_ Y).hom \u226b f = g"}, {"line": "  liftable_prefixes", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nY Z : C\nf : Y \u27f6 Z\ng : \ud835\udfd9_ C \u2297 Y \u27f6 Z\nw : false = true\n\u22a2 (\ud835\udfd9 (\ud835\udfd9_ C \u2297 Y) \u226b (\u03bb_ Y).hom) \u226b f = \ud835\udfd9 (\ud835\udfd9_ C \u2297 Y) \u226b g"}, {"line": "  guard_target = (\ud835\udfd9 _ \u226b (\u03bb_ _).hom) \u226b f = (\ud835\udfd9 _) \u226b g", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nY Z : C\nf : Y \u27f6 Z\ng : \ud835\udfd9_ C \u2297 Y \u27f6 Z\nw : false = true\n\u22a2 (\ud835\udfd9 (\ud835\udfd9_ C \u2297 Y) \u226b (\u03bb_ Y).hom) \u226b f = \ud835\udfd9 (\ud835\udfd9_ C \u2297 Y) \u226b g"}, {"line": "  cases w", "tactic_state": ""}]}
{"declaration": "example (f : \ud835\udfd9_ C \u27f6 _) : f \u226b (\u03bb_ (\ud835\udfd9_ C)).hom = f \u226b (\u03c1_ (\ud835\udfd9_ C)).hom := by\n  coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf : \ud835\udfd9_ C \u27f6 \ud835\udfd9_ C \u2297 \ud835\udfd9_ C\n\u22a2 f \u226b (\u03bb_ (\ud835\udfd9_ C)).hom = f \u226b (\u03c1_ (\ud835\udfd9_ C)).hom"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example (f) : (\u03bb_ (\ud835\udfd9_ C)).hom \u226b f \u226b (\u03bb_ (\ud835\udfd9_ C)).hom = (\u03c1_ (\ud835\udfd9_ C)).hom \u226b f \u226b (\u03c1_ (\ud835\udfd9_ C)).hom := by\n  coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf : \ud835\udfd9_ C \u27f6 \ud835\udfd9_ C \u2297 \ud835\udfd9_ C\n\u22a2 (\u03bb_ (\ud835\udfd9_ C)).hom \u226b f \u226b (\u03bb_ (\ud835\udfd9_ C)).hom = (\u03c1_ (\ud835\udfd9_ C)).hom \u226b f \u226b (\u03c1_ (\ud835\udfd9_ C)).hom"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example {U : C} (f : U \u27f6 \ud835\udfd9_ C) : f \u226b (\u03c1_ (\ud835\udfd9_ C)).inv \u226b (\u03bb_ (\ud835\udfd9_ C)).hom = f := by\n  coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nU : C\nf : U \u27f6 \ud835\udfd9_ C\n\u22a2 f \u226b (\u03c1_ (\ud835\udfd9_ C)).inv \u226b (\u03bb_ (\ud835\udfd9_ C)).hom = f"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example (W X Y Z : C) (f) :\n    ((\u03b1_ W X Y).hom \u2297 \ud835\udfd9 Z) \u226b (\u03b1_ W (X \u2297 Y) Z).hom \u226b (\ud835\udfd9 W \u2297 (\u03b1_ X Y Z).hom) \u226b f \u226b\n      (\u03b1_ (W \u2297 X) Y Z).hom \u226b (\u03b1_ W X (Y \u2297 Z)).hom =\n    (\u03b1_ (W \u2297 X) Y Z).hom \u226b (\u03b1_ W X (Y \u2297 Z)).hom \u226b f \u226b\n      ((\u03b1_ W X Y).hom \u2297 \ud835\udfd9 Z) \u226b (\u03b1_ W (X \u2297 Y) Z).hom \u226b (\ud835\udfd9 W \u2297 (\u03b1_ X Y Z).hom) := by\n  coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nW X Y Z : C\nf : W \u2297 X \u2297 Y \u2297 Z \u27f6 ((W \u2297 X) \u2297 Y) \u2297 Z\n\u22a2 ((\u03b1_ W X Y).hom \u2297 \ud835\udfd9 Z) \u226b\n      (\u03b1_ W (X \u2297 Y) Z).hom \u226b (\ud835\udfd9 W \u2297 (\u03b1_ X Y Z).hom) \u226b f \u226b (\u03b1_ (W \u2297 X) Y Z).hom \u226b (\u03b1_ W X (Y \u2297 Z)).hom =\n    (\u03b1_ (W \u2297 X) Y Z).hom \u226b\n      (\u03b1_ W X (Y \u2297 Z)).hom \u226b f \u226b ((\u03b1_ W X Y).hom \u2297 \ud835\udfd9 Z) \u226b (\u03b1_ W (X \u2297 Y) Z).hom \u226b (\ud835\udfd9 W \u2297 (\u03b1_ X Y Z).hom)"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example {U V W X Y : C} (f : U \u27f6 V \u2297 (W \u2297 X)) (g : (V \u2297 W) \u2297 X \u27f6 Y) :\n    f \u2297\u226b g = f \u226b (\u03b1_ _ _ _).inv \u226b g := by\n  coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nU V W X Y : C\nf : U \u27f6 V \u2297 W \u2297 X\ng : (V \u2297 W) \u2297 X \u27f6 Y\n\u22a2 f \u2297\u226b g = f \u226b (\u03b1_ V W X).inv \u226b g"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example : (\u03bb_ (\ud835\udfd9_ C)).hom = (\u03c1_ (\ud835\udfd9_ C)).hom := by coherence", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\n\u22a2 (\u03bb_ (\ud835\udfd9_ C)).hom = (\u03c1_ (\ud835\udfd9_ C)).hom"}]}
{"declaration": "example : (\u03bb_ (\ud835\udfd9_ C)).inv = (\u03c1_ (\ud835\udfd9_ C)).inv := by coherence", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\n\u22a2 (\u03bb_ (\ud835\udfd9_ C)).inv = (\u03c1_ (\ud835\udfd9_ C)).inv"}]}
{"declaration": "example (X Y Z : C) : (\u03b1_ X Y Z).inv \u226b (\u03b1_ X Y Z).hom = \ud835\udfd9 (X \u2297 Y \u2297 Z) := by coherence", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y Z : C\n\u22a2 (\u03b1_ X Y Z).inv \u226b (\u03b1_ X Y Z).hom = \ud835\udfd9 (X \u2297 Y \u2297 Z)"}]}
{"declaration": "example (X Y Z W : C) :\n  (\ud835\udfd9 X \u2297 (\u03b1_ Y Z W).hom) \u226b (\u03b1_ X Y (Z \u2297 W)).inv \u226b (\u03b1_ (X \u2297 Y) Z W).inv =\n    (\u03b1_ X (Y \u2297 Z) W).inv \u226b ((\u03b1_ X Y Z).inv \u2297 \ud835\udfd9 W) := by\n  coherence", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y Z W : C\n\u22a2 (\ud835\udfd9 X \u2297 (\u03b1_ Y Z W).hom) \u226b (\u03b1_ X Y (Z \u2297 W)).inv \u226b (\u03b1_ (X \u2297 Y) Z W).inv = (\u03b1_ X (Y \u2297 Z) W).inv \u226b ((\u03b1_ X Y Z).inv \u2297 \ud835\udfd9 W)"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example (X Y : C) :\n  (\ud835\udfd9 X \u2297 (\u03bb_ Y).inv) \u226b (\u03b1_ X (\ud835\udfd9_ C) Y).inv = (\u03c1_ X).inv \u2297 \ud835\udfd9 Y := by\n  coherence", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y : C\n\u22a2 (\ud835\udfd9 X \u2297 (\u03bb_ Y).inv) \u226b (\u03b1_ X (\ud835\udfd9_ C) Y).inv = (\u03c1_ X).inv \u2297 \ud835\udfd9 Y"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example (X Y : C) (f : \ud835\udfd9_ C \u27f6 X) (g : X \u27f6 Y) (_w : false) :\n  (\u03bb_ (\ud835\udfd9_ C)).hom \u226b f \u226b \ud835\udfd9 X \u226b g = (\u03c1_ (\ud835\udfd9_ C)).hom \u226b f \u226b g := by\n  coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y : C\nf : \ud835\udfd9_ C \u27f6 X\ng : X \u27f6 Y\n_w : false = true\n\u22a2 (\u03bb_ (\ud835\udfd9_ C)).hom \u226b f \u226b \ud835\udfd9 X \u226b g = (\u03c1_ (\ud835\udfd9_ C)).hom \u226b f \u226b g"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example (X\u2081 X\u2082 : C) :\n  (\u03b1_ (\ud835\udfd9_ C) (\ud835\udfd9_ C) (X\u2081 \u2297 X\u2082)).hom \u226b\n    (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03b1_ (\ud835\udfd9_ C) X\u2081 X\u2082).inv) \u226b\n      (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03bb_ _).hom \u226b (\u03c1_ X\u2081).inv \u2297 \ud835\udfd9 X\u2082) \u226b\n        (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03b1_ X\u2081 (\ud835\udfd9_ C) X\u2082).hom) \u226b\n          (\u03b1_ (\ud835\udfd9_ C) X\u2081 (\ud835\udfd9_ C \u2297 X\u2082)).inv \u226b\n            ((\u03bb_ X\u2081).hom \u226b (\u03c1_ X\u2081).inv \u2297 \ud835\udfd9 (\ud835\udfd9_ C \u2297 X\u2082)) \u226b\n              (\u03b1_ X\u2081 (\ud835\udfd9_ C) (\ud835\udfd9_ C \u2297 X\u2082)).hom \u226b\n                (\ud835\udfd9 X\u2081 \u2297 \ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03bb_ X\u2082).hom \u226b (\u03c1_ X\u2082).inv) \u226b\n                  (\ud835\udfd9 X\u2081 \u2297 (\u03b1_ (\ud835\udfd9_ C) X\u2082 (\ud835\udfd9_ C)).inv) \u226b\n                    (\ud835\udfd9 X\u2081 \u2297 (\u03bb_ X\u2082).hom \u226b (\u03c1_ X\u2082).inv \u2297 \ud835\udfd9 (\ud835\udfd9_ C)) \u226b\n                      (\ud835\udfd9 X\u2081 \u2297 (\u03b1_ X\u2082 (\ud835\udfd9_ C) (\ud835\udfd9_ C)).hom) \u226b\n                        (\u03b1_ X\u2081 X\u2082 (\ud835\udfd9_ C \u2297 \ud835\udfd9_ C)).inv =\n  (((\u03bb_ (\ud835\udfd9_ C)).hom \u2297 \ud835\udfd9 (X\u2081 \u2297 X\u2082)) \u226b (\u03bb_ (X\u2081 \u2297 X\u2082)).hom \u226b (\u03c1_ (X\u2081 \u2297 X\u2082)).inv) \u226b\n    (\ud835\udfd9 (X\u2081 \u2297 X\u2082) \u2297 (\u03bb_ (\ud835\udfd9_ C)).inv) := by\n  coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX\u2081 X\u2082 : C\n\u22a2 (\u03b1_ (\ud835\udfd9_ C) (\ud835\udfd9_ C) (X\u2081 \u2297 X\u2082)).hom \u226b\n      (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03b1_ (\ud835\udfd9_ C) X\u2081 X\u2082).inv) \u226b\n        (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03bb_ X\u2081).hom \u226b (\u03c1_ X\u2081).inv \u2297 \ud835\udfd9 X\u2082) \u226b\n          (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03b1_ X\u2081 (\ud835\udfd9_ C) X\u2082).hom) \u226b\n            (\u03b1_ (\ud835\udfd9_ C) X\u2081 (\ud835\udfd9_ C \u2297 X\u2082)).inv \u226b\n              ((\u03bb_ X\u2081).hom \u226b (\u03c1_ X\u2081).inv \u2297 \ud835\udfd9 (\ud835\udfd9_ C \u2297 X\u2082)) \u226b\n                (\u03b1_ X\u2081 (\ud835\udfd9_ C) (\ud835\udfd9_ C \u2297 X\u2082)).hom \u226b\n                  (\ud835\udfd9 X\u2081 \u2297 \ud835\udfd9 (\ud835\udfd9_ C) \u2297 (\u03bb_ X\u2082).hom \u226b (\u03c1_ X\u2082).inv) \u226b\n                    (\ud835\udfd9 X\u2081 \u2297 (\u03b1_ (\ud835\udfd9_ C) X\u2082 (\ud835\udfd9_ C)).inv) \u226b\n                      (\ud835\udfd9 X\u2081 \u2297 (\u03bb_ X\u2082).hom \u226b (\u03c1_ X\u2082).inv \u2297 \ud835\udfd9 (\ud835\udfd9_ C)) \u226b\n                        (\ud835\udfd9 X\u2081 \u2297 (\u03b1_ X\u2082 (\ud835\udfd9_ C) (\ud835\udfd9_ C)).hom) \u226b (\u03b1_ X\u2081 X\u2082 (\ud835\udfd9_ C \u2297 \ud835\udfd9_ C)).inv =\n    (((\u03bb_ (\ud835\udfd9_ C)).hom \u2297 \ud835\udfd9 (X\u2081 \u2297 X\u2082)) \u226b (\u03bb_ (X\u2081 \u2297 X\u2082)).hom \u226b (\u03c1_ (X\u2081 \u2297 X\u2082)).inv) \u226b (\ud835\udfd9 (X\u2081 \u2297 X\u2082) \u2297 (\u03bb_ (\ud835\udfd9_ C)).inv)"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example {a : B} (f : a \u27f6 a) : \ud835\udfd9 f \u25b7 f = \ud835\udfd9 (f \u226b f) := by whisker_simps\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory", "scoped Bicategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{B : Type u} [Bicategory.{w, v} B] {a b c d e : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na\u271d b c d e a : B\nf : a \u27f6 a\n\u22a2 \ud835\udfd9 f \u25b7 f = \ud835\udfd9 (f \u226b f)"}]}
{"declaration": "example : (\u03bb_ (\ud835\udfd9 a)).hom = (\u03c1_ (\ud835\udfd9 a)).hom := by bicategory_coherence", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory", "scoped Bicategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{B : Type u} [Bicategory.{w, v} B] {a b c d e : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\n\u22a2 sorry = sorry"}]}
{"declaration": "example : (\u03bb_ (\ud835\udfd9 a)).inv = (\u03c1_ (\ud835\udfd9 a)).inv := by bicategory_coherence", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory", "scoped Bicategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{B : Type u} [Bicategory.{w, v} B] {a b c d e : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\n\u22a2 sorry = sorry"}]}
{"declaration": "example (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) :\n  (\u03b1_ f g h).inv \u226b (\u03b1_ f g h).hom = \ud835\udfd9 (f \u226b g \u226b h) := by\n  bicategory_coherence", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory", "scoped Bicategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{B : Type u} [Bicategory.{w, v} B] {a b c d e : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf : a \u27f6 b\ng : b \u27f6 c\nh : c \u27f6 d\n\u22a2 (\u03b1_ f g h).inv \u226b (\u03b1_ f g h).hom = \ud835\udfd9 (f \u226b g \u226b h)"}, {"line": "  bicategory_coherence", "tactic_state": ""}]}
{"declaration": "example (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n  f \u25c1 (\u03b1_ g h i).hom \u226b (\u03b1_ f g (h \u226b i)).inv \u226b (\u03b1_ (f \u226b g) h i).inv =\n    (\u03b1_ f (g \u226b h) i).inv \u226b (\u03b1_ f g h).inv \u25b7 i := by\n  bicategory_coherence", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory", "scoped Bicategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{B : Type u} [Bicategory.{w, v} B] {a b c d e : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf : a \u27f6 b\ng : b \u27f6 c\nh : c \u27f6 d\ni : d \u27f6 e\n\u22a2 f \u25c1 (\u03b1_ g h i).hom \u226b (\u03b1_ f g (h \u226b i)).inv \u226b (\u03b1_ (f \u226b g) h i).inv = (\u03b1_ f (g \u226b h) i).inv \u226b (\u03b1_ f g h).inv \u25b7 i"}, {"line": "  bicategory_coherence", "tactic_state": ""}]}
{"declaration": "example (f : a \u27f6 b) (g : b \u27f6 c) :\n  f \u25c1 (\u03bb_ g).inv \u226b (\u03b1_ f (\ud835\udfd9 b) g).inv = (\u03c1_ f).inv \u25b7 g := by\n  bicategory_coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory", "scoped Bicategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{B : Type u} [Bicategory.{w, v} B] {a b c d e : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf : a \u27f6 b\ng : b \u27f6 c\n\u22a2 sorry \u226b (\u03b1_ f (\ud835\udfd9 b) g).inv = sorry"}, {"line": "  bicategory_coherence", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf : a \u27f6 b\ng : b \u27f6 c\n\u22a2 sorry \u226b (\u03b1_ f (\ud835\udfd9 b) g).inv = sorry"}]}
{"declaration": "example : \ud835\udfd9 (\ud835\udfd9 a \u226b \ud835\udfd9 a) \u226b (\u03bb_ (\ud835\udfd9 a)).hom = \ud835\udfd9 (\ud835\udfd9 a \u226b \ud835\udfd9 a) \u226b (\u03c1_ (\ud835\udfd9 a)).hom := by\n  bicategory_coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory", "scoped Bicategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{B : Type u} [Bicategory.{w, v} B] {a b c d e : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\n\u22a2 \ud835\udfd9 (\ud835\udfd9 a \u226b \ud835\udfd9 a) \u226b sorry = \ud835\udfd9 (\ud835\udfd9 a \u226b \ud835\udfd9 a) \u226b sorry"}, {"line": "  bicategory_coherence", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\n\u22a2 \ud835\udfd9 (\ud835\udfd9 a \u226b \ud835\udfd9 a) \u226b sorry = \ud835\udfd9 (\ud835\udfd9 a \u226b \ud835\udfd9 a) \u226b sorry"}]}
{"declaration": "example (f g : a \u27f6 a) (\u03b7 : \ud835\udfd9 a \u27f6 f) (\u03b8 : f \u27f6 g) (w : false) :\n  (\u03bb_ (\ud835\udfd9 a)).hom \u226b \u03b7 \u226b \u03b8 = (\u03c1_ (\ud835\udfd9 a)).hom \u226b \u03b7 \u226b \u03b8 := by\n  coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory", "scoped Bicategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{B : Type u} [Bicategory.{w, v} B] {a b c d e : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf g : a \u27f6 a\n\u03b7 : \ud835\udfd9 a \u27f6 f\n\u03b8 : f \u27f6 g\nw : false = true\n\u22a2 sorry \u226b \u03b7 \u226b \u03b8 = sorry \u226b \u03b7 \u226b \u03b8"}, {"line": "  coherence", "tactic_state": ""}]}
{"declaration": "example (f\u2081 : a \u27f6 b) (f\u2082 : b \u27f6 c) :\n  (\u03b1_ (\ud835\udfd9 a) (\ud835\udfd9 a) (f\u2081 \u226b f\u2082)).hom \u226b\n    \ud835\udfd9 a \u25c1 (\u03b1_ (\ud835\udfd9 a) f\u2081 f\u2082).inv \u226b\n      \ud835\udfd9 a \u25c1 ((\u03bb_ f\u2081).hom \u226b (\u03c1_ f\u2081).inv) \u25b7 f\u2082 \u226b\n        \ud835\udfd9 a \u25c1 (\u03b1_ f\u2081 (\ud835\udfd9 b) f\u2082).hom \u226b\n          (\u03b1_ (\ud835\udfd9 a) f\u2081 (\ud835\udfd9 b \u226b f\u2082)).inv \u226b\n            ((\u03bb_ f\u2081).hom \u226b (\u03c1_ f\u2081).inv) \u25b7 (\ud835\udfd9 b \u226b f\u2082) \u226b\n              (\u03b1_ f\u2081 (\ud835\udfd9 b) (\ud835\udfd9 b \u226b f\u2082)).hom \u226b\n                f\u2081 \u25c1 \ud835\udfd9 b \u25c1 ((\u03bb_ f\u2082).hom \u226b (\u03c1_ f\u2082).inv) \u226b\n                  f\u2081 \u25c1 (\u03b1_ (\ud835\udfd9 b) f\u2082 (\ud835\udfd9 c)).inv \u226b\n                    f\u2081 \u25c1 ((\u03bb_ f\u2082).hom \u226b (\u03c1_ f\u2082).inv) \u25b7 \ud835\udfd9 c \u226b\n                      (f\u2081 \u25c1 (\u03b1_ f\u2082 (\ud835\udfd9 c) (\ud835\udfd9 c)).hom) \u226b\n                        (\u03b1_ f\u2081 f\u2082 (\ud835\udfd9 c \u226b \ud835\udfd9 c)).inv =\n  ((\u03bb_ (\ud835\udfd9 a)).hom \u25b7 (f\u2081 \u226b f\u2082) \u226b (\u03bb_ (f\u2081 \u226b f\u2082)).hom \u226b (\u03c1_ (f\u2081 \u226b f\u2082)).inv) \u226b\n    (f\u2081 \u226b f\u2082) \u25c1 (\u03bb_ (\ud835\udfd9 c)).inv := by\n  pure_coherence\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory", "scoped MonoidalCategory", "scoped Bicategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{B : Type u} [Bicategory.{w, v} B] {a b c d e : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf\u2081 : a \u27f6 b\nf\u2082 : b \u27f6 c\n\u22a2 (\u03b1_ (\ud835\udfd9 a) (\ud835\udfd9 a) (f\u2081 \u226b f\u2082)).hom \u226b\n      \ud835\udfd9 a \u25c1 (\u03b1_ (\ud835\udfd9 a) f\u2081 f\u2082).inv \u226b\n        sorry \u226b\n          \ud835\udfd9 a \u25c1 (\u03b1_ f\u2081 (\ud835\udfd9 b) f\u2082).hom \u226b\n            (\u03b1_ (\ud835\udfd9 a) f\u2081 (\ud835\udfd9 b \u226b f\u2082)).inv \u226b\n              sorry \u226b\n                (\u03b1_ f\u2081 (\ud835\udfd9 b) (\ud835\udfd9 b \u226b f\u2082)).hom \u226b\n                  sorry \u226b\n                    f\u2081 \u25c1 (\u03b1_ (\ud835\udfd9 b) f\u2082 (\ud835\udfd9 c)).inv \u226b sorry \u226b f\u2081 \u25c1 (\u03b1_ f\u2082 (\ud835\udfd9 c) (\ud835\udfd9 c)).hom \u226b (\u03b1_ f\u2081 f\u2082 (\ud835\udfd9 c \u226b \ud835\udfd9 c)).inv =\n    (sorry \u226b sorry \u226b sorry) \u226b sorry"}, {"line": "  pure_coherence", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : MonoidalCategory C\nB : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf\u2081 : a \u27f6 b\nf\u2082 : b \u27f6 c\n\u22a2 (\u03b1_ (\ud835\udfd9 a) (\ud835\udfd9 a) (f\u2081 \u226b f\u2082)).hom \u226b\n      \ud835\udfd9 a \u25c1 (\u03b1_ (\ud835\udfd9 a) f\u2081 f\u2082).inv \u226b\n        sorry \u226b\n          \ud835\udfd9 a \u25c1 (\u03b1_ f\u2081 (\ud835\udfd9 b) f\u2082).hom \u226b\n            (\u03b1_ (\ud835\udfd9 a) f\u2081 (\ud835\udfd9 b \u226b f\u2082)).inv \u226b\n              sorry \u226b\n                (\u03b1_ f\u2081 (\ud835\udfd9 b) (\ud835\udfd9 b \u226b f\u2082)).hom \u226b\n                  sorry \u226b\n                    f\u2081 \u25c1 (\u03b1_ (\ud835\udfd9 b) f\u2082 (\ud835\udfd9 c)).inv \u226b sorry \u226b f\u2081 \u25c1 (\u03b1_ f\u2082 (\ud835\udfd9 c) (\ud835\udfd9 c)).hom \u226b (\u03b1_ f\u2081 f\u2082 (\ud835\udfd9 c \u226b \ud835\udfd9 c)).inv =\n    (sorry \u226b sorry \u226b sorry) \u226b sorry"}]}
{"declaration": "theorem ex1 [Category C] [HasForget C] (X : C) (f g h : X \u27f6 X) (h' : g \u226b h = h \u226b g) :\n    f \u226b g \u226b h = f \u226b h \u226b g := by rw [h']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : HasForget C\nX : C\nf g h : X \u27f6 X\nh' : g \u226b h = h \u226b g\n\u22a2 f \u226b g \u226b h = f \u226b h \u226b g"}]}
{"declaration": "theorem ex2 [Category C] (X : C) (f g h : X \u27f6 X) (h' : g \u226b h = h \u226b g) :\n    f \u226b g \u226b h = f \u226b h \u226b g := by rw [h']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nX : C\nf g h : X \u27f6 X\nh' : g \u226b h = h \u226b g\n\u22a2 f \u226b g \u226b h = f \u226b h \u226b g"}]}
{"declaration": "example : \u2200 C [Category C] (X Y : C) (f : X \u2245 Y)\n    {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]\n    [ConcreteCategory C FC]\n    (x : ToType X), f.inv (f.hom x) = x := by intros; simp only [ex3_apply]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (C : Type u_1) [inst : Category.{u_2, u_1} C] (X Y : C) (f : X \u2245 Y) {FC : C \u2192 C \u2192 Type u_3} {CC : C \u2192 Type u_4}\n    [inst_1 : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)] [inst_2 : ConcreteCategory C FC] (x : ToType X),\n    (ConcreteCategory.hom f.inv) ((ConcreteCategory.hom f.hom) x) = x"}]}
{"declaration": "lemma foo [Category C]\n    {M N K : C} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) : f \u226b \ud835\udfd9 N \u226b g = h := by\n  simp [w]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nM N K : C\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\n\u22a2 f \u226b \ud835\udfd9 N \u226b g = h"}, {"line": "  simp [w]", "tactic_state": ""}]}
{"declaration": "lemma foo' [Category C]\n    {M N K : C} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) : f \u226b \ud835\udfd9 N \u226b g = h := by\n  simp [w]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nM N K : C\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\n\u22a2 f \u226b \ud835\udfd9 N \u226b g = h"}, {"line": "  simp [w]", "tactic_state": ""}]}
{"declaration": "example {M N K : Type} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : M) :\n  g (f x) = h x := by\n  have := elementwise_of% w\n  guard_hyp this : \u2200 (x : M), g (f x) = h x\n  exact this x\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N K : Type\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : M\n\u22a2 g (f x) = h x"}, {"line": "  have := elementwise_of% w", "tactic_state": "M N K : Type\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : M\nthis : \u2200 (x : M), g (f x) = h x\n\u22a2 g (f x) = h x"}, {"line": "  guard_hyp this : \u2200 (x : M), g (f x) = h x", "tactic_state": "M N K : Type\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : M\nthis : \u2200 (x : M), g (f x) = h x\n\u22a2 g (f x) = h x"}, {"line": "  exact this x", "tactic_state": ""}]}
{"declaration": "lemma bar' {M N K : MonCat} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : M) :\n    g (f x) = h x := by exact foo_apply w x\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}]}
{"declaration": "lemma bar'' {M N K : MonCat} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : M) :\n    g (f x) = h x := by apply foo_apply w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}]}
{"declaration": "lemma bar''' {M N K : MonCat} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : M) :\n    g (f x) = h x := by apply foo_apply w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}]}
{"declaration": "example (M N K : MonCat) (f : M \u27f6 N) (g : N \u27f6 K) (h : M \u27f6 K) (w : f \u226b g = h) (m : M) :\n    g (f m) = h m := by rw [elementwise_of% w]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nm : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) m) = (ConcreteCategory.hom h) m"}]}
{"declaration": "example (M N K : MonCat) (f : M \u27f6 N) (g : N \u27f6 K) (h : M \u27f6 K) (w : f \u226b g = h) (m : M) :\n    g (f m) = h m := by\n  replace w := elementwise_of% w\n  apply w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nm : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) m) = (ConcreteCategory.hom h) m"}, {"line": "  replace w := elementwise_of% w", "tactic_state": "M N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nm : \u2191M\nw : \u2200 (x : ToType M), (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) m) = (ConcreteCategory.hom h) m"}, {"line": "  apply w", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f g : \u03b1 \u27f6 \u03b2) (w : f = g) (a : \u03b1) : f a = g a := by\n  replace w := elementwise_of% w\n  guard_hyp w : \u2200 (x : \u03b1), f x = g x\n  rw [w]\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\nw : f = g\na : \u03b1\n\u22a2 f a = g a"}, {"line": "  replace w := elementwise_of% w", "tactic_state": "\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\nw : f = g\na : \u03b1\n\u22a2 f a = g a"}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f g : \u03b1 \u27f6 \u03b2) (w : f \u226b \ud835\udfd9 \u03b2 = g) (a : \u03b1) : f a = g a := by\n  replace w := elementwise_of% w\n  guard_hyp w : \u2200 (x : \u03b1), f x = g x\n  rw [w]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\nw : f \u226b \ud835\udfd9 \u03b2 = g\na : \u03b1\n\u22a2 f a = g a"}, {"line": "  replace w := elementwise_of% w", "tactic_state": "\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\na : \u03b1\nw : \u2200 (x : \u03b1), f x = g x\n\u22a2 f a = g a"}, {"line": "  guard_hyp w : \u2200 (x : \u03b1), f x = g x", "tactic_state": "\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\na : \u03b1\nw : \u2200 (x : \u03b1), f x = g x\n\u22a2 f a = g a"}, {"line": "  rw [w]", "tactic_state": ""}]}
{"declaration": "theorem ex1 [Category C] [ConcreteCategory C FC] (X : C) (f g h : X \u27f6 X) (h' : g \u226b h = h \u226b g) :\n    f \u226b g \u226b h = f \u226b h \u226b g := by rw [h']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d\u00b2 : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\ninst\u271d\u00b9 : Category.{u_5, u_2} C\ninst\u271d : ConcreteCategory C FC\nX : C\nf g h : X \u27f6 X\nh' : g \u226b h = h \u226b g\n\u22a2 f \u226b g \u226b h = f \u226b h \u226b g"}]}
{"declaration": "lemma foo [Category C]\n    {M N K : C} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) : f \u226b \ud835\udfd9 N \u226b g = h := by\n  simp [w]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_2\ninst\u271d : Category.{u_5, u_2} C\nM N K : C\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\n\u22a2 f \u226b \ud835\udfd9 N \u226b g = h"}, {"line": "  simp [w]", "tactic_state": ""}]}
{"declaration": "lemma foo' [Category C]\n    {M N K : C} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) : f \u226b \ud835\udfd9 N \u226b g = h := by\n  simp [w]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_2\ninst\u271d : Category.{u_5, u_2} C\nM N K : C\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\n\u22a2 f \u226b \ud835\udfd9 N \u226b g = h"}, {"line": "  simp [w]", "tactic_state": ""}]}
{"declaration": "lemma bar [Category C]\n    {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]\n    [ConcreteCategory C FC]\n    {M N K : C} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : ToType M) : g (f x) = h x := by\n  apply foo_apply w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_2\ninst\u271d\u00b2 : Category.{u_5, u_2} C\nFC : C \u2192 C \u2192 Type u_6\nCC : C \u2192 Type u_7\ninst\u271d\u00b9 : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\ninst\u271d : ConcreteCategory C FC\nM N K : C\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : ToType M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}, {"line": "  apply foo_apply w", "tactic_state": ""}]}
{"declaration": "example {M N K : Type} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : M) :\n  g (f x) = h x := by\n  have := elementwise_of% w\n  guard_hyp this : \u2200 (x : M), g (f x) = h x\n  exact this x\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\nM N K : Type\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : M\n\u22a2 g (f x) = h x"}, {"line": "  have := elementwise_of% w", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\nM N K : Type\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : M\nthis : \u2200 (x : M), g (f x) = h x\n\u22a2 g (f x) = h x"}, {"line": "  guard_hyp this : \u2200 (x : M), g (f x) = h x", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\nM N K : Type\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : M\nthis : \u2200 (x : M), g (f x) = h x\n\u22a2 g (f x) = h x"}, {"line": "  exact this x", "tactic_state": ""}]}
{"declaration": "example [Category C] {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _}\n    [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)] [ConcreteCategory C FC]\n    {M N K : C} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : ToType M) :\n    g (f x) = h x := by\n  have := elementwise_of% w\n  guard_hyp this : \u2200 (x : ToType M), g (f x) = h x\n  exact this x\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u2075 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d\u00b9 : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d\u00b9 : C\u271d \u2192 Type ?u.323\ninst\u271d\u2074 : (X Y : C\u271d) \u2192 FunLike (FC\u271d\u00b9 X Y) (CC\u271d\u00b9 X) (CC\u271d\u00b9 Y)\nC : Type u_2\nFC\u271d : C \u2192 C \u2192 Type u_3\nCC\u271d : C \u2192 Type u_4\ninst\u271d\u00b3 : (X Y : C) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\ninst\u271d\u00b2 : Category.{u_5, u_2} C\nFC : C \u2192 C \u2192 Type u_6\nCC : C \u2192 Type u_7\ninst\u271d\u00b9 : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\ninst\u271d : ConcreteCategory C FC\nM N K : C\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : ToType M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}, {"line": "  have := elementwise_of% w", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u2075 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d\u00b9 : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d\u00b9 : C\u271d \u2192 Type ?u.323\ninst\u271d\u2074 : (X Y : C\u271d) \u2192 FunLike (FC\u271d\u00b9 X Y) (CC\u271d\u00b9 X) (CC\u271d\u00b9 Y)\nC : Type u_2\nFC\u271d : C \u2192 C \u2192 Type u_3\nCC\u271d : C \u2192 Type u_4\ninst\u271d\u00b3 : (X Y : C) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\ninst\u271d\u00b2 : Category.{u_5, u_2} C\nFC : C \u2192 C \u2192 Type u_6\nCC : C \u2192 Type u_7\ninst\u271d\u00b9 : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\ninst\u271d : ConcreteCategory C FC\nM N K : C\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : ToType M\nthis : \u2200 (x : ToType M), (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}, {"line": "  guard_hyp this : \u2200 (x : ToType M), g (f x) = h x", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u2075 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d\u00b9 : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d\u00b9 : C\u271d \u2192 Type ?u.323\ninst\u271d\u2074 : (X Y : C\u271d) \u2192 FunLike (FC\u271d\u00b9 X Y) (CC\u271d\u00b9 X) (CC\u271d\u00b9 Y)\nC : Type u_2\nFC\u271d : C \u2192 C \u2192 Type u_3\nCC\u271d : C \u2192 Type u_4\ninst\u271d\u00b3 : (X Y : C) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\ninst\u271d\u00b2 : Category.{u_5, u_2} C\nFC : C \u2192 C \u2192 Type u_6\nCC : C \u2192 Type u_7\ninst\u271d\u00b9 : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\ninst\u271d : ConcreteCategory C FC\nM N K : C\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : ToType M\nthis : \u2200 (x : ToType M), (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}, {"line": "  exact this x", "tactic_state": ""}]}
{"declaration": "lemma bar' {M N K : MonCat} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : M) :\n    g (f x) = h x := by exact foo_apply w x\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}]}
{"declaration": "lemma bar'' {M N K : MonCat} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : M) :\n    g (f x) = h x := by apply foo_apply w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}]}
{"declaration": "lemma bar''' {M N K : MonCat} {f : M \u27f6 N} {g : N \u27f6 K} {h : M \u27f6 K} (w : f \u226b g = h) (x : M) :\n    g (f x) = h x := by apply foo_apply w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nx : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x"}]}
{"declaration": "example (M N K : MonCat) (f : M \u27f6 N) (g : N \u27f6 K) (h : M \u27f6 K) (w : f \u226b g = h) (m : M) :\n    g (f m) = h m := by rw [elementwise_of% w]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\nM N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nm : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) m) = (ConcreteCategory.hom h) m"}]}
{"declaration": "example (M N K : MonCat) (f : M \u27f6 N) (g : N \u27f6 K) (h : M \u27f6 K) (w : f \u226b g = h) (m : M) :\n    g (f m) = h m := by\n  replace w := elementwise_of% w\n  apply w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\nM N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nw : f \u226b g = h\nm : \u2191M\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) m) = (ConcreteCategory.hom h) m"}, {"line": "  replace w := elementwise_of% w", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\nM N K : MonCat\nf : M \u27f6 N\ng : N \u27f6 K\nh : M \u27f6 K\nm : \u2191M\nw : \u2200 (x : ToType M), (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x) = (ConcreteCategory.hom h) x\n\u22a2 (ConcreteCategory.hom g) ((ConcreteCategory.hom f) m) = (ConcreteCategory.hom h) m"}, {"line": "  apply w", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f g : \u03b1 \u27f6 \u03b2) (w : f = g) (a : \u03b1) : f a = g a := by\n  replace w := elementwise_of% w\n  guard_hyp w : \u2200 (x : \u03b1), f x = g x\n  rw [w]\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\n\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\nw : f = g\na : \u03b1\n\u22a2 f a = g a"}, {"line": "  replace w := elementwise_of% w", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\n\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\nw : f = g\na : \u03b1\n\u22a2 f a = g a"}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f g : \u03b1 \u27f6 \u03b2) (w : f \u226b \ud835\udfd9 \u03b2 = g) (a : \u03b1) : f a = g a := by\n  replace w := elementwise_of% w\n  guard_hyp w : \u2200 (x : \u03b1), f x = g x\n  rw [w]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Elementwise.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type*} [Category C]", "(X : C) {FC : C \u2192 C \u2192 Type _} {CC : C \u2192 Type _} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "[ConcreteCategory C FC] (x : X)", "{C : Type*} {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\n\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\nw : f \u226b \ud835\udfd9 \u03b2 = g\na : \u03b1\n\u22a2 f a = g a"}, {"line": "  replace w := elementwise_of% w", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\n\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\na : \u03b1\nw : \u2200 (x : \u03b1), f x = g x\n\u22a2 f a = g a"}, {"line": "  guard_hyp w : \u2200 (x : \u03b1), f x = g x", "tactic_state": "C\u271d : Type u_1\ninst\u271d\u00b2 : Category.{?u.309, u_1} C\u271d\nX : C\u271d\nFC\u271d : C\u271d \u2192 C\u271d \u2192 Type ?u.318\nCC\u271d : C\u271d \u2192 Type ?u.323\ninst\u271d\u00b9 : (X Y : C\u271d) \u2192 FunLike (FC\u271d X Y) (CC\u271d X) (CC\u271d Y)\nC : Type u_2\nFC : C \u2192 C \u2192 Type u_3\nCC : C \u2192 Type u_4\ninst\u271d : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\n\u03b1 \u03b2 : Type\nf g : \u03b1 \u27f6 \u03b2\na : \u03b1\nw : \u2200 (x : \u03b1), f x = g x\n\u22a2 f a = g a"}, {"line": "  rw [w]", "tactic_state": ""}]}
{"declaration": "example {f j : a \u27f6 d} {g : a \u27f6 b} {h : b \u27f6 c} {i : c \u27f6 d}\n    (\u03b7 : f \u27f6 g \u226b (h \u226b i)) (\u03b8 : (g \u226b h) \u226b i \u27f6 j) :\n    \u03b7 \u2297\u226b \u03b8 = \u03b7 \u226b (\u03b1_ _ _ _).inv \u226b \u03b8 := by\n  bicategory\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Bicategory/Basic.lean", "context": {"open": ["CategoryTheory Mathlib.Tactic BicategoryLike", "Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c d : B\nf j : a \u27f6 d\ng : a \u27f6 b\nh : b \u27f6 c\ni : c \u27f6 d\n\u03b7 : f \u27f6 g \u226b h \u226b i\n\u03b8 : (g \u226b h) \u226b i \u27f6 j\n\u22a2 \u03b7 \u2297\u226b \u03b8 = \u03b7 \u226b (\u03b1_ g h i).inv \u226b \u03b8"}, {"line": "  bicategory", "tactic_state": ""}]}
{"declaration": "example {f : a \u27f6 b} {g : b \u27f6 c} {h i : c \u27f6 d} (\u03b7 : h \u27f6 i) :\n    (f \u226b g) \u25c1 \u03b7 = (\u03b1_ _ _ _).hom \u226b f \u25c1 g \u25c1 \u03b7 \u226b (\u03b1_ _ _ _).inv := by\n  bicategory\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Bicategory/Basic.lean", "context": {"open": ["CategoryTheory Mathlib.Tactic BicategoryLike", "Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c d : B\nf : a \u27f6 b\ng : b \u27f6 c\nh i : c \u27f6 d\n\u03b7 : h \u27f6 i\n\u22a2 (f \u226b g) \u25c1 \u03b7 = (\u03b1_ f g h).hom \u226b f \u25c1 g \u25c1 \u03b7 \u226b (\u03b1_ f g i).inv"}, {"line": "  bicategory", "tactic_state": ""}]}
{"declaration": "example {f g h : a \u27f6 b} {\u03b7 : f \u27f6 g} {\u03b8 : g \u27f6 h} : \u03b7 \u226b \u03b8 = \u03b7 \u226b \u03b8 := by\n  bicategory", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Bicategory/Basic.lean", "context": {"open": ["CategoryTheory Mathlib.Tactic BicategoryLike", "Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c d : B\nf g h : a \u27f6 b\n\u03b7 : f \u27f6 g\n\u03b8 : g \u27f6 h\n\u22a2 \u03b7 \u226b \u03b8 = \u03b7 \u226b \u03b8"}, {"line": "  bicategory", "tactic_state": ""}]}
{"declaration": "example : \u21d1(\ud835\udfd9 (of X)) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\n\u22a2 \u21d1(Hom.hom (\ud835\udfd9 sorry)) = id"}]}
{"declaration": "example {U V W : ProfiniteGrp} (f : U \u27f6 V) (g : V \u27f6 W) : \u21d1(f \u226b g) = \u21d1g \u2218 \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\nU V W : ProfiniteGrp.{u_1}\nf : U \u27f6 V\ng : V \u27f6 W\n\u22a2 \u21d1(Hom.hom (f \u226b g)) = \u21d1(Hom.hom g) \u2218 \u21d1(Hom.hom f)"}]}
{"declaration": "example {U V : ProfiniteGrp} (f : U \u27f6 V) (g : V \u27f6 of Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\nU V : ProfiniteGrp.{u}\nf : U \u27f6 V\ng : V \u27f6 sorry\n\u22a2 \u21d1(Hom.hom (f \u226b g)) = \u21d1(Hom.hom g) \u2218 \u21d1(Hom.hom f)"}]}
{"declaration": "example {V W : ProfiniteGrp} (f : of X \u27f6 V) (g : V \u27f6 W) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\nV W : ProfiniteGrp.{u}\nf : sorry \u27f6 V\ng : V \u27f6 W\n\u22a2 \u21d1(Hom.hom (f \u226b g)) = \u21d1(Hom.hom g) \u2218 \u21d1(Hom.hom f)"}]}
{"declaration": "example {U V W : ProfiniteGrp} (f : U \u27f6 V) (g : V \u27f6 W) (u : U) : (f \u226b g) u = g (f u) := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\nU V W : ProfiniteGrp.{u_1}\nf : U \u27f6 V\ng : V \u27f6 W\nu : \u2191U.toProfinite.toTop\n\u22a2 (Hom.hom (f \u226b g)) u = (Hom.hom g) ((Hom.hom f) u)"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {U V : ProfiniteGrp} (e : U \u2245 V) (u : U) : e.inv (e.hom u) = u := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\nU V : ProfiniteGrp.{u_1}\ne : U \u2245 V\nu : \u2191U.toProfinite.toTop\n\u22a2 (Hom.hom e.inv) ((Hom.hom e.hom) u) = u"}]}
{"declaration": "example {U V : ProfiniteGrp} (e : U \u2245 V) (v : V) : e.hom (e.inv v) = v := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\nU V : ProfiniteGrp.{u_1}\ne : U \u2245 V\nv : \u2191V.toProfinite.toTop\n\u22a2 (Hom.hom e.hom) ((Hom.hom e.inv) v) = v"}]}
{"declaration": "example (U : ProfiniteGrp) : \u21d1(\ud835\udfd9 U) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\nU : ProfiniteGrp.{u_1}\n\u22a2 \u21d1(Hom.hom (\ud835\udfd9 U)) = id"}]}
{"declaration": "example {M N : ProfiniteGrp.{u}} (f : M \u27f6 N) (x y : M) : f (x * y) = f x * f y := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\nM N : ProfiniteGrp.{u}\nf : M \u27f6 N\nx y : \u2191M.toProfinite.toTop\n\u22a2 (Hom.hom f) (x * y) = (Hom.hom f) x * (Hom.hom f) y"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {M N : ProfiniteGrp.{u}} (f : M \u27f6 N) : f 1 = 1 := by\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ProfiniteGrp.lean", "context": {"open": ["CategoryTheory ProfiniteGrp"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : IsTopologicalGroup X\nM N : ProfiniteGrp.{u}\nf : M \u27f6 N\n\u22a2 (Hom.hom f) 1 = 1"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example (X : Type u) [Monoid X] : \u21d1(\ud835\udfd9 (of X)) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : Monoid X\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 (of X))) = id"}]}
{"declaration": "example {X Y : Type u} [Monoid X] [Monoid Y] (f : X \u2192* Y) :\n    \u21d1(ofHom f) = \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Monoid X\ninst\u271d : Monoid Y\nf : X \u2192* Y\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f)) = \u21d1f"}]}
{"declaration": "example {X Y : Type u} [Monoid X] [Monoid Y] (f : X \u2192* Y)\n    (x : X) : (ofHom f) x = f x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Monoid X\ninst\u271d : Monoid Y\nf : X \u2192* Y\nx : X\n\u22a2 (ConcreteCategory.hom (ofHom f)) x = f x"}]}
{"declaration": "example {X Y Z : MonCat} (f : X \u27f6 Y) (g : Y \u27f6 Z) : \u21d1(f \u226b g) = \u21d1g \u2218 \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : MonCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : Type u} [Monoid X] [Monoid Y] [Monoid Z]\n    (f : X \u2192* Y) (g : Y \u2192* Z) :\n    \u21d1(ofHom f \u226b ofHom g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Monoid X\ninst\u271d\u00b9 : Monoid Y\ninst\u271d : Monoid Z\nf : X \u2192* Y\ng : Y \u2192* Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b ofHom g)) = \u21d1g \u2218 \u21d1f"}]}
{"declaration": "example {X Y : Type u} [Monoid X] [Monoid Y] {Z : MonCat}\n    (f : X \u2192* Y) (g : of Y \u27f6 Z) :\n    \u21d1(ofHom f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Monoid X\ninst\u271d : Monoid Y\nZ : MonCat\nf : X \u2192* Y\ng : of Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1f"}]}
{"declaration": "example {X Y : MonCat} {Z : Type u} [Monoid Z] (f : X \u27f6 Y) (g : Y \u27f6 of Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : MonCat\nZ : Type u\ninst\u271d : Monoid Z\nf : X \u27f6 Y\ng : Y \u27f6 of Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {Y Z : MonCat} {X : Type u} [Monoid X] (f : of X \u27f6 Y) (g : Y \u27f6 Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Y Z : MonCat\nX : Type u\ninst\u271d : Monoid X\nf : of X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : MonCat} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) : (f \u226b g) x = g (f x) := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : MonCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (f \u226b g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}]}
{"declaration": "example {X Y : MonCat} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : MonCat\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}]}
{"declaration": "example {X Y : MonCat} (e : X \u2245 Y) (y : Y) : e.hom (e.inv y) = y := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : MonCat\ne : X \u2245 Y\ny : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) y) = y"}]}
{"declaration": "example (X : MonCat) : \u21d1(\ud835\udfd9 X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : MonCat\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 X)) = id"}]}
{"declaration": "example {X : Type*} [Monoid X] : \u21d1(MonoidHom.id X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : Monoid X\n\u22a2 \u21d1(MonoidHom.id X) = id"}]}
{"declaration": "example {M N : MonCat} (f : M \u27f6 N) (x y : M) : f (x * y) = f x * f y := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : MonCat\nf : M \u27f6 N\nx y : \u2191M\n\u22a2 (ConcreteCategory.hom f) (x * y) = (ConcreteCategory.hom f) x * (ConcreteCategory.hom f) y"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {M N : MonCat} (f : M \u27f6 N) : f 1 = 1 := by\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/MonCat.lean", "context": {"open": ["CategoryTheory MonCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : MonCat\nf : M \u27f6 N\n\u22a2 (ConcreteCategory.hom f) 1 = 1"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example (X : Type u) [Semiring X] : \u21d1(\ud835\udfd9 (of X)) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : Semiring X\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 (of X))) = id"}]}
{"declaration": "example {X Y : Type u} [Semiring X] [Semiring Y] (f : X \u2192+* Y) :\n    \u21d1(ofHom f) = \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Semiring X\ninst\u271d : Semiring Y\nf : X \u2192+* Y\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f)) = \u21d1f"}]}
{"declaration": "example {X Y : Type u} [Semiring X] [Semiring Y] (f : X \u2192+* Y)\n    (x : X) : (ofHom f) x = f x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Semiring X\ninst\u271d : Semiring Y\nf : X \u2192+* Y\nx : X\n\u22a2 (ConcreteCategory.hom (ofHom f)) x = f x"}]}
{"declaration": "example {X Y Z : SemiRingCat} (f : X \u27f6 Y) (g : Y \u27f6 Z) : \u21d1(f \u226b g) = \u21d1g \u2218 \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : SemiRingCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : Type u} [Semiring X] [Semiring Y] [Semiring Z]\n    (f : X \u2192+* Y) (g : Y \u2192+* Z) :\n    \u21d1(ofHom f \u226b ofHom g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Semiring X\ninst\u271d\u00b9 : Semiring Y\ninst\u271d : Semiring Z\nf : X \u2192+* Y\ng : Y \u2192+* Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b ofHom g)) = \u21d1g \u2218 \u21d1f"}]}
{"declaration": "example {X Y : Type u} [Semiring X] [Semiring Y] {Z : SemiRingCat}\n    (f : X \u2192+* Y) (g : of Y \u27f6 Z) :\n    \u21d1(ofHom f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Semiring X\ninst\u271d : Semiring Y\nZ : SemiRingCat\nf : X \u2192+* Y\ng : of Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1f"}]}
{"declaration": "example {X Y : SemiRingCat} {Z : Type u} [Semiring Z] (f : X \u27f6 Y) (g : Y \u27f6 of Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : SemiRingCat\nZ : Type u\ninst\u271d : Semiring Z\nf : X \u27f6 Y\ng : Y \u27f6 of Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {Y Z : SemiRingCat} {X : Type u} [Semiring X] (f : of X \u27f6 Y) (g : Y \u27f6 Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Y Z : SemiRingCat\nX : Type u\ninst\u271d : Semiring X\nf : of X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : SemiRingCat} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) : (f \u226b g) x = g (f x) := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : SemiRingCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (f \u226b g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}]}
{"declaration": "example {X Y : SemiRingCat} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : SemiRingCat\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}]}
{"declaration": "example {X Y : SemiRingCat} (e : X \u2245 Y) (y : Y) : e.hom (e.inv y) = y := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : SemiRingCat\ne : X \u2245 Y\ny : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) y) = y"}]}
{"declaration": "example (X : SemiRingCat) : \u21d1(\ud835\udfd9 X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : SemiRingCat\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 X)) = id"}]}
{"declaration": "example {X : Type*} [Semiring X] : \u21d1(RingHom.id X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : Semiring X\n\u22a2 \u21d1(RingHom.id X) = id"}]}
{"declaration": "example {M N : SemiRingCat} (f : M \u27f6 N) (x y : M) : f (x + y) = f x + f y := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : SemiRingCat\nf : M \u27f6 N\nx y : \u2191M\n\u22a2 (ConcreteCategory.hom f) (x + y) = (ConcreteCategory.hom f) x + (ConcreteCategory.hom f) y"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {M N : SemiRingCat} (f : M \u27f6 N) (x y : M) : f (x * y) = f x * f y := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : SemiRingCat\nf : M \u27f6 N\nx y : \u2191M\n\u22a2 (ConcreteCategory.hom f) (x * y) = (ConcreteCategory.hom f) x * (ConcreteCategory.hom f) y"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {M N : SemiRingCat} (f : M \u27f6 N) : f 0 = 0 := by\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Ring.lean", "context": {"open": ["CategoryTheory SemiRingCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : SemiRingCat\nf : M \u27f6 N\n\u22a2 (ConcreteCategory.hom f) 0 = 0"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example (X : Type u) [Semigroup X] : \u21d1(\ud835\udfd9 (of X)) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : Semigroup X\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 (of X))) = id"}]}
{"declaration": "example {X Y : Type u} [Semigroup X] [Semigroup Y] (f : X \u2192\u2099* Y) :\n    \u21d1(ofHom f) = \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Semigroup X\ninst\u271d : Semigroup Y\nf : X \u2192\u2099* Y\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f)) = \u21d1f"}]}
{"declaration": "example {X Y : Type u} [Semigroup X] [Semigroup Y] (f : X \u2192\u2099* Y)\n    (x : X) : (ofHom f) x = f x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Semigroup X\ninst\u271d : Semigroup Y\nf : X \u2192\u2099* Y\nx : X\n\u22a2 (ConcreteCategory.hom (ofHom f)) x = f x"}]}
{"declaration": "example {X Y Z : Semigrp} (f : X \u27f6 Y) (g : Y \u27f6 Z) : \u21d1(f \u226b g) = \u21d1g \u2218 \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Semigrp\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : Type u} [Semigroup X] [Semigroup Y] [Semigroup Z]\n    (f : X \u2192\u2099* Y) (g : Y \u2192\u2099* Z) :\n    \u21d1(ofHom f \u226b ofHom g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Semigroup X\ninst\u271d\u00b9 : Semigroup Y\ninst\u271d : Semigroup Z\nf : X \u2192\u2099* Y\ng : Y \u2192\u2099* Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b ofHom g)) = \u21d1g \u2218 \u21d1f"}]}
{"declaration": "example {X Y : Type u} [Semigroup X] [Semigroup Y] {Z : Semigrp}\n    (f : X \u2192\u2099* Y) (g : of Y \u27f6 Z) :\n    \u21d1(ofHom f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Semigroup X\ninst\u271d : Semigroup Y\nZ : Semigrp\nf : X \u2192\u2099* Y\ng : of Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1f"}]}
{"declaration": "example {X Y : Semigrp} {Z : Type u} [Semigroup Z] (f : X \u27f6 Y) (g : Y \u27f6 of Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Semigrp\nZ : Type u\ninst\u271d : Semigroup Z\nf : X \u27f6 Y\ng : Y \u27f6 of Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {Y Z : Semigrp} {X : Type u} [Semigroup X] (f : of X \u27f6 Y) (g : Y \u27f6 Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Y Z : Semigrp\nX : Type u\ninst\u271d : Semigroup X\nf : of X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : Semigrp} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) : (f \u226b g) x = g (f x) := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Semigrp\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (f \u226b g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}]}
{"declaration": "example {X Y : Semigrp} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Semigrp\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}]}
{"declaration": "example {X Y : Semigrp} (e : X \u2245 Y) (y : Y) : e.hom (e.inv y) = y := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Semigrp\ne : X \u2245 Y\ny : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) y) = y"}]}
{"declaration": "example (X : Semigrp) : \u21d1(\ud835\udfd9 X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Semigrp\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 X)) = id"}]}
{"declaration": "example {X : Type*} [Semigroup X] : \u21d1(MulHom.id X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : Semigroup X\n\u22a2 \u21d1(MulHom.id X) = id"}]}
{"declaration": "example {M N : Semigrp} (f : M \u27f6 N) (x y : M) : f (x * y) = f x * f y := by\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Semigrp.lean", "context": {"open": ["CategoryTheory Semigrp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : Semigrp\nf : M \u27f6 N\nx y : \u2191M\n\u22a2 (ConcreteCategory.hom f) (x * y) = (ConcreteCategory.hom f) x * (ConcreteCategory.hom f) y"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example (X : Type v) [AddCommGroup X] [Module R X] : \u21d1(\ud835\udfd9 (of R X)) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nX : Type v\ninst\u271d\u00b9 : AddCommGroup X\ninst\u271d : Module R X\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 (of R X))) = id"}]}
{"declaration": "example {X Y : Type v} [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X \u2192\u2097[R] Y) :\n    \u21d1(ModuleCat.ofHom f) = \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\nX Y : Type v\ninst\u271d\u00b3 : AddCommGroup X\ninst\u271d\u00b2 : Module R X\ninst\u271d\u00b9 : AddCommGroup Y\ninst\u271d : Module R Y\nf : X \u2192\u2097[R] Y\n\u22a2 \u21d1(ConcreteCategory.hom (\u219ff)) = \u21d1f"}]}
{"declaration": "example {X Y : Type v} [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X \u2192\u2097[R] Y)\n    (x : X) : (ModuleCat.ofHom f) x = f x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\nX Y : Type v\ninst\u271d\u00b3 : AddCommGroup X\ninst\u271d\u00b2 : Module R X\ninst\u271d\u00b9 : AddCommGroup Y\ninst\u271d : Module R Y\nf : X \u2192\u2097[R] Y\nx : X\n\u22a2 (ConcreteCategory.hom (\u219ff)) x = f x"}]}
{"declaration": "example {X Y Z : ModuleCat R} (f : X \u27f6 Y) (g : Y \u27f6 Z) : \u21d1(f \u226b g) = \u21d1g \u2218 \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX Y Z : ModuleCat R\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : Type v} [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [Ring Z]\n    [Algebra R Z] (f : X \u2192\u2097[R] Y) (g : Y \u2192\u2097[R] Z) :\n    \u21d1(ModuleCat.ofHom f \u226b ModuleCat.ofHom g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2076 : CommRing R\nX Y Z : Type v\ninst\u271d\u2075 : AddCommGroup X\ninst\u271d\u2074 : Module R X\ninst\u271d\u00b3 : AddCommGroup Y\ninst\u271d\u00b2 : Module R Y\ninst\u271d\u00b9 : Ring Z\ninst\u271d : Algebra R Z\nf : X \u2192\u2097[R] Y\ng : Y \u2192\u2097[R] Z\n\u22a2 \u21d1(ConcreteCategory.hom (\u219ff \u226b \u219fg)) = \u21d1g \u2218 \u21d1f"}]}
{"declaration": "example {X Y : Type v} [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] {Z : ModuleCat R}\n    (f : X \u2192\u2097[R] Y) (g : of R Y \u27f6 Z) :\n    \u21d1(ModuleCat.ofHom f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\nX Y : Type v\ninst\u271d\u00b3 : AddCommGroup X\ninst\u271d\u00b2 : Module R X\ninst\u271d\u00b9 : AddCommGroup Y\ninst\u271d : Module R Y\nZ : ModuleCat R\nf : X \u2192\u2097[R] Y\ng : of R Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (\u219ff \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1f"}]}
{"declaration": "example {X Y : ModuleCat R} {Z : Type v} [Ring Z] [Algebra R Z] (f : X \u27f6 Y) (g : Y \u27f6 of R Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nX Y : ModuleCat R\nZ : Type v\ninst\u271d\u00b9 : Ring Z\ninst\u271d : Algebra R Z\nf : X \u27f6 Y\ng : Y \u27f6 of R Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {Y Z : ModuleCat R} {X : Type v} [AddCommGroup X] [Module R X] (f : of R X \u27f6 Y) (g : Y \u27f6 Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nY Z : ModuleCat R\nX : Type v\ninst\u271d\u00b9 : AddCommGroup X\ninst\u271d : Module R X\nf : of R X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : ModuleCat R} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) : (f \u226b g) x = g (f x) := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX Y Z : ModuleCat R\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (f \u226b g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}]}
{"declaration": "example {X Y : ModuleCat R} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX Y : ModuleCat R\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}]}
{"declaration": "example {X Y : ModuleCat R} (e : X \u2245 Y) (y : Y) : e.hom (e.inv y) = y := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX Y : ModuleCat R\ne : X \u2245 Y\ny : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) y) = y"}]}
{"declaration": "example (X : ModuleCat R) : \u21d1(\ud835\udfd9 X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX : ModuleCat R\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 X)) = id"}]}
{"declaration": "example {M N : ModuleCat.{v} R} (f : M \u27f6 N) (x y : M) : f (x + y) = f x + f y := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM N : ModuleCat R\nf : M \u27f6 N\nx y : \u2191M\n\u22a2 (ConcreteCategory.hom f) (x + y) = (ConcreteCategory.hom f) x + (ConcreteCategory.hom f) y"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {M N : ModuleCat.{v} R} (f : M \u27f6 N) : f 0 = 0 := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM N : ModuleCat R\nf : M \u27f6 N\n\u22a2 (ConcreteCategory.hom f) 0 = 0"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {M N : ModuleCat.{v} R} (f : M \u27f6 N) (r : R) (m : M) : f (r \u2022 m) = r \u2022 f m := by\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/ModuleCat.lean", "context": {"open": ["CategoryTheory ModuleCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM N : ModuleCat R\nf : M \u27f6 N\nr : R\nm : \u2191M\n\u22a2 (ConcreteCategory.hom f) (r \u2022 m) = r \u2022 (ConcreteCategory.hom f) m"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example (X : Type u) [Group X] : \u21d1(\ud835\udfd9 (of X)) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : Group X\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 (of X))) = id"}]}
{"declaration": "example {X Y : Type u} [Group X] [Group Y] (f : X \u2192* Y) :\n    \u21d1(ofHom f) = \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Group X\ninst\u271d : Group Y\nf : X \u2192* Y\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f)) = \u21d1f"}]}
{"declaration": "example {X Y : Type u} [Group X] [Group Y] (f : X \u2192* Y)\n    (x : X) : (ofHom f) x = f x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Group X\ninst\u271d : Group Y\nf : X \u2192* Y\nx : X\n\u22a2 (ConcreteCategory.hom (ofHom f)) x = f x"}]}
{"declaration": "example {X Y Z : Grp} (f : X \u27f6 Y) (g : Y \u27f6 Z) : \u21d1(f \u226b g) = \u21d1g \u2218 \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Grp\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : Type u} [Group X] [Group Y] [Group Z]\n    (f : X \u2192* Y) (g : Y \u2192* Z) :\n    \u21d1(ofHom f \u226b ofHom g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Type u\ninst\u271d\u00b2 : Group X\ninst\u271d\u00b9 : Group Y\ninst\u271d : Group Z\nf : X \u2192* Y\ng : Y \u2192* Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b ofHom g)) = \u21d1g \u2218 \u21d1f"}]}
{"declaration": "example {X Y : Type u} [Group X] [Group Y] {Z : Grp}\n    (f : X \u2192* Y) (g : of Y \u27f6 Z) :\n    \u21d1(ofHom f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\ninst\u271d\u00b9 : Group X\ninst\u271d : Group Y\nZ : Grp\nf : X \u2192* Y\ng : of Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1f"}]}
{"declaration": "example {X Y : Grp} {Z : Type u} [Group Z] (f : X \u27f6 Y) (g : Y \u27f6 of Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Grp\nZ : Type u\ninst\u271d : Group Z\nf : X \u27f6 Y\ng : Y \u27f6 of Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {Y Z : Grp} {X : Type u} [Group X] (f : of X \u27f6 Y) (g : Y \u27f6 Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Y Z : Grp\nX : Type u\ninst\u271d : Group X\nf : of X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : Grp} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) : (f \u226b g) x = g (f x) := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Grp\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (f \u226b g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}]}
{"declaration": "example {X Y : Grp} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Grp\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}]}
{"declaration": "example {X Y : Grp} (e : X \u2245 Y) (y : Y) : e.hom (e.inv y) = y := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Grp\ne : X \u2245 Y\ny : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) y) = y"}]}
{"declaration": "example (X : Grp) : \u21d1(\ud835\udfd9 X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Grp\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 X)) = id"}]}
{"declaration": "example {X : Type*} [Group X] : \u21d1(MonoidHom.id X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : Group X\n\u22a2 \u21d1(MonoidHom.id X) = id"}]}
{"declaration": "example {M N : Grp} (f : M \u27f6 N) (x y : M) : f (x * y) = f x * f y := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : Grp\nf : M \u27f6 N\nx y : \u2191M\n\u22a2 (ConcreteCategory.hom f) (x * y) = (ConcreteCategory.hom f) x * (ConcreteCategory.hom f) y"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {M N : Grp} (f : M \u27f6 N) : f 1 = 1 := by\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/Grp.lean", "context": {"open": ["CategoryTheory Grp"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : Grp\nf : M \u27f6 N\n\u22a2 (ConcreteCategory.hom f) 1 = 1"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example (X : Type u) [Ring X] [Algebra R X] : \u21d1(\ud835\udfd9 (of R X)) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nX : Type u\ninst\u271d\u00b9 : Ring X\ninst\u271d : Algebra R X\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 (of R X))) = id"}]}
{"declaration": "example {X Y : Type v} [Ring X] [Algebra R X] [Ring Y] [Algebra R Y] (f : X \u2192\u2090[R] Y) :\n    \u21d1(ofHom f) = \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\nX Y : Type v\ninst\u271d\u00b3 : Ring X\ninst\u271d\u00b2 : Algebra R X\ninst\u271d\u00b9 : Ring Y\ninst\u271d : Algebra R Y\nf : X \u2192\u2090[R] Y\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f)) = \u21d1f"}]}
{"declaration": "example {X Y : Type v} [Ring X] [Algebra R X] [Ring Y] [Algebra R Y] (f : X \u2192\u2090[R] Y)\n    (x : X) : (ofHom f) x = f x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\nX Y : Type v\ninst\u271d\u00b3 : Ring X\ninst\u271d\u00b2 : Algebra R X\ninst\u271d\u00b9 : Ring Y\ninst\u271d : Algebra R Y\nf : X \u2192\u2090[R] Y\nx : X\n\u22a2 (ConcreteCategory.hom (ofHom f)) x = f x"}]}
{"declaration": "example {X Y Z : AlgebraCat R} (f : X \u27f6 Y) (g : Y \u27f6 Z) : \u21d1(f \u226b g) = \u21d1g \u2218 \u21d1f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX Y Z : AlgebraCat R\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : Type v} [Ring X] [Algebra R X] [Ring Y] [Algebra R Y] [Ring Z]\n    [Algebra R Z] (f : X \u2192\u2090[R] Y) (g : Y \u2192\u2090[R] Z) :\n    \u21d1(ofHom f \u226b ofHom g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2076 : CommRing R\nX Y Z : Type v\ninst\u271d\u2075 : Ring X\ninst\u271d\u2074 : Algebra R X\ninst\u271d\u00b3 : Ring Y\ninst\u271d\u00b2 : Algebra R Y\ninst\u271d\u00b9 : Ring Z\ninst\u271d : Algebra R Z\nf : X \u2192\u2090[R] Y\ng : Y \u2192\u2090[R] Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b ofHom g)) = \u21d1g \u2218 \u21d1f"}]}
{"declaration": "example {X Y : Type v} [Ring X] [Algebra R X] [Ring Y] [Algebra R Y] {Z : AlgebraCat R}\n    (f : X \u2192\u2090[R] Y) (g : of R Y \u27f6 Z) :\n    \u21d1(ofHom f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\nX Y : Type v\ninst\u271d\u00b3 : Ring X\ninst\u271d\u00b2 : Algebra R X\ninst\u271d\u00b9 : Ring Y\ninst\u271d : Algebra R Y\nZ : AlgebraCat R\nf : X \u2192\u2090[R] Y\ng : of R Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (ofHom f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1f"}]}
{"declaration": "example {X Y : AlgebraCat R} {Z : Type v} [Ring Z] [Algebra R Z] (f : X \u27f6 Y) (g : Y \u27f6 of R Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nX Y : AlgebraCat R\nZ : Type v\ninst\u271d\u00b9 : Ring Z\ninst\u271d : Algebra R Z\nf : X \u27f6 Y\ng : Y \u27f6 of R Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {Y Z : AlgebraCat R} {X : Type v} [Ring X] [Algebra R X] (f : of R X \u27f6 Y) (g : Y \u27f6 Z) :\n    \u21d1(f \u226b g) = g \u2218 f := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nY Z : AlgebraCat R\nX : Type v\ninst\u271d\u00b9 : Ring X\ninst\u271d : Algebra R X\nf : of R X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 \u21d1(ConcreteCategory.hom (f \u226b g)) = \u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)"}]}
{"declaration": "example {X Y Z : AlgebraCat R} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) : (f \u226b g) x = g (f x) := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX Y Z : AlgebraCat R\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (f \u226b g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}]}
{"declaration": "example {X Y : AlgebraCat R} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX Y : AlgebraCat R\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}]}
{"declaration": "example {X Y : AlgebraCat R} (e : X \u2245 Y) (y : Y) : e.hom (e.inv y) = y := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX Y : AlgebraCat R\ne : X \u2245 Y\ny : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) y) = y"}]}
{"declaration": "example (X : AlgebraCat R) : \u21d1(\ud835\udfd9 X) = id := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nX : AlgebraCat R\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 X)) = id"}]}
{"declaration": "example {M N : AlgebraCat.{v} R} (f : M \u27f6 N) (x y : M) : f (x + y) = f x + f y := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM N : AlgebraCat R\nf : M \u27f6 N\nx y : \u2191M\n\u22a2 (ConcreteCategory.hom f) (x + y) = (ConcreteCategory.hom f) x + (ConcreteCategory.hom f) y"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {M N : AlgebraCat.{v} R} (f : M \u27f6 N) : f 0 = 0 := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM N : AlgebraCat R\nf : M \u27f6 N\n\u22a2 (ConcreteCategory.hom f) 0 = 0"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example {M N : AlgebraCat.{v} R} (f : M \u27f6 N) (r : R) (m : M) : f (r \u2022 m) = r \u2022 f m := by\n  simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/ConcreteCategory/AlgebraCat.lean", "context": {"open": ["CategoryTheory AlgebraCat"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM N : AlgebraCat R\nf : M \u27f6 N\nr : R\nm : \u2191M\n\u22a2 (ConcreteCategory.hom f) (r \u2022 m) = r \u2022 (ConcreteCategory.hom f) m"}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example (f : U \u27f6 V \u2297 (W \u2297 X)) (g : (V \u2297 W) \u2297 X \u27f6 Y) :\n    f \u2297\u226b g = f \u226b (\u03b1_ _ _ _).inv \u226b g := by\n  monoidal\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Monoidal/Basic.lean", "context": {"open": ["CategoryTheory Mathlib.Tactic BicategoryLike", "MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{X Y Z W : C} (f : X \u27f6 Y) (g : Y \u27f6 Z)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y Z W : C\nf\u271d : X \u27f6 Y\ng\u271d : Y \u27f6 Z\nU V : C\nf : U \u27f6 V \u2297 W \u2297 X\ng : (V \u2297 W) \u2297 X \u27f6 Y\n\u22a2 f \u2297\u226b g = f \u226b (\u03b1_ V W X).inv \u226b g"}, {"line": "  monoidal", "tactic_state": ""}]}
{"declaration": "example (f : Z \u27f6 W) : (X \u2297 Y) \u25c1 f = (\u03b1_ _ _ _).hom \u226b X \u25c1 Y \u25c1 f \u226b (\u03b1_ _ _ _).inv := by\n  monoidal\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Monoidal/Basic.lean", "context": {"open": ["CategoryTheory Mathlib.Tactic BicategoryLike", "MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{X Y Z W : C} (f : X \u27f6 Y) (g : Y \u27f6 Z)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y Z W : C\nf\u271d : X \u27f6 Y\ng : Y \u27f6 Z\nf : Z \u27f6 W\n\u22a2 (X \u2297 Y) \u25c1 f = (\u03b1_ X Y Z).hom \u226b X \u25c1 Y \u25c1 f \u226b (\u03b1_ X Y W).inv"}, {"line": "  monoidal", "tactic_state": ""}]}
{"declaration": "example : f \u226b g = f \u226b g := by\n  monoidal\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Monoidal/Basic.lean", "context": {"open": ["CategoryTheory Mathlib.Tactic BicategoryLike", "MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{X Y Z W : C} (f : X \u27f6 Y) (g : Y \u27f6 Z)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y Z W : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 f \u226b g = f \u226b g"}, {"line": "  monoidal", "tactic_state": ""}]}
{"declaration": "example : (f \u2297 g) \u25b7 X = (\u03b1_ _ _ _).hom \u226b (f \u2297 g \u25b7 X) \u226b (\u03b1_ _ _ _).inv := by\n  monoidal\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Monoidal/Basic.lean", "context": {"open": ["CategoryTheory Mathlib.Tactic BicategoryLike", "MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{X Y Z W : C} (f : X \u27f6 Y) (g : Y \u27f6 Z)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y Z W : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 (f \u2297 g) \u25b7 X = (\u03b1_ X Y X).hom \u226b (f \u2297 g \u25b7 X) \u226b (\u03b1_ Y Z X).inv"}, {"line": "  monoidal", "tactic_state": ""}]}
{"declaration": "example {V\u2081 V\u2082 V\u2083 : C} (R : \u2200 V\u2081 V\u2082 : C, V\u2081 \u2297 V\u2082 \u27f6 V\u2082 \u2297 V\u2081) :\n    R V\u2081 V\u2082 \u25b7 V\u2083 \u2297\u226b V\u2082 \u25c1 R V\u2081 V\u2083 =\n      R V\u2081 V\u2082 \u25b7 V\u2083 \u226b (\u03b1_ _ _ _).hom \u2297\u226b \ud835\udfd9 _ \u226b V\u2082 \u25c1 R V\u2081 V\u2083 := by\n  monoidal", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/CategoryTheory/Monoidal/Basic.lean", "context": {"open": ["CategoryTheory Mathlib.Tactic BicategoryLike", "MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C] [MonoidalCategory C]", "{X Y Z W : C} (f : X \u27f6 Y) (g : Y \u27f6 Z)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y Z W : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\nV\u2081 V\u2082 V\u2083 : C\nR : (V\u2081 V\u2082 : C) \u2192 V\u2081 \u2297 V\u2082 \u27f6 V\u2082 \u2297 V\u2081\n\u22a2 R V\u2081 V\u2082 \u25b7 V\u2083 \u2297\u226b V\u2082 \u25c1 R V\u2081 V\u2083 = R V\u2081 V\u2082 \u25b7 V\u2083 \u226b (\u03b1_ V\u2082 V\u2081 V\u2083).hom \u2297\u226b \ud835\udfd9 (V\u2082 \u2297 V\u2081 \u2297 V\u2083) \u226b V\u2082 \u25c1 R V\u2081 V\u2083"}, {"line": "  monoidal", "tactic_state": ""}]}
{"declaration": "example (h : Nat) : Nat := by solve_by_elim", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : \u2115\n\u22a2 \u2115"}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : \u03b2 := by solve_by_elim", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (a : \u03b1) : \u03b2 := by solve_by_elim", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type} (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (a : \u03b1) : \u03b3 := by solve_by_elim", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\na : \u03b1\n\u22a2 \u03b3"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type} (_f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (b : \u03b2) : \u03b3 := by solve_by_elim", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\n_f : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\n\u22a2 \u03b3"}]}
{"declaration": "example {\u03b1 : Nat \u2192 Type} (f : (n : Nat) \u2192 \u03b1 n \u2192 \u03b1 (n+1)) (a : \u03b1 0) : \u03b1 4 := by solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : \u2115 \u2192 Type\nf : (n : \u2115) \u2192 \u03b1 n \u2192 \u03b1 (n + 1)\na : \u03b1 0\n\u22a2 \u03b1 4"}]}
{"declaration": "example (h : Nat) : Nat := by solve_by_elim []", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : \u2115\n\u22a2 \u2115"}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : \u03b2 := by solve_by_elim []", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (a : \u03b1) : \u03b2 := by solve_by_elim []", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type} (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (a : \u03b1) : \u03b3 := by solve_by_elim []", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\na : \u03b1\n\u22a2 \u03b3"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type} (_f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (b : \u03b2) : \u03b3 := by solve_by_elim []", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\n_f : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\n\u22a2 \u03b3"}]}
{"declaration": "example {\u03b1 : Nat \u2192 Type} (f : (n : Nat) \u2192 \u03b1 n \u2192 \u03b1 (n+1)) (a : \u03b1 0) : \u03b1 4 := by solve_by_elim []\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : \u2115 \u2192 Type\nf : (n : \u2115) \u2192 \u03b1 n \u2192 \u03b1 (n + 1)\na : \u03b1 0\n\u22a2 \u03b1 4"}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : \u03b2 := by\n  fail_if_success solve_by_elim [-f]\n  fail_if_success solve_by_elim [-a]\n  fail_if_success solve_by_elim only [f]\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}, {"line": "  fail_if_success solve_by_elim [-f]", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}, {"line": "  fail_if_success solve_by_elim [-a]", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}, {"line": "  fail_if_success solve_by_elim only [f]", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type} (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (b : \u03b2) : \u03b3 := by\n  fail_if_success solve_by_elim [-g]\n  solve_by_elim [-f]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\n\u22a2 \u03b3"}, {"line": "  fail_if_success solve_by_elim [-g]", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\n\u22a2 \u03b3"}, {"line": "  solve_by_elim [-f]", "tactic_state": ""}]}
{"declaration": "example (h : Nat) : Nat := by solve_by_elim only [h]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : \u2115\n\u22a2 \u2115"}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : \u03b2 := by solve_by_elim only [f, a]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}]}
{"declaration": "example {\u03b1 \u03b2 : Type} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (a : \u03b1) : \u03b2 := by solve_by_elim only [f, a]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type} (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (a : \u03b1) : \u03b3 := by solve_by_elim only [f, g, a]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\na : \u03b1\n\u22a2 \u03b3"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type} (_f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (b : \u03b2) : \u03b3 := by solve_by_elim only [g, b]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Type\n_f : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\n\u22a2 \u03b3"}]}
{"declaration": "example {\u03b1 : Nat \u2192 Type} (f : (n : Nat) \u2192 \u03b1 n \u2192 \u03b1 (n+1)) (a : \u03b1 0) : \u03b1 4 := by\n  solve_by_elim only [f, a]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : \u2115 \u2192 Type\nf : (n : \u2115) \u2192 \u03b1 n \u2192 \u03b1 (n + 1)\na : \u03b1 0\n\u22a2 \u03b1 4"}, {"line": "  solve_by_elim only [f, a]", "tactic_state": ""}]}
{"declaration": "example (h\u2081 h\u2082 : False) : Empty := by\n  -- 'It doesn't make sense to remove local hypotheses when using `only` without `*`.'\n  fail_if_success solve_by_elim only [-h\u2081]\n  -- 'It does make sense to use `*` without `only`.'\n  fail_if_success solve_by_elim [*, -h\u2081]\n  solve_by_elim only [*, -h\u2081]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h\u2081 h\u2082 : False\n\u22a2 Empty"}, {"line": "  -- 'It doesn't make sense to remove local hypotheses when using `only` without `*`.'", "tactic_state": "h\u2081 h\u2082 : False\n\u22a2 Empty"}, {"line": "  fail_if_success solve_by_elim only [-h\u2081]", "tactic_state": "h\u2081 h\u2082 : False\n\u22a2 Empty"}, {"line": "  -- 'It does make sense to use `*` without `only`.'", "tactic_state": ""}]}
{"declaration": "example (P\u2081 P\u2082 : \u03b1 \u2192 Prop) (f : \u2200 (a : \u03b1), P\u2081 a \u2192 P\u2082 a \u2192 \u03b2)\n    (a : \u03b1) (ha\u2081 : P\u2081 a) (ha\u2082 : P\u2082 a) : \u03b2 := by\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort ?u.26\n\u03b2 : Sort ?u.40\nP\u2081 P\u2082 : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 P\u2081 a \u2192 P\u2082 a \u2192 \u03b2\na : \u03b1\nha\u2081 : P\u2081 a\nha\u2082 : P\u2082 a\n\u22a2 \u03b2"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example {X : Type} (x : X) : x = x := by\n  fail_if_success solve_by_elim (config := {constructor := false}) only -- needs the `rfl` lemma\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type\nx : X\n\u22a2 x = x"}, {"line": "  fail_if_success solve_by_elim (config := {constructor := false}) only -- needs the `rfl` lemma", "tactic_state": "X : Type\nx : X\n\u22a2 x = x"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example {X : Type} (x y : X) (p : Prop) (h : x = x \u2192 y = y \u2192 p) : p := by solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type\nx y : X\np : Prop\nh : x = x \u2192 y = y \u2192 p\n\u22a2 p"}]}
{"declaration": "example : True := by\n  fail_if_success solve_by_elim (config := {constructor := false}) only -- needs the `trivial` lemma\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  fail_if_success solve_by_elim (config := {constructor := false}) only -- needs the `trivial` lemma", "tactic_state": "\u22a2 True"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example : True := by\n  -- uses the `trivial` lemma, which should now be removed from the default set:\n  solve_by_elim (config := {constructor := false})\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  -- uses the `trivial` lemma, which should now be removed from the default set:", "tactic_state": ""}]}
{"declaration": "example : True := by\n  solve_by_elim only -- uses the constructor discharger.\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  solve_by_elim only -- uses the constructor discharger.", "tactic_state": ""}]}
{"declaration": "example (P\u2081 P\u2082 : \u03b1 \u2192 Prop) (f : \u2200 (a: \u03b1), P\u2081 a \u2192 P\u2082 a \u2192 \u03b2)\n    (a : \u03b1) (_ha\u2081 : P\u2081 a)\n    (a' : \u03b1) (ha'\u2081 : P\u2081 a') (ha'\u2082 : P\u2082 a') : \u03b2 := by\n  fail_if_success solve_by_elim (config := .noBackTracking)\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort ?u.26\n\u03b2 : Sort ?u.40\nP\u2081 P\u2082 : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 P\u2081 a \u2192 P\u2082 a \u2192 \u03b2\na : \u03b1\n_ha\u2081 : P\u2081 a\na' : \u03b1\nha'\u2081 : P\u2081 a'\nha'\u2082 : P\u2082 a'\n\u22a2 \u03b2"}, {"line": "  fail_if_success solve_by_elim (config := .noBackTracking)", "tactic_state": "\u03b1 : Sort ?u.26\n\u03b2 : Sort ?u.40\nP\u2081 P\u2082 : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 P\u2081 a \u2192 P\u2082 a \u2192 \u03b2\na : \u03b1\n_ha\u2081 : P\u2081 a\na' : \u03b1\nha'\u2081 : P\u2081 a'\nha'\u2082 : P\u2082 a'\n\u22a2 \u03b2"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} {a b : \u03b1 \u2192 Prop} (h\u2080 : b = a) (y : \u03b1) : a y = b y := by\n  fail_if_success solve_by_elim (config := {symm := false})\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\na b : \u03b1 \u2192 Prop\nh\u2080 : b = a\ny : \u03b1\n\u22a2 a y = b y"}, {"line": "  fail_if_success solve_by_elim (config := {symm := false})", "tactic_state": "\u03b1 : Type\na b : \u03b1 \u2192 Prop\nh\u2080 : b = a\ny : \u03b1\n\u22a2 a y = b y"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example (P : True \u2192 False) : 3 = 7 := by\n  fail_if_success solve_by_elim (config := {exfalso := false})\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : True \u2192 False\n\u22a2 3 = 7"}, {"line": "  fail_if_success solve_by_elim (config := {exfalso := false})", "tactic_state": "P : True \u2192 False\n\u22a2 3 = 7"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : Nat \u00d7 Nat := by\n  constructor\n  solve_by_elim\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2115 \u00d7 \u2115"}, {"line": "  constructor", "tactic_state": "case fst\nn : \u2115\n\u22a2 \u2115\n---\ncase snd\nn : \u2115\n\u22a2 \u2115"}, {"line": "  solve_by_elim", "tactic_state": "case snd\nn : \u2115\n\u22a2 \u2115"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : Nat \u00d7 Nat := by\n  constructor\n  solve_by_elim*\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2115 \u00d7 \u2115"}, {"line": "  constructor", "tactic_state": "case fst\nn : \u2115\n\u22a2 \u2115\n---\ncase snd\nn : \u2115\n\u22a2 \u2115"}, {"line": "  solve_by_elim*", "tactic_state": ""}]}
{"declaration": "example (n m : Nat) (f : Nat \u2192 Nat \u2192 Prop) (h : f n m) : \u2203 p : Nat \u00d7 Nat, f p.1 p.2 := by\n  fconstructor\n  fconstructor\n  solve_by_elim*\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nf : \u2115 \u2192 \u2115 \u2192 Prop\nh : f n m\n\u22a2 \u2203 p, f p.1 p.2"}, {"line": "  fconstructor", "tactic_state": "case w\nn m : \u2115\nf : \u2115 \u2192 \u2115 \u2192 Prop\nh : f n m\n\u22a2 \u2115 \u00d7 \u2115\n---\ncase h\nn m : \u2115\nf : \u2115 \u2192 \u2115 \u2192 Prop\nh : f n m\n\u22a2 f ?w.1 ?w.2"}, {"line": "  fconstructor", "tactic_state": "case w.fst\nn m : \u2115\nf : \u2115 \u2192 \u2115 \u2192 Prop\nh : f n m\n\u22a2 \u2115\n---\ncase w.snd\nn m : \u2115\nf : \u2115 \u2192 \u2115 \u2192 Prop\nh : f n m\n\u22a2 \u2115\n---\ncase h\nn m : \u2115\nf : \u2115 \u2192 \u2115 \u2192 Prop\nh : f n m\n\u22a2 f (?w.fst, ?w.snd).1 (?w.fst, ?w.snd).2"}, {"line": "  solve_by_elim*", "tactic_state": ""}]}
{"declaration": "example (P : Nat \u2192 Type) (f : {n : Nat} \u2192 P n) : P 2 \u00d7 P 3 := by\n  fconstructor\n  solve_by_elim* only [f]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Type\nf : {n : \u2115} \u2192 P n\n\u22a2 P 2 \u00d7 P 3"}, {"line": "  fconstructor", "tactic_state": "case fst\nP : \u2115 \u2192 Type\nf : {n : \u2115} \u2192 P n\n\u22a2 P 2\n---\ncase snd\nP : \u2115 \u2192 Type\nf : {n : \u2115} \u2192 P n\n\u22a2 P 3"}, {"line": "  solve_by_elim* only [f]", "tactic_state": ""}]}
{"declaration": "example : 6 = 6 \u2227 [7] = [7] := by\n  fconstructor\n  solve_by_elim* only [@rfl _]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 6 = 6 \u2227 [7] = [7]"}, {"line": "  fconstructor", "tactic_state": "case left\n\u22a2 6 = 6\n---\ncase right\n\u22a2 [7] = [7]"}, {"line": "  solve_by_elim* only [@rfl _]", "tactic_state": ""}]}
{"declaration": "example (f g : Nat \u2192 Prop) : (\u2203 k : Nat, f k) \u2228 (\u2203 k : Nat, g k) \u2194 \u2203 k : Nat, f k \u2228 g k := by\n  fconstructor\n  rintro (\u27e8n, fn\u27e9 | \u27e8n, gn\u27e9)\n  pick_goal 3\n  rintro \u27e8n, hf | hg\u27e9\n  solve_by_elim* (config := {maxDepth := 13}) [Or.inl, Or.inr, Exists.intro]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f g : \u2115 \u2192 Prop\n\u22a2 ((\u2203 k, f k) \u2228 \u2203 k, g k) \u2194 \u2203 k, f k \u2228 g k"}, {"line": "  fconstructor", "tactic_state": "case mp\nf g : \u2115 \u2192 Prop\n\u22a2 ((\u2203 k, f k) \u2228 \u2203 k, g k) \u2192 \u2203 k, f k \u2228 g k\n---\ncase mpr\nf g : \u2115 \u2192 Prop\n\u22a2 (\u2203 k, f k \u2228 g k) \u2192 (\u2203 k, f k) \u2228 \u2203 k, g k"}, {"line": "  rintro (\u27e8n, fn\u27e9 | \u27e8n, gn\u27e9)", "tactic_state": "case mp.inl.intro\nf g : \u2115 \u2192 Prop\nn : \u2115\nfn : f n\n\u22a2 \u2203 k, f k \u2228 g k\n---\ncase mp.inr.intro\nf g : \u2115 \u2192 Prop\nn : \u2115\ngn : g n\n\u22a2 \u2203 k, f k \u2228 g k\n---\ncase mpr\nf g : \u2115 \u2192 Prop\n\u22a2 (\u2203 k, f k \u2228 g k) \u2192 (\u2203 k, f k) \u2228 \u2203 k, g k"}, {"line": "  pick_goal 3", "tactic_state": "case mpr\nf g : \u2115 \u2192 Prop\n\u22a2 (\u2203 k, f k \u2228 g k) \u2192 (\u2203 k, f k) \u2228 \u2203 k, g k\n---\ncase mp.inl.intro\nf g : \u2115 \u2192 Prop\nn : \u2115\nfn : f n\n\u22a2 \u2203 k, f k \u2228 g k\n---\ncase mp.inr.intro\nf g : \u2115 \u2192 Prop\nn : \u2115\ngn : g n\n\u22a2 \u2203 k, f k \u2228 g k"}, {"line": "  rintro \u27e8n, hf | hg\u27e9", "tactic_state": "case mpr.intro.inl\nf g : \u2115 \u2192 Prop\nn : \u2115\nhf : f n\n\u22a2 (\u2203 k, f k) \u2228 \u2203 k, g k\n---\ncase mpr.intro.inr\nf g : \u2115 \u2192 Prop\nn : \u2115\nhg : g n\n\u22a2 (\u2203 k, f k) \u2228 \u2203 k, g k\n---\ncase mp.inl.intro\nf g : \u2115 \u2192 Prop\nn : \u2115\nfn : f n\n\u22a2 \u2203 k, f k \u2228 g k\n---\ncase mp.inr.intro\nf g : \u2115 \u2192 Prop\nn : \u2115\ngn : g n\n\u22a2 \u2203 k, f k \u2228 g k"}, {"line": "  solve_by_elim* (config := {maxDepth := 13}) [Or.inl, Or.inr, Exists.intro]", "tactic_state": ""}]}
{"declaration": "example (P : Prop) : P \u2192 P := by\n  fail_if_success solve_by_elim (config := {intro := false})\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Prop\n\u22a2 P \u2192 P"}, {"line": "  fail_if_success solve_by_elim (config := {intro := false})", "tactic_state": "P : Prop\n\u22a2 P \u2192 P"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example (P Q : Prop) : P \u2227 Q \u2192 P \u2227 Q := by\n  solve_by_elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 P \u2227 Q \u2192 P \u2227 Q"}, {"line": "  solve_by_elim", "tactic_state": ""}]}
{"declaration": "example {a b : Type} (h\u2080 : a \u2192 b) (h\u2081 : a) : b := by\n  apply_assumption\n  apply_assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Type\nh\u2080 : a \u2192 b\nh\u2081 : a\n\u22a2 b"}, {"line": "  apply_assumption", "tactic_state": "a b : Type\nh\u2080 : a \u2192 b\nh\u2081 : a\n\u22a2 a"}, {"line": "  apply_assumption", "tactic_state": ""}]}
{"declaration": "example {\u03b1 : Type} {p : \u03b1 \u2192 Prop} (h\u2080 : \u2200 x, p x) (y : \u03b1) : p y := by\n  apply_assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\np : \u03b1 \u2192 Prop\nh\u2080 : \u2200 (x : \u03b1), p x\ny : \u03b1\n\u22a2 p y"}, {"line": "  apply_assumption", "tactic_state": ""}]}
{"declaration": "example (a b : \u03b1) (h : b = a) : a = b := by\n  fail_if_success apply_assumption (config := {symm := false})\n  apply_assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\na b : \u03b1\nh : b = a\n\u22a2 a = b"}, {"line": "  fail_if_success apply_assumption (config := {symm := false})", "tactic_state": "\u03b1 : Sort u_1\na b : \u03b1\nh : b = a\n\u22a2 a = b"}, {"line": "  apply_assumption", "tactic_state": ""}]}
{"declaration": "example {P Q : Prop} (p : P) (q : Q) (h : P \u2192 \u00ac Q) : Nat := by\n  fail_if_success apply_assumption (config := {exfalso := false})\n  apply_assumption <;> assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\np : P\nq : Q\nh : P \u2192 \u00acQ\n\u22a2 \u2115"}, {"line": "  fail_if_success apply_assumption (config := {exfalso := false})", "tactic_state": "P Q : Prop\np : P\nq : Q\nh : P \u2192 \u00acQ\n\u22a2 \u2115"}, {"line": "  apply_assumption <;> assumption", "tactic_state": ""}]}
{"declaration": "example : 1 = 2 := by\n  fail_if_success solve_by_elim\n  solve_by_elim using dummy_label_attr\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 = 2"}, {"line": "  fail_if_success solve_by_elim", "tactic_state": "\u22a2 1 = 2"}, {"line": "  solve_by_elim using dummy_label_attr", "tactic_state": "\u22a2 1 = 2"}]}
{"declaration": "example : 5 \u2264 7 := by\n  apply_rules using dummy_label_attr\n  guard_target = 5 = 7\n  exact mySorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 5 \u2264 7"}, {"line": "  apply_rules using dummy_label_attr", "tactic_state": "\u22a2 5 \u2264 7"}]}
{"declaration": "example : 5 \u2264 7 := by\n  apply_rules [le_rfl]\n  guard_target = 5 = 7\n  exact mySorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 5 \u2264 7"}, {"line": "  apply_rules [le_rfl]", "tactic_state": ""}]}
{"declaration": "lemma foo (a b : \u2115) (ha : a \u2260 0) (hb : b \u2260 0) : a * b \u2260 0 := by\n  apply_rules [mul_ne_zero]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/solve_by_elim/instances.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 a * b \u2260 0"}, {"line": "  apply_rules [mul_ne_zero]", "tactic_state": ""}]}
{"declaration": "lemma prod_test (R : Type) [CommMonoid R] (f : Fin 10 \u2192 R) :\n    \u220f i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 * f 7 * f 8 * f 9 := by\n  simp only [Fin.prod_univ_ofNat]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simproc/ProdUnivMany.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type\ninst\u271d : CommMonoid R\nf : Fin 10 \u2192 R\n\u22a2 \u220f i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 * f 7 * f 8 * f 9"}, {"line": "  simp only [Fin.prod_univ_ofNat]", "tactic_state": ""}]}
{"declaration": "example (R : Type) [AddCommMonoid R] (f : Fin 10 \u2192 R) :\n    \u2211 i, f i = f 0 + f 1 + f 2 + f 3 + f 4 + f 5 + f 6 + f 7 + f 8 + f 9 := by\n  simp only [Fin.sum_univ_ofNat]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simproc/ProdUnivMany.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type\ninst\u271d : AddCommMonoid R\nf : Fin 10 \u2192 R\n\u22a2 \u2211 i, f i = f 0 + f 1 + f 2 + f 3 + f 4 + f 5 + f 6 + f 7 + f 8 + f 9"}, {"line": "  simp only [Fin.sum_univ_ofNat]", "tactic_state": ""}]}
{"declaration": "example (a : \u03b1) (hp : p a) (hq : q a) : \u2203 b : \u03b1, (p b \u2227 b = a) \u2227 q b := by\n  simp only [existsAndEq]\n  guard_target = (p a \u2227 True) \u2227 q a\n  exact \u27e8\u27e8hp, trivial\u27e9, hq\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simproc/ExistsAndEq.lean", "context": {"open": [], "variables": ["(\u03b1 : Type u) (p q : \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 \u2203 b, (p b \u2227 b = a) \u2227 q b"}, {"line": "  simp only [existsAndEq]", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 (p a \u2227 True) \u2227 q a"}, {"line": "  guard_target = (p a \u2227 True) \u2227 q a", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 (p a \u2227 True) \u2227 q a"}, {"line": "  exact \u27e8\u27e8hp, trivial\u27e9, hq\u27e9", "tactic_state": ""}]}
{"declaration": "example (a : \u03b1) : \u2203 b : \u03b1, b = a := by\n  simp only [existsAndEq]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simproc/ExistsAndEq.lean", "context": {"open": [], "variables": ["(\u03b1 : Type u) (p q : \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\n\u22a2 \u2203 b, b = a"}, {"line": "  simp only [existsAndEq]", "tactic_state": ""}]}
{"declaration": "example (f : \u03b1 \u2192 \u03b1) : \u2203 a : \u03b1, a = f a := by\n  simp only [existsAndEq]\n  sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simproc/ExistsAndEq.lean", "context": {"open": [], "variables": ["(\u03b1 : Type u) (p q : \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\nf : \u03b1 \u2192 \u03b1\n\u22a2 \u2203 a, a = f a"}, {"line": "  simp only [existsAndEq]", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\nf : \u03b1 \u2192 \u03b1\n\u22a2 \u2203 a, a = f a"}]}
{"declaration": "example (a : \u03b1) (hp : p a) (hq : q a) : (\u2203 b : \u03b1, p b \u2227 (\u2203 c : \u03b1, b = a \u2227 q c)) := by\n  -- the simproc doesn't handle nested `Exists`\n  simp -failIfUnchanged only [existsAndEq]\n  guard_target = \u2203 b : \u03b1, p b \u2227 (\u2203 c : \u03b1, b = a \u2227 q c)\n  simp only [exists_and_left]\n  guard_target = \u2203 b, p b \u2227 b = a \u2227 \u2203 x, q x\n  -- but can clean up the rest\n  simp only [existsAndEq]\n  guard_target = p a \u2227 True \u2227 \u2203 x, q x\n  exact \u27e8hp, trivial, a, hq\u27e9", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Simproc/ExistsAndEq.lean", "context": {"open": ["Lean Meta Simp"], "variables": ["(\u03b1 : Type u) (p q : \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 \u2203 b, p b \u2227 \u2203 c, b = a \u2227 q c"}, {"line": "  -- the simproc doesn't handle nested `Exists`", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 \u2203 b, p b \u2227 \u2203 c, b = a \u2227 q c"}, {"line": "  simp -failIfUnchanged only [existsAndEq]", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 \u2203 b, p b \u2227 \u2203 c, b = a \u2227 q c"}, {"line": "  guard_target = \u2203 b : \u03b1, p b \u2227 (\u2203 c : \u03b1, b = a \u2227 q c)", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 \u2203 b, p b \u2227 b = a \u2227 \u2203 x, q x"}, {"line": "  simp only [exists_and_left]", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 \u2203 b, p b \u2227 b = a \u2227 \u2203 x, q x"}, {"line": "  guard_target = \u2203 b, p b \u2227 b = a \u2227 \u2203 x, q x", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 p a \u2227 True \u2227 \u2203 x, q x"}, {"line": "  -- but can clean up the rest", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\na : \u03b1\nhp : p a\nhq : q a\n\u22a2 p a \u2227 True \u2227 \u2203 x, q x"}, {"line": "  simp only [existsAndEq]", "tactic_state": ""}]}
