{"context": {"open": [], "variables": []}, "declaration": "theorem imo1972_q5_have_1 (hf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y) (hf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1) (hf3 : \u2203 x, f x \u2260 0) (y : \u211d) (hneg : 1 < \u2016g y\u2016) (S : Set \u211d := Set.range fun x => \u2016f x\u2016) (k : \u211d := sSup S) : \u2200 x, \u2016f x\u2016 \u2264 k :=\n  by have h : BddAbove S := \u27e81, Set.forall_mem_range.mpr hf2\u27e9\n    intro x\n    exact le_csSup h (Set.mem_range_self x)"}
{"context": {"open": [], "variables": []}, "declaration": "theorem imo1972_q5_have_2 (hf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y) (hf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1) (hf3 : \u2203 x, f x \u2260 0) (y : \u211d) (hneg : 1 < \u2016g y\u2016) (S : Set \u211d := Set.range fun x => \u2016f x\u2016) (k : \u211d := sSup S) (hk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k) (hk\u2082 : \u2200 (x : \u211d), 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k) : k' < k :=\n  by have h\u2081 : 0 < k := by\n      obtain \u27e8x, hx\u27e9 := hf3\n      calc\n        0 < \u2016f x\u2016 := norm_pos_iff.mpr hx\n        _ \u2264 k := hk\u2081 x\n    rw [div_lt_iff\u2080]\n    \u00b7 apply lt_mul_of_one_lt_right h\u2081 hneg\n    \u00b7 exact zero_lt_one.trans hneg"}
{"context": {"open": [], "variables": []}, "declaration": "theorem imo1972_q5_have_3 (hf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y) (hf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1) (hf3 : \u2203 x, f x \u2260 0) (y : \u211d) (hneg : 1 < \u2016g y\u2016) (S : Set \u211d := Set.range fun x => \u2016f x\u2016) (k : \u211d := sSup S) (hk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k) (hk\u2082 : \u2200 (x : \u211d), 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k) (H\u2081 : k' < k) : k \u2264 k' :=\n  by have h\u2081 : \u2203 x : \u211d, x \u2208 S := by use \u2016f 0\u2016; exact Set.mem_range_self 0\n    have h\u2082 : \u2200 x, \u2016f x\u2016 \u2264 k' := by\n      intro x\n      rw [le_div_iff\u2080]\n      \u00b7 apply (mul_le_mul_left zero_lt_two).mp (hk\u2082 x)\n      \u00b7 exact zero_lt_one.trans hneg\n    apply csSup_le h\u2081\n    rintro y' \u27e8yy, rfl\u27e9\n    exact h\u2082 yy"}
{"context": {"open": [], "variables": []}, "declaration": "theorem key_insight_have_1 (hx : x > 0) (hy : y > 0) (hz : z > 0) (h : x * y * z \u2265 1) (key : ) : ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2))) \u2265 0 :=\n  by positivity"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_1 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) : p % 4 \u2260 3 :=\n  by linarith [show p % 4 = 1 from hp_mod_4_eq_1]"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_2 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) : p \u2223 n ^ 2 + 1 :=\n  by refine Int.natCast_dvd_natCast.mp ?_\n    simp only [n]\n    simp only [Int.natAbs_sq]\n    simp only [Int.natCast_pow]\n    simp only [Int.natCast_succ]\n    simp only [Int.natCast_dvd_natCast.mp]\n    refine (ZMod.intCast_zmod_eq_zero_iff_dvd (m ^ 2 + 1) p).mp ?_\n    simp only [m]\n    simp only [Int.cast_pow]\n    simp only [Int.cast_add]\n    simp only [Int.cast_one]\n    simp only [ZMod.coe_valMinAbs]\n    rw [pow_two]; exact neg_add_cancel 1\n    rw [\u2190 hy]; exact neg_add_cancel 1"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_3 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) : p \u2265 2 * n :=\n  by omega"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_4 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) : p \u2223 k ^ 2 + 4 :=\n  by obtain \u27e8x, hx\u27e9 := hnat\u2081\n    have : (p : \u2124) \u2223 (k : \u2124) ^ 2 + 4 := by\n      use (p : \u2124) - 4 * n + 4 * x\n      have hcast\u2081 : (k : \u2124) = p - 2 * n := by assumption_mod_cast\n      have hcast\u2082 : (n : \u2124) ^ 2 + 1 = p * x := by assumption_mod_cast\n      linear_combination ((k : \u2124) + p - 2 * n) * hcast\u2081 + 4 * hcast\u2082\n    assumption_mod_cast"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_5 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) (hnat\u2085 : p \u2223 k ^ 2 + 4) (hnat\u2086 : k ^ 2 + 4 \u2265 p) (hreal\u2081 : \u2191k = \u2191p - 2 * \u2191n) : (p : \u211d) > 20 :=\n  by assumption_mod_cast"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_6 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) (hnat\u2085 : p \u2223 k ^ 2 + 4) (hnat\u2086 : k ^ 2 + 4 \u2265 p) (hreal\u2081 : \u2191k = \u2191p - 2 * \u2191n) (hreal\u2082 : \u2191p > 20) : (k : \u211d) ^ 2 + 4 \u2265 p :=\n  by assumption_mod_cast"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_7 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) (hnat\u2085 : p \u2223 k ^ 2 + 4) (hnat\u2086 : k ^ 2 + 4 \u2265 p) (hreal\u2081 : \u2191k = \u2191p - 2 * \u2191n) (hreal\u2082 : \u2191p > 20) (hreal\u2083 : \u2191k ^ 2 + 4 \u2265 \u2191p) : (k : \u211d) > 4 :=\n  by refine lt_of_pow_lt_pow_left\u2080 2 k.cast_nonneg ?_\n    linarith only [hreal\u2082, hreal\u2083]"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_8 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) (hnat\u2085 : p \u2223 k ^ 2 + 4) (hnat\u2086 : k ^ 2 + 4 \u2265 p) (hreal\u2081 : \u2191k = \u2191p - 2 * \u2191n) (hreal\u2082 : \u2191p > 20) (hreal\u2083 : \u2191k ^ 2 + 4 \u2265 \u2191p) (hreal\u2085 : \u2191k > 4) : (k : \u211d) > sqrt (2 * n) :=\n  by refine lt_of_pow_lt_pow_left\u2080 2 k.cast_nonneg ?_\n    rw [sq_sqrt (mul_nonneg zero_le_two n.cast_nonneg)]\n    linarith only [hreal\u2081, hreal\u2083, hreal\u2085]"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem imo2020_q2_have_1 (hd0 : 0 < d) (hdc : d \u2264 c) (hcb : c \u2264 b) (hba : b \u2264 a) (h1 : a + b + c + d = 1) : a ^ a * b ^ b * c ^ c * d ^ d \u2264 a * a + b * b + c * c + d * d :=\n  by refine geom_mean_le_arith_mean4_weighted ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ h1 <;> linarith"}
{"context": {"open": ["Nat"], "variables": []}, "declaration": "theorem ge_100_have_1 (ProblemPredicate : x\u271d) (n : \u2115) (h1 : sorry) : 10 ^ 3 \u2264 10 * n :=\n  by rw [\u2190 h1.left]\n    refine Nat.base_pow_length_digits_le 10 n ?_ (not_zero h1)\n    simp"}
{"context": {"open": ["Nat"], "variables": []}, "declaration": "theorem lt_1000_have_1 (ProblemPredicate : x\u271d) (n : \u2115) (h1 : sorry) : n < 10 ^ 3 :=\n  by rw [\u2190 h1.left]\n    refine Nat.lt_base_pow_length_digits ?_\n    simp"}
{"context": {"open": ["Int Nat Set"], "variables": ["(N : \u2115)", "{N}"]}, "declaration": "theorem m_le_n_have_1 (ProblemPredicate : x\u271d) (h1 : sorry) (h2 : \u00acm \u2264 n) (h3 : 1 = (n * (n - m) - m ^ 2) ^ 2) : n * (n - m) - m ^ 2 < -1 :=\n  by nlinarith [h1.n_range.left]"}
{"context": {"open": ["Int Nat Set"], "variables": ["(N : \u2115)", "{N}"]}, "declaration": "theorem m_le_n_have_2 (ProblemPredicate : x\u271d) (h1 : sorry) (h2 : \u00acm \u2264 n) (h3 : 1 = (n * (n - m) - m ^ 2) ^ 2) (h4 : n * (n - m) - m ^ 2 < -1) : 1 < (n * (n - m) - m ^ 2) ^ 2 :=\n  by nlinarith"}
{"context": {"open": ["Function Polynomial"], "variables": []}, "declaration": "theorem Polynomial_have_1 (P : Polynomial \u2124) (t : \u2124) (ht : t \u2208 periodicPts fun x => eval x P) (C : Cycle \u2124 := Cycle.map (fun x => eval x P - x) (periodicOrbit (fun x => eval x P) t)) (HC : \u2200 {n : \u2115}, (fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t \u2208 C) : C.Chain (\u00b7 \u2223 \u00b7) :=\n  by rw [Cycle.chain_map]\n    rw [periodicOrbit_chain' _ ht]\n    intro n\n    convert sub_dvd_eval_sub ((fun x => P.eval x)^[n + 1] t) ((fun x => P.eval x)^[n] t) P <;>\n      rw [Function.iterate_succ_apply']"}
{"context": {"open": [], "variables": []}, "declaration": "theorem le_of_all_pow_lt_succ_have_1 (hx : 1 < x) (hy : 1 < y) (h : \u2200 (n : \u2115), 0 < n \u2192 x ^ n - 1 < y ^ n) (hxy : y < x) (hxmy : 0 < x - y) : \u2200 n : \u2115, 0 < n \u2192 (x - y) * (n : \u211d) \u2264 x ^ n - y ^ n :=\n  by intro n _\n    have hterm : \u2200 i : \u2115, i \u2208 Finset.range n \u2192 1 \u2264 x ^ i * y ^ (n - 1 - i) := by\n      intro i _\n      calc\n        1 \u2264 x ^ i := one_le_pow\u2080 hx.le\n        _ = x ^ i * 1 := by ring\n        _ \u2264 x ^ i * y ^ (n - 1 - i) := by gcongr; apply one_le_pow\u2080 hy.le\n    calc\n      (x - y) * (n : \u211d) = (n : \u211d) * (x - y) := by ring\n      _ = (\u2211 _i \u2208 Finset.range n, (1 : \u211d)) * (x - y) := by\n        simp only [mul_one]\n        simp only [Finset.sum_const]\n        simp only [nsmul_eq_mul]\n        simp only [Finset.card_range]\n      _ \u2264 (\u2211 i \u2208 Finset.range n, x ^ i * y ^ (n - 1 - i)) * (x - y) := by\n        gcongr with i hi; apply hterm i hi\n      _ = x ^ n - y ^ n := geom_sum\u2082_mul x y n"}
{"context": {"open": [], "variables": []}, "declaration": "theorem pow_f_le_f_pow_have_1 (f : \u211a \u2192 \u211d) (x : \u211a) (hx : 1 < x) (H1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y) (H4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n) (pn : \u2115) (hpn : 0 < pn + 1 \u2192 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)) (hn : 0 < pn + 1 + 1) : 0 < x :=\n  by positivity"}
{"context": {"open": [], "variables": []}, "declaration": "theorem fixed_point_of_gt_1_have_1 (f : \u211a \u2192 \u211d) (x : \u211a) (hx : 1 < x) (H1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y) (H2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)) (H4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n) (H5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x) (a : \u211a) (ha1 : 1 < a) (hae : f a = \u2191a) (N : \u2115) (hN : 1 + x < a ^ N) (h_big_enough : 1 < a ^ N - x) (h1 : \u2191x + \u2191(a ^ N - x) \u2264 f x + f (a ^ N - x)) : 0 < x :=\n  by positivity"}
{"context": {"open": [], "variables": []}, "declaration": "theorem fixed_point_of_gt_1_have_2 (f : \u211a \u2192 \u211d) (x : \u211a) (hx : 1 < x) (H1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y) (H2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)) (H4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n) (H5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x) (a : \u211a) (ha1 : 1 < a) (hae : f a = \u2191a) (N : \u2115) (hN : 1 + x < a ^ N) (h_big_enough : 1 < a ^ N - x) (h1 : \u2191x + \u2191(a ^ N - x) \u2264 f x + f (a ^ N - x)) (hxp : 0 < x) : 0 < N :=\n  by_contra! H; rw [Nat.le_zero.mp H] at hN; linarith"}
{"context": {"open": ["scoped Finset"], "variables": ["{a : \u2115 \u2192 \u2115} {N : \u2115} (hc : Condition a N)"]}, "declaration": "theorem exists_infinite_setOf_apply_eq_have_1 (Condition : ?m.433) (N : \u2115) (hc : sorry) (a : \u2115 \u2192 \u2115) (hi : \u00ac\u2203 m, {i | a i = m}.Infinite) : (Set.range a).Infinite :=\n  by contrapose! hi with hr\n    rw [Set.not_infinite] at hr\n    rw [\u2190 Set.finite_coe_iff] at hr\n    obtain \u27e8n, hn\u27e9 := Finite.exists_infinite_fiber (Set.rangeFactorization a)\n    rw [Set.infinite_coe_iff] at hn\n    rw [Set.preimage] at hn\n    simp only [Set.mem_singleton_iff] at hn\n    simp only [Set.rangeFactorization] at hn\n    simp only [Subtype.ext_iff] at hn\n    exact \u27e8\u2191n, hn\u27e9"}
{"context": {"open": ["MiuAtom"], "variables": []}, "declaration": "theorem my_theorem_have_1 (Derivable : x\u271d) : Derivable \"MII\" :=\n  by change Derivable (M :: [I] ++ [I])\n    exact Derivable.r2 Derivable.mk"}
{"context": {"open": ["MiuAtom"], "variables": []}, "declaration": "theorem my_theorem_have_2 (Derivable : x\u271d) (h\u2082 : sorry) : Derivable \"MIIII\" :=\n  by change Derivable (M :: [I, I] ++ [I, I])\n    exact Derivable.r2 h\u2082"}
{"context": {"open": ["SetTheory PGame"], "variables": []}, "declaration": "theorem star_sq_have_1  : star * star \u2264 star :=\n  by rw [le_iff_forall_lf]\n    constructor <;>\n    intro i\n    \u00b7 apply leftMoves_mul_cases i <;>\n      intro _ _\n      case' hl => rw [mul_moveLeft_inl]\n      case' hr => rw [mul_moveLeft_inr]\n      all_goals rw [lf_iff_game_lf]; simpa using zero_lf_star\n    \u00b7 refine lf_zero.2 \u27e8toRightMovesMul (Sum.inl default), ?_\u27e9\n      rintro (j | j) <;> -- Instance can't be inferred otherwise.\n      exact isEmptyElim j"}
{"context": {"open": ["scoped Pointwise", "QuotientGroup", "CategoryTheory", "XWithInfinity Equiv.Perm"], "variables": ["{A : Type u} {B : Type v}", "[Group A] [Group B]", "[CommGroup A] [CommGroup B]", "{A B : Grp.{u}} (f : A \u27f6 B)", "{A B : AddGrp.{u}} (f : A \u27f6 B)"]}, "declaration": "theorem epi_iff_surjective_have_1 (f : A \u27f6 B) : Epi f \u2194 Epi (groupAddGroupEquivalence.inverse.map f) :=\n  by refine \u27e8?_, groupAddGroupEquivalence.inverse.epi_of_epi_map\u27e9\n    intro e'\n    apply groupAddGroupEquivalence.inverse.map_epi"}
{"context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]"]}, "declaration": "theorem _root__have_1 (R : Type u) (A : Type v) (a : A) (h : _root_.IsNilpotent a) : IsNilpotent (LinearMap.mulLeft R a) :=\n  by rwa [LinearMap.isNilpotent_mulLeft_iff]"}
{"context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]"]}, "declaration": "theorem _root__have_2 (R : Type u) (A : Type v) (a : A) (h : _root_.IsNilpotent a) (hl : sorry) : IsNilpotent (LinearMap.mulRight R a) :=\n  by rwa [LinearMap.isNilpotent_mulRight_iff]"}{"context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]"]}, "declaration": "theorem _root__have_1 (R : Type u) (A : Type v) (a : A) (h : _root_.IsNilpotent a) : IsNilpotent (LinearMap.mulLeft R a) :=\n  by rwa [LinearMap.isNilpotent_mulLeft_iff]"}
{"context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]"]}, "declaration": "theorem _root__have_2 (R : Type u) (A : Type v) (a : A) (h : _root_.IsNilpotent a) (hl : sorry) : IsNilpotent (LinearMap.mulRight R a) :=\n  by rwa [LinearMap.isNilpotent_mulRight_iff]"}
{"context": {"open": [], "variables": ["{R : Type*} [Semiring R] [LinearOrder R] {a b : R} {m n : \u2115}"]}, "declaration": "theorem finset_image_add_have_1 (R : Type u_1) (F : Type u_2) (\u03b1 : Type u_3) (\u03b2 : Type u_4) (f : F) (hna : IsNonarchimedean \u21d1f) (g : \u03b2 \u2192 \u03b1) (t : Finset \u03b2) : t.Nonempty \u2194 t.val \u2260 0 :=\n  by simp [Finset.nonempty_iff_ne_empty]"}
{"context": {"open": ["Polynomial", "Finset in", "EuclideanDomain"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]", "[DivisionRing R] {p q : R[X]}", "[Field R] {p q : R[X]}"]}, "declaration": "theorem divByMonic_add_X_sub_C_mul_derivate_divByMonic_eq_derivative_have_1 (K : Type u_1) (f : Polynomial K) (a : K) : key :=\n  by apply congrArg derivative <| X_sub_C_mul_divByMonic_eq_sub_modByMonic f a"}
{"context": {"open": ["Polynomial", "Finsupp Finset", "scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]"]}, "declaration": "theorem natDegree_map_eq_iff_have_1 (R : Type u) (S : Type v) (f : R \u2192+* S) (p : Polynomial R) (h : sorry \u2260 0) : p \u2260 0 :=\n  by rintro rfl; simp at h"}
{"context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem rpow_arith_mean_le_arith_mean_rpow_have_1 (\u03b9 : Type u) (s : Finset \u03b9) (p : \u211d) (hp : 1 \u2264 p) : 0 < p :=\n  by positivity"}
{"context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem rpow_arith_mean_le_arith_mean_rpow_have_2 (\u03b9 : Type u) (s : Finset \u03b9) (p : \u211d) (hp : 1 \u2264 p) (hp_pos : 0 < p) : 0 \u2264 p :=\n  by positivity"}
{"context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem rpow_arith_mean_le_arith_mean_rpow_have_3 (\u03b9 : Type u) (s : Finset \u03b9) (p : \u211d) (hp : 1 \u2264 p) (hp_pos : 0 < p) (hp_nonneg : 0 \u2264 p) : \u00acp < 0 :=\n  by simp [hp_nonneg]"}
{"context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem inner_le_Lp_mul_Lq_tsum_have_1 (\u03b9 : Type u) (hpq : p.HolderConjugate q) (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) : \u2211 i \u2208 s, f i * g i \u2264 (\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q) :=\n  by intro s\n    refine le_trans (inner_le_Lp_mul_Lq s f g hpq) (mul_le_mul ?_ ?_ bot_le bot_le)\n    \u00b7 rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.pos)]\n      exact hf.sum_le_tsum _ (fun _ _ => zero_le _)\n    \u00b7 rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.symm.pos)]\n      exact hg.sum_le_tsum _ (fun _ _ => zero_le _)"}
{"context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem Lp_add_le_tsum_have_1 (\u03b9 : Type u) (p : \u211d) (hp : 1 \u2264 p) (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ p) (pos : 0 < p) : ((\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)) ^ p :=\n  by intro s\n    rw [one_div]\n    rw [\u2190 NNReal.rpow_inv_le_iff pos]\n    rw [\u2190 one_div]\n    refine le_trans (Lp_add_le s f g hp) (add_le_add ?_ ?_) <;>\n        rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr pos)] <;>\n      refine Summable.sum_le_tsum _ (fun _ _ => zero_le _) ?_\n    exacts [hf, hg]"}
{"context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E]"]}, "declaration": "theorem hasMellin_one_Ioc_have_1 (s : \u2102) (hs : 0 < s.re) : -1 < (s - 1).re :=\n  by simpa only [sub_re,one_re,sub_eq_add_neg] using lt_add_of_pos_left _ hs"}
{"context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E]"]}, "declaration": "theorem hasMellin_one_Ioc_have_2 (s : \u2102) (hs : 0 < s.re) (aux1 : -1 < (s - 1).re) : s \u2260 0 :=\n  by contrapose! hs; rw [hs, zero_re]"}
{"context": {"open": ["Topology EMetric Set ENNReal"], "variables": ["{E : Type u} {F : Type v} [PseudoEMetricSpace F]", "[PseudoEMetricSpace E] {K : Set E}", "{f : E \u2192 F} {D : Set E} {\u03b5 : ENNReal}"]}, "declaration": "theorem uniform_oscillationWithin_have_1 (E : Type u) (F : Type v) (K : Set E) (f : E \u2192 F) (D : Set E) (\u03b5 : ENNReal) (comp : IsCompact K) (hK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5) (S : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}) : \u2200 r > 0, IsOpen (S r) :=\n  by refine fun r _ \u21a6 isOpen_iff.mpr fun x \u27e8a, ar, ha\u27e9 \u21a6\n      \u27e8ENNReal.ofReal ((a - r) / 2), by simp [ar], ?_\u27e9\n    refine fun y hy \u21a6 \u27e8a - (a - r) / 2, by linarith,\n      le_trans (diam_mono (image_mono fun z hz \u21a6 ?_)) ha\u27e9\n    refine \u27e8lt_of_le_of_lt (edist_triangle z y x) (lt_of_lt_of_eq (ENNReal.add_lt_add hz.1 hy) ?_),\n      hz.2\u27e9\n    rw [\u2190 ofReal_add (by linarith) (by linarith)]\n    rw [sub_add_cancel]"}
{"context": {"open": ["Topology EMetric Set ENNReal"], "variables": ["{E : Type u} {F : Type v} [PseudoEMetricSpace F]", "[PseudoEMetricSpace E] {K : Set E}", "{f : E \u2192 F} {D : Set E} {\u03b5 : ENNReal}"]}, "declaration": "theorem uniform_oscillationWithin_have_2 (E : Type u) (F : Type v) (K : Set E) (f : E \u2192 F) (D : Set E) (\u03b5 : ENNReal) (comp : IsCompact K) (hK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5) (S : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}) (S_open : \u2200 r > 0, sorry) : K \u2286 \u22c3 r > 0, S r :=\n  by intro x hx\n    have : oscillationWithin f D x < \u03b5 := hK x hx\n    simp only [oscillationWithin] at this\n    simp only [Filter.mem_map] at this\n    simp only [iInf_lt_iff] at this\n    obtain \u27e8n, hn\u2081, hn\u2082\u27e9 := this\n    obtain \u27e8r, r0, hr\u27e9 := mem_nhdsWithin_iff.1 hn\u2081\n    simp only [gt_iff_lt]\n    simp only [mem_iUnion]\n    simp only [exists_prop]\n    have : \u2200 r', (ENNReal.ofReal r') \u2264 r \u2192 diam (f '' (ball x (ENNReal.ofReal r') \u2229 D)) \u2264 \u03b5 := by\n      intro r' hr'\n      refine le_trans (diam_mono (subset_trans ?_ (image_subset_iff.2 hr))) (le_of_lt hn\u2082)\n      exact image_mono (inter_subset_inter_left D (ball_subset_ball hr'))\n    by_cases r_top : r = \u22a4\n    \u00b7 use 1, one_pos, 2, one_lt_two, this 2 (by simp only [r_top, le_top])\n    \u00b7 obtain \u27e8r', hr'\u27e9 := exists_between (toReal_pos (ne_of_gt r0) r_top)\n      use r', hr'.1, r.toReal, hr'.2, this r.toReal ofReal_toReal_le"}
{"context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "declaration": "theorem summable_condensed_iff_of_nonneg_have_1 (f : \u2115 \u2192 \u211d) (h_nonneg : \u2200 (n : \u2115), 0 \u2264 f n) (h_mono : \u2200 \u2983m n : \u2115\u2984, 0 < m \u2192 m \u2264 n \u2192 f n \u2264 f m) : SuccDiffBounded 2 (2 ^ \u00b7) :=\n  by intro n\n    simp [pow_succ, mul_two, two_mul]"}
{"context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "declaration": "theorem AntitoneOn_have_1 (x\u2080 : \u211d) (a : \u2115) (f : \u211d \u2192 \u211d) (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + \u2191a))) : \u2200 k : \u2115, k < a \u2192 IntervalIntegrable f volume (x\u2080 + k) (x\u2080 + (k + 1 : \u2115)) :=\n  by intro k hk\n    refine (hf.mono ?_).intervalIntegrable\n    rw [uIcc_of_le]\n    \u00b7 apply Icc_subset_Icc\n      \u00b7 simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]\n      \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]\n    \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]"}
{"context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "declaration": "theorem AntitoneOn_have_1 (x\u2080 : \u211d) (a : \u2115) (f : \u211d \u2192 \u211d) (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + \u2191a))) : \u2200 k : \u2115, k < a \u2192 IntervalIntegrable f volume (x\u2080 + k) (x\u2080 + (k + 1 : \u2115)) :=\n  by intro k hk\n    refine (hf.mono ?_).intervalIntegrable\n    rw [uIcc_of_le]\n    \u00b7 apply Icc_subset_Icc\n      \u00b7 simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]\n      \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]\n    \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]"}
{"context": {"open": ["ENNReal EReal Filter Function Set", "scoped Topology"], "variables": ["{u v : \u2115 \u2192 \u211d\u22650\u221e} {a : EReal} {b : \u211d\u22650\u221e}", "{u : \u2115 \u2192 \u211d\u22650\u221e} {v : \u2115 \u2192 \u2115}"]}, "declaration": "theorem tendsto_atTop_of_linGrowthInf_pos_have_1 (v : \u2115 \u2192 \u2115) (h : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0) (M : \u2115) (a : EReal) (a_0 : 0 < a) (a_v : a < liminf (fun n => \u2191(v n) / \u2191n) atTop) : \u2200\u1da0 n : \u2115 in atTop, M \u2264 a * n :=\n  by obtain \u27e8n, hn\u27e9 := EReal.exists_nat_ge_mul a.inv_lt_top.ne M\n    rw [\u2190 EReal.div_eq_inv_mul] at hn\n    rw [EReal.div_le_iff_le_mul a_0 (ne_top_of_lt a_v)] at hn\n    refine eventually_atTop.2 \u27e8n, fun k k_n \u21a6 ?_\u27e9\n    exact hn.trans (mul_le_mul_of_nonneg_left (Nat.cast_le.2 k_n) a_0.le)"}
{"context": {"open": ["ENNReal EReal Filter Function Set", "scoped Topology"], "variables": ["{u v : \u2115 \u2192 \u211d\u22650\u221e} {a : EReal} {b : \u211d\u22650\u221e}", "{u : \u2115 \u2192 \u211d\u22650\u221e} {v : \u2115 \u2192 \u2115}"]}, "declaration": "theorem tendsto_atTop_of_linGrowthInf_pos_have_2 (v : \u2115 \u2192 \u2115) (h : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0) (M : \u2115) (a : EReal) (a_0 : 0 < a) (a_v : a < liminf (fun n => \u2191(v n) / \u2191n) atTop) (h\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2191M \u2264 a * \u2191n) : \u2200\u1da0 n : \u2115 in atTop, a * n \u2264 v n :=\n  by refine (eventually_lt_of_lt_liminf a_v).mp (eventually_atTop.2 \u27e81, fun n n_1 a_vn \u21a6 ?_\u27e9)\n    rw [lt_div_iff (Nat.cast_pos'.2 n_1) (natCast_ne_top n)] at a_vn\n    exact a_vn.le"}
{"context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "declaration": "theorem lhopital_zero_right_on_Ioo_have_1 (l : Filter \u211d) (hab : a < b) (hfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)) (hga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)) (hdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l) (sub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b) : \u2200 x \u2208 Ioo a b, g x \u2260 0 :=\n  by intro x hx h\n    have : Tendsto g (\ud835\udcdd[<] x) (\ud835\udcdd 0) := by\n      rw [\u2190 h]\n      rw [\u2190 nhdsWithin_Ioo_eq_nhdsLT hx.1]\n      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto\n    obtain \u27e8y, hyx, hy\u27e9 : \u2203 c \u2208 Ioo a x, g' c = 0 :=\n      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy\n    exact hg' y (sub x hx hyx) hy"}
{"context": {"open": ["scoped Interval Topology Nat", "Set"], "variables": ["{\ud835\udd5c E F : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "declaration": "theorem taylor_mean_remainder_cauchy_have_1 (f : \u211d \u2192 \u211d) (n : \u2115) (hx : x\u2080 < x) (hf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)) : ContinuousOn id (Icc x\u2080 x) :=\n  by fun_prop"}
{"context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology", "FormalMultilinearSeries", "Finset in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}", "{p : FormalMultilinearSeries \ud835\udd5c \ud835\udd5c F} {r : \u211d\u22650\u221e}", "{f : \ud835\udd5c \u2192 F} {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e} {n : \u2115}", "{f : E \u2192 F} {x : E} {s : Set E}", "{p : FormalMultilinearSeries \ud835\udd5c \ud835\udd5c F} {r : \u211d\u22650\u221e}", "{f : \ud835\udd5c \u2192 F} {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (E i)] [\u2200 i, NormedSpace \ud835\udd5c (E i)]", "{n : WithTop \u2115\u221e} (x : \u2200 i, E i)"]}, "declaration": "theorem _root__have_1 (\u03b9 : Type u_1) (n : \u2115) (e : Fin (n + 1) \u21aa \u03b9) (j : Fin (n + 1)) : j \u2260 0 :=\n  by rintro rfl\n    simp at h'k"}
{"context": {"open": ["Filter Set Metric ContinuousLinearMap", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]"]}, "declaration": "theorem hasDerivAt_of_hasDerivAt_of_ne_have_1 (E : Type u_1) (x : \u211d) (f_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y) (hf : ContinuousAt f x) (hg : ContinuousAt g x) : HasDerivWithinAt f (g x) (Ici x) x :=\n  by have diff : DifferentiableOn \u211d f (Ioi x) := fun y hy =>\n      (f_diff y (ne_of_gt hy)).differentiableAt.differentiableWithinAt\n    apply\n      hasDerivWithinAt_Ici_of_tendsto_deriv diff hf.continuousWithinAt\n        self_mem_nhdsWithin\n    have : Tendsto g (\ud835\udcdd[>] x) (\ud835\udcdd (g x)) := tendsto_inf_left hg\n    apply this.congr' _\n    apply mem_of_superset self_mem_nhdsWithin fun y hy => _\n    intros y hy\n    exact (f_diff y (ne_of_gt hy)).deriv.symm"}
{"context": {"open": ["Filter Set Metric ContinuousLinearMap", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]"]}, "declaration": "theorem hasDerivAt_of_hasDerivAt_of_ne_have_2 (E : Type u_1) (x : \u211d) (f_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y) (hf : ContinuousAt f x) (hg : ContinuousAt g x) (A : sorry) : HasDerivWithinAt f (g x) (Iic x) x :=\n  by have diff : DifferentiableOn \u211d f (Iio x) := fun y hy =>\n      (f_diff y (ne_of_lt hy)).differentiableAt.differentiableWithinAt\n    apply\n      hasDerivWithinAt_Iic_of_tendsto_deriv diff hf.continuousWithinAt\n        self_mem_nhdsWithin\n    have : Tendsto g (\ud835\udcdd[<] x) (\ud835\udcdd (g x)) := tendsto_inf_left hg\n    apply this.congr' _\n    apply mem_of_superset self_mem_nhdsWithin fun y hy => _\n    intros y hy\n    exact (f_diff y (ne_of_lt hy)).deriv.symm"}
{"context": {"open": ["Set", "scoped NNReal"], "variables": []}, "declaration": "theorem exists_homeomorph_extension_have_1 (E : Type u_1) (F : Type u_2) (s : Set E) (f : E \u2192 F) (c : NNReal) (hf : ApproximatesLinearOn f (\u2191f') s c) (hc : Subsingleton E \u2228 lipschitzExtensionConstant F * c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9) (u : E \u2192 F) (hu : sorry) (uf : EqOn sorry u s) (g : E \u2192 F := fun x => sorry) (fg : EqOn f g s) : ApproximatesLinearOn g (f' : E \u2192L[\u211d] F) univ (lipschitzExtensionConstant F * c) :=\n  by apply LipschitzOnWith.approximatesLinearOn\n    rw [lipschitzOnWith_univ]\n    convert hu\n    ext x\n    simp only [g]\n    simp only [add_sub_cancel_left]\n    simp only [ContinuousLinearEquiv.coe_coe]\n    simp only [Pi.sub_apply]"}
{"context": {"open": ["scoped Topology Filter ENNReal NNReal", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c)", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}", "{f f\u2081 : E \u2192 F} {f' f\u2080' f\u2081' : F} {s t : Set E} {x v : E}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]"]}, "declaration": "theorem Filter_have_1 (\ud835\udd5c : Type u_1) (F : Type u_2) (E : Type u_3) (s : Set E) (hs : f\u2081 =\u1da0[sorry] f) (hx : f\u2081 x = f x) : Continuous (fun (t : \ud835\udd5c) \u21a6 x + t \u2022 v) :=\n  by fun_prop"}
{"context": {"open": ["TopologicalSpace Metric Set Filter Asymptotics Function MeasureTheory AffineMap Bornology", "scoped Topology Filter NNReal Real"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E] {F : Type v} [NormedAddCommGroup F]", "[StrictConvexSpace \u211d F]"]}, "declaration": "theorem eventually_eq_or_eq_zero_of_isLocalMin_norm_have_1 (E : Type u) (f : E \u2192 \u2102) (c : E) (hf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z) (hc : IsLocalMin (norm \u2218 f) c) (h : \u00acf c = 0) (h1 : \u2200\u1da0 (z : E) in sorry, f z \u2260 0) (h2 : sorry) : IsLocalMax (norm \u2218 f\u207b\u00b9) c :=\n  by refine h2.congr (Eventually.of_forall ?_); simp"}
{"context": {"open": ["TopologicalSpace Metric Set Filter Asymptotics Function MeasureTheory AffineMap Bornology", "scoped Topology Filter NNReal Real"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E] {F : Type v} [NormedAddCommGroup F]", "[StrictConvexSpace \u211d F]"]}, "declaration": "theorem eventually_eq_or_eq_zero_of_isLocalMin_norm_have_2 (E : Type u) (f : E \u2192 \u2102) (c : E) (hf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z) (hc : IsLocalMin (norm \u2218 f) c) (h : \u00acf c = 0) (h1 : \u2200\u1da0 (z : E) in sorry, f z \u2260 0) (h2 : sorry) (h3 : sorry) : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f\u207b\u00b9 z :=\n  by filter_upwards [hf, h1] with z h using h.inv"}
{"context": {"open": ["Filter Finset", "scoped Topology", "Real"], "variables": []}, "declaration": "theorem stolzCone_subset_stolzSet_aux_have_1 (hx\u2080 : 0 < x) (hx\u2081 : x < 1 / (1 + s ^ 2)) (hy : |y| < s * x) : sqrt ((1 - x) ^ 2 + y ^ 2) \u2264 1 - x / 2 :=\n  by calc sqrt ((1 - x) ^ 2 + y ^ 2)\n      _ \u2264 sqrt ((1 - x) ^ 2 + (s * x) ^ 2) := sqrt_le_sqrt <| by rw [\u2190 sq_abs y]; gcongr\n      _ = sqrt (1 - 2 * x + (1 + s ^ 2) * x * x) := by congr 1; ring\n      _ \u2264 sqrt (1 - 2 * x + (1 + s ^ 2) * (1 / (1 + s ^ 2)) * x) := sqrt_le_sqrt <| by gcongr\n      _ = sqrt (1 - x) := by congr 1; field_simp; ring\n      _ \u2264 1 - x / 2 := by\n        simp_rw [sub_eq_add_neg, \u2190 neg_div]\n        refine sqrt_one_add_le <| neg_le_neg_iff.mpr (hx\u2081.trans_le ?_).le\n        rw [div_le_one (by positivity)]\n        exact le_add_of_nonneg_right <| sq_nonneg s"}
{"context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "declaration": "theorem le_gronwallBound_of_liminf_deriv_right_le_have_1 (hf : ContinuousOn f (Icc a b)) (ha : f a \u2264 \u03b4) (bound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5) : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a) :=\n  by intro x hx \u03b5' h\u03b5'\n    apply image_le_of_liminf_slope_right_lt_deriv_boundary hf hf'\n    \u00b7 rwa [sub_self, gronwallBound_x0]\n    \u00b7 exact fun x => hasDerivAt_gronwallBound_shift \u03b4 K \u03b5' x a\n    \u00b7 intro x hx hfB\n      rw [\u2190 hfB]\n      apply lt_of_le_of_lt (bound x hx)\n      exact add_lt_add_left (mem_Ioi.1 h\u03b5') _\n    \u00b7 exact hx"}
{"context": {"open": ["scoped BoundedContinuousFunction unitInterval"], "variables": []}, "declaration": "theorem bernstein_nonneg_have_1 (x : \u2191unitInterval) : (0 : \u211d) \u2264 x :=\n  by unit_interval"}
{"context": {"open": ["scoped BoundedContinuousFunction unitInterval"], "variables": []}, "declaration": "theorem bernstein_nonneg_have_2 (x : \u2191unitInterval) (h\u2081 : 0 \u2264 \u2191x) : (0 : \u211d) \u2264 1 - x :=\n  by unit_interval"}
{"context": {"open": ["scoped BoundedContinuousFunction unitInterval", "Lean Meta Qq Function", "bernstein", "bernsteinApproximation", "BoundedContinuousFunction", "Filter", "scoped Topology"], "variables": []}, "declaration": "theorem bernsteinApproximation_uniform_have_1 (f : C(\u2191unitInterval, \u211d)) (\u03b5 : \u211d) (h : 0 < \u03b5) (\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h) (nhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)) (n : \u2115) (nh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2) : 0 < (n : \u211d) :=\n  by positivity"}
{"context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "declaration": "theorem integrableOn_Ioi_deriv_ofReal_cpow_have_1 (s : \u2102) (t : \u211d) (ht : 0 < t) (hs : s.re < 0) : IntegrableOn (fun x : \u211d \u21a6 s * x ^ (s - 1)) (Set.Ioi t) :=\n  by refine (integrableOn_Ioi_cpow_of_lt ?_ ht).const_mul _\n    rwa [Complex.sub_re, Complex.one_re, sub_lt_iff_lt_add, neg_add_cancel]"}
{"context": {"open": ["Real Set MeasureTheory", "scoped ENNReal Real Topology"], "variables": []}, "declaration": "theorem polarCoord_source_ae_eq_univ_have_1  : polarCoord.source\u1d9c \u2286 LinearMap.ker (LinearMap.snd \u211d \u211d \u211d) :=\n  by intro x hx\n    simp only [polarCoord_source] at hx\n    simp only [compl_union] at hx\n    simp only [mem_inter_iff] at hx\n    simp only [mem_compl_iff] at hx\n    simp only [mem_setOf_eq] at hx\n    simp only [not_lt] at hx\n    simp only [Classical.not_not] at hx\n    exact hx.2"}
{"context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "declaration": "theorem inv_Gamma\u211d_one_sub_have_1 (s : \u2102) (hs : \u2200 (n : \u2115), s \u2260 -\u2191n) : Gamma\u211d s \u2260 0 :=\n  by rw [Ne]\n    rw [Gamma\u211d_eq_zero_iff]\n    rw [not_exists]\n    intro n h\n    specialize hs (2 * n)\n    simp_all"}
{"context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "declaration": "theorem inv_Gamma\u211d_one_sub_have_2 (s : \u2102) (hs : \u2200 (n : \u2115), s \u2260 -\u2191n) (h1 : s.Gamma\u211d \u2260 0) : \u2200 (n : \u2115), s \u2260 -(2 * \u2191n + 1) :=\n  by intro n h\n    specialize hs (2 * n + 1)\n    simp_all"}
{"context": {"open": ["Filter Set MeasureTheory", "scoped Nat ENNReal Topology Real"], "variables": ["{f : \u211d \u2192 \u211d} {x : \u211d} {n : \u2115}"]}, "declaration": "theorem f_add_nat_ge_have_1 (f : \u211d \u2192 \u211d) (x : \u211d) (n : \u2115) (log : x\u271d) (hf_conv : ConvexOn \u211d (Ioi 0) f) (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry) (hn : 2 \u2264 n) (hx : 0 < x) : 0 < (n : \u211d) - 1 :=\n  by rw [\u2190 Nat.cast_one, sub_pos, Nat.cast_lt]; omega"}
{"context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "declaration": "theorem integral_gaussian_complex_have_1 (b : \u2102) (hb : 0 < b.re) : \u2200 {b : \u2102}, 0 < re b \u2192 b \u2260 0 :=\n  by intro b hb; contrapose! hb; rw [hb]; simp"}
{"context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}", "(b_pos : 0 < b) (b_ne_one : b \u2260 1)"]}, "declaration": "theorem log_b_ne_zero_have_1 (log : x\u271d) : b \u2260 0 :=\n  by linarith"}
{"context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}", "(b_pos : 0 < b) (b_ne_one : b \u2260 1)"]}, "declaration": "theorem log_b_ne_zero_have_2 (log : x\u271d) (b_ne_zero : sorry \u2260 0) : b \u2260 -1 :=\n  by linarith"}
{"context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "declaration": "theorem quadratic_root_cos_pi_div_five_have_1 (\u03b8 : \u2115 := sorry / 5) (h\u03b8 : \u03b8 = sorry / 5) (c : \u211d := cos \u2191\u03b8) (s : \u211d := sin \u2191\u03b8) : s \u2260 0 :=\n  by rw [ne_eq]\n    rw [sin_eq_zero_iff]\n    rw [h\u03b8]\n    push_neg\n    intro n hn\n    replace hn : n * 5 = 1 := by field_simp [mul_comm _ \u03c0, mul_assoc] at hn; norm_cast at hn\n    omega"}
{"context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "declaration": "theorem tan_pi_div_four_have_1  : \u221a2 / 2 > 0 :=\n  by positivity"}
{"context": {"open": ["scoped Real Topology", "Real Set Filter intervalIntegral MeasureTheory.MeasureSpace"], "variables": ["{z : \u2102} {n : \u2115}"]}, "declaration": "theorem tendsto_integral_cos_pow_mul_div_have_1 (f : \u211d \u2192 \u2102) (hf : ContinuousOn f (Icc 0 (Real.pi / 2))) (c_lt : \u2200 y \u2208 Icc 0 (sorry / 2), y \u2260 0 \u2192 cos y < cos 0) (c_nonneg : \u2200 x \u2208 Icc 0 (sorry / 2), 0 \u2264 cos x) : 0 < cos 0 :=\n  by rw [cos_zero]; exact zero_lt_one"}
{"context": {"open": ["scoped Real Topology", "Real Set Filter intervalIntegral MeasureTheory.MeasureSpace"], "variables": ["{z : \u2102} {n : \u2115}"]}, "declaration": "theorem tendsto_integral_cos_pow_mul_div_have_2 (f : \u211d \u2192 \u2102) (hf : ContinuousOn f (Icc 0 (Real.pi / 2))) (c_lt : \u2200 y \u2208 Icc 0 (sorry / 2), y \u2260 0 \u2192 cos y < cos 0) (c_nonneg : \u2200 x \u2208 Icc 0 (sorry / 2), 0 \u2264 cos x) (c_zero_pos : 0 < cos 0) : (0 : \u211d) \u2208 closure (interior (Icc 0 (\u03c0 / 2))) :=\n  by rw [interior_Icc]\n    rw [closure_Ioo pi_div_two_pos.ne]\n    rw [left_mem_Icc]\n    exact pi_div_two_pos.le"}
{"context": {"open": ["Filter Finset", "Topology"], "variables": []}, "declaration": "theorem sum_div_pow_sq_le_div_sq_have_1 (N : \u2115) (j : \u211d) (hj : 0 < j) (c : \u211d) (hc : 1 < c) (cpos : 0 < c) (A : 0 < c\u207b\u00b9 ^ 2) : c ^ 2 * ((1 : \u211d) - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 :=\n  by rw [\u2190 div_eq_mul_inv]\n    rw [\u2190 div_eq_mul_inv]\n    rw [div_le_div_iff\u2080 _ (sub_pos.2 hc)]\n    swap\n    \u00b7 exact sub_pos.2 (pow_lt_one\u2080 (inv_nonneg.2 cpos.le) (inv_lt_one_of_one_lt\u2080 hc) two_ne_zero)\n    have : c ^ 3 = c ^ 2 * c := by ring\n    simp only [mul_sub]\n    simp only [this]\n    simp only [mul_one]\n    simp only [inv_pow]\n    simp only [sub_le_sub_iff_left]\n    rw [mul_assoc]\n    rw [mul_comm c]\n    rw [\u2190 mul_assoc]\n    rw [mul_inv_cancel\u2080 (sq_pos_of_pos cpos).ne']\n    rw [one_mul]\n    simpa using pow_right_mono\u2080 hc.le one_le_two"}
{"context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "declaration": "theorem Monotone_have_1 (f : \u2115 \u2192 \u211d) (l : \u211d) (hfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)) (hfm : Monotone f) (k : \u2115) : Antitone (fun n \u21a6 \u2211 i \u2208 range (2 * n), (-1) ^ i * f i) :=\n  by refine antitone_nat_of_succ_le (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ]\n    rw [sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, one_mul,\n      \u2190 sub_eq_add_neg, sub_le_iff_le_add]\n    gcongr\n    exact hfm (by omega)"}
{"context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "declaration": "theorem Monotone_have_1 (f : \u2115 \u2192 \u211d) (l : \u211d) (hfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)) (hfm : Monotone f) (k : \u2115) : Monotone (fun n \u21a6 \u2211 i \u2208 range (2 * n + 1), (-1) ^ i * f i) :=\n  by refine monotone_nat_of_le_succ (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ _ (2 * n + 1 + 1)]\n    rw [sum_range_succ _ (2 * n + 1)]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, neg_neg, one_mul,\n      \u2190 sub_eq_add_neg, sub_add_eq_add_sub, le_sub_iff_add_le]\n    gcongr\n    exact hfm (by omega)"}
{"context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "declaration": "theorem Antitone_have_1 (f : \u2115 \u2192 \u211d) (l : \u211d) (hfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)) (hfa : Antitone f) (k : \u2115) : Monotone (fun n \u21a6 \u2211 i \u2208 range (2 * n), (-1) ^ i * f i) :=\n  by refine monotone_nat_of_le_succ (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ]\n    rw [sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, one_mul,\n      \u2190 sub_eq_add_neg, le_sub_iff_add_le]\n    gcongr\n    exact hfa (by omega)"}
{"context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "declaration": "theorem Antitone_have_1 (f : \u2115 \u2192 \u211d) (l : \u211d) (hfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)) (hfa : Antitone f) (k : \u2115) : Antitone (fun n \u21a6 \u2211 i \u2208 range (2 * n + 1), (-1) ^ i * f i) :=\n  by refine antitone_nat_of_succ_le (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ]\n    rw [sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, neg_neg, one_mul,\n      \u2190 sub_eq_add_neg, sub_add_eq_add_sub, sub_le_iff_le_add]\n    gcongr\n    exact hfa (by omega)"}
{"context": {"open": ["Limits"], "variables": ["{C : Type*} [Category C] [Preregular C] {X : C}"]}, "declaration": "theorem mem_sieves_of_hasEffectiveEpi_have_1 (Sieve : x\u271d\u00b2) (C : Type u_2) (X : C) (EffectiveEpi : x\u271d\u00b9) (regularTopology : x\u271d) (S : sorry) (Y : C) (\u03c0 : sorry) (h : sorry \u2227 sorry) : Sieve.generate (Presieve.ofArrows (fun () \u21a6 Y) (fun _ \u21a6 \u03c0)) \u2264 S :=\n  by rw [Sieve.generate_le_iff (Presieve.ofArrows _ _) S]\n    apply Presieve.le_of_factorsThru_sieve (Presieve.ofArrows _ _) S _\n    intro W g f\n    refine \u27e8W, \ud835\udfd9 W, ?_\u27e9\n    cases f\n    exact \u27e8\u03c0, \u27e8h.2, Category.id_comp \u03c0\u27e9\u27e9"}
{"context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise", "scoped Filter Topology", "Real"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "declaration": "theorem exp_neg_two_mul_le_have_1 (x : \u211d) (hx : 0 < x) (h\u2081 : \u2191\u2308x\u2309\u208a < x + 1) : 1 - x \u2264 2 - \u2308x\u2309\u208a :=\n  by linarith"}
{"context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "declaration": "theorem sizeUpTo_index_le_have_1 (n : \u2115) (c : Composition n) (j : Fin n) (i : Fin c.length := c.index j) (H : \u2191j < c.sizeUpTo \u2191i) : (0 : \u2115) < i :=\n  by_contra! i_pos\n    revert H\n    simp [nonpos_iff_eq_zero.1 i_pos, c.sizeUpTo_zero]"}
