{"declaration": "theorem factorization_eq_count {n p : \u03b1} :\n    factorization n p = Multiset.count p (normalizedFactors n) := by simp [factorization]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/Finsupp.lean", "context": {"open": ["UniqueFactorizationMonoid"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1]", "[NormalizationMonoid \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\nn p : \u03b1\n\u22a2 (factorization n) p = Multiset.count p (normalizedFactors n)"}, {"line": "simp [factorization]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_zero : factorization (0 : \u03b1) = 0 := by simp [factorization]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/Finsupp.lean", "context": {"open": ["UniqueFactorizationMonoid"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1]", "[NormalizationMonoid \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 factorization 0 = 0"}, {"line": "simp [factorization]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_one : factorization (1 : \u03b1) = 0 := by simp [factorization]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/Finsupp.lean", "context": {"open": ["UniqueFactorizationMonoid"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1]", "[NormalizationMonoid \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 factorization 1 = 0"}, {"line": "simp [factorization]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_factorization {n : \u03b1} :\n    (factorization n).support = (normalizedFactors n).toFinset := by\n  simp [factorization, Multiset.toFinsupp_support]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/Finsupp.lean", "context": {"open": ["UniqueFactorizationMonoid"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1]", "[NormalizationMonoid \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u03b1\n\u22a2 (factorization n).support = (normalizedFactors n).toFinset"}, {"line": "simp [factorization, Multiset.toFinsupp_support]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_mul {a b : \u03b1} (ha : a \u2260 0) (hb : b \u2260 0) :\n    factorization (a * b) = factorization a + factorization b := by\n  simp [factorization, normalizedFactors_mul ha hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/Finsupp.lean", "context": {"open": ["UniqueFactorizationMonoid"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1]", "[NormalizationMonoid \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 factorization (a * b) = factorization a + factorization b"}, {"line": "simp [factorization, normalizedFactors_mul ha hb]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 Multiset.toFinsupp (normalizedFactors (a * b)) =\n    Multiset.toFinsupp (normalizedFactors a) + Multiset.toFinsupp (normalizedFactors b)"}]}
{"declaration": "theorem factorization_pow {x : \u03b1} {n : \u2115} : factorization (x ^ n) = n \u2022 factorization x := by\n  ext\n  simp [factorization]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/Finsupp.lean", "context": {"open": ["UniqueFactorizationMonoid"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1]", "[NormalizationMonoid \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 factorization (x ^ n) = n \u2022 factorization x"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nn : \u2115\na\u271d : \u03b1\n\u22a2 (factorization (x ^ n)) a\u271d = (n \u2022 factorization x) a\u271d"}, {"line": "simp [factorization]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem induction_on_prime_power {P : \u03b1 \u2192 Prop} (s : Finset \u03b1) (i : \u03b1 \u2192 \u2115)\n    (is_prime : \u2200 p \u2208 s, Prime p) (is_coprime : \u2200\u1d49 (p \u2208 s) (q \u2208 s), p \u2223 q \u2192 p = q)\n    (h1 : \u2200 {x}, IsUnit x \u2192 P x) (hpr : \u2200 {p} (i : \u2115), Prime p \u2192 P (p ^ i))\n    (hcp : \u2200 {x y}, IsRelPrime x y \u2192 P x \u2192 P y \u2192 P (x * y)) :\n    P (\u220f p \u2208 s, p ^ i p) := by\n  letI := Classical.decEq \u03b1\n  induction' s using Finset.induction_on with p f' hpf' ih\n  \u00b7 simpa using h1 isUnit_one\n  rw [Finset.prod_insert hpf']\n  exact\n    hcp (prime_pow_coprime_prod_of_coprime_insert i p hpf' is_prime is_coprime)\n      (hpr (i p) (is_prime _ (Finset.mem_insert_self _ _)))\n      (ih (fun q hq => is_prime _ (Finset.mem_insert_of_mem hq)) fun q hq q' hq' =>\n        is_coprime _ (Finset.mem_insert_of_mem hq) _ (Finset.mem_insert_of_mem hq'))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/Multiplicative.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "{R : Type*} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]", "[CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1]", "{\u03b2 : Type*} [CancelCommMonoidWithZero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nP : \u03b1 \u2192 Prop\ns : Finset \u03b1\ni : \u03b1 \u2192 \u2115\nis_prime : \u2200 p \u2208 s, Prime p\nis_coprime : \u2200 p \u2208 s, \u2200 q \u2208 s, p \u2223 q \u2192 p = q\nh1 : \u2200 {x : \u03b1}, IsUnit x \u2192 P x\nhpr : \u2200 {p : \u03b1} (i : \u2115), Prime p \u2192 P (p ^ i)\nhcp : \u2200 {x y : \u03b1}, IsRelPrime x y \u2192 P x \u2192 P y \u2192 P (x * y)\n\u22a2 P (\u220f p \u2208 s, p ^ i p)"}, {"line": "letI := Classical.decEq \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nP : \u03b1 \u2192 Prop\ns : Finset \u03b1\ni : \u03b1 \u2192 \u2115\nis_prime : \u2200 p \u2208 s, Prime p\nis_coprime : \u2200 p \u2208 s, \u2200 q \u2208 s, p \u2223 q \u2192 p = q\nh1 : \u2200 {x : \u03b1}, IsUnit x \u2192 P x\nhpr : \u2200 {p : \u03b1} (i : \u2115), Prime p \u2192 P (p ^ i)\nhcp : \u2200 {x y : \u03b1}, IsRelPrime x y \u2192 P x \u2192 P y \u2192 P (x * y)\nthis : DecidableEq \u03b1 := Classical.decEq \u03b1\n\u22a2 P (\u220f p \u2208 s, p ^ i p)"}, {"line": "induction' s using Finset.induction_on with p f' hpf' ih", "tactic_state": "case empty\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nP : \u03b1 \u2192 Prop\ni : \u03b1 \u2192 \u2115\nh1 : \u2200 {x : \u03b1}, IsUnit x \u2192 P x\nhpr : \u2200 {p : \u03b1} (i : \u2115), Prime p \u2192 P (p ^ i)\nhcp : \u2200 {x y : \u03b1}, IsRelPrime x y \u2192 P x \u2192 P y \u2192 P (x * y)\nthis : DecidableEq \u03b1 := Classical.decEq \u03b1\nis_prime : \u2200 p \u2208 \u2205, Prime p\nis_coprime : \u2200 p \u2208 \u2205, \u2200 q \u2208 \u2205, p \u2223 q \u2192 p = q\n\u22a2 P (\u220f p \u2208 \u2205, p ^ i p)\n---\ncase insert\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nP : \u03b1 \u2192 Prop\ni : \u03b1 \u2192 \u2115\nh1 : \u2200 {x : \u03b1}, IsUnit x \u2192 P x\nhpr : \u2200 {p : \u03b1} (i : \u2115), Prime p \u2192 P (p ^ i)\nhcp : \u2200 {x y : \u03b1}, IsRelPrime x y \u2192 P x \u2192 P y \u2192 P (x * y)\nthis : DecidableEq \u03b1 := Classical.decEq \u03b1\np : \u03b1\nf' : Finset \u03b1\nhpf' : p \u2209 f'\nih : (\u2200 p \u2208 f', Prime p) \u2192 (\u2200 p \u2208 f', \u2200 q \u2208 f', p \u2223 q \u2192 p = q) \u2192 P (\u220f p \u2208 f', p ^ i p)\nis_prime : \u2200 p_1 \u2208 insert p f', Prime p_1\nis_coprime : \u2200 p_1 \u2208 insert p f', \u2200 q \u2208 insert p f', p_1 \u2223 q \u2192 p_1 = q\n\u22a2 P (\u220f p \u2208 insert p f', p ^ i p)"}, {"line": "\u00b7 simpa using h1 isUnit_one", "tactic_state": "case insert\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nP : \u03b1 \u2192 Prop\ni : \u03b1 \u2192 \u2115\nh1 : \u2200 {x : \u03b1}, IsUnit x \u2192 P x\nhpr : \u2200 {p : \u03b1} (i : \u2115), Prime p \u2192 P (p ^ i)\nhcp : \u2200 {x y : \u03b1}, IsRelPrime x y \u2192 P x \u2192 P y \u2192 P (x * y)\nthis : DecidableEq \u03b1 := Classical.decEq \u03b1\np : \u03b1\nf' : Finset \u03b1\nhpf' : p \u2209 f'\nih : (\u2200 p \u2208 f', Prime p) \u2192 (\u2200 p \u2208 f', \u2200 q \u2208 f', p \u2223 q \u2192 p = q) \u2192 P (\u220f p \u2208 f', p ^ i p)\nis_prime : \u2200 p_1 \u2208 insert p f', Prime p_1\nis_coprime : \u2200 p_1 \u2208 insert p f', \u2200 q \u2208 insert p f', p_1 \u2223 q \u2192 p_1 = q\n\u22a2 P (\u220f p \u2208 insert p f', p ^ i p)"}, {"line": "rw [Finset.prod_insert hpf']", "tactic_state": "case insert\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nP : \u03b1 \u2192 Prop\ni : \u03b1 \u2192 \u2115\nh1 : \u2200 {x : \u03b1}, IsUnit x \u2192 P x\nhpr : \u2200 {p : \u03b1} (i : \u2115), Prime p \u2192 P (p ^ i)\nhcp : \u2200 {x y : \u03b1}, IsRelPrime x y \u2192 P x \u2192 P y \u2192 P (x * y)\nthis : DecidableEq \u03b1 := Classical.decEq \u03b1\np : \u03b1\nf' : Finset \u03b1\nhpf' : p \u2209 f'\nih : (\u2200 p \u2208 f', Prime p) \u2192 (\u2200 p \u2208 f', \u2200 q \u2208 f', p \u2223 q \u2192 p = q) \u2192 P (\u220f p \u2208 f', p ^ i p)\nis_prime : \u2200 p_1 \u2208 insert p f', Prime p_1\nis_coprime : \u2200 p_1 \u2208 insert p f', \u2200 q \u2208 insert p f', p_1 \u2223 q \u2192 p_1 = q\n\u22a2 P (p ^ i p * \u220f x \u2208 f', x ^ i x)"}, {"line": "exact\n    hcp (prime_pow_coprime_prod_of_coprime_insert i p hpf' is_prime is_coprime)\n      (hpr (i p) (is_prime _ (Finset.mem_insert_self _ _)))\n      (ih (fun q hq => is_prime _ (Finset.mem_insert_of_mem hq)) fun q hq q' hq' =>\n        is_coprime _ (Finset.mem_insert_of_mem hq) _ (Finset.mem_insert_of_mem hq'))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dvd_of_dvd_mul_right_of_no_prime_factors {a b c : R} (ha : a \u2260 0)\n    (no_factors : \u2200 {d}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) : a \u2223 b * c \u2192 a \u2223 c := by\n  simpa [mul_comm b c] using dvd_of_dvd_mul_left_of_no_prime_factors ha @no_factors\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/Basic.lean", "context": {"open": ["Associates Nat", "Classical in", "Multiset in", "Multiset UniqueFactorizationMonoid"], "variables": ["{\u03b1 : Type*}", "[CommMonoidWithZero \u03b1]", "[WfDvdMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]", "[UniqueFactorizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]", "(pf : \u2200 a : \u03b1, a \u2260 0 \u2192 \u2203 f : Multiset \u03b1, (\u2200 b \u2208 f, Prime b) \u2227 f.prod ~\u1d64 a)", "{\u03b2 : Type*} [CancelCommMonoidWithZero \u03b1] [CancelCommMonoidWithZero \u03b2]", "{R : Type*} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : UniqueFactorizationMonoid R\na b c : R\nha : a \u2260 0\nno_factors : \u2200 {d : R}, d \u2223 a \u2192 d \u2223 b \u2192 \u00ac_root_.Prime d\n\u22a2 a \u2223 b * c \u2192 a \u2223 c"}, {"line": "simpa [mul_comm b c] using dvd_of_dvd_mul_left_of_no_prime_factors ha @no_factors", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_subtype_coe_factors' {a : \u03b1} :\n    (factors' a).map (\u2191) = (factors a).map Associates.mk := by\n  simp [factors', Multiset.map_pmap, Multiset.pmap_eq_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/FactorSet.lean", "context": {"open": ["UniqueFactorizationMonoid Associated Multiset"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1]", "[DecidableEq (Associates \u03b1)]", "[\u2200 p : Associates \u03b1, Decidable (Irreducible p)] {p : Associates \u03b1}", "[UniqueFactorizationMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b9 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx\u271d : Sort u_2\nfactors' : x\u271d\na : \u03b1\n\u22a2 sorry = Multiset.map Associates.mk (factors a)"}, {"line": "simp [factors', Multiset.map_pmap, Multiset.pmap_eq_map]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b9 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx\u271d : Sort u_2\nfactors' : x\u271d\na : \u03b1\n\u22a2 sorry () = Multiset.map Associates.mk (factors a)"}]}
{"declaration": "theorem factors_subsingleton [Subsingleton \u03b1] {a : Associates \u03b1} : a.factors = \u22a4 := by\n  have : Subsingleton (Associates \u03b1) := inferInstance\n  convert factors_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/FactorSet.lean", "context": {"open": ["UniqueFactorizationMonoid Associated Multiset"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1]", "[DecidableEq (Associates \u03b1)]", "[\u2200 p : Associates \u03b1, Decidable (Irreducible p)] {p : Associates \u03b1}", "[UniqueFactorizationMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b3 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b2 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ninst\u271d : Subsingleton \u03b1\na : Associates \u03b1\n\u22a2 a.factors = \u22a4"}, {"line": "have : Subsingleton (Associates \u03b1) := inferInstance", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b3 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b2 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ninst\u271d : Subsingleton \u03b1\na : Associates \u03b1\nthis : Subsingleton sorry\n\u22a2 a.factors = \u22a4"}, {"line": "convert factors_zero", "tactic_state": "case a\n\u03b1 : Type u_1\ninst\u271d\u2074 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b3 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b2 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ninst\u271d : Subsingleton \u03b1\na : Associates \u03b1\nthis : Subsingleton sorry\n\u22a2 a.factors = \u22a4 \u2194 factors 0 = 0\n---\ncase convert_1\n\u03b1 : Type u_1\ninst\u271d\u2074 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b3 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b2 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ninst\u271d : Subsingleton \u03b1\na : Associates \u03b1\nthis : Subsingleton sorry\n\u22a2 Type ?u.4908\n---\ncase convert_2\n\u03b1 : Type u_1\ninst\u271d\u2074 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b3 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b2 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ninst\u271d : Subsingleton \u03b1\na : Associates \u03b1\nthis : Subsingleton sorry\n\u22a2 CancelCommMonoidWithZero ?convert_1\n---\ncase convert_3\n\u03b1 : Type u_1\ninst\u271d\u2074 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b3 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b2 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ninst\u271d : Subsingleton \u03b1\na : Associates \u03b1\nthis : Subsingleton sorry\n\u22a2 UniqueFactorizationMonoid ?convert_1"}]}
{"declaration": "theorem factors_eq_top_iff_zero {a : Associates \u03b1} : a.factors = \u22a4 \u2194 a = 0 := by\n  nontriviality \u03b1\n  exact \u27e8fun h \u21a6 by rwa [\u2190 factors_prod a, FactorSet.prod_eq_zero_iff], fun h \u21a6 h \u25b8 factors_zero\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/FactorSet.lean", "context": {"open": ["UniqueFactorizationMonoid Associated Multiset"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1]", "[DecidableEq (Associates \u03b1)]", "[\u2200 p : Associates \u03b1, Decidable (Irreducible p)] {p : Associates \u03b1}", "[UniqueFactorizationMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b9 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na : Associates \u03b1\n\u22a2 a.factors = \u22a4 \u2194 a = 0"}, {"line": "nontriviality \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq (Associates \u03b1)\ninst\u271d\u00b9 : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na : Associates \u03b1\na\u271d : Nontrivial \u03b1\n\u22a2 a.factors = \u22a4 \u2194 a = 0"}, {"line": "exact \u27e8fun h \u21a6 by rwa [\u2190 factors_prod a, FactorSet.prod_eq_zero_iff], fun h \u21a6 h \u25b8 factors_zero\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma factors_multiset_prod_of_irreducible {s : Multiset \u2115} (h : \u2200 x : \u2115, x \u2208 s \u2192 Irreducible x) :\n    normalizedFactors s.prod = s := by\n  rw [\u2190 Multiset.rel_eq]\n  rw [\u2190 associated_eq_eq]\n  apply UniqueFactorizationMonoid.factors_unique irreducible_of_normalized_factor h\n    (prod_normalizedFactors _)\n  rw [Ne]\n  rw [Multiset.prod_eq_zero_iff]\n  exact fun con \u21a6 not_irreducible_zero (h 0 con)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/Nat.lean", "context": {"open": ["UniqueFactorizationMonoid"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Multiset \u2115\nh : \u2200 x \u2208 s, Irreducible x\n\u22a2 normalizedFactors s.prod = s"}, {"line": "rw [\u2190 Multiset.rel_eq]", "tactic_state": "s : Multiset \u2115\nh : \u2200 x \u2208 s, Irreducible x\n\u22a2 Multiset.Rel (fun x1 x2 => x1 = x2) (normalizedFactors s.prod) s"}, {"line": "rw [\u2190 associated_eq_eq]", "tactic_state": "s : Multiset \u2115\nh : \u2200 x \u2208 s, Irreducible x\n\u22a2 Multiset.Rel (fun x1 x2 => Associated x1 x2) (normalizedFactors s.prod) s"}, {"line": "apply UniqueFactorizationMonoid.factors_unique irreducible_of_normalized_factor h\n    (prod_normalizedFactors _)", "tactic_state": "s : Multiset \u2115\nh : \u2200 x \u2208 s, Irreducible x\n\u22a2 s.prod \u2260 0"}, {"line": "rw [Ne]", "tactic_state": "s : Multiset \u2115\nh : \u2200 x \u2208 s, Irreducible x\n\u22a2 \u00acs.prod = 0"}, {"line": "rw [Multiset.prod_eq_zero_iff]", "tactic_state": "s : Multiset \u2115\nh : \u2200 x \u2208 s, Irreducible x\n\u22a2 0 \u2209 s"}, {"line": "exact fun con \u21a6 not_irreducible_zero (h 0 con)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_normalizedFactors_eq {a : \u03b1} (ane0 : a \u2260 0) :\n    (normalizedFactors a).prod = normalize a := by\n  trans normalize (normalizedFactors a).prod\n  \u00b7 rw [normalizedFactors, \u2190 map_multiset_prod, normalize_idem]\n  \u00b7 exact normalize_eq_normalize_iff.mpr (dvd_dvd_iff_associated.mpr (prod_normalizedFactors ane0))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/NormalizedFactors.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[UniqueFactorizationMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx\u271d : Sort u_2\nnormalizedFactors : x\u271d\na : \u03b1\nane0 : a \u2260 0\n\u22a2 sorry = normalize a"}, {"line": "trans normalize (normalizedFactors a).prod", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx\u271d : Sort u_2\nnormalizedFactors : x\u271d\na : \u03b1\nane0 : a \u2260 0\n\u22a2 sorry = sorry\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx\u271d : Sort u_2\nnormalizedFactors : x\u271d\na : \u03b1\nane0 : a \u2260 0\n\u22a2 sorry = normalize a"}, {"line": "\u00b7 rw [normalizedFactors, \u2190 map_multiset_prod, normalize_idem]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx\u271d : Sort u_2\nnormalizedFactors : x\u271d\na : \u03b1\nane0 : a \u2260 0\n\u22a2 sorry = normalize a"}, {"line": "\u00b7 exact normalize_eq_normalize_iff.mpr (dvd_dvd_iff_associated.mpr (prod_normalizedFactors ane0))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normalizedFactors_zero : normalizedFactors (0 : \u03b1) = 0 := by\n  simp [normalizedFactors, factors]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/UniqueFactorizationDomain/NormalizedFactors.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[UniqueFactorizationMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nnormalizedFactors : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [normalizedFactors, factors]", "tactic_state": "x\u271d : Sort u_2\nnormalizedFactors : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem isIntegral_of_mem_ringOfIntegers {x : L} (hx : x \u2208 integralClosure v.valuationSubring L) :\n    IsIntegral v.valuationSubring (\u27e8x, hx\u27e9 : integralClosure v.valuationSubring L) := by\n  obtain \u27e8P, hPm, hP\u27e9 := hx\n  refine \u27e8P, hPm, ?_\u27e9\n  rw [\u2190 Polynomial.aeval_def]\n  rw [\u2190 Subalgebra.coe_eq_zero]\n  rw [Polynomial.aeval_subalgebra_coe]\n  rw [Polynomial.aeval_def]\n  rw [Subtype.coe_mk]\n  rw [hP]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/AlgebraInstances.lean", "context": {"open": ["Function Valuation", "scoped Multiplicative"], "variables": ["{K : Type*} [Field K] (v : Valuation K \u2124\u2098\u2080) (L : Type*) [Field L] [Algebra K L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b2 : Field K\nv : Valuation K (WithZero (Multiplicative \u2124))\nL : Type u_2\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nhx : x \u2208 integralClosure (\u21a5v.valuationSubring) L\n\u22a2 IsIntegral \u21a5v.valuationSubring \u27e8x, hx\u27e9"}, {"line": "obtain \u27e8P, hPm, hP\u27e9 := hx", "tactic_state": "case intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\nv : Valuation K (WithZero (Multiplicative \u2124))\nL : Type u_2\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nP : Polynomial \u21a5v.valuationSubring\nhPm : P.Monic\nhP : Polynomial.eval\u2082 (algebraMap (\u21a5v.valuationSubring) L) x P = 0\n\u22a2 IsIntegral \u21a5v.valuationSubring \u27e8x, \u22ef\u27e9"}, {"line": "refine \u27e8P, hPm, ?_\u27e9", "tactic_state": "case intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\nv : Valuation K (WithZero (Multiplicative \u2124))\nL : Type u_2\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nP : Polynomial \u21a5v.valuationSubring\nhPm : P.Monic\nhP : Polynomial.eval\u2082 (algebraMap (\u21a5v.valuationSubring) L) x P = 0\n\u22a2 Polynomial.eval\u2082 (algebraMap \u21a5v.valuationSubring \u21a5(integralClosure (\u21a5v.valuationSubring) L)) \u27e8x, \u22ef\u27e9 P = 0"}, {"line": "rw [\u2190 Polynomial.aeval_def]", "tactic_state": "case intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\nv : Valuation K (WithZero (Multiplicative \u2124))\nL : Type u_2\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nP : Polynomial \u21a5v.valuationSubring\nhPm : P.Monic\nhP : Polynomial.eval\u2082 (algebraMap (\u21a5v.valuationSubring) L) x P = 0\n\u22a2 (Polynomial.aeval \u27e8x, \u22ef\u27e9) P = 0"}, {"line": "rw [\u2190 Subalgebra.coe_eq_zero]", "tactic_state": "case intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\nv : Valuation K (WithZero (Multiplicative \u2124))\nL : Type u_2\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nP : Polynomial \u21a5v.valuationSubring\nhPm : P.Monic\nhP : Polynomial.eval\u2082 (algebraMap (\u21a5v.valuationSubring) L) x P = 0\n\u22a2 \u2191((Polynomial.aeval \u27e8x, \u22ef\u27e9) P) = 0"}, {"line": "rw [Polynomial.aeval_subalgebra_coe]", "tactic_state": "case intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\nv : Valuation K (WithZero (Multiplicative \u2124))\nL : Type u_2\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nP : Polynomial \u21a5v.valuationSubring\nhPm : P.Monic\nhP : Polynomial.eval\u2082 (algebraMap (\u21a5v.valuationSubring) L) x P = 0\n\u22a2 (Polynomial.aeval \u2191\u27e8x, \u22ef\u27e9) P = 0"}, {"line": "rw [Polynomial.aeval_def]", "tactic_state": "case intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\nv : Valuation K (WithZero (Multiplicative \u2124))\nL : Type u_2\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nP : Polynomial \u21a5v.valuationSubring\nhPm : P.Monic\nhP : Polynomial.eval\u2082 (algebraMap (\u21a5v.valuationSubring) L) x P = 0\n\u22a2 Polynomial.eval\u2082 (algebraMap (\u21a5v.valuationSubring) L) (\u2191\u27e8x, \u22ef\u27e9) P = 0"}, {"line": "rw [Subtype.coe_mk]", "tactic_state": "case intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\nv : Valuation K (WithZero (Multiplicative \u2124))\nL : Type u_2\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nP : Polynomial \u21a5v.valuationSubring\nhPm : P.Monic\nhP : Polynomial.eval\u2082 (algebraMap (\u21a5v.valuationSubring) L) x P = 0\n\u22a2 Polynomial.eval\u2082 (algebraMap (\u21a5v.valuationSubring) L) x P = 0"}, {"line": "rw [hP]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIntegral_of_mem_ringOfIntegers' {x : (integralClosure v.valuationSubring L)} :\n    IsIntegral v.valuationSubring (x : integralClosure v.valuationSubring L) := by\n  apply isIntegral_of_mem_ringOfIntegers\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/AlgebraInstances.lean", "context": {"open": ["Function Valuation", "scoped Multiplicative"], "variables": ["{K : Type*} [Field K] (v : Valuation K \u2124\u2098\u2080) (L : Type*) [Field L] [Algebra K L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b2 : Field K\nv : Valuation K (WithZero (Multiplicative \u2124))\nL : Type u_2\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : \u21a5(integralClosure (\u21a5v.valuationSubring) L)\n\u22a2 IsIntegral (\u21a5v.valuationSubring) x"}, {"line": "apply isIntegral_of_mem_ringOfIntegers", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff]\n  rw [\u2190 ge_iff_le]\n  apply v.map_add\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : Ring R\n\u0393\u2080 : Type u_5\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\n\u22a2 \u2200 (x y : R), v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y"}, {"line": "intro x y", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : Ring R\n\u0393\u2080 : Type u_5\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y : R\n\u22a2 v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y"}, {"line": "rw [\u2190 le_max_iff]", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : Ring R\n\u0393\u2080 : Type u_5\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y : R\n\u22a2 v (x + y) \u2264 max (v x) (v y)"}, {"line": "rw [\u2190 ge_iff_le]", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : Ring R\n\u0393\u2080 : Type u_5\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y : R\n\u22a2 max (v x) (v y) \u2265 v (x + y)"}, {"line": "apply v.map_add", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b2 : DivisionRing K\n\u0393\u2080 : Type u_5\ninst\u271d\u00b9 : LinearOrderedCommMonoidWithZero \u0393\u2080\ninst\u271d : Nontrivial \u0393\u2080\nv : Valuation K \u0393\u2080\nx : K\nhx : IsUnit x\n\u22a2 v x \u2260 0"}, {"line": "simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx <| (v.map_neg y).trans_le hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : Ring R\n\u0393\u2080 : Type u_5\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y : R\ng : \u0393\u2080\nhx : v x \u2264 g\nhy : v y \u2264 g\n\u22a2 v (x - y) \u2264 g"}, {"line": "rw [sub_eq_add_neg]", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : Ring R\n\u0393\u2080 : Type u_5\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y : R\ng : \u0393\u2080\nhx : v x \u2264 g\nhy : v y \u2264 g\n\u22a2 v (x + -y) \u2264 g"}, {"line": "exact v.map_add_le hx <| (v.map_neg y).trans_le hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_sub_lt {x y : R} {g : \u0393\u2080} (hx : v x < g) (hy : v y < g) : v (x - y) < g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_lt hx <| (v.map_neg y).trans_lt hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : Ring R\n\u0393\u2080 : Type u_5\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y : R\ng : \u0393\u2080\nhx : v x < g\nhy : v y < g\n\u22a2 v (x - y) < g"}, {"line": "rw [sub_eq_add_neg]", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : Ring R\n\u0393\u2080 : Type u_5\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y : R\ng : \u0393\u2080\nhx : v x < g\nhy : v y < g\n\u22a2 v (x + -y) < g"}, {"line": "exact v.map_add_lt hx <| (v.map_neg y).trans_lt hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal", "scoped Classical in"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)", "{x y : R}", "[LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\nv : sorry\nx : K\nh : x \u2260 sorry\n\u22a2 1 < sorry \u2194 sorry < 1"}, {"line": "simp [inv_lt_one\u2080 (v.pos_iff.2 h)]", "tactic_state": "K : Type u_5\nv : sorry\nx : K\nh : x \u2260 sorry\n\u22a2 1 < sorry () \u2194 sorry () = 0"}]}
{"declaration": "theorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal", "scoped Classical in"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)", "{x y : R}", "[LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\nv : sorry\nx : K\nh : x \u2260 sorry\n\u22a2 1 \u2264 sorry \u2194 sorry \u2264 1"}, {"line": "simp [inv_le_one\u2080 (v.pos_iff.2 h)]", "tactic_state": "K : Type u_5\nv : sorry\nx : K\nh : x \u2260 sorry\n\u22a2 1 \u2264 sorry () \u2194 sorry () \u2264 1"}]}
{"declaration": "theorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal", "scoped Classical in"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)", "{x y : R}", "[LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\nv : sorry\nx : K\nh : x \u2260 sorry\n\u22a2 sorry < 1 \u2194 1 < sorry"}, {"line": "simp [one_lt_inv\u2080 (v.pos_iff.2 h)]", "tactic_state": "K : Type u_5\nv : sorry\nx : K\nh : x \u2260 sorry\n\u22a2 sorry () = 0 \u2194 1 < sorry ()"}]}
{"declaration": "theorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal", "scoped Classical in"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)", "{x y : R}", "[LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\nv : sorry\nx : K\nh : x \u2260 sorry\n\u22a2 sorry \u2264 1 \u2194 1 \u2264 sorry"}, {"line": "simp [one_le_inv\u2080 (v.pos_iff.2 h)]", "tactic_state": "K : Type u_5\nv : sorry\nx : K\nh : x \u2260 sorry\n\u22a2 sorry () \u2264 1 \u2194 1 \u2264 sorry ()"}]}
{"declaration": "theorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff,And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal", "scoped Classical in"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)", "{x y : R}", "[LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\nv : sorry\nx : K\n\u22a2 sorry = 1 \u2194 sorry = 1"}, {"line": "by_cases h : x = 0", "tactic_state": "K : Type u_5\nv : sorry\nx : K\n\u22a2 OfNat K 0\n---\ncase pos\nK : Type u_5\nv : sorry\nx : K\nh : x = 0\n\u22a2 sorry = 1 \u2194 sorry = 1\n---\ncase neg\nK : Type u_5\nv : sorry\nx : K\nh : \u00acx = 0\n\u22a2 sorry = 1 \u2194 sorry = 1"}, {"line": "\u00b7 simp only [map_inv\u2080, inv_eq_one]", "tactic_state": "case pos\nK : Type u_5\nv : sorry\nx : K\nh : x = 0\n\u22a2 sorry = 1 \u2194 sorry = 1\n---\ncase neg\nK : Type u_5\nv : sorry\nx : K\nh : \u00acx = 0\n\u22a2 sorry = 1 \u2194 sorry = 1"}, {"line": "\u00b7 simpa only [le_antisymm_iff,And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)", "tactic_state": "case neg\nK : Type u_5\nv : sorry\nx : K\nh : \u00acx = 0\n\u22a2 sorry = 1 \u2194 sorry = 1"}]}
{"declaration": "theorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal", "scoped Classical in"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)", "{x y : R}", "[LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\nv : sorry\nx : K\n\u22a2 sorry \u2264 1 \u2228 sorry < 1"}, {"line": "by_cases h : x = 0", "tactic_state": "K : Type u_5\nv : sorry\nx : K\n\u22a2 OfNat K 0\n---\ncase pos\nK : Type u_5\nv : sorry\nx : K\nh : x = 0\n\u22a2 sorry \u2264 1 \u2228 sorry < 1\n---\ncase neg\nK : Type u_5\nv : sorry\nx : K\nh : \u00acx = 0\n\u22a2 sorry \u2264 1 \u2228 sorry < 1"}, {"line": "\u00b7 simp only [h, map_zero, zero_le', inv_zero, zero_lt_one, or_self]", "tactic_state": "case pos\nK : Type u_5\nv : sorry\nx : K\nh : x = 0\n\u22a2 sorry \u2264 1 \u2228 sorry < 1\n---\ncase neg\nK : Type u_5\nv : sorry\nx : K\nh : \u00acx = 0\n\u22a2 sorry \u2264 1 \u2228 sorry < 1"}, {"line": "\u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]", "tactic_state": "case neg\nK : Type u_5\nv : sorry\nx : K\nh : \u00acx = 0\n\u22a2 sorry \u2264 1 \u2228 sorry < 1"}]}
{"declaration": "theorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Basic.lean", "context": {"open": ["Function Ideal", "scoped Classical in"], "variables": ["{K F R : Type*} [DivisionRing K]", "(F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]", "{\u0393\u2080 : Type*}", "{\u0393'\u2080 : Type*}", "{\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]", "[Ring R]", "[LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]", "(v : Valuation R \u0393\u2080)", "{x y : R}", "[LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\nv : sorry\nx : K\n\u22a2 sorry \u2264 1 \u2228 sorry \u2264 1"}, {"line": "by_cases h : x = 0", "tactic_state": "K : Type u_5\nv : sorry\nx : K\n\u22a2 OfNat K 0\n---\ncase pos\nK : Type u_5\nv : sorry\nx : K\nh : x = 0\n\u22a2 sorry \u2264 1 \u2228 sorry \u2264 1\n---\ncase neg\nK : Type u_5\nv : sorry\nx : K\nh : \u00acx = 0\n\u22a2 sorry \u2264 1 \u2228 sorry \u2264 1"}, {"line": "\u00b7 simp only [h, map_zero, zero_le', inv_zero, or_self]", "tactic_state": "case pos\nK : Type u_5\nv : sorry\nx : K\nh : x = 0\n\u22a2 sorry \u2264 1 \u2228 sorry \u2264 1\n---\ncase neg\nK : Type u_5\nv : sorry\nx : K\nh : \u00acx = 0\n\u22a2 sorry \u2264 1 \u2228 sorry \u2264 1"}, {"line": "\u00b7 simp only [\u2190 one_le_val_iff v h, le_total]", "tactic_state": "case neg\nK : Type u_5\nv : sorry\nx : K\nh : \u00acx = 0\n\u22a2 sorry \u2264 1 \u2228 sorry \u2264 1"}]}
{"declaration": "lemma mem_integer_iff (r : R) : r \u2208 v.integer \u2194 v r \u2264 1 := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Integers.lean", "context": {"open": ["Set"], "variables": ["{R : Type u} {\u0393\u2080 : Type v} [Ring R] [LinearOrderedCommGroupWithZero \u0393\u2080]", "(v : Valuation R \u0393\u2080)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u0393\u2080 : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nr : R\n\u22a2 r \u2208 v.integer \u2194 v r \u2264 1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma valuation_pos_iff_ne_zero (hv : Integers v O) {x : O} :\n    0 < v (algebraMap O F x) \u2194 x \u2260 0 := by\n  rw [\u2190 not_le]\n  refine not_congr ?_\n  simp [map_eq_zero_iff _ hv.hom_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/Integers.lean", "context": {"open": ["Set"], "variables": ["{R : Type u} {\u0393\u2080 : Type v} [Ring R] [LinearOrderedCommGroupWithZero \u0393\u2080]", "(v : Valuation R \u0393\u2080)", "{R : Type u} {\u0393\u2080 : Type v} [CommRing R] [LinearOrderedCommGroupWithZero \u0393\u2080]", "(v : Valuation R \u0393\u2080)", "(O : Type w) [CommRing O] [Algebra O R]", "{v O}", "{F : Type u} {\u0393\u2080 : Type v} [Field F] [LinearOrderedCommGroupWithZero \u0393\u2080]", "{v : Valuation F \u0393\u2080} {O : Type w} [CommRing O] [Algebra O F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\n\u0393\u2080 : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation F \u0393\u2080\nO : Type w\ninst\u271d\u00b9 : CommRing O\ninst\u271d : Algebra O F\nx\u271d : Sort u_1\nIntegers : x\u271d\nhv : sorry\nx : O\n\u22a2 0 < v ((algebraMap O F) x) \u2194 x \u2260 0"}, {"line": "rw [\u2190 not_le]", "tactic_state": "F : Type u\n\u0393\u2080 : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation F \u0393\u2080\nO : Type w\ninst\u271d\u00b9 : CommRing O\ninst\u271d : Algebra O F\nx\u271d : Sort u_1\nIntegers : x\u271d\nhv : sorry\nx : O\n\u22a2 \u00acv ((algebraMap O F) x) \u2264 0 \u2194 x \u2260 0"}, {"line": "refine not_congr ?_", "tactic_state": "F : Type u\n\u0393\u2080 : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation F \u0393\u2080\nO : Type w\ninst\u271d\u00b9 : CommRing O\ninst\u271d : Algebra O F\nx\u271d : Sort u_1\nIntegers : x\u271d\nhv : sorry\nx : O\n\u22a2 v ((algebraMap O F) x) \u2264 0 \u2194 x = 0"}, {"line": "simp [map_eq_zero_iff _ hv.hom_inj]", "tactic_state": "F : Type u\n\u0393\u2080 : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation F \u0393\u2080\nO : Type w\ninst\u271d\u00b9 : CommRing O\ninst\u271d : Algebra O F\nx\u271d : Sort u_1\nIntegers : x\u271d\nhv : sorry\nx : O\n\u22a2 v ((algebraMap O F) x) = 0 \u2194 x = 0"}]}
{"declaration": "theorem val_map_le_one_iff (x : R) : vA (algebraMap R A x) \u2264 1 \u2194 vR x \u2264 1 := by\n  simpa only [map_one] using val_map_le_iff vR vA x 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/ValExtension.lean", "context": {"open": ["Valuation"], "variables": ["{R A \u0393R \u0393A : Type*} [CommRing R] [Ring A]", "[IsValExtension vR vA]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u271d\u00b9 : Sort u_5\nvA : x\u271d\u00b9\nx\u271d : Sort u_6\nvR : x\u271d\nx : R\n\u22a2 sorry \u2264 1 \u2194 sorry \u2264 1"}, {"line": "simpa only [map_one] using val_map_le_iff vR vA x 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_map_lt_one_iff (x : R) : vA (algebraMap R A x) < 1 \u2194 vR x < 1 := by\n  simpa only [map_one,not_le] using (val_map_le_iff vR vA 1 x).not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/ValExtension.lean", "context": {"open": ["Valuation"], "variables": ["{R A \u0393R \u0393A : Type*} [CommRing R] [Ring A]", "[IsValExtension vR vA]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u271d\u00b9 : Sort u_5\nvA : x\u271d\u00b9\nx\u271d : Sort u_6\nvR : x\u271d\nx : R\n\u22a2 sorry < 1 \u2194 sorry < 1"}, {"line": "simpa only [map_one,not_le] using (val_map_le_iff vR vA 1 x).not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_map_eq_one_iff (x : R) : vA (algebraMap R A x) = 1 \u2194 vR x = 1 := by\n  simpa only [le_antisymm_iff,map_one] using\n    and_congr (val_map_le_iff vR vA x 1) (val_map_le_iff vR vA 1 x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/ValExtension.lean", "context": {"open": ["Valuation"], "variables": ["{R A \u0393R \u0393A : Type*} [CommRing R] [Ring A]", "[IsValExtension vR vA]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u271d\u00b9 : Sort u_5\nvA : x\u271d\u00b9\nx\u271d : Sort u_6\nvR : x\u271d\nx : R\n\u22a2 sorry = 1 \u2194 sorry = 1"}, {"line": "simpa only [le_antisymm_iff,map_one] using\n    and_congr (val_map_le_iff vR vA x 1) (val_map_le_iff vR vA 1 x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_algebraMap (r : vR.integer) :\n    ((algebraMap vR.integer vA.integer) r : A) = (algebraMap R A) (r : R) := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Valuation/ValExtension.lean", "context": {"open": ["Valuation"], "variables": ["{R A \u0393R \u0393A : Type*} [CommRing R] [Ring A]", "[IsValExtension vR vA]", "{K : Type*} [Field K] [Algebra K A] {\u0393R \u0393A \u0393K : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d : Ring A\nr : sorry\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zmodEquivTrunc_compat (k\u2081 k\u2082 : \u2115) (hk : k\u2081 \u2264 k\u2082) :\n    (TruncatedWittVector.truncate hk).comp\n        ((zmodEquivTrunc p k\u2082).toRingHom.comp (PadicInt.toZModPow k\u2082)) =\n      (zmodEquivTrunc p k\u2081).toRingHom.comp (PadicInt.toZModPow k\u2081) := by\n  rw [\u2190 RingHom.comp_assoc]\n  rw [commutes]\n  rw [RingHom.comp_assoc]\n  rw [PadicInt.zmod_cast_comp_toZModPow _ _ hk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Compare.lean", "context": {"open": ["TruncatedWittVector"], "variables": ["{p : \u2115} [hp : Fact p.Prime]", "(p) (n : \u2115) (R : Type*) [CommRing R]", "{R}", "(p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk\u2081 k\u2082 : \u2115\nhk : k\u2081 \u2264 k\u2082\n\u22a2 (truncate hk).comp ((zmodEquivTrunc p k\u2082).toRingHom.comp (PadicInt.toZModPow k\u2082)) =\n    (zmodEquivTrunc p k\u2081).toRingHom.comp (PadicInt.toZModPow k\u2081)"}, {"line": "rw [\u2190 RingHom.comp_assoc]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk\u2081 k\u2082 : \u2115\nhk : k\u2081 \u2264 k\u2082\n\u22a2 ((truncate hk).comp (zmodEquivTrunc p k\u2082).toRingHom).comp (PadicInt.toZModPow k\u2082) =\n    (zmodEquivTrunc p k\u2081).toRingHom.comp (PadicInt.toZModPow k\u2081)"}, {"line": "rw [commutes]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk\u2081 k\u2082 : \u2115\nhk : k\u2081 \u2264 k\u2082\n\u22a2 ((zmodEquivTrunc p k\u2081).toRingHom.comp (ZMod.castHom \u22ef (ZMod (p ^ k\u2081)))).comp (PadicInt.toZModPow k\u2082) =\n    (zmodEquivTrunc p k\u2081).toRingHom.comp (PadicInt.toZModPow k\u2081)"}, {"line": "rw [RingHom.comp_assoc]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk\u2081 k\u2082 : \u2115\nhk : k\u2081 \u2264 k\u2082\n\u22a2 (zmodEquivTrunc p k\u2081).toRingHom.comp ((ZMod.castHom \u22ef (ZMod (p ^ k\u2081))).comp (PadicInt.toZModPow k\u2082)) =\n    (zmodEquivTrunc p k\u2081).toRingHom.comp (PadicInt.toZModPow k\u2081)"}, {"line": "rw [PadicInt.zmod_cast_comp_toZModPow _ _ hk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem v2_coeff {p' R'} (x y : WittVector p' R') (i : Fin 2) :\n    (![x, y] i).coeff = ![x.coeff, y.coeff] i := by fin_cases i <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p' : \u2115\nR' : Type u_2\nx y : WittVector p' R'\ni : Fin 2\n\u22a2 (![x, y] i).coeff = ![x.coeff, y.coeff] i"}, {"line": "fin_cases i <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_coeff (x y : \ud835\udd4e R) (n : \u2115) :\n    (x + y).coeff n = peval (wittAdd p n) ![x.coeff, y.coeff] := by\n  simp [(\u00b7 + \u00b7), Add.add, eval, coeff_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nx : sorry\ny : sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp [(\u00b7 + \u00b7), Add.add, eval, coeff_mk]", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nx : sorry\ny : sorry\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem sub_coeff (x y : \ud835\udd4e R) (n : \u2115) :\n    (x - y).coeff n = peval (wittSub p n) ![x.coeff, y.coeff] := by\n  simp [(\u00b7 - \u00b7), Sub.sub, eval, coeff_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nx : sorry\ny : sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp [(\u00b7 - \u00b7), Sub.sub, eval, coeff_mk]", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nx : sorry\ny : sorry\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem mul_coeff (x y : \ud835\udd4e R) (n : \u2115) :\n    (x * y).coeff n = peval (wittMul p n) ![x.coeff, y.coeff] := by\n  simp [(\u00b7 * \u00b7), Mul.mul, eval, coeff_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nx : sorry\ny : sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp [(\u00b7 * \u00b7), Mul.mul, eval, coeff_mk]", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nx : sorry\ny : sorry\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem neg_coeff (x : \ud835\udd4e R) (n : \u2115) : (-x).coeff n = peval (wittNeg p n) ![x.coeff] := by\n  simp [Neg.neg, eval, Matrix.cons_fin_one, coeff_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nx : sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp [Neg.neg, eval, Matrix.cons_fin_one, coeff_mk]", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nx : sorry\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem nsmul_coeff (m : \u2115) (x : \ud835\udd4e R) (n : \u2115) :\n    (m \u2022 x).coeff n = peval (wittNSMul p m n) ![x.coeff] := by\n  simp [(\u00b7 \u2022 \u00b7), SMul.smul, eval, Matrix.cons_fin_one, coeff_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nm : \u2115\nx : sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp [(\u00b7 \u2022 \u00b7), SMul.smul, eval, Matrix.cons_fin_one, coeff_mk]", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nm : \u2115\nx : sorry\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem zsmul_coeff (m : \u2124) (x : \ud835\udd4e R) (n : \u2115) :\n    (m \u2022 x).coeff n = peval (wittZSMul p m n) ![x.coeff] := by\n  simp [(\u00b7 \u2022 \u00b7), SMul.smul, eval, Matrix.cons_fin_one, coeff_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nm : \u2124\nx : sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp [(\u00b7 \u2022 \u00b7), SMul.smul, eval, Matrix.cons_fin_one, coeff_mk]", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nm : \u2124\nx : sorry\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem pow_coeff (m : \u2115) (x : \ud835\udd4e R) (n : \u2115) :\n    (x ^ m).coeff n = peval (wittPow p m n) ![x.coeff] := by\n  simp [(\u00b7 ^ \u00b7), Pow.pow, eval, Matrix.cons_fin_one, coeff_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nm : \u2115\nx : sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp [(\u00b7 ^ \u00b7), Pow.pow, eval, Matrix.cons_fin_one, coeff_mk]", "tactic_state": "x\u271d\u00b9 : Sort u_2\n\ud835\udd4e : x\u271d\u00b9\nx\u271d : Sort u_3\npeval : x\u271d\nm : \u2115\nx : sorry\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem add_coeff_zero (x y : \ud835\udd4e R) : (x + y).coeff 0 = x.coeff 0 + y.coeff 0 := by\n  simp [add_coeff, peval, Function.uncurry]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\n\ud835\udd4e : x\u271d\nx : sorry\ny : sorry\n\u22a2 sorry = sorry + sorry"}, {"line": "simp [add_coeff, peval, Function.uncurry]", "tactic_state": "x\u271d : Sort u_2\n\ud835\udd4e : x\u271d\nx : sorry\ny : sorry\n\u22a2 sorry () = sorry () + sorry ()"}]}
{"declaration": "theorem mul_coeff_zero (x y : \ud835\udd4e R) : (x * y).coeff 0 = x.coeff 0 * y.coeff 0 := by\n  simp [mul_coeff, peval, Function.uncurry]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Defs.lean", "context": {"open": ["MvPolynomial"], "variables": ["{p : \u2115}", "{R : Type*}", "(p)", "[hp : Fact p.Prime] [CommRing R]", "{p}", "(R)", "{p R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\n\ud835\udd4e : x\u271d\nx : sorry\ny : sorry\n\u22a2 sorry = sorry * sorry"}, {"line": "simp [mul_coeff, peval, Function.uncurry]", "tactic_state": "x\u271d : Sort u_2\n\ud835\udd4e : x\u271d\nx : sorry\ny : sorry\n\u22a2 sorry () = sorry () * sorry ()"}]}
{"declaration": "theorem map_frobeniusPoly.key\u2081 (n j : \u2115) (hj : j < p ^ n) :\n    p ^ (n - v p (j + 1)) \u2223 (p ^ n).choose (j + 1) := by\n  apply pow_dvd_of_le_emultiplicity\n  rw [hp.out.emultiplicity_choose_prime_pow hj j.succ_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Frobenius.lean", "context": {"open": ["MvPolynomial Finset"], "variables": ["{p : \u2115} {R : Type*} [hp : Fact p.Prime] [CommRing R]", "(p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx\u271d : Sort u_2\nv : x\u271d\nn j : \u2115\nhj : j < p ^ n\n\u22a2 p ^ (n - sorry) \u2223 (p ^ n).choose (j + 1)"}, {"line": "apply pow_dvd_of_le_emultiplicity", "tactic_state": "case hk\np : \u2115\nhp : Fact (Nat.Prime p)\nx\u271d : Sort u_2\nv : x\u271d\nn j : \u2115\nhj : j < p ^ n\n\u22a2 \u2191(n - sorry) \u2264 emultiplicity p ((p ^ n).choose (j + 1))"}, {"line": "rw [hp.out.emultiplicity_choose_prime_pow hj j.succ_ne_zero]", "tactic_state": "case hk\np : \u2115\nhp : Fact (Nat.Prime p)\nx\u271d : Sort u_2\nv : x\u271d\nn j : \u2115\nhj : j < p ^ n\n\u22a2 \u2191(n - sorry) \u2264 \u2191(n - multiplicity p j.succ)"}]}
{"declaration": "theorem coeff_p_pow [CharP R p] (i : \u2115) : ((p : \ud835\udd4e R) ^ i).coeff i = 1 := by\n  induction' i with i h\n  \u00b7 simp only [one_coeff_zero, Ne, pow_zero]\n  \u00b7 rw [pow_succ, \u2190 frobenius_verschiebung, coeff_frobenius_charP,\n      verschiebung_coeff_succ, h, one_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Identities.lean", "context": {"open": [], "variables": ["{p : \u2115} {R : Type*} [hp : Fact p.Prime] [CommRing R]", "(p R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d : CharP R p\ni : \u2115\n\u22a2 sorry = 1"}, {"line": "induction' i with i h", "tactic_state": "case zero\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d : CharP R p\n\u22a2 sorry = 1\n---\ncase succ\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d : CharP R p\ni : \u2115\nh : sorry = 1\n\u22a2 sorry = 1"}, {"line": "\u00b7 simp only [one_coeff_zero, Ne, pow_zero]", "tactic_state": "case succ\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d : CharP R p\ni : \u2115\nh : sorry = 1\n\u22a2 sorry = 1"}, {"line": "\u00b7 rw [pow_succ, \u2190 frobenius_verschiebung, coeff_frobenius_charP,\n      verschiebung_coeff_succ, h, one_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_p [CharP R p] (i : \u2115) : (p : \ud835\udd4e R).coeff i = if i = 1 then 1 else 0 := by\n  split_ifs with hi\n  \u00b7 simpa only [hi,pow_one] using coeff_p_pow p R 1\n  \u00b7 simpa only [pow_one] using coeff_p_pow_eq_zero p R hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Identities.lean", "context": {"open": [], "variables": ["{p : \u2115} {R : Type*} [hp : Fact p.Prime] [CommRing R]", "(p R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d : CharP R p\ni : \u2115\n\u22a2 sorry = if i = 1 then 1 else 0"}, {"line": "split_ifs with hi", "tactic_state": "case pos\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d : CharP R p\ni : \u2115\nhi : i = 1\n\u22a2 sorry = 1\n---\ncase neg\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d : CharP R p\ni : \u2115\nhi : \u00aci = 1\n\u22a2 sorry = 0"}, {"line": "\u00b7 simpa only [hi,pow_one] using coeff_p_pow p R 1", "tactic_state": "case neg\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d : CharP R p\ni : \u2115\nhi : \u00aci = 1\n\u22a2 sorry = 0"}, {"line": "\u00b7 simpa only [pow_one] using coeff_p_pow_eq_zero p R hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem p_nonzero [Nontrivial R] [CharP R p] : (p : \ud835\udd4e R) \u2260 0 := by\n  intro h\n  simpa only [h,zero_coeff,zero_ne_one] using coeff_p_one p R\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/Identities.lean", "context": {"open": [], "variables": ["{p : \u2115} {R : Type*} [hp : Fact p.Prime] [CommRing R]", "(p R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b2 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharP R p\n\u22a2 p \u2260 0"}, {"line": "intro h", "tactic_state": "p : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b2 : CommRing R\nx\u271d : Sort u_2\n\ud835\udd4e : x\u271d\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharP R p\nh : p = 0\n\u22a2 False"}, {"line": "simpa only [h,zero_coeff,zero_ne_one] using coeff_p_one p R", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bind\u2081_onePoly_wittPolynomial [hp : Fact p.Prime] (n : \u2115) :\n    bind\u2081 onePoly (wittPolynomial p \u2124 n) = 1 := by\n  rw [wittPolynomial_eq_sum_C_mul_X_pow]\n  rw [map_sum]\n  rw [Finset.sum_eq_single 0]\n  \u00b7 simp only [onePoly, one_pow, one_mul, map_pow, C_1, pow_zero, bind\u2081_X_right, if_true,\n      eq_self_iff_true]\n  \u00b7 intro i _hi hi0\n    simp only [onePoly]\n    simp only [if_neg hi0]\n    simp only [zero_pow (pow_ne_zero _ hp.1.ne_zero)]\n    simp only [mul_zero]\n    simp only [map_pow]\n    simp only [bind\u2081_X_right]\n    simp only [map_mul]\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/IsPoly.lean", "context": {"open": ["MvPolynomial", "Function (uncurry)"], "variables": ["{p : \u2115} {R S : Type u} {idx : Type*} [CommRing R] [CommRing S]", "(p)", "{p}", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\n\u03c3\u271d : Type u_2\nonePoly : \u2115 \u2192 MvPolynomial \u03c3\u271d \u2124\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 (bind\u2081 onePoly) (wittPolynomial p \u2124 n) = 1"}, {"line": "rw [wittPolynomial_eq_sum_C_mul_X_pow]", "tactic_state": "p : \u2115\n\u03c3\u271d : Type u_2\nonePoly : \u2115 \u2192 MvPolynomial \u03c3\u271d \u2124\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 (bind\u2081 onePoly) (\u2211 i \u2208 Finset.range (n + 1), C (\u2191p ^ i) * X i ^ p ^ (n - i)) = 1"}, {"line": "rw [map_sum]", "tactic_state": "p : \u2115\n\u03c3\u271d : Type u_2\nonePoly : \u2115 \u2192 MvPolynomial \u03c3\u271d \u2124\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 \u2211 x \u2208 Finset.range (n + 1), (bind\u2081 onePoly) (C (\u2191p ^ x) * X x ^ p ^ (n - x)) = 1"}, {"line": "rw [Finset.sum_eq_single 0]", "tactic_state": "p : \u2115\n\u03c3\u271d : Type u_2\nonePoly : \u2115 \u2192 MvPolynomial \u03c3\u271d \u2124\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 (bind\u2081 onePoly) (C (\u2191p ^ 0) * X 0 ^ p ^ (n - 0)) = 1\n---\ncase h\u2080\np : \u2115\n\u03c3\u271d : Type u_2\nonePoly : \u2115 \u2192 MvPolynomial \u03c3\u271d \u2124\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 \u2200 b \u2208 Finset.range (n + 1), b \u2260 0 \u2192 (bind\u2081 onePoly) (C (\u2191p ^ b) * X b ^ p ^ (n - b)) = 0\n---\ncase h\u2081\np : \u2115\n\u03c3\u271d : Type u_2\nonePoly : \u2115 \u2192 MvPolynomial \u03c3\u271d \u2124\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 0 \u2209 Finset.range (n + 1) \u2192 (bind\u2081 onePoly) (C (\u2191p ^ 0) * X 0 ^ p ^ (n - 0)) = 0"}, {"line": "\u00b7 simp only [onePoly, one_pow, one_mul, map_pow, C_1, pow_zero, bind\u2081_X_right, if_true,\n      eq_self_iff_true]", "tactic_state": "case h\u2080\np : \u2115\n\u03c3\u271d : Type u_2\nonePoly : \u2115 \u2192 MvPolynomial \u03c3\u271d \u2124\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 \u2200 b \u2208 Finset.range (n + 1), b \u2260 0 \u2192 (bind\u2081 onePoly) (C (\u2191p ^ b) * X b ^ p ^ (n - b)) = 0\n---\ncase h\u2081\np : \u2115\n\u03c3\u271d : Type u_2\nonePoly : \u2115 \u2192 MvPolynomial \u03c3\u271d \u2124\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 0 \u2209 Finset.range (n + 1) \u2192 (bind\u2081 onePoly) (C (\u2191p ^ 0) * X 0 ^ p ^ (n - 0)) = 0"}, {"line": "\u00b7 intro i _hi hi0\n    simp only [onePoly]\n    simp only [if_neg hi0]\n    simp only [zero_pow (pow_ne_zero _ hp.1.ne_zero)]\n    simp only [mul_zero]\n    simp only [map_pow]\n    simp only [bind\u2081_X_right]\n    simp only [map_mul]", "tactic_state": "case h\u2081\np : \u2115\n\u03c3\u271d : Type u_2\nonePoly : \u2115 \u2192 MvPolynomial \u03c3\u271d \u2124\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 0 \u2209 Finset.range (n + 1) \u2192 (bind\u2081 onePoly) (C (\u2191p ^ 0) * X 0 ^ p ^ (n - 0)) = 0"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem constantCoeff_wittStructureInt_zero (\u03a6 : MvPolynomial idx \u2124) :\n    constantCoeff (wittStructureInt p \u03a6 0) = constantCoeff \u03a6 := by\n  have inj : Function.Injective (Int.castRingHom \u211a) := by intro m n; exact Int.cast_inj.mp\n  apply inj\n  rw [\u2190 constantCoeff_map]\n  rw [map_wittStructureInt]\n  rw [constantCoeff_wittStructureRat_zero]\n  rw [constantCoeff_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/StructurePolynomial.lean", "context": {"open": ["MvPolynomial Set", "Finset (range)", "Finsupp (single)", "scoped Witt"], "variables": ["{p : \u2115} {R : Type*} {idx : Type*} [CommRing R]", "(p)", "[hp : Fact p.Prime]", "{p}", "(p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\n\u22a2 constantCoeff (wittStructureInt p \u03a6 0) = constantCoeff \u03a6"}, {"line": "have inj : Function.Injective (Int.castRingHom \u211a) := sorry", "tactic_state": "p : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 constantCoeff (wittStructureInt p \u03a6 0) = constantCoeff \u03a6"}, {"line": "apply inj", "tactic_state": "case a\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 (Int.castRingHom \u211a) (constantCoeff (wittStructureInt p \u03a6 0)) = (Int.castRingHom \u211a) (constantCoeff \u03a6)"}, {"line": "rw [\u2190 constantCoeff_map]", "tactic_state": "case a\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 constantCoeff ((map (Int.castRingHom \u211a)) (wittStructureInt p \u03a6 0)) = (Int.castRingHom \u211a) (constantCoeff \u03a6)"}, {"line": "rw [map_wittStructureInt]", "tactic_state": "case a\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 constantCoeff (wittStructureRat p ((map (Int.castRingHom \u211a)) \u03a6) 0) = (Int.castRingHom \u211a) (constantCoeff \u03a6)"}, {"line": "rw [constantCoeff_wittStructureRat_zero]", "tactic_state": "case a\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 constantCoeff ((map (Int.castRingHom \u211a)) \u03a6) = (Int.castRingHom \u211a) (constantCoeff \u03a6)"}, {"line": "rw [constantCoeff_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem constantCoeff_wittStructureInt (\u03a6 : MvPolynomial idx \u2124) (h : constantCoeff \u03a6 = 0) (n : \u2115) :\n    constantCoeff (wittStructureInt p \u03a6 n) = 0 := by\n  have inj : Function.Injective (Int.castRingHom \u211a) := by intro m n; exact Int.cast_inj.mp\n  apply inj\n  rw [\u2190 constantCoeff_map]\n  rw [map_wittStructureInt]\n  rw [constantCoeff_wittStructureRat]\n  rw [RingHom.map_zero]\n  rw [constantCoeff_map]\n  rw [h]\n  rw [RingHom.map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/StructurePolynomial.lean", "context": {"open": ["MvPolynomial Set", "Finset (range)", "Finsupp (single)", "scoped Witt"], "variables": ["{p : \u2115} {R : Type*} {idx : Type*} [CommRing R]", "(p)", "[hp : Fact p.Prime]", "{p}", "(p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\n\u22a2 constantCoeff (wittStructureInt p \u03a6 n) = 0"}, {"line": "have inj : Function.Injective (Int.castRingHom \u211a) := sorry", "tactic_state": "p : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 constantCoeff (wittStructureInt p \u03a6 n) = 0"}, {"line": "apply inj", "tactic_state": "case a\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 (Int.castRingHom \u211a) (constantCoeff (wittStructureInt p \u03a6 n)) = (Int.castRingHom \u211a) 0"}, {"line": "rw [\u2190 constantCoeff_map]", "tactic_state": "case a\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 constantCoeff ((map (Int.castRingHom \u211a)) (wittStructureInt p \u03a6 n)) = (Int.castRingHom \u211a) 0"}, {"line": "rw [map_wittStructureInt]", "tactic_state": "case a\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 constantCoeff (wittStructureRat p ((map (Int.castRingHom \u211a)) \u03a6) n) = (Int.castRingHom \u211a) 0"}, {"line": "rw [constantCoeff_wittStructureRat]", "tactic_state": "case a\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 0 = (Int.castRingHom \u211a) 0\n---\ncase a.h\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 constantCoeff ((map (Int.castRingHom \u211a)) \u03a6) = 0"}, {"line": "rw [RingHom.map_zero]", "tactic_state": "case a.h\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 constantCoeff ((map (Int.castRingHom \u211a)) \u03a6) = 0"}, {"line": "rw [constantCoeff_map]", "tactic_state": "case a.h\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 (Int.castRingHom \u211a) (constantCoeff \u03a6) = 0"}, {"line": "rw [h]", "tactic_state": "case a.h\np : \u2115\nidx : Type u_2\nhp : Fact (Nat.Prime p)\n\u03a6 : MvPolynomial idx \u2124\nh : constantCoeff \u03a6 = 0\nn : \u2115\ninj : Function.Injective \u21d1(Int.castRingHom \u211a)\n\u22a2 (Int.castRingHom \u211a) 0 = 0"}, {"line": "rw [RingHom.map_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem wittPolynomial_eq_sum_C_mul_X_pow (n : \u2115) :\n    wittPolynomial p R n = \u2211 i \u2208 range (n + 1), C ((p : R) ^ i) * X i ^ p ^ (n - i) := by\n  apply sum_congr rfl\n  rintro i -\n  rw [monomial_eq]\n  rw [Finsupp.prod_single_index]\n  rw [pow_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/WittPolynomial.lean", "context": {"open": ["MvPolynomial", "Finset hiding map", "Finsupp (single)"], "variables": ["(p : \u2115)", "(R : Type*) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\n\u22a2 wittPolynomial p R n = \u2211 i \u2208 range (n + 1), C (\u2191p ^ i) * X i ^ p ^ (n - i)"}, {"line": "apply sum_congr rfl", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\n\u22a2 \u2200 x \u2208 range (n + 1), (monomial fun\u2080 | x => p ^ (n - x)) (\u2191p ^ x) = C (\u2191p ^ x) * X x ^ p ^ (n - x)"}, {"line": "rintro i -", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nn i : \u2115\n\u22a2 (monomial fun\u2080 | i => p ^ (n - i)) (\u2191p ^ i) = C (\u2191p ^ i) * X i ^ p ^ (n - i)"}, {"line": "rw [monomial_eq]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nn i : \u2115\n\u22a2 (C (\u2191p ^ i) * (fun\u2080 | i => p ^ (n - i)).prod fun n e => X n ^ e) = C (\u2191p ^ i) * X i ^ p ^ (n - i)"}, {"line": "rw [Finsupp.prod_single_index]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nn i : \u2115\n\u22a2 X i ^ 0 = 1"}, {"line": "rw [pow_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem constantCoeff_wittPolynomial [hp : Fact p.Prime] (n : \u2115) :\n    constantCoeff (wittPolynomial p R n) = 0 := by\n  simp only [wittPolynomial]\n  simp only [map_sum]\n  simp only [constantCoeff_monomial]\n  rw [sum_eq_zero]\n  rintro i _\n  rw [if_neg]\n  rw [Finsupp.single_eq_zero]\n  exact ne_of_gt (pow_pos hp.1.pos _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/WittPolynomial.lean", "context": {"open": ["MvPolynomial", "Finset hiding map", "Finsupp (single)", "Witt", "MvPolynomial"], "variables": ["(p : \u2115)", "(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 constantCoeff (wittPolynomial p R n) = 0"}, {"line": "simp only [wittPolynomial]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 constantCoeff (\u2211 i \u2208 range (n + 1), (monomial fun\u2080 | i => p ^ (n - i)) (\u2191p ^ i)) = 0"}, {"line": "simp only [map_sum]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 \u2211 x \u2208 range (n + 1), constantCoeff ((monomial fun\u2080 | x => p ^ (n - x)) (\u2191p ^ x)) = 0"}, {"line": "simp only [constantCoeff_monomial]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 (\u2211 x \u2208 range (n + 1), if (fun\u2080 | x => p ^ (n - x)) = 0 then \u2191p ^ x else 0) = 0"}, {"line": "rw [sum_eq_zero]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 \u2200 x \u2208 range (n + 1), (if (fun\u2080 | x => p ^ (n - x)) = 0 then \u2191p ^ x else 0) = 0"}, {"line": "rintro i _", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nhp : Fact (Nat.Prime p)\nn i : \u2115\na\u271d : i \u2208 range (n + 1)\n\u22a2 (if (fun\u2080 | i => p ^ (n - i)) = 0 then \u2191p ^ i else 0) = 0"}, {"line": "rw [if_neg]", "tactic_state": "case hnc\np : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nhp : Fact (Nat.Prime p)\nn i : \u2115\na\u271d : i \u2208 range (n + 1)\n\u22a2 \u00ac(fun\u2080 | i => p ^ (n - i)) = 0"}, {"line": "rw [Finsupp.single_eq_zero]", "tactic_state": "case hnc\np : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nhp : Fact (Nat.Prime p)\nn i : \u2115\na\u271d : i \u2208 range (n + 1)\n\u22a2 \u00acp ^ (n - i) = 0"}, {"line": "exact ne_of_gt (pow_pos hp.1.pos _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aeval_wittPolynomial {A : Type*} [CommRing A] [Algebra R A] (f : \u2115 \u2192 A) (n : \u2115) :\n    aeval f (W_ R n) = \u2211 i \u2208 range (n + 1), (p : A) ^ i * f i ^ p ^ (n - i) := by\n  simp [wittPolynomial, map_sum, aeval_monomial, Finsupp.prod_single_index]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/WittPolynomial.lean", "context": {"open": ["MvPolynomial", "Finset hiding map", "Finsupp (single)", "Witt", "MvPolynomial"], "variables": ["(p : \u2115)", "(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nf : \u2115 \u2192 A\nn : \u2115\n\u22a2 (aeval f) sorry = \u2211 i \u2208 range (n + 1), \u2191p ^ i * f i ^ p ^ (n - i)"}, {"line": "simp [wittPolynomial, map_sum, aeval_monomial, Finsupp.prod_single_index]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nf : \u2115 \u2192 A\nn : \u2115\n\u22a2 (aeval f) (sorry ()) = \u2211 i \u2208 range (n + 1), \u2191p ^ i * f i ^ p ^ (n - i)"}]}
{"declaration": "theorem xInTermsOfW_eq [Invertible (p : R)] {n : \u2115} : xInTermsOfW p R n =\n    (X n - \u2211 i \u2208 range n, C ((p : R) ^ i) *\n      xInTermsOfW p R i ^ p ^ (n - i)) * C ((\u215fp : R) ^ n) := by\n  rw [xInTermsOfW]\n  rw [\u2190 Fin.sum_univ_eq_sum_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/WittPolynomial.lean", "context": {"open": ["MvPolynomial", "Finset hiding map", "Finsupp (single)", "Witt", "MvPolynomial"], "variables": ["(p : \u2115)", "(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]", "(R)", "[hp : NeZero p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nhp : NeZero p\ninst\u271d : Invertible \u2191p\nn : \u2115\n\u22a2 xInTermsOfW p R n = (X n - \u2211 i \u2208 range n, C (\u2191p ^ i) * xInTermsOfW p R i ^ p ^ (n - i)) * C (\u215f \u2191p ^ n)"}, {"line": "rw [xInTermsOfW]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nhp : NeZero p\ninst\u271d : Invertible \u2191p\nn : \u2115\n\u22a2 (X n - \u2211 i, C (\u2191p ^ \u2191i) * xInTermsOfW p R \u2191i ^ p ^ (n - \u2191i)) * C (\u215f \u2191p ^ n) =\n    (X n - \u2211 i \u2208 range n, C (\u2191p ^ i) * xInTermsOfW p R i ^ p ^ (n - i)) * C (\u215f \u2191p ^ n)"}, {"line": "rw [\u2190 Fin.sum_univ_eq_sum_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem xInTermsOfW_zero [Invertible (p : R)] : xInTermsOfW p R 0 = X 0 := by\n  rw [xInTermsOfW_eq]\n  rw [range_zero]\n  rw [sum_empty]\n  rw [pow_zero]\n  rw [C_1]\n  rw [mul_one]\n  rw [sub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/WittVector/WittPolynomial.lean", "context": {"open": ["MvPolynomial", "Finset hiding map", "Finsupp (single)", "Witt", "MvPolynomial"], "variables": ["(p : \u2115)", "(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]", "(R)", "[hp : NeZero p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nhp : NeZero p\ninst\u271d : Invertible \u2191p\n\u22a2 xInTermsOfW p R 0 = X 0"}, {"line": "rw [xInTermsOfW_eq]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nhp : NeZero p\ninst\u271d : Invertible \u2191p\n\u22a2 (X 0 - \u2211 i \u2208 range 0, C (\u2191p ^ i) * xInTermsOfW p R i ^ p ^ (0 - i)) * C (\u215f \u2191p ^ 0) = X 0"}, {"line": "rw [range_zero]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nhp : NeZero p\ninst\u271d : Invertible \u2191p\n\u22a2 (X 0 - \u2211 i \u2208 \u2205, C (\u2191p ^ i) * xInTermsOfW p R i ^ p ^ (0 - i)) * C (\u215f \u2191p ^ 0) = X 0"}, {"line": "rw [sum_empty]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nhp : NeZero p\ninst\u271d : Invertible \u2191p\n\u22a2 (X 0 - 0) * C (\u215f \u2191p ^ 0) = X 0"}, {"line": "rw [pow_zero]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nhp : NeZero p\ninst\u271d : Invertible \u2191p\n\u22a2 (X 0 - 0) * C 1 = X 0"}, {"line": "rw [C_1]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nhp : NeZero p\ninst\u271d : Invertible \u2191p\n\u22a2 (X 0 - 0) * 1 = X 0"}, {"line": "rw [mul_one]", "tactic_state": "p : \u2115\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nhp : NeZero p\ninst\u271d : Invertible \u2191p\n\u22a2 X 0 - 0 = X 0"}, {"line": "rw [sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem to_ofList (l : List (Lists \u03b1)) : toList (ofList l) = l := by induction l <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Lists.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\nl : List (Lists \u03b1)\n\u22a2 sorry = l"}, {"line": "induction l <;> simp [*]", "tactic_state": "case nil\n\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\n\u22a2 sorry () = []\n---\ncase cons\n\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\nhead\u271d : Lists \u03b1\ntail\u271d : List (Lists \u03b1)\ntail_ih\u271d : sorry = tail\u271d\n\u22a2 False"}]}
{"declaration": "theorem to_ofList (l : List (Lists \u03b1)) : toList (ofList l) = l := by simp [ofList, of']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Lists.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\nl : List (Lists \u03b1)\n\u22a2 sorry = l"}, {"line": "simp [ofList, of']", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\nl : List (Lists \u03b1)\n\u22a2 sorry () = l"}]}
{"declaration": "theorem sizeof_pos {b} (l : Lists' \u03b1 b) : 0 < SizeOf.sizeOf l := by\n  cases l <;> simp only [Lists'.atom.sizeOf_spec, Lists'.nil.sizeOf_spec, Lists'.cons'.sizeOf_spec,\n    true_or, add_pos_iff, zero_lt_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Lists.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nb : Bool\nl : Lists' \u03b1 b\n\u22a2 0 < sizeOf l"}, {"line": "cases l <;> simp only [Lists'.atom.sizeOf_spec, Lists'.nil.sizeOf_spec, Lists'.cons'.sizeOf_spec,\n    true_or, add_pos_iff, zero_lt_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_sizeof_cons' {b} (a : Lists' \u03b1 b) (l) :\n    SizeOf.sizeOf (\u27e8b, a\u27e9 : Lists \u03b1) < SizeOf.sizeOf (Lists'.cons' a l) := by\n  simp only [Sigma.mk.sizeOf_spec]\n  simp only [Lists'.cons'.sizeOf_spec]\n  simp only [lt_add_iff_pos_right]\n  apply sizeof_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Lists.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nb : Bool\na : Lists' \u03b1 b\nl : Lists' \u03b1 true\n\u22a2 sizeOf \u27e8b, a\u27e9 < sizeOf (a.cons' l)"}, {"line": "simp only [Sigma.mk.sizeOf_spec]", "tactic_state": "\u03b1 : Type u_1\nb : Bool\na : Lists' \u03b1 b\nl : Lists' \u03b1 true\n\u22a2 1 + sizeOf b + sizeOf a < sizeOf (a.cons' l)"}, {"line": "simp only [Lists'.cons'.sizeOf_spec]", "tactic_state": "\u03b1 : Type u_1\nb : Bool\na : Lists' \u03b1 b\nl : Lists' \u03b1 true\n\u22a2 1 + sizeOf b + sizeOf a < 1 + sizeOf b + sizeOf a + sizeOf l"}, {"line": "simp only [lt_add_iff_pos_right]", "tactic_state": "\u03b1 : Type u_1\nb : Bool\na : Lists' \u03b1 b\nl : Lists' \u03b1 true\n\u22a2 0 < sizeOf l"}, {"line": "apply sizeof_pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_continuum : lift.{v} \ud835\udd20 = \ud835\udd20 := by\n  rw [\u2190 two_power_aleph0]\n  rw [lift_two_power]\n  rw [lift_aleph0]\n  rw [two_power_aleph0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 lift.{v, u_1} continuum = continuum"}, {"line": "rw [\u2190 two_power_aleph0]", "tactic_state": "\u22a2 lift.{v, u_1} (2 ^ aleph0) = continuum"}, {"line": "rw [lift_two_power]", "tactic_state": "\u22a2 2 ^ lift.{v, u_1} aleph0 = continuum"}, {"line": "rw [lift_aleph0]", "tactic_state": "\u22a2 2 ^ aleph0 = continuum"}, {"line": "rw [two_power_aleph0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem beth_one : \u2136_ 1 = \ud835\udd20 := by simpa using beth_succ 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 beth 1 = continuum"}, {"line": "simpa using beth_succ 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_set_nat : #(Set \u2115) = \ud835\udd20 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 mk (Set \u2115) = continuum"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph_one_le_continuum : \u2135\u2081 \u2264 \ud835\udd20 := by\n  rw [\u2190 succ_aleph0]\n  exact Order.succ_le_of_lt aleph0_lt_continuum\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 aleph 1 \u2264 continuum"}, {"line": "rw [\u2190 succ_aleph0]", "tactic_state": "\u22a2 Order.succ aleph0 \u2264 continuum"}, {"line": "exact Order.succ_le_of_lt aleph0_lt_continuum", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuum_power_aleph0 : \ud835\udd20 ^ \u2135\u2080 = \ud835\udd20 := by\n  rw [\u2190 two_power_aleph0]\n  rw [\u2190 power_mul]\n  rw [mul_eq_left le_rfl le_rfl aleph0_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 continuum ^ aleph0 = continuum"}, {"line": "rw [\u2190 two_power_aleph0]", "tactic_state": "\u22a2 (2 ^ aleph0) ^ aleph0 = 2 ^ aleph0"}, {"line": "rw [\u2190 power_mul]", "tactic_state": "\u22a2 2 ^ (aleph0 * aleph0) = 2 ^ aleph0"}, {"line": "rw [mul_eq_left le_rfl le_rfl aleph0_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasCardinalLT_iff_cardinal_mk_lt (X : Type u) (\u03ba : Cardinal.{u}) :\n    HasCardinalLT X \u03ba \u2194 Cardinal.mk X < \u03ba := by\n  simp [HasCardinalLT]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/HasCardinalLT.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\n\u03ba : Cardinal.{u}\n\u22a2 HasCardinalLT X \u03ba \u2194 Cardinal.mk X < \u03ba"}, {"line": "simp [HasCardinalLT]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasCardinalLT_aleph0_iff (X : Type u) :\n    HasCardinalLT X Cardinal.aleph0.{v} \u2194 Finite X := by\n  simpa [HasCardinalLT] using Cardinal.mk_lt_aleph0_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/HasCardinalLT.lean", "context": {"open": [], "variables": ["{X : Type u} {\u03ba : Cardinal.{v}} (h : HasCardinalLT X \u03ba)", "{Y : Type u'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\n\u22a2 HasCardinalLT X Cardinal.aleph0 \u2194 Finite X"}, {"line": "simpa [HasCardinalLT] using Cardinal.mk_lt_aleph0_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasCardinalLT_option_iff (X : Type u) (\u03ba : Cardinal.{w})\n    (h\u03ba : Cardinal.aleph0 \u2264 \u03ba) :\n    HasCardinalLT (Option X) \u03ba \u2194 HasCardinalLT X \u03ba := by\n  rw [hasCardinalLT_iff_of_equiv (Equiv.optionEquivSumPUnit.{0} X)]\n  rw [hasCardinalLT_sum_iff _ _ _ h\u03ba]\n  rw [and_iff_left_iff_imp]\n  refine fun _ \u21a6 HasCardinalLT.of_le ?_ h\u03ba\n  rw [hasCardinalLT_aleph0_iff]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/HasCardinalLT.lean", "context": {"open": [], "variables": ["{X : Type u} {\u03ba : Cardinal.{v}} (h : HasCardinalLT X \u03ba)", "{Y : Type u'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\n\u03ba : Cardinal.{w}\nh\u03ba : Cardinal.aleph0 \u2264 \u03ba\n\u22a2 HasCardinalLT (Option X) \u03ba \u2194 HasCardinalLT X \u03ba"}, {"line": "rw [hasCardinalLT_iff_of_equiv (Equiv.optionEquivSumPUnit.{0} X)]", "tactic_state": "X : Type u\n\u03ba : Cardinal.{w}\nh\u03ba : Cardinal.aleph0 \u2264 \u03ba\n\u22a2 HasCardinalLT (X \u2295 PUnit.{1}) \u03ba \u2194 HasCardinalLT X \u03ba"}, {"line": "rw [hasCardinalLT_sum_iff _ _ _ h\u03ba]", "tactic_state": "X : Type u\n\u03ba : Cardinal.{w}\nh\u03ba : Cardinal.aleph0 \u2264 \u03ba\n\u22a2 HasCardinalLT X \u03ba \u2227 HasCardinalLT PUnit.{1} \u03ba \u2194 HasCardinalLT X \u03ba"}, {"line": "rw [and_iff_left_iff_imp]", "tactic_state": "X : Type u\n\u03ba : Cardinal.{w}\nh\u03ba : Cardinal.aleph0 \u2264 \u03ba\n\u22a2 HasCardinalLT X \u03ba \u2192 HasCardinalLT PUnit.{1} \u03ba"}, {"line": "refine fun _ \u21a6 HasCardinalLT.of_le ?_ h\u03ba", "tactic_state": "X : Type u\n\u03ba : Cardinal.{w}\nh\u03ba : Cardinal.aleph0 \u2264 \u03ba\nx\u271d : HasCardinalLT X \u03ba\n\u22a2 HasCardinalLT PUnit.{1} Cardinal.aleph0"}, {"line": "rw [hasCardinalLT_aleph0_iff]", "tactic_state": "X : Type u\n\u03ba : Cardinal.{w}\nh\u03ba : Cardinal.aleph0 \u2264 \u03ba\nx\u271d : HasCardinalLT X \u03ba\n\u22a2 Finite PUnit.{1}"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_le_cardinal : (count p n : Cardinal) \u2264 Cardinal.mk { k | p k } := by\n  rw [count_eq_card_fintype]\n  rw [\u2190 Cardinal.mk_fintype]\n  exact Cardinal.mk_subtype_mono fun x hx \u21a6 hx.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/NatCount.lean", "context": {"open": ["Nat Count"], "variables": ["{p : \u2115 \u2192 Prop} [DecidablePred p] (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 Cardinal.mk \u2191{k | p k}"}, {"line": "rw [count_eq_card_fintype]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(Fintype.card { k // k < n \u2227 p k }) \u2264 Cardinal.mk \u2191{k | p k}"}, {"line": "rw [\u2190 Cardinal.mk_fintype]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 Cardinal.mk { k // k < n \u2227 p k } \u2264 Cardinal.mk \u2191{k | p k}"}, {"line": "exact Cardinal.mk_subtype_mono fun x hx \u21a6 hx.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_le_setENCard : count p n \u2264 Set.encard { k | p k } := by\n  simp only [Set.encard]\n  simp only [ENat.card]\n  simp only [Set.coe_setOf]\n  simp only [Cardinal.natCast_le_toENat_iff]\n  exact Nat.count_le_cardinal n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/NatCount.lean", "context": {"open": ["Nat Count"], "variables": ["{p : \u2115 \u2192 Prop} [DecidablePred p] (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 {k | p k}.encard"}, {"line": "simp only [Set.encard]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 ENat.card \u2191{k | p k}"}, {"line": "simp only [ENat.card]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 Cardinal.toENat (Cardinal.mk \u2191{k | p k})"}, {"line": "simp only [Set.coe_setOf]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 Cardinal.toENat (Cardinal.mk { k // p k })"}, {"line": "simp only [Cardinal.natCast_le_toENat_iff]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 Cardinal.mk { k // p k }"}, {"line": "exact Nat.count_le_cardinal n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_le_setNCard (h : { k | p k }.Finite) : count p n \u2264 Set.ncard { k | p k } := by\n  rw [Set.ncard_def]\n  rw [\u2190 ENat.coe_le_coe]\n  rw [ENat.coe_toNat (by simpa)]\n  exact count_le_setENCard n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/NatCount.lean", "context": {"open": ["Nat Count"], "variables": ["{p : \u2115 \u2192 Prop} [DecidablePred p] (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\nh : {k | p k}.Finite\n\u22a2 count p n \u2264 {k | p k}.ncard"}, {"line": "rw [Set.ncard_def]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\nh : {k | p k}.Finite\n\u22a2 count p n \u2264 {k | p k}.encard.toNat"}, {"line": "rw [\u2190 ENat.coe_le_coe]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\nh : {k | p k}.Finite\n\u22a2 \u2191(count p n) \u2264 \u2191{k | p k}.encard.toNat"}, {"line": "rw [ENat.coe_toNat (by simpa)]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\nh : {k | p k}.Finite\n\u22a2 \u2191(count p n) \u2264 {k | p k}.encard"}, {"line": "exact count_le_setENCard n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsRegular.cof_omega_eq {o : Ordinal} (H : (\u2135_ o).IsRegular) : (\u03c9_ o).cof = \u2135_ o := by\n  rw [\u2190 ord_aleph]\n  rw [H.cof_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nH : (aleph o).IsRegular\n\u22a2 (omega o).cof = aleph o"}, {"line": "rw [\u2190 ord_aleph]", "tactic_state": "o : Ordinal.{u_1}\nH : (aleph o).IsRegular\n\u22a2 (aleph o).ord.cof = aleph o"}, {"line": "rw [H.cof_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsRegular.ord_pos {c : Cardinal} (H : c.IsRegular) : 0 < c.ord := by\n  rw [Cardinal.lt_ord]\n  rw [card_zero]\n  exact H.pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nH : c.IsRegular\n\u22a2 0 < c.ord"}, {"line": "rw [Cardinal.lt_ord]", "tactic_state": "c : Cardinal.{u_1}\nH : c.IsRegular\n\u22a2 card 0 < c"}, {"line": "rw [card_zero]", "tactic_state": "c : Cardinal.{u_1}\nH : c.IsRegular\n\u22a2 0 < c"}, {"line": "exact H.pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_lt_of_card_biUnion_lt {\u03b1 \u03b2 : Type u} {s : Set \u03b1} {t : \u2200 a \u2208 s, Set \u03b2} {c : Cardinal}\n    (h : #(\u22c3 a \u2208 s, t a \u2039_\u203a) < c) (a : \u03b1) (ha : a \u2208 s) : # (t a ha) < c := by\n  rw [biUnion_eq_iUnion] at h\n  have := card_lt_of_card_iUnion_lt h\n  simp_all only [iUnion_coe_set, Subtype.forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nh : mk \u2191(\u22c3 a, \u22c3 (h : a \u2208 s), t a h) < c\na : \u03b1\nha : a \u2208 s\n\u22a2 mk \u2191(t a ha) < c"}, {"line": "rw [biUnion_eq_iUnion] at h", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nh : mk \u2191(\u22c3 x, t \u2191x \u22ef) < c\na : \u03b1\nha : a \u2208 s\n\u22a2 mk \u2191(t a ha) < c"}, {"line": "have := card_lt_of_card_iUnion_lt h", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nh : mk \u2191(\u22c3 x, t \u2191x \u22ef) < c\na : \u03b1\nha : a \u2208 s\nthis : \u2200 (i : \u2191s), mk \u2191(t \u2191i \u22ef) < c\n\u22a2 mk \u2191(t a ha) < c"}, {"line": "simp_all only [iUnion_coe_set, Subtype.forall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_biUnion_lt_iff_forall_of_isRegular {\u03b1 \u03b2 : Type u} {s : Set \u03b1} {t : \u2200 a \u2208 s, Set \u03b2}\n    {c : Cardinal} (hc : c.IsRegular) (hs : #s < c) :\n    #(\u22c3 a \u2208 s, t a \u2039_\u203a) < c \u2194 \u2200 a (ha : a \u2208 s), # (t a ha) < c := by\n  rw [biUnion_eq_iUnion]\n  rw [card_iUnion_lt_iff_forall_of_isRegular hc hs]\n  rw [SetCoe.forall']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nhc : c.IsRegular\nhs : mk \u2191s < c\n\u22a2 mk \u2191(\u22c3 a, \u22c3 (h : a \u2208 s), t a h) < c \u2194 \u2200 (a : \u03b1) (ha : a \u2208 s), mk \u2191(t a ha) < c"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nhc : c.IsRegular\nhs : mk \u2191s < c\n\u22a2 mk \u2191(\u22c3 x, t \u2191x \u22ef) < c \u2194 \u2200 (a : \u03b1) (ha : a \u2208 s), mk \u2191(t a ha) < c"}, {"line": "rw [card_iUnion_lt_iff_forall_of_isRegular hc hs]", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nhc : c.IsRegular\nhs : mk \u2191s < c\n\u22a2 (\u2200 (i : \u2191s), mk \u2191(t \u2191i \u22ef) < c) \u2194 \u2200 (a : \u03b1) (ha : a \u2208 s), mk \u2191(t a ha) < c"}, {"line": "rw [SetCoe.forall']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nfpFamily_lt_ord_lift_of_isRegular {\u03b9} {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c) (hc' : c \u2260 \u2135\u2080) (hf : \u2200 (i), \u2200 b < c.ord, f i b < c.ord) {a}\n    (ha : a < c.ord) : nfpFamily f a < c.ord := by\n  apply nfpFamily_lt_ord_lift _ _ hf ha <;> rw [hc.cof_eq]\n  \u00b7 exact lt_of_le_of_ne hc.1 hc'.symm\n  \u00b7 exact h\u03b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nh\u03b9 : Cardinal.lift.{v, u} (mk \u03b9) < c\nhc' : c \u2260 aleph0\nhf : \u2200 (i : \u03b9), \u2200 b < c.ord, f i b < c.ord\na : Ordinal.{max u v}\nha : a < c.ord\n\u22a2 nfpFamily f a < c.ord"}, {"line": "apply nfpFamily_lt_ord_lift _ _ hf ha <;> rw [hc.cof_eq]", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nh\u03b9 : Cardinal.lift.{v, u} (mk \u03b9) < c\nhc' : c \u2260 aleph0\nhf : \u2200 (i : \u03b9), \u2200 b < c.ord, f i b < c.ord\na : Ordinal.{max u v}\nha : a < c.ord\n\u22a2 aleph0 < c\n---\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nh\u03b9 : Cardinal.lift.{v, u} (mk \u03b9) < c\nhc' : c \u2260 aleph0\nhf : \u2200 (i : \u03b9), \u2200 b < c.ord, f i b < c.ord\na : Ordinal.{max u v}\nha : a < c.ord\n\u22a2 Cardinal.lift.{v, u} (mk \u03b9) < c"}, {"line": "\u00b7 exact lt_of_le_of_ne hc.1 hc'.symm", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nh\u03b9 : Cardinal.lift.{v, u} (mk \u03b9) < c\nhc' : c \u2260 aleph0\nhf : \u2200 (i : \u03b9), \u2200 b < c.ord, f i b < c.ord\na : Ordinal.{max u v}\nha : a < c.ord\n\u22a2 Cardinal.lift.{v, u} (mk \u03b9) < c"}, {"line": "\u00b7 exact h\u03b9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iSup_sequence_lt_omega1 {\u03b1 : Type u} [Countable \u03b1]\n    (o : \u03b1 \u2192 Ordinal.{max u v}) (ho : \u2200 n, o n < (aleph 1).ord) :\n    iSup o < (aleph 1).ord := by\n  apply iSup_lt_ord_lift _ ho\n  rw [Cardinal.isRegular_aleph_one.cof_eq]\n  exact lt_of_le_of_lt mk_le_aleph0 aleph0_lt_aleph_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal", "Cardinal", "scoped Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Countable \u03b1\no : \u03b1 \u2192 Ordinal.{max u v}\nho : \u2200 (n : \u03b1), o n < (aleph 1).ord\n\u22a2 iSup o < (aleph 1).ord"}, {"line": "apply iSup_lt_ord_lift _ ho", "tactic_state": "\u03b1 : Type u\ninst\u271d : Countable \u03b1\no : \u03b1 \u2192 Ordinal.{max u v}\nho : \u2200 (n : \u03b1), o n < (aleph 1).ord\n\u22a2 Cardinal.lift.{v, u} (mk \u03b1) < (aleph 1).ord.cof"}, {"line": "rw [Cardinal.isRegular_aleph_one.cof_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Countable \u03b1\no : \u03b1 \u2192 Ordinal.{max u v}\nho : \u2200 (n : \u03b1), o n < (aleph 1).ord\n\u22a2 Cardinal.lift.{v, u} (mk \u03b1) < aleph 1"}, {"line": "exact lt_of_le_of_lt mk_le_aleph0 aleph0_lt_aleph_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univLE_iff_exists_embedding : UnivLE.{u, v} \u2194 Nonempty (Ordinal.{u} \u21aa Ordinal.{v}) := by\n  rw [univLE_iff_cardinal_le]\n  exact lift_mk_le'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/UnivLE.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 UnivLE.{u, v} \u2194 Nonempty (Ordinal.{u} \u21aa Ordinal.{v})"}, {"line": "rw [univLE_iff_cardinal_le]", "tactic_state": "\u22a2 univ.{u, v + 1} \u2264 univ.{v, u + 1} \u2194 Nonempty (Ordinal.{u} \u21aa Ordinal.{v})"}, {"line": "exact lift_mk_le'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInitial.card_le_card {a b : Ordinal} (ha : IsInitial a) : a.card \u2264 b.card \u2194 a \u2264 b := by\n  refine \u27e8fun h \u21a6 ?_, Ordinal.card_le_card\u27e9\n  rw [\u2190 ord_le_ord] at h\n  rw [ha.ord_card] at h\n  exact h.trans (ord_card_le b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nha : a.IsInitial\n\u22a2 a.card \u2264 b.card \u2194 a \u2264 b"}, {"line": "refine \u27e8fun h \u21a6 ?_, Ordinal.card_le_card\u27e9", "tactic_state": "a b : Ordinal.{u_1}\nha : a.IsInitial\nh : a.card \u2264 b.card\n\u22a2 a \u2264 b"}, {"line": "rw [\u2190 ord_le_ord] at h", "tactic_state": "a b : Ordinal.{u_1}\nha : a.IsInitial\nh : a.card.ord \u2264 b.card.ord\n\u22a2 a \u2264 b"}, {"line": "rw [ha.ord_card] at h", "tactic_state": "a b : Ordinal.{u_1}\nha : a.IsInitial\nh : a \u2264 b.card.ord\n\u22a2 a \u2264 b"}, {"line": "exact h.trans (ord_card_le b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_ord (c : Cardinal) : IsInitial c.ord := by\n  rw [IsInitial]\n  rw [card_ord]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c.ord.IsInitial"}, {"line": "rw [IsInitial]", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c.ord.card.ord = c.ord"}, {"line": "rw [card_ord]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_natCast (n : \u2115) : IsInitial n := by\n  rw [IsInitial]\n  rw [card_nat]\n  rw [ord_nat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (\u2191n).IsInitial"}, {"line": "rw [IsInitial]", "tactic_state": "n : \u2115\n\u22a2 (\u2191n).card.ord = \u2191n"}, {"line": "rw [card_nat]", "tactic_state": "n : \u2115\n\u22a2 (\u2191n).ord = \u2191n"}, {"line": "rw [ord_nat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_zero : IsInitial 0 := by\n  exact_mod_cast isInitial_natCast 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 IsInitial 0"}, {"line": "exact_mod_cast isInitial_natCast 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_one : IsInitial 1 := by\n  exact_mod_cast isInitial_natCast 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 IsInitial 1"}, {"line": "exact_mod_cast isInitial_natCast 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_omega0 : IsInitial \u03c9 := by\n  rw [IsInitial]\n  rw [card_omega0]\n  rw [ord_aleph0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 omega0.IsInitial"}, {"line": "rw [IsInitial]", "tactic_state": "\u22a2 omega0.card.ord = omega0"}, {"line": "rw [card_omega0]", "tactic_state": "\u22a2 aleph0.ord = omega0"}, {"line": "rw [ord_aleph0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_bddAbove_isInitial : \u00ac BddAbove {x | IsInitial x} := by\n  rintro \u27e8a, ha\u27e9\n  have := ha (isInitial_ord (succ a.card))\n  rw [ord_le] at this\n  exact (lt_succ _).not_le this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acBddAbove {x | x.IsInitial}"}, {"line": "rintro \u27e8a, ha\u27e9", "tactic_state": "case intro\na : Ordinal.{u_1}\nha : a \u2208 upperBounds {x | x.IsInitial}\n\u22a2 False"}, {"line": "have := ha (isInitial_ord (succ a.card))", "tactic_state": "case intro\na : Ordinal.{u_1}\nha : a \u2208 upperBounds {x | x.IsInitial}\nthis : (succ a.card).ord \u2264 a\n\u22a2 False"}, {"line": "rw [ord_le] at this", "tactic_state": "case intro\na : Ordinal.{u_1}\nha : a \u2208 upperBounds {x | x.IsInitial}\nthis : succ a.card \u2264 a.card\n\u22a2 False"}, {"line": "exact (lt_succ _).not_le this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preOmega_zero : preOmega 0 = 0 := by\n  rw [coe_preOmega]\n  rw [enumOrd_zero]\n  exact csInf_eq_bot_of_bot_mem isInitial_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preOmega 0 = 0"}, {"line": "rw [coe_preOmega]", "tactic_state": "\u22a2 enumOrd {x | x.IsInitial} 0 = 0"}, {"line": "rw [enumOrd_zero]", "tactic_state": "\u22a2 sInf {x | x.IsInitial} = 0"}, {"line": "exact csInf_eq_bot_of_bot_mem isInitial_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_range_preOmega_iff {x : Ordinal} : x \u2208 range preOmega \u2194 IsInitial x := by\n  rw [range_preOmega]\n  rw [mem_setOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 x \u2208 range \u21d1preOmega \u2194 x.IsInitial"}, {"line": "rw [range_preOmega]", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 x \u2208 {x | x.IsInitial} \u2194 x.IsInitial"}, {"line": "rw [mem_setOf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preOmega_omega0 : preOmega \u03c9 = \u03c9 := by\n  simp_rw [\u2190 isNormal_preOmega.apply_omega0, preOmega_natCast, iSup_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preOmega omega0 = omega0"}, {"line": "simp_rw [\u2190 isNormal_preOmega.apply_omega0, preOmega_natCast, iSup_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega0_le_preOmega_iff {x : Ordinal} : \u03c9 \u2264 preOmega x \u2194 \u03c9 \u2264 x := by\n  conv_lhs => rw [\u2190 preOmega_omega0, preOmega_le_preOmega]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 omega0 \u2264 preOmega x \u2194 omega0 \u2264 x"}, {"line": "conv_lhs => rw [\u2190 preOmega_omega0, preOmega_le_preOmega]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega0_lt_preOmega_iff {x : Ordinal} : \u03c9 < preOmega x \u2194 \u03c9 < x := by\n  conv_lhs => rw [\u2190 preOmega_omega0, preOmega_lt_preOmega]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 omega0 < preOmega x \u2194 omega0 < x"}, {"line": "conv_lhs => rw [\u2190 preOmega_omega0, preOmega_lt_preOmega]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega_zero : \u03c9_ 0 = \u03c9 := by\n  rw [omega_eq_preOmega]\n  rw [add_zero]\n  rw [preOmega_omega0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 omega 0 = omega0"}, {"line": "rw [omega_eq_preOmega]", "tactic_state": "\u22a2 preOmega (omega0 + 0) = omega0"}, {"line": "rw [add_zero]", "tactic_state": "\u22a2 preOmega omega0 = omega0"}, {"line": "rw [preOmega_omega0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega0_le_omega (o : Ordinal) : \u03c9 \u2264 \u03c9_ o := by\n  rw [\u2190 omega_zero]\n  rw [omega_le_omega]\n  exact Ordinal.zero_le o\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 omega0 \u2264 omega o"}, {"line": "rw [\u2190 omega_zero]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 omega 0 \u2264 omega o"}, {"line": "rw [omega_le_omega]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 0 \u2264 o"}, {"line": "exact Ordinal.zero_le o", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega0_lt_omega1 : \u03c9 < \u03c9\u2081 := by\n  rw [\u2190 omega_zero]\n  rw [omega_lt_omega]\n  exact zero_lt_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 omega0 < omega 1"}, {"line": "rw [\u2190 omega_zero]", "tactic_state": "\u22a2 omega 0 < omega 1"}, {"line": "rw [omega_lt_omega]", "tactic_state": "\u22a2 0 < 1"}, {"line": "exact zero_lt_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_range_omega_iff {x : Ordinal} : x \u2208 range omega \u2194 \u03c9 \u2264 x \u2227 IsInitial x := by\n  rw [range_omega]\n  rw [mem_setOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 x \u2208 range \u21d1omega \u2194 omega0 \u2264 x \u2227 x.IsInitial"}, {"line": "rw [range_omega]", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 x \u2208 {x | omega0 \u2264 x \u2227 x.IsInitial} \u2194 omega0 \u2264 x \u2227 x.IsInitial"}, {"line": "rw [mem_setOf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ord_preAleph (o : Ordinal) : (preAleph o).ord = preOmega o := by\n  rw [\u2190 o.card_preOmega]\n  rw [(isInitial_preOmega o).ord_card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 (preAleph o).ord = preOmega o"}, {"line": "rw [\u2190 o.card_preOmega]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 (preOmega o).card.ord = preOmega o"}, {"line": "rw [(isInitial_preOmega o).ord_card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem type_cardinal : typeLT Cardinal = Ordinal.univ.{u, u + 1} := by\n  rw [Ordinal.univ_id]\n  exact Quotient.sound \u27e8preAleph.symm.toRelIsoLT\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (type fun x1 x2 => x1 < x2) = Ordinal.univ.{u, u + 1}"}, {"line": "rw [Ordinal.univ_id]", "tactic_state": "\u22a2 (type fun x1 x2 => x1 < x2) = type fun x1 x2 => x1 < x2"}, {"line": "exact Quotient.sound \u27e8preAleph.symm.toRelIsoLT\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_nat (n : \u2115) : preAleph n = n := by\n  rw [\u2190 card_preOmega]\n  rw [preOmega_natCast]\n  rw [card_nat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 preAleph \u2191n = \u2191n"}, {"line": "rw [\u2190 card_preOmega]", "tactic_state": "n : \u2115\n\u22a2 (preOmega \u2191n).card = \u2191n"}, {"line": "rw [preOmega_natCast]", "tactic_state": "n : \u2115\n\u22a2 (\u2191n).card = \u2191n"}, {"line": "rw [card_nat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_omega0 : preAleph \u03c9 = \u2135\u2080 := by\n  rw [\u2190 card_preOmega]\n  rw [preOmega_omega0]\n  rw [card_omega0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preAleph omega0 = aleph0"}, {"line": "rw [\u2190 card_preOmega]", "tactic_state": "\u22a2 (preOmega omega0).card = aleph0"}, {"line": "rw [preOmega_omega0]", "tactic_state": "\u22a2 omega0.card = aleph0"}, {"line": "rw [card_omega0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_pos {o : Ordinal} : 0 < preAleph o \u2194 0 < o := by\n  rw [\u2190 preAleph_zero]\n  rw [preAleph_lt_preAleph]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 0 < preAleph o \u2194 0 < o"}, {"line": "rw [\u2190 preAleph_zero]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 preAleph 0 < preAleph o \u2194 0 < o"}, {"line": "rw [preAleph_lt_preAleph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_le_preAleph {o : Ordinal} : \u2135\u2080 \u2264 preAleph o \u2194 \u03c9 \u2264 o := by\n  rw [\u2190 preAleph_omega0]\n  rw [preAleph_le_preAleph]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 aleph0 \u2264 preAleph o \u2194 omega0 \u2264 o"}, {"line": "rw [\u2190 preAleph_omega0]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 preAleph omega0 \u2264 preAleph o \u2194 omega0 \u2264 o"}, {"line": "rw [preAleph_le_preAleph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Ordinal.lift_preOmega (o : Ordinal.{u}) :\n    Ordinal.lift.{v} (preOmega o) = preOmega (Ordinal.lift.{v} o) := by\n  rw [\u2190 ord_preAleph]\n  rw [lift_ord]\n  rw [lift_preAleph]\n  rw [ord_preAleph]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\n\u22a2 Ordinal.lift.{v, u} (preOmega o) = preOmega (Ordinal.lift.{v, u} o)"}, {"line": "rw [\u2190 ord_preAleph]", "tactic_state": "o : Ordinal.{u}\n\u22a2 Ordinal.lift.{v, u} (preAleph o).ord = preOmega (Ordinal.lift.{v, u} o)"}, {"line": "rw [lift_ord]", "tactic_state": "o : Ordinal.{u}\n\u22a2 (Cardinal.lift.{v, u} (preAleph o)).ord = preOmega (Ordinal.lift.{v, u} o)"}, {"line": "rw [lift_preAleph]", "tactic_state": "o : Ordinal.{u}\n\u22a2 (preAleph (Ordinal.lift.{v, u} o)).ord = preOmega (Ordinal.lift.{v, u} o)"}, {"line": "rw [ord_preAleph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_limit {o : Ordinal} (ho : o.IsLimit) : preAleph o = \u2a06 a : Iio o, preAleph a := by\n  refine le_antisymm ?_ (ciSup_le' fun i => preAleph_le_preAleph.2 i.2.le)\n  rw [preAleph_le_of_isLimit ho]\n  exact fun a ha => le_ciSup (bddAbove_of_small _) (\u27e8a, ha\u27e9 : Iio o)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nho : o.IsLimit\n\u22a2 preAleph o = \u2a06 a, preAleph \u2191a"}, {"line": "refine le_antisymm ?_ (ciSup_le' fun i => preAleph_le_preAleph.2 i.2.le)", "tactic_state": "o : Ordinal.{u_1}\nho : o.IsLimit\n\u22a2 preAleph o \u2264 \u2a06 a, preAleph \u2191a"}, {"line": "rw [preAleph_le_of_isLimit ho]", "tactic_state": "o : Ordinal.{u_1}\nho : o.IsLimit\n\u22a2 \u2200 o' < o, preAleph o' \u2264 \u2a06 a, preAleph \u2191a"}, {"line": "exact fun a ha => le_ciSup (bddAbove_of_small _) (\u27e8a, ha\u27e9 : Iio o)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_le_of_strictMono {f : Ordinal \u2192 Cardinal} (hf : StrictMono f) (o : Ordinal) :\n    preAleph o \u2264 f o := by\n  simpa using (hf.comp preAleph.symm.strictMono).id_le (preAleph o)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : Ordinal.{u_1} \u2192 Cardinal.{u_1}\nhf : StrictMono f\no : Ordinal.{u_1}\n\u22a2 preAleph o \u2264 f o"}, {"line": "simpa using (hf.comp preAleph.symm.strictMono).id_le (preAleph o)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph_succ (o : Ordinal) : \u2135_ (succ o) = succ (\u2135_ o) := by\n  rw [aleph_eq_preAleph]\n  rw [add_succ]\n  rw [preAleph_succ]\n  rw [aleph_eq_preAleph]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 aleph (succ o) = succ (aleph o)"}, {"line": "rw [aleph_eq_preAleph]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 preAleph (omega0 + succ o) = succ (aleph o)"}, {"line": "rw [add_succ]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 preAleph (succ (omega0 + o)) = succ (aleph o)"}, {"line": "rw [preAleph_succ]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 succ (preAleph (omega0 + o)) = succ (aleph o)"}, {"line": "rw [aleph_eq_preAleph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph_zero : \u2135_ 0 = \u2135\u2080 := by rw [aleph_eq_preAleph, add_zero, preAleph_omega0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 aleph 0 = aleph0"}, {"line": "rw [aleph_eq_preAleph, add_zero, preAleph_omega0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_aleph (o : Ordinal.{u}) : lift.{v} (aleph o) = aleph (Ordinal.lift.{v} o) := by\n  simp [aleph_eq_preAleph]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\n\u22a2 Cardinal.lift.{v, u} (aleph o) = aleph (Ordinal.lift.{v, u} o)"}, {"line": "simp [aleph_eq_preAleph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Ordinal.lift_omega (o : Ordinal.{u}) :\n    Ordinal.lift.{v} (\u03c9_ o) = \u03c9_ (Ordinal.lift.{v} o) := by\n  simp [omega_eq_preOmega]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\n\u22a2 Ordinal.lift.{v, u} (omega o) = omega (Ordinal.lift.{v, u} o)"}, {"line": "simp [omega_eq_preOmega]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_le_aleph (o : Ordinal) : \u2135\u2080 \u2264 \u2135_ o := by\n  rw [aleph_eq_preAleph]\n  rw [aleph0_le_preAleph]\n  apply Ordinal.le_add_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 aleph0 \u2264 aleph o"}, {"line": "rw [aleph_eq_preAleph]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 aleph0 \u2264 preAleph (omega0 + o)"}, {"line": "rw [aleph0_le_preAleph]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 omega0 \u2264 omega0 + o"}, {"line": "apply Ordinal.le_add_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_range_aleph_iff {c : Cardinal} : c \u2208 range aleph \u2194 \u2135\u2080 \u2264 c := by\n  rw [range_aleph]\n  rw [mem_Ici]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c \u2208 range \u21d1aleph \u2194 aleph0 \u2264 c"}, {"line": "rw [range_aleph]", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c \u2208 Ici aleph0 \u2194 aleph0 \u2264 c"}, {"line": "rw [mem_Ici]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_aleph0 : succ \u2135\u2080 = \u2135\u2081 := by\n  rw [\u2190 aleph_zero]\n  rw [\u2190 aleph_succ]\n  rw [Ordinal.succ_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 succ aleph0 = aleph 1"}, {"line": "rw [\u2190 aleph_zero]", "tactic_state": "\u22a2 succ (aleph 0) = aleph 1"}, {"line": "rw [\u2190 aleph_succ]", "tactic_state": "\u22a2 aleph (succ 0) = aleph 1"}, {"line": "rw [Ordinal.succ_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_lt_aleph_one : \u2135\u2080 < \u2135\u2081 := by\n  rw [\u2190 succ_aleph0]\n  apply lt_succ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 aleph0 < aleph 1"}, {"line": "rw [\u2190 succ_aleph0]", "tactic_state": "\u22a2 aleph0 < succ aleph0"}, {"line": "apply lt_succ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem countable_iff_lt_aleph_one {\u03b1 : Type*} (s : Set \u03b1) : s.Countable \u2194 #s < \u2135\u2081 := by\n  rw [\u2190 succ_aleph0]\n  rw [lt_succ_iff]\n  rw [le_aleph0_iff_set_countable]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s.Countable \u2194 Cardinal.mk \u2191s < aleph 1"}, {"line": "rw [\u2190 succ_aleph0]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s.Countable \u2194 Cardinal.mk \u2191s < succ aleph0"}, {"line": "rw [lt_succ_iff]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s.Countable \u2194 Cardinal.mk \u2191s \u2264 aleph0"}, {"line": "rw [le_aleph0_iff_set_countable]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph1_le_lift {c : Cardinal.{u}} : \u2135\u2081 \u2264 lift.{v} c \u2194 \u2135\u2081 \u2264 c := by\n  simpa using lift_le (a := \u2135\u2081)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 aleph 1 \u2264 Cardinal.lift.{v, u} c \u2194 aleph 1 \u2264 c"}, {"line": "simpa using lift_le (a := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_le_aleph1 {c : Cardinal.{u}} : lift.{v} c \u2264 \u2135\u2081 \u2194 c \u2264 \u2135\u2081 := by\n  simpa using lift_le (b := \u2135\u2081)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 Cardinal.lift.{v, u} c \u2264 aleph 1 \u2194 c \u2264 aleph 1"}, {"line": "simpa using lift_le (b := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph1_lt_lift {c : Cardinal.{u}} : \u2135\u2081 < lift.{v} c \u2194 \u2135\u2081 < c := by\n  simpa using lift_lt (a := \u2135\u2081)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 aleph 1 < Cardinal.lift.{v, u} c \u2194 aleph 1 < c"}, {"line": "simpa using lift_lt (a := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_lt_aleph1 {c : Cardinal.{u}} : lift.{v} c < \u2135\u2081 \u2194 c < \u2135\u2081 := by\n  simpa using lift_lt (b := \u2135\u2081)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 Cardinal.lift.{v, u} c < aleph 1 \u2194 c < aleph 1"}, {"line": "simpa using lift_lt (b := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph1_eq_lift {c : Cardinal.{u}} : \u2135\u2081 = lift.{v} c \u2194 \u2135\u2081 = c := by\n  simpa using lift_inj (a := \u2135\u2081)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 aleph 1 = Cardinal.lift.{v, u} c \u2194 aleph 1 = c"}, {"line": "simpa using lift_inj (a := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_eq_aleph1 {c : Cardinal.{u}} : lift.{v} c = \u2135\u2081 \u2194 c = \u2135\u2081 := by\n  simpa using lift_inj (b := \u2135\u2081)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 Cardinal.lift.{v, u} c = aleph 1 \u2194 c = aleph 1"}, {"line": "simpa using lift_inj (b := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_omega_iff_card_lt {x o : Ordinal} : x < \u03c9_ o \u2194 x.card < \u2135_ o := by\n  rw [\u2190 (isInitial_omega o).card_lt_card]\n  rw [card_omega]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x o : Ordinal.{u_1}\n\u22a2 x < omega o \u2194 x.card < aleph o"}, {"line": "rw [\u2190 (isInitial_omega o).card_lt_card]", "tactic_state": "x o : Ordinal.{u_1}\n\u22a2 x.card < (omega o).card \u2194 x.card < aleph o"}, {"line": "rw [card_omega]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preBeth_zero : preBeth 0 = 0 := by\n  rw [preBeth]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preBeth 0 = 0"}, {"line": "rw [preBeth]", "tactic_state": "\u22a2 \u2a06 a, 2 ^ preBeth \u2191a = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preBeth_one : preBeth 1 = 1 := by\n  simpa using preBeth_nat 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preBeth 1 = 1"}, {"line": "simpa using preBeth_nat 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preBeth_pos {o : Ordinal} : 0 < preBeth o \u2194 0 < o := by\n  simpa using preBeth_lt_preBeth (o\u2081 := 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 0 < preBeth o \u2194 0 < o"}, {"line": "simpa using preBeth_lt_preBeth (o\u2081 := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem beth_zero : \u2136_ 0 = \u2135\u2080 := by\n  simp [beth]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 beth 0 = aleph0"}, {"line": "simp [beth]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem beth_succ (o : Ordinal) : \u2136_ (succ o) = 2 ^ \u2136_ o := by\n  simp [beth, add_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 beth (succ o) = 2 ^ beth o"}, {"line": "simp [beth, add_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph_mul_aleph (o\u2081 o\u2082 : Ordinal) : \u2135_ o\u2081 * \u2135_ o\u2082 = \u2135_ (max o\u2081 o\u2082) := by\n  rw [Cardinal.mul_eq_max (aleph0_le_aleph o\u2081) (aleph0_le_aleph o\u2082)]\n  rw [aleph_max]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o\u2081 o\u2082 : Ordinal.{u_1}\n\u22a2 aleph o\u2081 * aleph o\u2082 = aleph (max o\u2081 o\u2082)"}, {"line": "rw [Cardinal.mul_eq_max (aleph0_le_aleph o\u2081) (aleph0_le_aleph o\u2082)]", "tactic_state": "o\u2081 o\u2082 : Ordinal.{u_1}\n\u22a2 max (aleph o\u2081) (aleph o\u2082) = aleph (max o\u2081 o\u2082)"}, {"line": "rw [aleph_max]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_max_of_aleph0_le_left {a b : Cardinal} (h : \u2135\u2080 \u2264 a) : a * b \u2264 max a b := by\n  convert mul_le_mul' (le_max_left a b) (le_max_right a b) using 1\n  rw [mul_eq_self]\n  exact h.trans (le_max_left a b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : aleph0 \u2264 a\n\u22a2 a * b \u2264 max a b"}, {"line": "convert mul_le_mul' (le_max_left a b) (le_max_right a b) using 1", "tactic_state": "case h.e'_4\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\n\u22a2 max a b = max a b * max a b"}, {"line": "rw [mul_eq_self]", "tactic_state": "case h.e'_4\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\n\u22a2 aleph0 \u2264 max a b"}, {"line": "exact h.trans (le_max_left a b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_max_of_aleph0_le_left {a b : Cardinal} (h : \u2135\u2080 \u2264 a) (h' : b \u2260 0) :\n    a * b = max a b := by\n  rcases le_or_lt \u2135\u2080 b with hb | hb\n  \u00b7 exact mul_eq_max h hb\n  refine (mul_le_max_of_aleph0_le_left h).antisymm ?_\n  have : b \u2264 a := hb.le.trans h\n  rw [max_eq_left this]\n  convert mul_le_mul_left' (one_le_iff_ne_zero.mpr h') a\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\n\u22a2 a * b = max a b"}, {"line": "rcases le_or_lt \u2135\u2080 b with hb | hb", "tactic_state": "case inl\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : sorry \u2264 b\n\u22a2 a * b = max a b\n---\ncase inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\n\u22a2 a * b = max a b"}, {"line": "\u00b7 exact mul_eq_max h hb", "tactic_state": "case inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\n\u22a2 a * b = max a b"}, {"line": "refine (mul_le_max_of_aleph0_le_left h).antisymm ?_", "tactic_state": "case inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\n\u22a2 max a b \u2264 a * b"}, {"line": "have : b \u2264 a := hb.le.trans h", "tactic_state": "case inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\nthis : b \u2264 a\n\u22a2 max a b \u2264 a * b"}, {"line": "rw [max_eq_left this]", "tactic_state": "case inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\nthis : b \u2264 a\n\u22a2 a \u2264 a * b"}, {"line": "convert mul_le_mul_left' (one_le_iff_ne_zero.mpr h') a", "tactic_state": "case h.e'_3\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\nthis : b \u2264 a\n\u22a2 a = a * 1"}, {"line": "rw [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_max_of_aleph0_le_right {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a * b \u2264 max a b := by\n  simpa only [mul_comm b,max_comm b] using mul_le_max_of_aleph0_le_left h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : aleph0 \u2264 b\n\u22a2 a * b \u2264 max a b"}, {"line": "simpa only [mul_comm b,max_comm b] using mul_le_max_of_aleph0_le_left h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_max_of_aleph0_le_right {a b : Cardinal} (h' : a \u2260 0) (h : \u2135\u2080 \u2264 b) :\n    a * b = max a b := by\n  rw [mul_comm]\n  rw [max_comm]\n  exact mul_eq_max_of_aleph0_le_left h h'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh' : a \u2260 0\nh : aleph0 \u2264 b\n\u22a2 a * b = max a b"}, {"line": "rw [mul_comm]", "tactic_state": "a b : Cardinal.{u_1}\nh' : a \u2260 0\nh : aleph0 \u2264 b\n\u22a2 b * a = max a b"}, {"line": "rw [max_comm]", "tactic_state": "a b : Cardinal.{u_1}\nh' : a \u2260 0\nh : aleph0 \u2264 b\n\u22a2 b * a = max b a"}, {"line": "exact mul_eq_max_of_aleph0_le_left h h'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_max' {a b : Cardinal} (h : \u2135\u2080 \u2264 a * b) : a * b = max a b := by\n  rcases aleph0_le_mul_iff.mp h with \u27e8ha, hb, ha' | hb'\u27e9\n  \u00b7 exact mul_eq_max_of_aleph0_le_left ha' hb\n  \u00b7 exact mul_eq_max_of_aleph0_le_right ha hb'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : aleph0 \u2264 a * b\n\u22a2 a * b = max a b"}, {"line": "rcases aleph0_le_mul_iff.mp h with \u27e8ha, hb, ha' | hb'\u27e9", "tactic_state": "case intro.intro.inl\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a * b\nha : a \u2260 0\nhb : b \u2260 0\nha' : aleph0 \u2264 a\n\u22a2 a * b = max a b\n---\ncase intro.intro.inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a * b\nha : a \u2260 0\nhb : b \u2260 0\nhb' : aleph0 \u2264 b\n\u22a2 a * b = max a b"}, {"line": "\u00b7 exact mul_eq_max_of_aleph0_le_left ha' hb", "tactic_state": "case intro.intro.inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a * b\nha : a \u2260 0\nhb : b \u2260 0\nhb' : aleph0 \u2264 b\n\u22a2 a * b = max a b"}, {"line": "\u00b7 exact mul_eq_max_of_aleph0_le_right ha hb'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_left {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 a) (hb' : b \u2260 0) : a * b = a := by\n  rw [mul_eq_max_of_aleph0_le_left ha hb']\n  rw [max_eq_left hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nhb : b \u2264 a\nhb' : b \u2260 0\n\u22a2 a * b = a"}, {"line": "rw [mul_eq_max_of_aleph0_le_left ha hb']", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nhb : b \u2264 a\nhb' : b \u2260 0\n\u22a2 max a b = a"}, {"line": "rw [max_eq_left hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_right {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (ha : a \u2264 b) (ha' : a \u2260 0) : a * b = b := by\n  rw [mul_comm]\n  rw [mul_eq_left hb ha ha']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nhb : aleph0 \u2264 b\nha : a \u2264 b\nha' : a \u2260 0\n\u22a2 a * b = b"}, {"line": "rw [mul_comm]", "tactic_state": "a b : Cardinal.{u_1}\nhb : aleph0 \u2264 b\nha : a \u2264 b\nha' : a \u2260 0\n\u22a2 b * a = b"}, {"line": "rw [mul_eq_left hb ha ha']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_mul_left {a b : Cardinal} (h : b \u2260 0) : a \u2264 b * a := by\n  convert mul_le_mul_right' (one_le_iff_ne_zero.mpr h) a\n  rw [one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : b \u2260 0\n\u22a2 a \u2264 b * a"}, {"line": "convert mul_le_mul_right' (one_le_iff_ne_zero.mpr h) a", "tactic_state": "case h.e'_3\na b : Cardinal.{u_1}\nh : b \u2260 0\n\u22a2 a = 1 * a"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_mul_right {a b : Cardinal} (h : b \u2260 0) : a \u2264 a * b := by\n  rw [mul_comm]\n  exact le_mul_left h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : b \u2260 0\n\u22a2 a \u2264 a * b"}, {"line": "rw [mul_comm]", "tactic_state": "a b : Cardinal.{u_1}\nh : b \u2260 0\n\u22a2 a \u2264 b * a"}, {"line": "exact le_mul_left h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_max' {a b : Cardinal} (ha : \u2135\u2080 \u2264 b) : a + b = max a b := by\n  rw [add_comm]\n  rw [max_comm]\n  rw [add_eq_max ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 b\n\u22a2 a + b = max a b"}, {"line": "rw [add_comm]", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 b\n\u22a2 b + a = max a b"}, {"line": "rw [max_comm]", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 b\n\u22a2 b + a = max b a"}, {"line": "rw [add_eq_max ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_left {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 a) : a + b = a := by\n  rw [add_eq_max ha]\n  rw [max_eq_left hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nhb : b \u2264 a\n\u22a2 a + b = a"}, {"line": "rw [add_eq_max ha]", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nhb : b \u2264 a\n\u22a2 max a b = a"}, {"line": "rw [max_eq_left hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_right {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (ha : a \u2264 b) : a + b = b := by\n  rw [add_comm]\n  rw [add_eq_left hb ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nhb : aleph0 \u2264 b\nha : a \u2264 b\n\u22a2 a + b = b"}, {"line": "rw [add_comm]", "tactic_state": "a b : Cardinal.{u_1}\nhb : aleph0 \u2264 b\nha : a \u2264 b\n\u22a2 b + a = b"}, {"line": "rw [add_eq_left hb ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_right_iff {a b : Cardinal} : a + b = b \u2194 max \u2135\u2080 a \u2264 b \u2228 a = 0 := by\n  rw [add_comm]\n  rw [add_eq_left_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\n\u22a2 a + b = b \u2194 max aleph0 a \u2264 b \u2228 a = 0"}, {"line": "rw [add_comm]", "tactic_state": "a b : Cardinal.{u_1}\n\u22a2 b + a = b \u2194 max aleph0 a \u2264 b \u2228 a = 0"}, {"line": "rw [add_eq_left_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_add_eq {a : Cardinal} (n : \u2115) (ha : \u2135\u2080 \u2264 a) : n + a = a := by\n  rw [add_comm]\n  rw [add_nat_eq n ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Cardinal.{u_1}\nn : \u2115\nha : aleph0 \u2264 a\n\u22a2 \u2191n + a = a"}, {"line": "rw [add_comm]", "tactic_state": "a : Cardinal.{u_1}\nn : \u2115\nha : aleph0 \u2264 a\n\u22a2 a + \u2191n = a"}, {"line": "rw [add_nat_eq n ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_eq_iSup_lift {f : \u03b9 \u2192 Cardinal.{max u v}} (h\u03b9 : \u2135\u2080 \u2264 #\u03b9)\n    (h : lift.{v} #\u03b9 \u2264 iSup f) : sum f = iSup f := by\n  apply (iSup_le_sum f).antisymm'\n  convert sum_le_iSup_lift f\n  rw [mul_eq_max (aleph0_le_lift.mpr h\u03b9) ((aleph0_le_lift.mpr h\u03b9).trans h)]\n  rw [max_eq_right h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{max u v}\nh\u03b9 : aleph0 \u2264 Cardinal.mk \u03b9\nh : Cardinal.lift.{v, u} (Cardinal.mk \u03b9) \u2264 iSup f\n\u22a2 sum f = iSup f"}, {"line": "apply (iSup_le_sum f).antisymm'", "tactic_state": "\u03b9 : Type u\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{max u v}\nh\u03b9 : aleph0 \u2264 Cardinal.mk \u03b9\nh : Cardinal.lift.{v, u} (Cardinal.mk \u03b9) \u2264 iSup f\n\u22a2 sum f \u2264 iSup f"}, {"line": "convert sum_le_iSup_lift f", "tactic_state": "case h.e'_4\n\u03b9 : Type u\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{max u v}\nh\u03b9 : aleph0 \u2264 Cardinal.mk \u03b9\nh : Cardinal.lift.{v, u} (Cardinal.mk \u03b9) \u2264 iSup f\n\u22a2 iSup f = Cardinal.lift.{v, u} (Cardinal.mk \u03b9) * iSup f"}, {"line": "rw [mul_eq_max (aleph0_le_lift.mpr h\u03b9) ((aleph0_le_lift.mpr h\u03b9).trans h)]", "tactic_state": "case h.e'_4\n\u03b9 : Type u\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{max u v}\nh\u03b9 : aleph0 \u2264 Cardinal.mk \u03b9\nh : Cardinal.lift.{v, u} (Cardinal.mk \u03b9) \u2264 iSup f\n\u22a2 iSup f = max (Cardinal.lift.{v, u} (Cardinal.mk \u03b9)) (iSup f)"}, {"line": "rw [max_eq_right h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph_add_aleph (o\u2081 o\u2082 : Ordinal) : \u2135_ o\u2081 + \u2135_ o\u2082 = \u2135_ (max o\u2081 o\u2082) := by\n  rw [Cardinal.add_eq_max (aleph0_le_aleph o\u2081)]\n  rw [aleph_max]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o\u2081 o\u2082 : Ordinal.{u_1}\n\u22a2 aleph o\u2081 + aleph o\u2082 = aleph (max o\u2081 o\u2082)"}, {"line": "rw [Cardinal.add_eq_max (aleph0_le_aleph o\u2081)]", "tactic_state": "o\u2081 o\u2082 : Ordinal.{u_1}\n\u22a2 max (aleph o\u2081) (aleph o\u2082) = aleph (max o\u2081 o\u2082)"}, {"line": "rw [aleph_max]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_le_add_iff_of_lt_aleph0 {\u03b1 \u03b2 \u03b3 : Cardinal} (\u03b3\u2080 : \u03b3 < \u2135\u2080) :\n    \u03b1 + \u03b3 \u2264 \u03b2 + \u03b3 \u2194 \u03b1 \u2264 \u03b2 := by\n  refine \u27e8fun h => ?_, fun h => add_le_add_right h \u03b3\u27e9\n  contrapose h\n  rw [not_le] at h \u22a2\n  rw [lt_iff_le_and_ne] at h \u22a2\n  rw [Ne] at h \u22a2\n  exact \u27e8add_le_add_right h.1 \u03b3, mt (add_right_inj_of_lt_aleph0 \u03b3\u2080).1 h.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\n\u22a2 \u03b1 + \u03b3 \u2264 \u03b2 + \u03b3 \u2194 \u03b1 \u2264 \u03b2"}, {"line": "refine \u27e8fun h => ?_, fun h => add_le_add_right h \u03b3\u27e9", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\nh : \u03b1 + \u03b3 \u2264 \u03b2 + \u03b3\n\u22a2 \u03b1 \u2264 \u03b2"}, {"line": "contrapose h", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\nh : \u00ac\u03b1 \u2264 \u03b2\n\u22a2 \u00ac\u03b1 + \u03b3 \u2264 \u03b2 + \u03b3"}, {"line": "rw [not_le] at h \u22a2", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\nh : \u03b2 < \u03b1\n\u22a2 \u03b2 + \u03b3 < \u03b1 + \u03b3"}, {"line": "rw [lt_iff_le_and_ne] at h \u22a2", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\nh : \u03b2 \u2264 \u03b1 \u2227 \u03b2 \u2260 \u03b1\n\u22a2 \u03b2 + \u03b3 \u2264 \u03b1 + \u03b3 \u2227 \u03b2 + \u03b3 \u2260 \u03b1 + \u03b3"}, {"line": "rw [Ne] at h \u22a2", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\nh : \u03b2 \u2264 \u03b1 \u2227 \u00ac\u03b2 = \u03b1\n\u22a2 \u03b2 + \u03b3 \u2264 \u03b1 + \u03b3 \u2227 \u00ac\u03b2 + \u03b3 = \u03b1 + \u03b3"}, {"line": "exact \u27e8add_le_add_right h.1 \u03b3, mt (add_right_inj_of_lt_aleph0 \u03b3\u2080).1 h.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem power_nat_le_max {c : Cardinal.{u}} {n : \u2115} : c ^ (n : Cardinal.{u}) \u2264 max c \u2135\u2080 := by\n  rcases le_or_lt \u2135\u2080 c with hc | hc\n  \u00b7 exact le_max_of_le_left (power_nat_le hc)\n  \u00b7 exact le_max_of_le_right (power_lt_aleph0 hc (nat_lt_aleph0 _)).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\nn : \u2115\n\u22a2 c ^ \u2191n \u2264 max c aleph0"}, {"line": "rcases le_or_lt \u2135\u2080 c with hc | hc", "tactic_state": "case inl\nc : Cardinal.{u}\nn : \u2115\nhc : sorry \u2264 c\n\u22a2 c ^ \u2191n \u2264 max c aleph0\n---\ncase inr\nc : Cardinal.{u}\nn : \u2115\nhc : c < sorry\n\u22a2 c ^ \u2191n \u2264 max c aleph0"}, {"line": "\u00b7 exact le_max_of_le_left (power_nat_le hc)", "tactic_state": "case inr\nc : Cardinal.{u}\nn : \u2115\nhc : c < sorry\n\u22a2 c ^ \u2191n \u2264 max c aleph0"}, {"line": "\u00b7 exact le_max_of_le_right (power_lt_aleph0 hc (nat_lt_aleph0 _)).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_equiv_eq_zero_iff_lift_ne : #(\u03b1 \u2243 \u03b2') = 0 \u2194 lift.{v} #\u03b1 \u2260 lift.{u} #\u03b2' := by\n  rw [mk_eq_zero_iff]\n  rw [\u2190 not_nonempty_iff]\n  rw [\u2190 lift_mk_eq']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk (\u03b1 \u2243 \u03b2') = 0 \u2194 Cardinal.lift.{v, u} (Cardinal.mk \u03b1) \u2260 Cardinal.lift.{u, v} (Cardinal.mk \u03b2')"}, {"line": "rw [mk_eq_zero_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 IsEmpty (\u03b1 \u2243 \u03b2') \u2194 Cardinal.lift.{v, u} (Cardinal.mk \u03b1) \u2260 Cardinal.lift.{u, v} (Cardinal.mk \u03b2')"}, {"line": "rw [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 \u00acNonempty (\u03b1 \u2243 \u03b2') \u2194 Cardinal.lift.{v, u} (Cardinal.mk \u03b1) \u2260 Cardinal.lift.{u, v} (Cardinal.mk \u03b2')"}, {"line": "rw [\u2190 lift_mk_eq']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_embedding_eq_zero_iff_lift_lt : #(\u03b1 \u21aa \u03b2') = 0 \u2194 lift.{u} #\u03b2' < lift.{v} #\u03b1 := by\n  rw [mk_eq_zero_iff]\n  rw [\u2190 not_nonempty_iff]\n  rw [\u2190 lift_mk_le']\n  rw [not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk (\u03b1 \u21aa \u03b2') = 0 \u2194 Cardinal.lift.{u, v} (Cardinal.mk \u03b2') < Cardinal.lift.{v, u} (Cardinal.mk \u03b1)"}, {"line": "rw [mk_eq_zero_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 IsEmpty (\u03b1 \u21aa \u03b2') \u2194 Cardinal.lift.{u, v} (Cardinal.mk \u03b2') < Cardinal.lift.{v, u} (Cardinal.mk \u03b1)"}, {"line": "rw [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 \u00acNonempty (\u03b1 \u21aa \u03b2') \u2194 Cardinal.lift.{u, v} (Cardinal.mk \u03b2') < Cardinal.lift.{v, u} (Cardinal.mk \u03b1)"}, {"line": "rw [\u2190 lift_mk_le']", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 \u00acCardinal.lift.{v, u} (Cardinal.mk \u03b1) \u2264 Cardinal.lift.{u, v} (Cardinal.mk \u03b2') \u2194\n    Cardinal.lift.{u, v} (Cardinal.mk \u03b2') < Cardinal.lift.{v, u} (Cardinal.mk \u03b1)"}, {"line": "rw [not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_arrow_eq_zero_iff : #(\u03b1 \u2192 \u03b2') = 0 \u2194 #\u03b1 \u2260 0 \u2227 #\u03b2' = 0 := by\n  simp_rw [mk_eq_zero_iff, mk_ne_zero_iff, isEmpty_fun]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk (\u03b1 \u2192 \u03b2') = 0 \u2194 Cardinal.mk \u03b1 \u2260 0 \u2227 Cardinal.mk \u03b2' = 0"}, {"line": "simp_rw [mk_eq_zero_iff, mk_ne_zero_iff, isEmpty_fun]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_surjective_eq_zero_iff_lift :\n    #{f : \u03b1 \u2192 \u03b2' | Surjective f} = 0 \u2194 lift.{v} #\u03b1 < lift.{u} #\u03b2' \u2228 (#\u03b1 \u2260 0 \u2227 #\u03b2' = 0) := by\n  rw [\u2190 not_iff_not]\n  rw [not_or]\n  rw [not_lt]\n  rw [lift_mk_le']\n  rw [\u2190 Ne]\n  rw [not_and_or]\n  rw [not_ne_iff]\n  rw [and_comm]\n  simp_rw [mk_ne_zero_iff, mk_eq_zero_iff, nonempty_coe_sort,\n    Set.Nonempty, mem_setOf, exists_surjective_iff, nonempty_fun]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk \u2191{f | Surjective f} = 0 \u2194\n    Cardinal.lift.{v, u} (Cardinal.mk \u03b1) < Cardinal.lift.{u, v} (Cardinal.mk \u03b2') \u2228\n      Cardinal.mk \u03b1 \u2260 0 \u2227 Cardinal.mk \u03b2' = 0"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 \u00acCardinal.mk \u2191{f | Surjective f} = 0 \u2194\n    \u00ac(Cardinal.lift.{v, u} (Cardinal.mk \u03b1) < Cardinal.lift.{u, v} (Cardinal.mk \u03b2') \u2228\n        Cardinal.mk \u03b1 \u2260 0 \u2227 Cardinal.mk \u03b2' = 0)"}, {"line": "rw [not_or]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 \u00acCardinal.mk \u2191{f | Surjective f} = 0 \u2194\n    \u00acCardinal.lift.{v, u} (Cardinal.mk \u03b1) < Cardinal.lift.{u, v} (Cardinal.mk \u03b2') \u2227\n      \u00ac(Cardinal.mk \u03b1 \u2260 0 \u2227 Cardinal.mk \u03b2' = 0)"}, {"line": "rw [not_lt]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 \u00acCardinal.mk \u2191{f | Surjective f} = 0 \u2194\n    Cardinal.lift.{u, v} (Cardinal.mk \u03b2') \u2264 Cardinal.lift.{v, u} (Cardinal.mk \u03b1) \u2227\n      \u00ac(Cardinal.mk \u03b1 \u2260 0 \u2227 Cardinal.mk \u03b2' = 0)"}, {"line": "rw [lift_mk_le']", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 \u00acCardinal.mk \u2191{f | Surjective f} = 0 \u2194 Nonempty (\u03b2' \u21aa \u03b1) \u2227 \u00ac(Cardinal.mk \u03b1 \u2260 0 \u2227 Cardinal.mk \u03b2' = 0)"}, {"line": "rw [\u2190 Ne]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk \u2191{f | Surjective f} \u2260 0 \u2194 Nonempty (\u03b2' \u21aa \u03b1) \u2227 \u00ac(Cardinal.mk \u03b1 \u2260 0 \u2227 Cardinal.mk \u03b2' = 0)"}, {"line": "rw [not_and_or]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk \u2191{f | Surjective f} \u2260 0 \u2194 Nonempty (\u03b2' \u21aa \u03b1) \u2227 (\u00acCardinal.mk \u03b1 \u2260 0 \u2228 \u00acCardinal.mk \u03b2' = 0)"}, {"line": "rw [not_ne_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk \u2191{f | Surjective f} \u2260 0 \u2194 Nonempty (\u03b2' \u21aa \u03b1) \u2227 (Cardinal.mk \u03b1 = 0 \u2228 \u00acCardinal.mk \u03b2' = 0)"}, {"line": "rw [and_comm]", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk \u2191{f | Surjective f} \u2260 0 \u2194 (Cardinal.mk \u03b1 = 0 \u2228 \u00acCardinal.mk \u03b2' = 0) \u2227 Nonempty (\u03b2' \u21aa \u03b1)"}, {"line": "simp_rw [mk_ne_zero_iff, mk_eq_zero_iff, nonempty_coe_sort,\n    Set.Nonempty, mem_setOf, exists_surjective_iff, nonempty_fun]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_list_eq_mk (\u03b1 : Type u) [Infinite \u03b1] : #(List \u03b1) = #\u03b1 :=\n  have H1 : \u2135\u2080 \u2264 #\u03b1 := aleph0_le_mk \u03b1\n  Eq.symm <|\n    le_antisymm ((le_def _ _).2 \u27e8\u27e8fun a => [a], fun _ => by simp\u27e9\u27e9) <|\n      calc\n        #(List \u03b1) = sum fun n : \u2115 => #\u03b1 ^ (n : Cardinal.{u}) := mk_list_eq_sum_pow \u03b1\n        _ \u2264 sum fun _ : \u2115 => #\u03b1 := sum_le_sum _ _ fun n => pow_le H1 <| nat_lt_aleph0 n\n        _ = #\u03b1 := by simp [H1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}", "(\u03b1 \u03b2')", "[Infinite \u03b1] {\u03b1 \u03b2'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Infinite \u03b1\nH1 : aleph0 \u2264 Cardinal.mk \u03b1\n\u22a2 (sum fun x => Cardinal.mk \u03b1) = Cardinal.mk \u03b1"}, {"line": "simp [H1]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_compl_of_infinite {\u03b1 : Type*} [Infinite \u03b1] (s : Set \u03b1) (h2 : #s < #\u03b1) :\n    #(s\u1d9c : Set \u03b1) = #\u03b1 := by\n  refine eq_of_add_eq_of_aleph0_le ?_ h2 (aleph0_le_mk \u03b1)\n  exact mk_sum_compl s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}", "(\u03b1 \u03b2')", "[Infinite \u03b1] {\u03b1 \u03b2'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Infinite \u03b1\ns : Set \u03b1\nh2 : Cardinal.mk \u2191s < Cardinal.mk \u03b1\n\u22a2 Cardinal.mk \u2191s\u1d9c = Cardinal.mk \u03b1"}, {"line": "refine eq_of_add_eq_of_aleph0_le ?_ h2 (aleph0_le_mk \u03b1)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Infinite \u03b1\ns : Set \u03b1\nh2 : Cardinal.mk \u2191s < Cardinal.mk \u03b1\n\u22a2 Cardinal.mk \u2191s + Cardinal.mk \u2191s\u1d9c = Cardinal.mk \u03b1"}, {"line": "exact mk_sum_compl s", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iInf_eq_zero_iff {\u03b9 : Sort*} {f : \u03b9 \u2192 Cardinal} :\n    (\u2a05 i, f i) = 0 \u2194 IsEmpty \u03b9 \u2228 \u2203 i, f i = 0 := by\n  simp [iInf, sInf_eq_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 Cardinal.{u_2}\n\u22a2 \u2a05 i, f i = 0 \u2194 IsEmpty \u03b9 \u2228 \u2203 i, f i = 0"}, {"line": "simp [iInf, sInf_eq_zero_iff]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 Cardinal.{u_2}\n\u22a2 sInf (range fun i => f i) = 0 \u2194 IsEmpty \u03b9 \u2228 \u2203 i, f i = 0"}]}
{"declaration": "theorem bddAbove_range_comp {\u03b9 : Type u} {f : \u03b9 \u2192 Cardinal.{v}} (hf : BddAbove (range f))\n    (g : Cardinal.{v} \u2192 Cardinal.{max v w}) : BddAbove (range (g \u2218 f)) := by\n  rw [range_comp]\n  exact bddAbove_image g hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : BddAbove (range f)\ng : Cardinal.{v} \u2192 Cardinal.{max v w}\n\u22a2 BddAbove (range (g \u2218 f))"}, {"line": "rw [range_comp]", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : BddAbove (range f)\ng : Cardinal.{v} \u2192 Cardinal.{max v w}\n\u22a2 BddAbove (g '' range f)"}, {"line": "exact bddAbove_image g hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succ_natCast (n : \u2115) : Order.succ (n : Cardinal) = n + 1 := by\n  rw [\u2190 Cardinal.nat_succ]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 succ \u2191n = \u2191n + 1"}, {"line": "rw [\u2190 Cardinal.nat_succ]", "tactic_state": "n : \u2115\n\u22a2 \u2191n.succ = \u2191n + 1"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natCast_add_one_le_iff {n : \u2115} {c : Cardinal} : n + 1 \u2264 c \u2194 n < c := by\n  rw [\u2190 Order.succ_le_iff]\n  rw [Cardinal.succ_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u2191n + 1 \u2264 c \u2194 \u2191n < c"}, {"line": "rw [\u2190 Order.succ_le_iff]", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u2191n + 1 \u2264 c \u2194 succ \u2191n \u2264 c"}, {"line": "rw [Cardinal.succ_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_zero : succ (0 : Cardinal) = 1 := by norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 succ 0 = 1"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_two : (1 : Cardinal) < 2 := by norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 < 2"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantor' (a) {b : Cardinal} (hb : 1 < b) : a < b ^ a := by\n  rw [\u2190 succ_le_iff] at hb\n  rw [(by norm_cast : succ (1 : Cardinal) = 2)] at hb\n  exact (cantor a).trans_le (power_le_power_right hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nhb : 1 < b\n\u22a2 a < b ^ a"}, {"line": "rw [\u2190 succ_le_iff] at hb", "tactic_state": "a b : Cardinal.{u_1}\nhb : succ 1 \u2264 b\n\u22a2 a < b ^ a"}, {"line": "rw [(by norm_cast : succ (1 : Cardinal) = 2)] at hb", "tactic_state": "a b : Cardinal.{u_1}\nhb : 2 \u2264 b\n\u22a2 a < b ^ a"}, {"line": "exact (cantor a).trans_le (power_le_power_right hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_iff_ne_zero {c : Cardinal} : 1 \u2264 c \u2194 c \u2260 0 := by\n  rw [one_le_iff_pos]\n  rw [pos_iff_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 1 \u2264 c \u2194 c \u2260 0"}, {"line": "rw [one_le_iff_pos]", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 0 < c \u2194 c \u2260 0\n---\nc : Cardinal.{u_1}\n\u22a2 SuccAddOrder Cardinal.{u_1}"}, {"line": "rw [pos_iff_ne_zero]", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 SuccAddOrder Cardinal.{u_1}"}]}
{"declaration": "theorem lt_one_iff_zero {c : Cardinal} : c < 1 \u2194 c = 0 := by\n  simpa using lt_succ_bot_iff (a := c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c < 1 \u2194 c = 0"}, {"line": "simpa using lt_succ_bot_iff (a := c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_aleph0 : 1 < \u2135\u2080 := by simpa using nat_lt_aleph0 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 : \u2115\n\u22a2 1 < \u2135\u2080"}, {"line": "simpa using nat_lt_aleph0 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_le_of_isSuccLimit {c : Cardinal} (h : IsSuccLimit c) : \u2135\u2080 \u2264 c := by\n  contrapose! h\n  exact not_isSuccLimit_of_lt_aleph0 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 c : Cardinal.{u_1}\nh : IsSuccLimit c\n\u22a2 \u2135\u2080 \u2264 c"}, {"line": "contrapose! h", "tactic_state": "\u2135\u2080 c : Cardinal.{u_1}\nh : c < \u2135\u2080\n\u22a2 \u00acIsSuccLimit c"}, {"line": "exact not_isSuccLimit_of_lt_aleph0 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Set.countable_infinite_iff_nonempty_denumerable {\u03b1 : Type*} {s : Set \u03b1} :\n    s.Countable \u2227 s.Infinite \u2194 Nonempty (Denumerable s) := by\n  rw [nonempty_denumerable_iff]\n  rw [\u2190 Set.infinite_coe_iff]\n  rw [countable_coe_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s.Countable \u2227 s.Infinite \u2194 Nonempty (Denumerable \u2191s)"}, {"line": "rw [nonempty_denumerable_iff]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s.Countable \u2227 s.Infinite \u2194 Countable \u2191s \u2227 Infinite \u2191s"}, {"line": "rw [\u2190 Set.infinite_coe_iff]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s.Countable \u2227 Infinite \u2191s \u2194 Countable \u2191s \u2227 Infinite \u2191s"}, {"line": "rw [countable_coe_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_nat_eq_of_le_nat {c : Cardinal} {n : \u2115} (h : c \u2264 n) : \u2203 m, m \u2264 n \u2227 c = m := by\n  lift c to \u2115 using h.trans_lt (nat_lt_aleph0 _)\n  exact \u27e8c, mod_cast h, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nn : \u2115\nh : c \u2264 \u2191n\n\u22a2 \u2203 m \u2264 n, c = \u2191m"}, {"line": "lift c to \u2115 using h.trans_lt (nat_lt_aleph0 _)", "tactic_state": "case intro\nn c : \u2115\nh : \u2191c \u2264 \u2191n\n\u22a2 \u2203 m \u2264 n, \u2191c = \u2191m"}, {"line": "exact \u27e8c, mod_cast h, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem powerlt_zero {a : Cardinal} : a ^< 0 = 0 := by\n  convert Cardinal.iSup_of_empty _\n  exact Subtype.isEmpty_of_false fun x => mem_Iio.not.mpr (Cardinal.zero_le x).not_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Cardinal.{u_1}\n\u22a2 a ^< 0 = 0"}, {"line": "convert Cardinal.iSup_of_empty _", "tactic_state": "case convert_3\na : Cardinal.{u_1}\n\u22a2 IsEmpty \u2191(Iio 0)"}, {"line": "exact Subtype.isEmpty_of_false fun x => mem_Iio.not.mpr (Cardinal.zero_le x).not_lt", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem cof_le_lift [IsRefl \u03b2 s] (f : r \u2243r s) :\n    Cardinal.lift.{v} (Order.cof r) \u2264 Cardinal.lift.{u} (Order.cof s) := by\n  rw [Order.cof]\n  rw [Order.cof]\n  rw [lift_sInf]\n  rw [lift_sInf]\n  rw [le_csInf_iff'' ((Order.cof_nonempty s).image _)]\n  rintro - \u27e8-, \u27e8u, H, rfl\u27e9, rfl\u27e9\n  apply csInf_le'\n  refine \u27e8_, \u27e8f.symm '' u, fun a => ?_, rfl\u27e9, lift_mk_eq'.2 \u27e8(f.symm.toEquiv.image u).symm\u27e9\u27e9\n  rcases H (f a) with \u27e8b, hb, hb'\u27e9\n  refine \u27e8f.symm b, mem_image_of_mem _ hb, f.map_rel_iff.1 ?_\u27e9\n  rwa [RelIso.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\n\u22a2 lift.{v, u} (cof r) \u2264 lift.{u, v} (cof s)"}, {"line": "rw [Order.cof]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\n\u22a2 lift.{v, u} (sInf {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}) \u2264 lift.{u, v} (cof s)"}, {"line": "rw [Order.cof]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\n\u22a2 lift.{v, u} (sInf {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}) \u2264\n    lift.{u, v} (sInf {c | \u2203 S, (\u2200 (a : \u03b2), \u2203 b \u2208 S, s a b) \u2227 mk \u2191S = c})"}, {"line": "rw [lift_sInf]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\n\u22a2 sInf (lift.{v, u} '' {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}) \u2264\n    lift.{u, v} (sInf {c | \u2203 S, (\u2200 (a : \u03b2), \u2203 b \u2208 S, s a b) \u2227 mk \u2191S = c})"}, {"line": "rw [lift_sInf]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\n\u22a2 sInf (lift.{v, u} '' {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}) \u2264\n    sInf (lift.{u, v} '' {c | \u2203 S, (\u2200 (a : \u03b2), \u2203 b \u2208 S, s a b) \u2227 mk \u2191S = c})"}, {"line": "rw [le_csInf_iff'' ((Order.cof_nonempty s).image _)]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\n\u22a2 \u2200 b \u2208 lift.{u, v} '' {c | \u2203 S, (\u2200 (a : \u03b2), \u2203 b \u2208 S, s a b) \u2227 mk \u2191S = c},\n    sInf (lift.{v, u} '' {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}) \u2264 b"}, {"line": "rintro - \u27e8-, \u27e8u, H, rfl\u27e9, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\n\u22a2 sInf (lift.{v, u} '' {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}) \u2264 lift.{u, v} (mk \u2191u)"}, {"line": "apply csInf_le'", "tactic_state": "case intro.intro.intro.intro.h\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\n\u22a2 lift.{u, v} (mk \u2191u) \u2208 lift.{v, u} '' {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}"}, {"line": "refine \u27e8_, \u27e8f.symm '' u, fun a => ?_, rfl\u27e9, lift_mk_eq'.2 \u27e8(f.symm.toEquiv.image u).symm\u27e9\u27e9", "tactic_state": "case intro.intro.intro.intro.h\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\na : \u03b1\n\u22a2 \u2203 b \u2208 \u21d1f.symm '' u, r a b"}, {"line": "rcases H (f a) with \u27e8b, hb, hb'\u27e9", "tactic_state": "case intro.intro.intro.intro.h.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\na : \u03b1\nb : \u03b2\nhb : b \u2208 u\nhb' : s (f a) b\n\u22a2 \u2203 b \u2208 \u21d1f.symm '' u, r a b"}, {"line": "refine \u27e8f.symm b, mem_image_of_mem _ hb, f.map_rel_iff.1 ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.h.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\na : \u03b1\nb : \u03b2\nhb : b \u2208 u\nhb' : s (f a) b\n\u22a2 s (f a) (f (f.symm b))"}, {"line": "rwa [RelIso.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cof_ord_le (c : Cardinal) : c.ord.cof \u2264 c := by simpa using cof_le_card c.ord\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c.ord.cof \u2264 c"}, {"line": "simpa using cof_le_card c.ord", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cof_preOmega {o : Ordinal} (ho : IsSuccPrelimit o) : (preOmega o).cof = o.cof := by\n  by_cases h : IsMin o\n  \u00b7 simp [h.eq_bot]\n  \u00b7 exact isNormal_preOmega.cof_eq \u27e8h, ho\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{a o : Ordinal.{u}} {f : \u2200 b < o, Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\npreOmega : x\u271d\no : Ordinal.{u_2}\nho : IsSuccPrelimit o\n\u22a2 sorry = o.cof"}, {"line": "by_cases h : IsMin o", "tactic_state": "case pos\nx\u271d : Sort u_1\npreOmega : x\u271d\no : Ordinal.{u_2}\nho : IsSuccPrelimit o\nh : IsMin o\n\u22a2 sorry = o.cof\n---\ncase neg\nx\u271d : Sort u_1\npreOmega : x\u271d\no : Ordinal.{u_2}\nho : IsSuccPrelimit o\nh : \u00acIsMin o\n\u22a2 sorry = o.cof"}, {"line": "\u00b7 simp [h.eq_bot]", "tactic_state": "case neg\nx\u271d : Sort u_1\npreOmega : x\u271d\no : Ordinal.{u_2}\nho : IsSuccPrelimit o\nh : \u00acIsMin o\n\u22a2 sorry = o.cof"}, {"line": "\u00b7 exact isNormal_preOmega.cof_eq \u27e8h, ho\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unbounded_of_unbounded_sUnion (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [wo : IsWellOrder \u03b1 r] {s : Set (Set \u03b1)}\n    (h\u2081 : Unbounded r <| \u22c3\u2080 s) (h\u2082 : #s < Order.cof (swap r\u1d9c)) : \u2203 x \u2208 s, Unbounded r x := by\n  by_contra! h\n  simp_rw [not_unbounded_iff] at h\n  let f : s \u2192 \u03b1 := fun x : s => wo.wf.sup x (h x.1 x.2)\n  refine h\u2082.not_le (le_trans (csInf_le' \u27e8range f, fun x => ?_, rfl\u27e9) mk_range_le)\n  rcases h\u2081 x with \u27e8y, \u27e8c, hc, hy\u27e9, hxy\u27e9\n  exact \u27e8f \u27e8c, hc\u27e9, mem_range_self _, fun hxz => hxy (Trans.trans (wo.wf.lt_sup _ hy) hxz)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{a o : Ordinal.{u}} {f : \u2200 b < o, Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\n\u22a2 \u2203 x \u2208 s, Unbounded r x"}, {"line": "by_contra! h", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, \u00acUnbounded r x\n\u22a2 False"}, {"line": "simp_rw [not_unbounded_iff] at h", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, Bounded r x\n\u22a2 False"}, {"line": "let f : s \u2192 \u03b1 := fun x : s => wo.wf.sup x (h x.1 x.2)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, Bounded r x\nf : \u2191s \u2192 \u03b1 := fun x => \u22ef.sup \u2191x \u22ef\n\u22a2 False"}, {"line": "refine h\u2082.not_le (le_trans (csInf_le' \u27e8range f, fun x => ?_, rfl\u27e9) mk_range_le)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, Bounded r x\nf : \u2191s \u2192 \u03b1 := fun x => \u22ef.sup \u2191x \u22ef\nx : \u03b1\n\u22a2 \u2203 b \u2208 range f, swap r\u1d9c x b"}, {"line": "rcases h\u2081 x with \u27e8y, \u27e8c, hc, hy\u27e9, hxy\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, Bounded r x\nf : \u2191s \u2192 \u03b1 := fun x => \u22ef.sup \u2191x \u22ef\nx y : \u03b1\nhxy : \u00acr y x\nc : Set \u03b1\nhc : c \u2208 s\nhy : y \u2208 c\n\u22a2 \u2203 b \u2208 range f, swap r\u1d9c x b"}, {"line": "exact \u27e8f \u27e8c, hc\u27e9, mem_range_self _, fun hxz => hxy (Trans.trans (wo.wf.lt_sup _ hy) hxz)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_cof_power {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (b1 : 1 < b) : a < (b ^ a).ord.cof := by\n  have b0 : b \u2260 0 := (zero_lt_one.trans b1).ne'\n  apply lt_imp_lt_of_le_imp_le (power_le_power_left <| power_ne_zero a b0)\n  rw [\u2190 power_mul]\n  rw [mul_eq_self ha]\n  exact lt_power_cof (ha.trans <| (cantor' _ b1).le)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{a o : Ordinal.{u}} {f : \u2200 b < o, Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nb1 : 1 < b\n\u22a2 a < (b ^ a).ord.cof"}, {"line": "have b0 : b \u2260 0 := (zero_lt_one.trans b1).ne'", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nb1 : 1 < b\nb0 : b \u2260 0\n\u22a2 a < (b ^ a).ord.cof"}, {"line": "apply lt_imp_lt_of_le_imp_le (power_le_power_left <| power_ne_zero a b0)", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nb1 : 1 < b\nb0 : b \u2260 0\n\u22a2 (b ^ a) ^ a < (b ^ a) ^ (b ^ a).ord.cof"}, {"line": "rw [\u2190 power_mul]", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nb1 : 1 < b\nb0 : b \u2260 0\n\u22a2 b ^ (a * a) < (b ^ a) ^ (b ^ a).ord.cof"}, {"line": "rw [mul_eq_self ha]", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nb1 : 1 < b\nb0 : b \u2260 0\n\u22a2 b ^ a < (b ^ a) ^ (b ^ a).ord.cof"}, {"line": "exact lt_power_cof (ha.trans <| (cantor' _ b1).le)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_of_countable_eventually_mem {\u03b1 : Type u} {\u03b9 : Type v} {a : Cardinal}\n    [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1} {l : Filter \u03b9} [NeBot l] (ht : \u2200 x, \u2200\u1da0 i in l, x \u2208 f i)\n    (h'f : \u2200 i, #(f i) = a) : #\u03b1 = a := by\n  apply le_antisymm\n  \u00b7 apply mk_le_of_countable_eventually_mem ht (fun i \u21a6 (h'f i).le)\n  \u00b7 obtain \u27e8i\u27e9 : Nonempty \u03b9 := nonempty_of_neBot l\n    rw [\u2190 (h'f i)]\n    exact mk_set_le (f i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/CountableCover.lean", "context": {"open": ["Set Order Filter", "scoped Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type v\na : Cardinal.{u}\ninst\u271d\u00b9 : Countable \u03b9\nf : \u03b9 \u2192 Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.NeBot\nht : \u2200 (x : \u03b1), \u2200\u1da0 (i : \u03b9) in l, x \u2208 f i\nh'f : \u2200 (i : \u03b9), Cardinal.mk \u2191(f i) = a\n\u22a2 Cardinal.mk \u03b1 = a"}, {"line": "apply le_antisymm", "tactic_state": "case a\n\u03b1 : Type u\n\u03b9 : Type v\na : Cardinal.{u}\ninst\u271d\u00b9 : Countable \u03b9\nf : \u03b9 \u2192 Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.NeBot\nht : \u2200 (x : \u03b1), \u2200\u1da0 (i : \u03b9) in l, x \u2208 f i\nh'f : \u2200 (i : \u03b9), Cardinal.mk \u2191(f i) = a\n\u22a2 Cardinal.mk \u03b1 \u2264 a\n---\ncase a\n\u03b1 : Type u\n\u03b9 : Type v\na : Cardinal.{u}\ninst\u271d\u00b9 : Countable \u03b9\nf : \u03b9 \u2192 Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.NeBot\nht : \u2200 (x : \u03b1), \u2200\u1da0 (i : \u03b9) in l, x \u2208 f i\nh'f : \u2200 (i : \u03b9), Cardinal.mk \u2191(f i) = a\n\u22a2 a \u2264 Cardinal.mk \u03b1"}, {"line": "\u00b7 apply mk_le_of_countable_eventually_mem ht (fun i \u21a6 (h'f i).le)", "tactic_state": "case a\n\u03b1 : Type u\n\u03b9 : Type v\na : Cardinal.{u}\ninst\u271d\u00b9 : Countable \u03b9\nf : \u03b9 \u2192 Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.NeBot\nht : \u2200 (x : \u03b1), \u2200\u1da0 (i : \u03b9) in l, x \u2208 f i\nh'f : \u2200 (i : \u03b9), Cardinal.mk \u2191(f i) = a\n\u22a2 a \u2264 Cardinal.mk \u03b1"}, {"line": "\u00b7 obtain \u27e8i\u27e9 : Nonempty \u03b9 := nonempty_of_neBot l\n    rw [\u2190 (h'f i)]\n    exact mk_set_le (f i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_ne_zero {\u03b9} (f : \u03b9 \u2192 Cardinal) : prod f \u2260 0 \u2194 \u2200 i, f i \u2260 0 := by simp [prod_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Defs.lean", "context": {"open": ["List Function Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 Cardinal.{u_2}\n\u22a2 sorry \u2260 0 \u2194 \u2200 (i : \u03b9), f i \u2260 0"}, {"line": "simp [prod_eq_zero]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 Cardinal.{u_2}\n\u22a2 \u00acsorry () = 0 \u2194 \u2200 (i : \u03b9), \u00acf i = 0"}]}
{"declaration": "theorem is_prime_iff {a : Cardinal} : Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p : \u2115, a = p \u2227 p.Prime := by\n  rcases le_or_lt \u2135\u2080 a with h | h\n  \u00b7 simp [h]\n  lift a to \u2115 using id h\n  simp [not_le.mpr h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Divisibility.lean", "context": {"open": [], "variables": ["{a b : Cardinal.{u}} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 a : Cardinal.{u_1}\n\u22a2 Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p, a = \u2191p \u2227 Nat.Prime p"}, {"line": "rcases le_or_lt \u2135\u2080 a with h | h", "tactic_state": "case inl\n\u2135\u2080 a : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\n\u22a2 Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p, a = \u2191p \u2227 Nat.Prime p\n---\ncase inr\n\u2135\u2080 a : Cardinal.{u_1}\nh : a < \u2135\u2080\n\u22a2 Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p, a = \u2191p \u2227 Nat.Prime p"}, {"line": "\u00b7 simp [h]", "tactic_state": "case inr\n\u2135\u2080 a : Cardinal.{u_1}\nh : a < \u2135\u2080\n\u22a2 Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p, a = \u2191p \u2227 Nat.Prime p"}, {"line": "lift a to \u2115 using id h", "tactic_state": "case inr.intro\n\u2135\u2080 : Cardinal.{u_1}\na : \u2115\nh : \u2191a < \u2135\u2080\n\u22a2 Prime \u2191a \u2194 \u2135\u2080 \u2264 \u2191a \u2228 \u2203 p, \u2191a = \u2191p \u2227 Nat.Prime p"}, {"line": "simp [not_le.mpr h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toENat_ne_top {a : Cardinal} : toENat a \u2260 \u22a4 \u2194 a < \u2135\u2080 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/ENat.lean", "context": {"open": ["Function Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoENat : x\u271d\n\u2135\u2080 a : Cardinal.{u_2}\n\u22a2 sorry \u2260 \u22a4 \u2194 a < \u2135\u2080"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\ntoENat : x\u271d\n\u2135\u2080 a : Cardinal.{u_2}\n\u22a2 \u00acsorry () = \u22a4 \u2194 a < \u2135\u2080"}]}
{"declaration": "lemma ofENat_add (m n : \u2115\u221e) : ofENat (m + n) = m + n := by apply toENat_injOn <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/ENat.lean", "context": {"open": ["Function Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofENat : x\u271d\nm n : \u2115\u221e\n\u22a2 sorry = m + n"}, {"line": "apply toENat_injOn <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_eq_finsetCard (s : Finset \u03b1) : Nat.card s = s.card := by\n  simp only [Nat.card_eq_fintype_card]\n  simp only [Fintype.card_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\n\u22a2 Nat.card { x // x \u2208 s } = s.card"}, {"line": "simp only [Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\n\u22a2 Fintype.card { x // x \u2208 s } = s.card"}, {"line": "simp only [Fintype.card_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_eq_card_finite_toFinset {s : Set \u03b1} (hs : s.Finite) : Nat.card s = hs.toFinset.card := by\n  simp only [\u2190 Nat.card_eq_finsetCard]\n  simp only [hs.mem_toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\n\u22a2 Nat.card \u2191s = hs.toFinset.card"}, {"line": "simp only [\u2190 Nat.card_eq_finsetCard]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\n\u22a2 Nat.card \u2191s = Nat.card { x // x \u2208 hs.toFinset }"}, {"line": "simp only [hs.mem_toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cast_card [Finite \u03b1] : (Nat.card \u03b1 : Cardinal) = Cardinal.mk \u03b1 := by\n  rw [Nat.card]\n  rw [Cardinal.cast_toNat_of_lt_aleph0]\n  exact Cardinal.lt_aleph0_of_finite _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 \u2191(Nat.card \u03b1) = mk \u03b1"}, {"line": "rw [Nat.card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 \u2191(Cardinal.toNat (mk \u03b1)) = mk \u03b1"}, {"line": "rw [Cardinal.cast_toNat_of_lt_aleph0]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 mk \u03b1 < aleph0"}, {"line": "exact Cardinal.lt_aleph0_of_finite _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_eq_zero : Nat.card \u03b1 = 0 \u2194 IsEmpty \u03b1 \u2228 Infinite \u03b1 := by\n  simp [Nat.card, mk_eq_zero_iff, aleph0_le_mk_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Nat.card \u03b1 = 0 \u2194 IsEmpty \u03b1 \u2228 Infinite \u03b1"}, {"line": "simp [Nat.card, mk_eq_zero_iff, aleph0_le_mk_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_ne_zero : Nat.card \u03b1 \u2260 0 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1 := by simp [card_eq_zero, not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Nat.card \u03b1 \u2260 0 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1"}, {"line": "simp [card_eq_zero, not_or]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u00acNat.card \u03b1 = 0 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1"}]}
{"declaration": "lemma card_pos_iff : 0 < Nat.card \u03b1 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1 := by\n  simp [Nat.card, mk_eq_zero_iff, mk_lt_aleph0_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 0 < Nat.card \u03b1 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1"}, {"line": "simp [Nat.card, mk_eq_zero_iff, mk_lt_aleph0_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_le_card_of_injective {\u03b1 : Type u} {\u03b2 : Type v} [Finite \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hf : Injective f) : Nat.card \u03b1 \u2264 Nat.card \u03b2 := by\n  simpa using toNat_le_toNat (lift_mk_le_lift_mk_of_injective hf) (by simp [lt_aleph0_of_finite])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Finite \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\n\u22a2 Nat.card \u03b1 \u2264 Nat.card \u03b2"}, {"line": "simpa using toNat_le_toNat (lift_mk_le_lift_mk_of_injective hf) (by simp [lt_aleph0_of_finite])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_of_equiv_fin {\u03b1 : Type*} {n : \u2115} (f : \u03b1 \u2243 Fin n) : Nat.card \u03b1 = n := by\n  simpa only [card_eq_fintype_card,Fintype.card_fin] using card_congr f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nn : \u2115\nf : \u03b1 \u2243 Fin n\n\u22a2 Nat.card \u03b1 = n"}, {"line": "simpa only [card_eq_fintype_card,Fintype.card_fin] using card_congr f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_preimage_of_injOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (hf : (f \u207b\u00b9' s).InjOn f) (hsf : s \u2286 range f) :\n    Nat.card (f \u207b\u00b9' s) = Nat.card s := by\n  rw [\u2190 Nat.card_image_of_injOn hf]\n  rw [image_preimage_eq_iff.2 hsf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhf : InjOn f (f \u207b\u00b9' s)\nhsf : s \u2286 range f\n\u22a2 Nat.card \u2191(f \u207b\u00b9' s) = Nat.card \u2191s"}, {"line": "rw [\u2190 Nat.card_image_of_injOn hf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhf : InjOn f (f \u207b\u00b9' s)\nhsf : s \u2286 range f\n\u22a2 Nat.card \u2191(f '' (f \u207b\u00b9' s)) = Nat.card \u2191s"}, {"line": "rw [image_preimage_eq_iff.2 hsf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_range_of_injective {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    Nat.card (range f) = Nat.card \u03b1 := by\n  rw [\u2190 Nat.card_preimage_of_injective hf le_rfl]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\n\u22a2 Nat.card \u2191(range f) = Nat.card \u03b1"}, {"line": "rw [\u2190 Nat.card_preimage_of_injective hf le_rfl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\n\u22a2 Nat.card \u2191(f \u207b\u00b9' range f) = Nat.card \u03b1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_unique [Nonempty \u03b1] [Subsingleton \u03b1] : Nat.card \u03b1 = 1 := by\n  simp [card_eq_one_iff_unique, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Subsingleton \u03b1\n\u22a2 Nat.card \u03b1 = 1"}, {"line": "simp [card_eq_one_iff_unique, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_sum [Finite \u03b1] [Finite \u03b2] : Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2 := by\n  have := Fintype.ofFinite \u03b1\n  have := Fintype.ofFinite \u03b2\n  simp_rw [Nat.card_eq_fintype_card, Fintype.card_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"line": "have := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"line": "have := Fintype.ofFinite \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"line": "simp_rw [Nat.card_eq_fintype_card, Fintype.card_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_prod (\u03b1 \u03b2 : Type*) : Nat.card (\u03b1 \u00d7 \u03b2) = Nat.card \u03b1 * Nat.card \u03b2 := by\n  simp only [Nat.card]\n  simp only [mk_prod]\n  simp only [toNat_mul]\n  simp only [toNat_lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u22a2 Nat.card (\u03b1 \u00d7 \u03b2) = Nat.card \u03b1 * Nat.card \u03b2"}, {"line": "simp only [Nat.card]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u22a2 Cardinal.toNat (mk (\u03b1 \u00d7 \u03b2)) = Cardinal.toNat (mk \u03b1) * Cardinal.toNat (mk \u03b2)"}, {"line": "simp only [mk_prod]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u22a2 Cardinal.toNat (lift.{u_4, u_3} (mk \u03b1) * lift.{u_3, u_4} (mk \u03b2)) = Cardinal.toNat (mk \u03b1) * Cardinal.toNat (mk \u03b2)"}, {"line": "simp only [toNat_mul]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u22a2 Cardinal.toNat (lift.{u_4, u_3} (mk \u03b1)) * Cardinal.toNat (lift.{u_3, u_4} (mk \u03b2)) =\n    Cardinal.toNat (mk \u03b1) * Cardinal.toNat (mk \u03b2)"}, {"line": "simp only [toNat_lift]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fun [Finite \u03b1] : Nat.card (\u03b1 \u2192 \u03b2) = Nat.card \u03b2 ^ Nat.card \u03b1 := by\n  haveI := Fintype.ofFinite \u03b1\n  rw [Nat.card_pi]\n  rw [Finset.prod_const]\n  rw [Finset.card_univ]\n  rw [\u2190 Nat.card_eq_fintype_card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Finite \u03b1\n\u22a2 Nat.card (\u03b1 \u2192 \u03b2) = Nat.card \u03b2 ^ Nat.card \u03b1"}, {"line": "haveI := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2192 \u03b2) = Nat.card \u03b2 ^ Nat.card \u03b1"}, {"line": "rw [Nat.card_pi]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 \u220f a, Nat.card \u03b2 = Nat.card \u03b2 ^ Nat.card \u03b1"}, {"line": "rw [Finset.prod_const]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b2 ^ Finset.univ.card = Nat.card \u03b2 ^ Nat.card \u03b1"}, {"line": "rw [Finset.card_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b2 ^ Fintype.card \u03b1 = Nat.card \u03b2 ^ Nat.card \u03b1"}, {"line": "rw [\u2190 Nat.card_eq_fintype_card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_zmod (n : \u2115) : Nat.card (ZMod n) = n := by\n  cases n\n  \u00b7 exact @Nat.card_eq_zero_of_infinite _ Int.infinite\n  \u00b7 rw [Nat.card_eq_fintype_card, ZMod.card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Nat.card (ZMod n) = n"}, {"line": "cases n", "tactic_state": "case zero\n\u22a2 Nat.card (ZMod 0) = 0\n---\ncase succ\nn\u271d : \u2115\n\u22a2 Nat.card (ZMod (n\u271d + 1)) = n\u271d + 1"}, {"line": "\u00b7 exact @Nat.card_eq_zero_of_infinite _ Int.infinite", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 Nat.card (ZMod (n\u271d + 1)) = n\u271d + 1"}, {"line": "\u00b7 rw [Nat.card_eq_fintype_card, ZMod.card]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_singleton_prod (a : \u03b1) (t : Set \u03b2) : Nat.card ({a} \u00d7\u02e2 t) = Nat.card t := by\n  rw [singleton_prod]\n  rw [Nat.card_image_of_injective (Prod.mk_right_injective a)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nt : Set \u03b2\n\u22a2 Nat.card \u2191({a} \u00d7\u02e2 t) = Nat.card \u2191t"}, {"line": "rw [singleton_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nt : Set \u03b2\n\u22a2 Nat.card \u2191(Prod.mk a '' t) = Nat.card \u2191t"}, {"line": "rw [Nat.card_image_of_injective (Prod.mk_right_injective a)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_prod_singleton (s : Set \u03b1) (b : \u03b2) : Nat.card (s \u00d7\u02e2 {b}) = Nat.card s := by\n  rw [prod_singleton]\n  rw [Nat.card_image_of_injective (Prod.mk_left_injective b)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nb : \u03b2\n\u22a2 Nat.card \u2191(s \u00d7\u02e2 {b}) = Nat.card \u2191s"}, {"line": "rw [prod_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nb : \u03b2\n\u22a2 Nat.card \u2191((fun a => (a, b)) '' s) = Nat.card \u2191s"}, {"line": "rw [Nat.card_image_of_injective (Prod.mk_left_injective b)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCard_pos (hs : s.Finite) : 0 < Nat.card s \u2194 s.Nonempty := by\n  simp [pos_iff_ne_zero, Nat.card_eq_zero, hs.to_subtype, nonempty_iff_ne_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\n\u22a2 0 < Nat.card \u2191s \u2194 s.Nonempty"}, {"line": "simp [pos_iff_ne_zero, Nat.card_eq_zero, hs.to_subtype, nonempty_iff_ne_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_coe_fintype_card [Fintype \u03b1] : card \u03b1 = Fintype.card \u03b1 := by\n  simp [card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ncard : x\u271d\ninst\u271d : Fintype \u03b1\n\u22a2 sorry = Fintype.card \u03b1"}, {"line": "simp [card]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ncard : x\u271d\ninst\u271d : Fintype \u03b1\n\u22a2 sorry () = Fintype.card \u03b1"}]}
{"declaration": "theorem _root_.Cardinal.natCast_le_toENat_iff {n : \u2115} {c : Cardinal} :\n    \u2191n \u2264 toENat c \u2194 \u2191n \u2264 c := by\n  rw [\u2190 toENat_nat n]\n  rw [toENat_le_iff_of_le_aleph0 (le_of_lt (nat_lt_aleph0 n))]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 \u2191n \u2264 toENat c \u2194 \u2191n \u2264 c"}, {"line": "rw [\u2190 toENat_nat n]", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 toENat \u2191n \u2264 toENat c \u2194 \u2191n \u2264 c"}, {"line": "rw [toENat_le_iff_of_le_aleph0 (le_of_lt (nat_lt_aleph0 n))]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.toENat_le_natCast_iff {c : Cardinal} {n : \u2115} :\n    toENat c \u2264 n \u2194 c \u2264 n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_3}\nn : \u2115\n\u22a2 toENat c \u2264 \u2191n \u2194 c \u2264 \u2191n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.natCast_eq_toENat_iff {n : \u2115} {c : Cardinal} :\n    \u2191n = toENat c \u2194 \u2191n = c := by\n  rw [le_antisymm_iff]\n  rw [le_antisymm_iff]\n  rw [Cardinal.toENat_le_natCast_iff]\n  rw [Cardinal.natCast_le_toENat_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 \u2191n = toENat c \u2194 \u2191n = c"}, {"line": "rw [le_antisymm_iff]", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 \u2191n \u2264 toENat c \u2227 toENat c \u2264 \u2191n \u2194 \u2191n = c"}, {"line": "rw [le_antisymm_iff]", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 \u2191n \u2264 toENat c \u2227 toENat c \u2264 \u2191n \u2194 \u2191n \u2264 c \u2227 c \u2264 \u2191n"}, {"line": "rw [Cardinal.toENat_le_natCast_iff]", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 \u2191n \u2264 toENat c \u2227 c \u2264 \u2191n \u2194 \u2191n \u2264 c \u2227 c \u2264 \u2191n"}, {"line": "rw [Cardinal.natCast_le_toENat_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.toENat_eq_natCast_iff {c : Cardinal} {n : \u2115} :\n    Cardinal.toENat c = n \u2194 c = n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_3}\nn : \u2115\n\u22a2 toENat c = \u2191n \u2194 c = \u2191n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.natCast_lt_toENat_iff {n : \u2115} {c : Cardinal} :\n    \u2191n < toENat c \u2194 \u2191n < c := by\n  simp only [\u2190 not_le]\n  simp only [Cardinal.toENat_le_natCast_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 \u2191n < toENat c \u2194 \u2191n < c"}, {"line": "simp only [\u2190 not_le]", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 \u00actoENat c \u2264 \u2191n \u2194 \u00acc \u2264 \u2191n"}, {"line": "simp only [Cardinal.toENat_le_natCast_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.toENat_lt_natCast_iff {n : \u2115} {c : Cardinal} :\n    toENat c < \u2191n \u2194 c < \u2191n := by\n  simp only [\u2190 not_le]\n  simp only [Cardinal.natCast_le_toENat_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 toENat c < \u2191n \u2194 c < \u2191n"}, {"line": "simp only [\u2190 not_le]", "tactic_state": "n : \u2115\nc : Cardinal.{u_3}\n\u22a2 \u00ac\u2191n \u2264 toENat c \u2194 \u00ac\u2191n \u2264 c"}, {"line": "simp only [Cardinal.natCast_le_toENat_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_zero_iff_empty (\u03b1 : Type*) : card \u03b1 = 0 \u2194 IsEmpty \u03b1 := by\n  rw [\u2190 Cardinal.mk_eq_zero_iff]\n  simp [card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry = 0 \u2194 IsEmpty \u03b1"}, {"line": "rw [\u2190 Cardinal.mk_eq_zero_iff]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry = 0 \u2194 mk \u03b1 = 0"}, {"line": "simp [card]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry () = 0 \u2194 mk \u03b1 = 0"}]}
{"declaration": "theorem card_le_one_iff_subsingleton (\u03b1 : Type*) : card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1 := by\n  rw [\u2190 le_one_iff_subsingleton]\n  simp [card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry \u2264 1 \u2194 Subsingleton \u03b1"}, {"line": "rw [\u2190 le_one_iff_subsingleton]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry \u2264 1 \u2194 mk \u03b1 \u2264 1"}, {"line": "simp [card]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry () \u2264 1 \u2194 mk \u03b1 \u2264 1"}]}
{"declaration": "theorem card_prod (\u03b1 \u03b2 : Type*) : ENat.card (\u03b1 \u00d7 \u03b2) = .card \u03b1 * .card \u03b2 := by\n  simp [ENat.card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u22a2 ENat.card (\u03b1 \u00d7 \u03b2) = ENat.card \u03b1 * ENat.card \u03b2"}, {"line": "simp [ENat.card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem power_mul {a b c : Cardinal} : a ^ (b * c) = (a ^ b) ^ c := by\n  rw [mul_comm b c]\n  exact inductionOn\u2083 a b c fun \u03b1 \u03b2 \u03b3 => mk_congr <| Equiv.curry \u03b3 \u03b2 \u03b1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Cardinal.{u_1}\n\u22a2 a ^ (b * c) = (a ^ b) ^ c"}, {"line": "rw [mul_comm b c]", "tactic_state": "a b c : Cardinal.{u_1}\n\u22a2 a ^ (c * b) = (a ^ b) ^ c"}, {"line": "exact inductionOn\u2083 a b c fun \u03b1 \u03b2 \u03b3 => mk_congr <| Equiv.curry \u03b3 \u03b2 \u03b1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_two : lift.{u, v} 2 = 2 := by simp [\u2190 one_add_one_eq_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u22a2 sorry = 2"}, {"line": "simp [\u2190 one_add_one_eq_two]", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u22a2 sorry () = 2"}]}
{"declaration": "theorem lift_two_power (a : Cardinal) : lift.{v} (2 ^ a) = 2 ^ lift.{v} a := by\n  simp [\u2190 one_add_one_eq_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u_2}\n\u22a2 sorry = 2 ^ sorry"}, {"line": "simp [\u2190 one_add_one_eq_two]", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u_2}\n\u22a2 sorry () = 2 ^ sorry ()"}]}
{"declaration": "theorem self_le_power (a : Cardinal) {b : Cardinal} (hb : 1 \u2264 b) : a \u2264 a ^ b := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  \u00b7 exact zero_le _\n  \u00b7 convert power_le_power_left ha hb\n    exact (power_one a).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nhb : 1 \u2264 b\n\u22a2 a \u2264 a ^ b"}, {"line": "rcases eq_or_ne a 0 with (rfl | ha)", "tactic_state": "case inl\nb : Cardinal.{u_1}\nhb : 1 \u2264 b\n\u22a2 0 \u2264 0 ^ b\n---\ncase inr\na b : Cardinal.{u_1}\nhb : 1 \u2264 b\nha : a \u2260 0\n\u22a2 a \u2264 a ^ b"}, {"line": "\u00b7 exact zero_le _", "tactic_state": "case inr\na b : Cardinal.{u_1}\nhb : 1 \u2264 b\nha : a \u2260 0\n\u22a2 a \u2264 a ^ b"}, {"line": "\u00b7 convert power_le_power_left ha hb\n    exact (power_one a).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem power_le_max_power_one {a b c : Cardinal} (h : b \u2264 c) : a ^ b \u2264 max (a ^ c) 1 := by\n  by_cases ha : a = 0\n  \u00b7 simp [ha, zero_power_le]\n  \u00b7 exact (power_le_power_left ha h).trans (le_max_left _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Cardinal.{u_1}\nh : b \u2264 c\n\u22a2 a ^ b \u2264 max (a ^ c) 1"}, {"line": "by_cases ha : a = 0", "tactic_state": "case pos\na b c : Cardinal.{u_1}\nh : b \u2264 c\nha : a = 0\n\u22a2 a ^ b \u2264 max (a ^ c) 1\n---\ncase neg\na b c : Cardinal.{u_1}\nh : b \u2264 c\nha : \u00aca = 0\n\u22a2 a ^ b \u2264 max (a ^ c) 1"}, {"line": "\u00b7 simp [ha, zero_power_le]", "tactic_state": "case neg\na b c : Cardinal.{u_1}\nh : b \u2264 c\nha : \u00aca = 0\n\u22a2 a ^ b \u2264 max (a ^ c) 1"}, {"line": "\u00b7 exact (power_le_power_left ha h).trans (le_max_left _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_eq_of_iSup_eq_of_not_isSuccPrelimit\n    {\u03b9 : Type u} (f : \u03b9 \u2192 Cardinal.{v}) (\u03c9 : Cardinal.{v})\n    (h\u03c9 : \u00ac IsSuccPrelimit \u03c9)\n    (h : \u2a06 i : \u03b9, f i = \u03c9) : \u2203 i, f i = \u03c9 := by\n  subst h\n  suffices BddAbove (range f) from (isLUB_csSup' this).mem_of_not_isSuccPrelimit h\u03c9\n  contrapose! h\u03c9 with hf\n  rw [iSup]\n  rw [csSup_of_not_bddAbove hf]\n  rw [csSup_empty]\n  exact isSuccPrelimit_bot\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\n\u03c9 : Cardinal.{v}\nh\u03c9 : \u00acIsSuccPrelimit \u03c9\nh : \u2a06 i, f i = \u03c9\n\u22a2 \u2203 i, f i = \u03c9"}, {"line": "subst h", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nh\u03c9 : \u00acIsSuccPrelimit (\u2a06 i, f i)\n\u22a2 \u2203 i, f i = \u2a06 i, f i"}, {"line": "suffices BddAbove (range f) from (isLUB_csSup' this).mem_of_not_isSuccPrelimit h\u03c9", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nh\u03c9 : \u00acIsSuccPrelimit (\u2a06 i, f i)\n\u22a2 BddAbove (Set.range f)"}, {"line": "contrapose! h\u03c9 with hf", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : \u00acBddAbove (Set.range f)\n\u22a2 IsSuccPrelimit (\u2a06 i, f i)"}, {"line": "rw [iSup]", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : \u00acBddAbove (Set.range f)\n\u22a2 IsSuccPrelimit (sSup (Set.range fun i => f i))"}, {"line": "rw [csSup_of_not_bddAbove hf]", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : \u00acBddAbove (Set.range f)\n\u22a2 IsSuccPrelimit (sSup \u2205)"}, {"line": "rw [csSup_empty]", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : \u00acBddAbove (Set.range f)\n\u22a2 IsSuccPrelimit \u22a5"}, {"line": "exact isSuccPrelimit_bot", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_eq_of_iSup_eq_of_not_isSuccLimit\n    {\u03b9 : Type u} [h\u03b9 : Nonempty \u03b9] (f : \u03b9 \u2192 Cardinal.{v}) (hf : BddAbove (range f))\n    {c : Cardinal.{v}} (hc : \u00ac IsSuccLimit c)\n    (h : \u2a06 i, f i = c) : \u2203 i, f i = c := by\n  rw [Cardinal.isSuccLimit_iff] at hc\n  refine (not_and_or.mp hc).elim (fun e \u21a6 \u27e8h\u03b9.some, ?_\u27e9)\n    (Cardinal.exists_eq_of_iSup_eq_of_not_isSuccPrelimit.{u, v} f c \u00b7 h)\n  cases not_not.mp e\n  rw [\u2190 le_zero_iff] at h \u22a2\n  exact (le_ciSup hf _).trans h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nh\u03b9 : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{v}\nhf : BddAbove (Set.range f)\nc : Cardinal.{v}\nhc : \u00acIsSuccLimit c\nh : \u2a06 i, f i = c\n\u22a2 \u2203 i, f i = c"}, {"line": "rw [Cardinal.isSuccLimit_iff] at hc", "tactic_state": "\u03b9 : Type u\nh\u03b9 : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{v}\nhf : BddAbove (Set.range f)\nc : Cardinal.{v}\nhc : \u00ac(c \u2260 0 \u2227 IsSuccPrelimit c)\nh : \u2a06 i, f i = c\n\u22a2 \u2203 i, f i = c"}, {"line": "refine (not_and_or.mp hc).elim (fun e \u21a6 \u27e8h\u03b9.some, ?_\u27e9)\n    (Cardinal.exists_eq_of_iSup_eq_of_not_isSuccPrelimit.{u, v} f c \u00b7 h)", "tactic_state": "\u03b9 : Type u\nh\u03b9 : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{v}\nhf : BddAbove (Set.range f)\nc : Cardinal.{v}\nhc : \u00ac(c \u2260 0 \u2227 IsSuccPrelimit c)\nh : \u2a06 i, f i = c\ne : \u00acc \u2260 0\n\u22a2 f h\u03b9.some = c"}, {"line": "cases not_not.mp e", "tactic_state": "case refl\n\u03b9 : Type u\nh\u03b9 : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{v}\nhf : BddAbove (Set.range f)\nhc : \u00ac(0 \u2260 0 \u2227 IsSuccPrelimit 0)\nh : \u2a06 i, f i = 0\ne : \u00ac0 \u2260 0\n\u22a2 f h\u03b9.some = 0"}, {"line": "rw [\u2190 le_zero_iff] at h \u22a2", "tactic_state": "case refl\n\u03b9 : Type u\nh\u03b9 : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{v}\nhf : BddAbove (Set.range f)\nhc : \u00ac(0 \u2260 0 \u2227 IsSuccPrelimit 0)\nh : \u2a06 i, f i \u2264 0\ne : \u00ac0 \u2260 0\n\u22a2 f h\u03b9.some \u2264 0"}, {"line": "exact (le_ciSup hf _).trans h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_le_lift {c : Cardinal.{u}} : \u2135\u2080 \u2264 lift.{v} c \u2194 \u2135\u2080 \u2264 c := by\n  simpa using lift_le (a := \u2135\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 : Cardinal.{u}\nx\u271d : Sort u_1\nlift : x\u271d\nc : Cardinal.{u}\n\u22a2 \u2135\u2080 \u2264 sorry \u2194 \u2135\u2080 \u2264 c"}, {"line": "simpa using lift_le (a := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c \u2264 \u2135\u2080 \u2194 c \u2264 \u2135\u2080 := by\n  simpa using lift_le (b := \u2135\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u2135\u2080 c : Cardinal.{u}\n\u22a2 sorry \u2264 \u2135\u2080 \u2194 c \u2264 \u2135\u2080"}, {"line": "simpa using lift_le (b := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_lt_lift {c : Cardinal.{u}} : \u2135\u2080 < lift.{v} c \u2194 \u2135\u2080 < c := by\n  simpa using lift_lt (a := \u2135\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 : Cardinal.{u}\nx\u271d : Sort u_1\nlift : x\u271d\nc : Cardinal.{u}\n\u22a2 \u2135\u2080 < sorry \u2194 \u2135\u2080 < c"}, {"line": "simpa using lift_lt (a := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_lt_aleph0 {c : Cardinal.{u}} : lift.{v} c < \u2135\u2080 \u2194 c < \u2135\u2080 := by\n  simpa using lift_lt (b := \u2135\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u2135\u2080 c : Cardinal.{u}\n\u22a2 sorry < \u2135\u2080 \u2194 c < \u2135\u2080"}, {"line": "simpa using lift_lt (b := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_eq_lift {c : Cardinal.{u}} : \u2135\u2080 = lift.{v} c \u2194 \u2135\u2080 = c := by\n  simpa using lift_inj (a := \u2135\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 : Cardinal.{u}\nx\u271d : Sort u_1\nlift : x\u271d\nc : Cardinal.{u}\n\u22a2 \u2135\u2080 = sorry \u2194 \u2135\u2080 = c"}, {"line": "simpa using lift_inj (a := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_eq_aleph0 {c : Cardinal.{u}} : lift.{v} c = \u2135\u2080 \u2194 c = \u2135\u2080 := by\n  simpa using lift_inj (b := \u2135\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u2135\u2080 c : Cardinal.{u}\n\u22a2 sorry = \u2135\u2080 \u2194 c = \u2135\u2080"}, {"line": "simpa using lift_inj (b := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_natCast (n : \u2115) : lift.{u} (n : Cardinal.{v}) = n := by induction n <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\nn : \u2115\n\u22a2 sorry = n"}, {"line": "induction n <;> simp [*]", "tactic_state": "case zero\nx\u271d : Sort u_1\nlift : x\u271d\n\u22a2 sorry () = 0\n---\ncase succ\nx\u271d : Sort u_1\nlift : x\u271d\nn\u271d : \u2115\na\u271d : sorry = n\u271d\n\u22a2 False"}]}
{"declaration": "theorem zero_eq_lift_iff {a : Cardinal.{u}} :\n    (0 : Cardinal) = lift.{v} a \u2194 0 = a := by\n  simpa using nat_eq_lift_iff (n := 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 0 = sorry \u2194 0 = a"}, {"line": "simpa using nat_eq_lift_iff (n := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_eq_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) = lift.{v} a \u2194 1 = a := by\n  simpa using nat_eq_lift_iff (n := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 1 = sorry \u2194 1 = a"}, {"line": "simpa using nat_eq_lift_iff (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) \u2264 lift.{v} a \u2194 1 \u2264 a := by\n  simpa using nat_le_lift_iff (n := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 1 \u2264 sorry \u2194 1 \u2264 a"}, {"line": "simpa using nat_le_lift_iff (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_lt_lift_iff {a : Cardinal.{u}} :\n    (0 : Cardinal) < lift.{v} a \u2194 0 < a := by\n  simpa using nat_lt_lift_iff (n := 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 0 < sorry \u2194 0 < a"}, {"line": "simpa using nat_lt_lift_iff (n := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) < lift.{v} a \u2194 1 < a := by\n  simpa using nat_lt_lift_iff (n := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 1 < sorry \u2194 1 < a"}, {"line": "simpa using nat_lt_lift_iff (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_iUnion_Ordinal_le_of_le {\u03b2 : Type*} {o : Ordinal} {c : Cardinal}\n    (ho : o.card \u2264 c) (hc : \u2135\u2080 \u2264 c) (A : Ordinal \u2192 Set \u03b2)\n    (hA : \u2200 j < o, #(A j) \u2264 c) : #(\u22c3 j < o, A j) \u2264 c := by\n  apply mk_iUnion_Ordinal_lift_le_of_le _ hc A hA\n  rwa [Cardinal.lift_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_1\no : Ordinal.{u_1}\nc : Cardinal.{u_1}\nho : o.card \u2264 c\nhc : aleph0 \u2264 c\nA : Ordinal.{u_1} \u2192 Set \u03b2\nhA : \u2200 j < o, mk \u2191(A j) \u2264 c\n\u22a2 mk \u2191(\u22c3 j, \u22c3 (_ : j < o), A j) \u2264 c"}, {"line": "apply mk_iUnion_Ordinal_lift_le_of_le _ hc A hA", "tactic_state": "\u03b2 : Type u_1\no : Ordinal.{u_1}\nc : Cardinal.{u_1}\nho : o.card \u2264 c\nhc : aleph0 \u2264 c\nA : Ordinal.{u_1} \u2192 Set \u03b2\nhA : \u2200 j < o, mk \u2191(A j) \u2264 c\n\u22a2 Cardinal.lift.{u_1, u_1} o.card \u2264 Cardinal.lift.{u_1, u_1} c"}, {"line": "rwa [Cardinal.lift_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_iSup_le_sum_card {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    (\u2a06 i, f i).card \u2264 Cardinal.sum (fun i \u21a6 (f i).card) := by\n  have := lift_card_iSup_le_sum_card f\n  rwa [Cardinal.lift_id'] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\n\u22a2 (\u2a06 i, f i).card \u2264 sum fun i => (f i).card"}, {"line": "have := lift_card_iSup_le_sum_card f", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nthis : Cardinal.lift.{u, max u v} (\u2a06 i, f i).card \u2264 sum fun i => (f i).card\n\u22a2 (\u2a06 i, f i).card \u2264 sum fun i => (f i).card"}, {"line": "rwa [Cardinal.lift_id'] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_iSup_Iio_le_sum_card {o : Ordinal.{u}} (f : Iio o \u2192 Ordinal.{max u v}) :\n    (\u2a06 a : Iio o, f a).card \u2264 Cardinal.sum fun i \u21a6 (f ((enumIsoToType o).symm i)).card := by\n  apply le_of_eq_of_le (congr_arg _ _).symm (card_iSup_le_sum_card _)\n  simpa using (enumIsoToType o).symm.iSup_comp (g := fun x \u21a6 f x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 (\u2a06 a, f a).card \u2264 sum fun i => (f (o.enumIsoToType.symm i)).card"}, {"line": "apply le_of_eq_of_le (congr_arg _ _).symm (card_iSup_le_sum_card _)", "tactic_state": "o : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 \u2a06 i, f (o.enumIsoToType.symm i) = \u2a06 a, f a"}, {"line": "simpa using (enumIsoToType o).symm.iSup_comp (g := fun x \u21a6 f x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_iSup_Iio_le_card_mul_iSup {o : Ordinal.{u}} (f : Iio o \u2192 Ordinal.{max u v}) :\n    (\u2a06 a : Iio o, f a).card \u2264 Cardinal.lift.{v} o.card * \u2a06 a : Iio o, (f a).card := by\n  apply (card_iSup_Iio_le_sum_card f).trans\n  convert \u2190 sum_le_iSup_lift _\n  \u00b7 exact mk_toType o\n  \u00b7 exact (enumIsoToType o).symm.iSup_comp (g := fun x \u21a6 (f x).card)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 (\u2a06 a, f a).card \u2264 Cardinal.lift.{v, u} o.card * \u2a06 a, (f a).card"}, {"line": "apply (card_iSup_Iio_le_sum_card f).trans", "tactic_state": "o : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 (sum fun i => (f (o.enumIsoToType.symm i)).card) \u2264 Cardinal.lift.{v, u} o.card * \u2a06 a, (f a).card"}, {"line": "convert \u2190 sum_le_iSup_lift _", "tactic_state": "case h.e'_4.h.e'_5.h.e'_1\no : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 mk o.toType = o.card\n---\ncase h.e'_4.h.e'_6\no : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 \u2a06 i, (f (o.enumIsoToType.symm i)).card = \u2a06 a, (f a).card"}, {"line": "\u00b7 exact mk_toType o", "tactic_state": "case h.e'_4.h.e'_6\no : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 \u2a06 i, (f (o.enumIsoToType.symm i)).card = \u2a06 a, (f a).card"}, {"line": "\u00b7 exact (enumIsoToType o).symm.iSup_comp (g := fun x \u21a6 (f x).card)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_opow_le_of_omega0_le_right (a : Ordinal) {b : Ordinal} (hb : \u03c9 \u2264 b) :\n    (a ^ b).card \u2264 max a.card b.card := by\n  obtain \u27e8n, rfl\u27e9 | ha := eq_nat_or_omega0_le a\n  \u00b7 apply (card_le_card <| opow_le_opow_left b (nat_lt_omega0 n).le).trans\n    apply (card_opow_le_of_omega0_le_left le_rfl _).trans\n    simp [hb]\n  \u00b7 exact card_opow_le_of_omega0_le_left ha b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nhb : omega0 \u2264 b\n\u22a2 (a ^ b).card \u2264 max a.card b.card"}, {"line": "obtain \u27e8n, rfl\u27e9 | ha := eq_nat_or_omega0_le a", "tactic_state": "case inl.intro\nb : Ordinal.{u_1}\nhb : omega0 \u2264 b\nn : \u2115\n\u22a2 (\u2191n ^ b).card \u2264 max (\u2191n).card b.card\n---\ncase inr\na b : Ordinal.{u_1}\nhb : omega0 \u2264 b\nha : omega0 \u2264 a\n\u22a2 (a ^ b).card \u2264 max a.card b.card"}, {"line": "\u00b7 apply (card_le_card <| opow_le_opow_left b (nat_lt_omega0 n).le).trans\n    apply (card_opow_le_of_omega0_le_left le_rfl _).trans\n    simp [hb]", "tactic_state": "case inr\na b : Ordinal.{u_1}\nhb : omega0 \u2264 b\nha : omega0 \u2264 a\n\u22a2 (a ^ b).card \u2264 max a.card b.card"}, {"line": "\u00b7 exact card_opow_le_of_omega0_le_left ha b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_opow_le (a b : Ordinal) : (a ^ b).card \u2264 max \u2135\u2080 (max a.card b.card) := by\n  obtain \u27e8n, rfl\u27e9 | ha := eq_nat_or_omega0_le a\n  \u00b7 obtain \u27e8m, rfl\u27e9 | hb := eq_nat_or_omega0_le b\n    \u00b7 rw [\u2190 natCast_opow, card_nat]\n      exact le_max_of_le_left (nat_lt_aleph0 _).le\n    \u00b7 exact (card_opow_le_of_omega0_le_right _ hb).trans (le_max_right _ _)\n  \u00b7 exact (card_opow_le_of_omega0_le_left ha _).trans (le_max_right _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 (a ^ b).card \u2264 max aleph0 (max a.card b.card)"}, {"line": "obtain \u27e8n, rfl\u27e9 | ha := eq_nat_or_omega0_le a", "tactic_state": "case inl.intro\nb : Ordinal.{u_1}\nn : \u2115\n\u22a2 (\u2191n ^ b).card \u2264 max aleph0 (max (\u2191n).card b.card)\n---\ncase inr\na b : Ordinal.{u_1}\nha : omega0 \u2264 a\n\u22a2 (a ^ b).card \u2264 max aleph0 (max a.card b.card)"}, {"line": "\u00b7 obtain \u27e8m, rfl\u27e9 | hb := eq_nat_or_omega0_le b\n    \u00b7 rw [\u2190 natCast_opow, card_nat]\n      exact le_max_of_le_left (nat_lt_aleph0 _).le\n    \u00b7 exact (card_opow_le_of_omega0_le_right _ hb).trans (le_max_right _ _)", "tactic_state": "case inr\na b : Ordinal.{u_1}\nha : omega0 \u2264 a\n\u22a2 (a ^ b).card \u2264 max aleph0 (max a.card b.card)"}, {"line": "\u00b7 exact (card_opow_le_of_omega0_le_left ha _).trans (le_max_right _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_omega0_opow {a : Ordinal} (h : a \u2260 0) : card (\u03c9 ^ a) = max \u2135\u2080 a.card := by\n  rw [card_opow_eq_of_omega0_le_left le_rfl h.bot_lt]\n  rw [card_omega0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 (omega0 ^ a).card = max aleph0 a.card"}, {"line": "rw [card_opow_eq_of_omega0_le_left le_rfl h.bot_lt]", "tactic_state": "a : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 max omega0.card a.card = max aleph0 a.card"}, {"line": "rw [card_omega0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_opow_omega0 {a : Ordinal} (h : 1 < a) : card (a ^ \u03c9) = max \u2135\u2080 a.card := by\n  rw [card_opow_eq_of_omega0_le_right h le_rfl]\n  rw [card_omega0]\n  rw [max_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\nh : 1 < a\n\u22a2 (a ^ omega0).card = max aleph0 a.card"}, {"line": "rw [card_opow_eq_of_omega0_le_right h le_rfl]", "tactic_state": "a : Ordinal.{u_1}\nh : 1 < a\n\u22a2 max a.card omega0.card = max aleph0 a.card"}, {"line": "rw [card_omega0]", "tactic_state": "a : Ordinal.{u_1}\nh : 1 < a\n\u22a2 max a.card aleph0 = max aleph0 a.card"}, {"line": "rw [max_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInitial.principal_opow {o : Ordinal} (h : IsInitial o) (ho : \u03c9 \u2264 o) :\n    Principal (\u00b7 ^ \u00b7) o := by\n  obtain \u27e8a, rfl\u27e9 := mem_range_omega_iff.2 \u27e8ho, h\u27e9\n  exact principal_opow_omega a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 ^ x2) o"}, {"line": "obtain \u27e8a, rfl\u27e9 := mem_range_omega_iff.2 \u27e8ho, h\u27e9", "tactic_state": "case intro\na : Ordinal.{u_1}\nh : (omega a).IsInitial\nho : omega0 \u2264 omega a\n\u22a2 Principal (fun x1 x2 => x1 ^ x2) (omega a)"}, {"line": "exact principal_opow_omega a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem principal_opow_ord {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : Principal (\u00b7 ^ \u00b7) c.ord := by\n  apply (isInitial_ord c).principal_opow\n  rwa [omega0_le_ord]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\n\u22a2 Principal (fun x1 x2 => x1 ^ x2) c.ord"}, {"line": "apply (isInitial_ord c).principal_opow", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\n\u22a2 omega0 \u2264 c.ord"}, {"line": "rwa [omega0_le_ord]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem principal_add_ord {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : Principal (\u00b7 + \u00b7) c.ord := by\n  intro a b ha hb\n  rw [lt_ord] at *\n  rw [card_add] at *\n  exact add_lt_of_lt hc ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\n\u22a2 Principal (fun x1 x2 => x1 + x2) c.ord"}, {"line": "intro a b ha hb", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a < c.ord\nhb : b < c.ord\n\u22a2 (fun x1 x2 => x1 + x2) a b < c.ord"}, {"line": "rw [lt_ord] at *", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a.card < c\nhb : b.card < c\n\u22a2 ((fun x1 x2 => x1 + x2) a b).card < c"}, {"line": "rw [card_add] at *", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a.card < c\nhb : b.card < c\n\u22a2 a.card + b.card < c"}, {"line": "exact add_lt_of_lt hc ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInitial.principal_add {o : Ordinal} (h : IsInitial o) (ho : \u03c9 \u2264 o) :\n    Principal (\u00b7 + \u00b7) o := by\n  rw [\u2190 h.ord_card]\n  apply principal_add_ord\n  rwa [aleph0_le_card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 + x2) o"}, {"line": "rw [\u2190 h.ord_card]", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 + x2) o.card.ord"}, {"line": "apply principal_add_ord", "tactic_state": "case hc\no : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 aleph0 \u2264 o.card"}, {"line": "rwa [aleph0_le_card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem principal_mul_ord {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : Principal (\u00b7 * \u00b7) c.ord := by\n  intro a b ha hb\n  rw [lt_ord] at *\n  rw [card_mul] at *\n  exact mul_lt_of_lt hc ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\n\u22a2 Principal (fun x1 x2 => x1 * x2) c.ord"}, {"line": "intro a b ha hb", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a < c.ord\nhb : b < c.ord\n\u22a2 (fun x1 x2 => x1 * x2) a b < c.ord"}, {"line": "rw [lt_ord] at *", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a.card < c\nhb : b.card < c\n\u22a2 ((fun x1 x2 => x1 * x2) a b).card < c"}, {"line": "rw [card_mul] at *", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a.card < c\nhb : b.card < c\n\u22a2 a.card * b.card < c"}, {"line": "exact mul_lt_of_lt hc ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInitial.principal_mul {o : Ordinal} (h : IsInitial o) (ho : \u03c9 \u2264 o) :\n    Principal (\u00b7 * \u00b7) o := by\n  rw [\u2190 h.ord_card]\n  apply principal_mul_ord\n  rwa [aleph0_le_card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 * x2) o"}, {"line": "rw [\u2190 h.ord_card]", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 * x2) o.card.ord"}, {"line": "apply principal_mul_ord", "tactic_state": "case hc\no : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 aleph0 \u2264 o.card"}, {"line": "rwa [aleph0_le_card]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_of_append {x y : List A} (h : x ++ y \u2208 T) : x \u2208 T := by\n  induction' y with y ys ih generalizing x\n  \u00b7 simpa using h\n  \u00b7 exact T.prop (ih (by simpa))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Descriptive/Tree.lean", "context": {"open": [], "variables": ["{A : Type*} {S T : tree A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "tree : ?m.832\nA\u271d : Type u_1\nS : sorry\nT : sorry\nA : Type u_1\nx y : List A\nh : sorry\n\u22a2 sorry"}, {"line": "induction' y with y ys ih generalizing x", "tactic_state": "case nil\ntree : ?m.832\nA\u271d : Type u_1\nS : sorry\nT : sorry\nA : Type u_1\nh : sorry\nx : List A\n\u22a2 sorry\n---\ncase cons\ntree : ?m.832\nA\u271d : Type u_1\nS : sorry\nT : sorry\nA : Type u_1\nh : sorry\ny : A\nys : List A\nih : \u2200 {x : List A}, sorry\nx : List A\n\u22a2 sorry"}, {"line": "\u00b7 simpa using h", "tactic_state": "case cons\ntree : ?m.832\nA\u271d : Type u_1\nS : sorry\nT : sorry\nA : Type u_1\nh : sorry\ny : A\nys : List A\nih : \u2200 {x : List A}, sorry\nx : List A\n\u22a2 sorry"}, {"line": "\u00b7 exact T.prop (ih (by simpa))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_pullSub_short (hl : y.length \u2264 x.length) :\n  y \u2208 pullSub T x \u2194 y <+: x \u2227 [] \u2208 T := by\n  simp [pullSub, List.take_of_length_le hl, List.drop_eq_nil_iff.mpr hl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Descriptive/Tree.lean", "context": {"open": [], "variables": ["{A : Type*} {S T : tree A}", "(T) (x y : List A)", "{T x y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "tree : ?m.2508\nA\u271d : Type u_1\nS : sorry\nT : sorry\nx\u271d\u00b9 y\u271d : List A\u271d\nA : Type u_1\nx y : List A\nx\u271d : Sort u_2\npullSub : x\u271d\nhl : y.length \u2264 x.length\n\u22a2 y \u2208 sorry \u2194 y <+: x \u2227 sorry"}, {"line": "simp [pullSub, List.take_of_length_le hl, List.drop_eq_nil_iff.mpr hl]", "tactic_state": "tree : ?m.2508\nA\u271d : Type u_1\nS : sorry\nT : sorry\nx\u271d\u00b9 y\u271d : List A\u271d\nA : Type u_1\nx y : List A\nx\u271d : Sort u_2\npullSub : x\u271d\nhl : y.length \u2264 x.length\n\u22a2 y \u2208 sorry () \u2194 y <+: x \u2227 sorry ()"}]}
{"declaration": "theorem nonneg : \u00acG < 0 := by\n  simpa using nonpos (-G)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Impartial.lean", "context": {"open": ["scoped PGame"], "variables": ["(G : PGame) [Impartial G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : \u2115\n\u22a2 \u00acG < 0"}, {"line": "simpa using nonpos (-G)", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short 0 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short 1 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short 2 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short (-2) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short (ofLists [0] [1]) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short (ofLists [-2, -1] [1]) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short (0 + 0) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Decidable ((1 : PGame) \u2264 1) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\n\u22a2 Decidable sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bddAbove_of_small (s : Set Game.{u}) [Small.{u} s] : BddAbove s := by\n  simpa using bddAbove_range_of_small (Subtype.val : s \u2192 Game.{u})\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Basic.lean", "context": {"open": ["Function PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nGame : x\u271d\ns : Set sorry\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry"}, {"line": "simpa using bddAbove_range_of_small (Subtype.val : s \u2192 Game.{u})", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bddBelow_of_small (s : Set Game.{u}) [Small.{u} s] : BddBelow s := by\n  simpa using bddBelow_range_of_small (Subtype.val : s \u2192 Game.{u})\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Basic.lean", "context": {"open": ["Function PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nGame : x\u271d\ns : Set sorry\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry"}, {"line": "simpa using bddBelow_range_of_small (Subtype.val : s \u2192 Game.{u})", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quot_neg_mul_neg (x y : PGame) : \u27e6-x * -y\u27e7 = (\u27e6x * y\u27e7 : Game) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Basic.lean", "context": {"open": ["Function PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nGame : Sort u_2\nx y : PGame\n\u22a2 \u27e6sorry\u27e7 = sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nGame : Sort u_2\nx y : PGame\n\u22a2 \u27e6sorry ()\u27e7 = sorry ()"}]}
{"declaration": "lemma mulOption_neg_neg {x} (y) {i j} :\n    mulOption x y i j = mulOption x (-(-y)) i (toLeftMovesNeg <| toRightMovesNeg j) := by\n  simp [mulOption]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Basic.lean", "context": {"open": ["Function PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nmulOption : x\u271d\nx : ?m.850\ny : ?m.851\ni : ?m.852 y\nj : ?m.853 y\n\u22a2 sorry = sorry"}, {"line": "simp [mulOption]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem birthday_zero : birthday 0 = 0 := by simp [inferInstanceAs (IsEmpty PEmpty)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Birthday.lean", "context": {"open": ["Ordinal", "scoped NaturalOps PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbirthday : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [inferInstanceAs (IsEmpty PEmpty)]", "tactic_state": "x\u271d : Sort u_1\nbirthday : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem neg_birthday_le : -x.birthday.toPGame \u2264 x := by\n  simpa only [birthday_neg,\u2190 neg_le_iff] using le_birthday (-x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Birthday.lean", "context": {"open": ["Ordinal", "scoped NaturalOps PGame"], "variables": ["(x : PGame.{u})"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : ?m.10\nx : sorry\n\u22a2 sorry"}, {"line": "simpa only [birthday_neg,\u2190 neg_le_iff] using le_birthday (-x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem moveLeft_toLeftMovesNim {o : Ordinal} (i) :\n    (nim o).moveLeft (toLeftMovesNim i) = nim i := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnim : x\u271d\no : Ordinal.{u_2}\ni : ?m.856\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem moveRight_toRightMovesNim {o : Ordinal} (i) :\n    (nim o).moveRight (toRightMovesNim i) = nim i := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnim : x\u271d\no : Ordinal.{u_2}\ni : ?m.856\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toLeftMovesNim_one_symm (i) :\n    (@toLeftMovesNim 1).symm i = \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9 := by\n  simp [eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoLeftMovesNim : x\u271d\ni : ?m.446\n\u22a2 sorry = sorry"}, {"line": "simp [eq_iff_true_of_subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toRightMovesNim_one_symm (i) :\n    (@toRightMovesNim 1).symm i = \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9 := by\n  simp [eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoRightMovesNim : x\u271d\ni : ?m.446\n\u22a2 sorry = sorry"}, {"line": "simp [eq_iff_true_of_subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nim_one_moveLeft (x) : (nim 1).moveLeft x = nim 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnim : x\u271d\nx : ?m.850\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nim_one_moveRight (x) : (nim 1).moveRight x = nim 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnim : x\u271d\nx : ?m.850\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_grundyValue_of_Iio_subset_moveLeft {G : PGame} {o : Nimber}\n    (h : Set.Iio o \u2286 Set.range (grundyValue \u2218 G.moveLeft)) : o \u2264 grundyValue G := by\n  by_contra! ho\n  obtain \u27e8i, hi\u27e9 := h ho\n  exact grundyValue_ne_moveLeft i hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Sort u_1\ngrundyValue : PGame \u2192 Nimber\nG : PGame\no : Nimber\nh : Set.Iio o \u2286 Set.range (grundyValue \u2218 sorry)\n\u22a2 o \u2264 grundyValue G"}, {"line": "by_contra! ho", "tactic_state": "PGame : Sort u_1\ngrundyValue : PGame \u2192 Nimber\nG : PGame\no : Nimber\nh : Set.Iio o \u2286 Set.range (grundyValue \u2218 sorry)\nho : grundyValue G < o\n\u22a2 False"}, {"line": "obtain \u27e8i, hi\u27e9 := h ho", "tactic_state": "case intro\nPGame : Sort u_1\ngrundyValue : PGame \u2192 Nimber\nG : PGame\no : Nimber\nh : Set.Iio o \u2286 Set.range (grundyValue \u2218 sorry)\nho : grundyValue G < o\ni : ?m.652\nhi : (grundyValue \u2218 sorry) i = grundyValue G\n\u22a2 False"}, {"line": "exact grundyValue_ne_moveLeft i hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem grundyValue_le_of_forall_moveLeft {G : PGame} {o : Nimber}\n    (h : \u2200 i, grundyValue (G.moveLeft i) \u2260 o) : G.grundyValue \u2264 o := by\n  contrapose! h\n  exact exists_grundyValue_moveLeft_of_lt h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Sort u_1\nx\u271d : Sort u_2\ngrundyValue : x\u271d\nG : PGame\no : Nimber\nh : ?m.596 \u2192 sorry \u2260 o\n\u22a2 sorry \u2264 o"}, {"line": "contrapose! h", "tactic_state": "PGame : Sort u_1\nx\u271d : Sort u_2\ngrundyValue : x\u271d\nG : PGame\no : Nimber\nh : o < sorry\n\u22a2 \u2203 i, sorry = o"}, {"line": "exact exists_grundyValue_moveLeft_of_lt h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toPGame_moveLeft {o : Ordinal} (i) :\n    o.toPGame.moveLeft (toLeftMovesToPGame i) = i.val.toPGame := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Ordinal.lean", "context": {"open": ["SetTheory PGame", "scoped NaturalOps PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoLeftMovesToPGame : x\u271d\no : Ordinal.{u_2}\ni : ?m.473\n\u22a2 o.toPGame.moveLeft sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\ntoLeftMovesToPGame : x\u271d\no : Ordinal.{u_2}\ni : ?m.473\n\u22a2 (\u2191(Ordinal.toLeftMovesToPGame.symm (sorry ()))).toPGame = sorry ()"}]}
{"declaration": "theorem to_leftMoves_one_toPGame_symm (i) :\n    (@toLeftMovesToPGame 1).symm i = \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9 := by\n  simp [eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Ordinal.lean", "context": {"open": ["SetTheory PGame", "scoped NaturalOps PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoLeftMovesToPGame : x\u271d\ni : ?m.446\n\u22a2 sorry = sorry"}, {"line": "simp [eq_iff_true_of_subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_toPGame_moveLeft (x) : (toPGame 1).moveLeft x = toPGame 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Ordinal.lean", "context": {"open": ["SetTheory PGame", "scoped NaturalOps PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoPGame : x\u271d\nx : ?m.850\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_def (a b : Nimber) :\n    a + b = sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c := by\n  change Nimber.add a b = _\n  rw [Nimber.add]\n  simp_rw [exists_prop]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Nimber\n\u22a2 a + b = sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c"}, {"line": "change Nimber.add a b = _", "tactic_state": "a b : Nimber\n\u22a2 a.add b = sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c"}, {"line": "rw [Nimber.add]", "tactic_state": "a b : Nimber\n\u22a2 sInf {x | (\u2203 a', \u2203 (_ : a' < a), a'.add b = x) \u2228 \u2203 b', \u2203 (_ : b' < b), a.add b' = x}\u1d9c =\n    sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c"}, {"line": "simp_rw [exists_prop]", "tactic_state": "a b : Nimber\n\u22a2 sInf {x | (\u2203 a' < a, a'.add b = x) \u2228 \u2203 b' < b, a.add b' = x}\u1d9c =\n    sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_of_lt_add (h : c < a + b) : (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c := by\n  rw [add_def] at h\n  have := not_mem_of_lt_csInf' h\n  rwa [Set.mem_compl_iff, not_not] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Nimber\nh : c < a + b\n\u22a2 (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c"}, {"line": "rw [add_def] at h", "tactic_state": "a b c : Nimber\nh : c < sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c\n\u22a2 (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c"}, {"line": "have := not_mem_of_lt_csInf' h", "tactic_state": "a b c : Nimber\nh : c < sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c\nthis : c \u2209 {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c\n\u22a2 (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c"}, {"line": "rwa [Set.mem_compl_iff, not_not] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_le_of_forall_ne (h\u2081 : \u2200 a' < a, a' + b \u2260 c) (h\u2082 : \u2200 b' < b, a + b' \u2260 c) :\n    a + b \u2264 c := by\n  by_contra! h\n  have := exists_of_lt_add h\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Nimber\nh\u2081 : \u2200 a' < a, a' + b \u2260 c\nh\u2082 : \u2200 b' < b, a + b' \u2260 c\n\u22a2 a + b \u2264 c"}, {"line": "by_contra! h", "tactic_state": "a b c : Nimber\nh\u2081 : \u2200 a' < a, a' + b \u2260 c\nh\u2082 : \u2200 b' < b, a + b' \u2260 c\nh : c < a + b\n\u22a2 False"}, {"line": "have := exists_of_lt_add h", "tactic_state": "a b c : Nimber\nh\u2081 : \u2200 a' < a, a' + b \u2260 c\nh\u2082 : \u2200 b' < b, a + b' \u2260 c\nh : c < a + b\nthis : (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c\n\u22a2 False"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_cancel_right (a b : Nimber) : a + b + b = a := by\n  rw [add_assoc]\n  rw [add_self]\n  rw [add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Nimber\n\u22a2 a + b + b = a"}, {"line": "rw [add_assoc]", "tactic_state": "a b : Nimber\n\u22a2 a + (b + b) = a"}, {"line": "rw [add_self]", "tactic_state": "a b : Nimber\n\u22a2 a + 0 = a"}, {"line": "rw [add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_cancel_left (a b : Nimber) : a + (a + b) = b := by\n  rw [\u2190 add_assoc]\n  rw [add_self]\n  rw [zero_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Nimber\n\u22a2 a + (a + b) = b"}, {"line": "rw [\u2190 add_assoc]", "tactic_state": "a b : Nimber\n\u22a2 a + a + b = b"}, {"line": "rw [add_self]", "tactic_state": "a b : Nimber\n\u22a2 0 + b = b"}, {"line": "rw [zero_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_add_cases {a b c : Nimber} (h : a < b + c) : a + c < b \u2228 a + b < c := by\n  obtain ha | hb | hc := add_trichotomy <| add_assoc a b c \u25b8 add_ne_zero_iff.2 h.ne\n  exacts [(h.asymm ha).elim, Or.inl <| add_comm c a \u25b8 hb, Or.inr hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Nimber\nh : a < b + c\n\u22a2 a + c < b \u2228 a + b < c"}, {"line": "obtain ha | hb | hc := add_trichotomy <| add_assoc a b c \u25b8 add_ne_zero_iff.2 h.ne", "tactic_state": "case inl\na b c : Nimber\nh : a < b + c\nha : b + c < a\n\u22a2 a + c < b \u2228 a + b < c\n---\ncase inr.inl\na b c : Nimber\nh : a < b + c\nhb : c + a < b\n\u22a2 a + c < b \u2228 a + b < c\n---\ncase inr.inr\na b c : Nimber\nh : a < b + c\nhc : a + b < c\n\u22a2 a + c < b \u2228 a + b < c"}, {"line": "exacts [(h.asymm ha).elim, Or.inl <| add_comm c a \u25b8 hb, Or.inr hc]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem two_zsmul (x : Nimber) : (2 : \u2124) \u2022 x = 0 := by\n  rw [_root_.two_zsmul]\n  exact add_self x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Field.lean", "context": {"open": ["Function Order"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Nimber\n\u22a2 2 \u2022 x = 0"}, {"line": "rw [_root_.two_zsmul]", "tactic_state": "x : Nimber\n\u22a2 x + x = 0"}, {"line": "exact add_self x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_def (a b : Nimber) :\n    a * b = sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c := by\n  change Nimber.mul a b = _\n  rw [Nimber.mul]\n  simp_rw [exists_prop]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Field.lean", "context": {"open": ["Function Order"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Nimber\n\u22a2 a * b = sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c"}, {"line": "change Nimber.mul a b = _", "tactic_state": "a b : Nimber\n\u22a2 a.mul b = sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c"}, {"line": "rw [Nimber.mul]", "tactic_state": "a b : Nimber\n\u22a2 sInf {x | \u2203 a', \u2203 (_ : a' < a), \u2203 b', \u2203 (_ : b' < b), a'.mul b + a.mul b' + a'.mul b' = x}\u1d9c =\n    sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c"}, {"line": "simp_rw [exists_prop]", "tactic_state": "a b : Nimber\n\u22a2 sInf {x | \u2203 a' < a, \u2203 b' < b, a'.mul b + a.mul b' + a'.mul b' = x}\u1d9c =\n    sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_eq (h : Acc r a) :\n    h.rank = \u2a06 b : { b // r b a }, Order.succ (h.inv b.2).rank := by\n  change (Acc.intro a fun _ => h.inv).rank = _\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Rank.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {a b : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\na : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Acc r a\n\u22a2 h.rank = \u2a06 b, Order.succ \u22ef.rank"}, {"line": "change (Acc.intro a fun _ => h.inv).rank = _", "tactic_state": "\u03b1 : Type u\na : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Acc r a\n\u22a2 \u22ef.rank = \u2a06 b, Order.succ \u22ef.rank"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLimit_iff {o} : IsLimit o \u2194 o \u2260 0 \u2227 IsSuccPrelimit o := by\n  simp [IsLimit, IsSuccLimit]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\no : \u2115\n\u22a2 sorry \u2194 o \u2260 0 \u2227 IsSuccPrelimit o"}, {"line": "simp [IsLimit, IsSuccLimit]", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\no : \u2115\n\u22a2 \u00acsorry ()"}]}
{"declaration": "theorem IsLimit.one_lt {o : Ordinal} (h : IsLimit o) : 1 < o := by\n  simpa only [succ_zero] using h.succ_lt h.pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\n\u22a2 1 < o"}, {"line": "simpa only [succ_zero] using h.succ_lt h.pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLimit.sSup_Iio {o : Ordinal} (h : IsLimit o) : sSup (Iio o) = o := by\n  apply (csSup_le' (fun a ha \u21a6 le_of_lt ha)).antisymm\n  apply le_of_forall_lt\n  intro a ha\n  exact (lt_succ a).trans_le (le_csSup bddAbove_Iio (h.succ_lt ha))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\n\u22a2 sSup (Iio o) = o"}, {"line": "apply (csSup_le' (fun a ha \u21a6 le_of_lt ha)).antisymm", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\n\u22a2 o \u2264 sSup fun a => Preorder.toLT.1 a o"}, {"line": "apply le_of_forall_lt", "tactic_state": "case H\nx\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\n\u22a2 \u2200 c < o, c < sSup fun a => Preorder.toLT.1 a o"}, {"line": "intro a ha", "tactic_state": "case H\nx\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\na : Ordinal.{u_2}\nha : a < o\n\u22a2 a < sSup fun a => Preorder.toLT.1 a o"}, {"line": "exact (lt_succ a).trans_le (le_csSup bddAbove_Iio (h.succ_lt ha))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_sub_of_le {a b c : Ordinal} (h : b \u2264 a) : c \u2264 a - b \u2194 b + c \u2264 a := by\n  rw [\u2190 add_le_add_iff_left b]\n  rw [Ordinal.add_sub_cancel_of_le h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nh : b \u2264 a\n\u22a2 c \u2264 a - b \u2194 b + c \u2264 a"}, {"line": "rw [\u2190 add_le_add_iff_left b]", "tactic_state": "a b c : Ordinal.{u_1}\nh : b \u2264 a\n\u22a2 b + c \u2264 b + (a - b) \u2194 b + c \u2264 a"}, {"line": "rw [Ordinal.add_sub_cancel_of_le h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_zero (a : Ordinal) : a - 0 = a := by simpa only [zero_add] using add_sub_cancel 0 a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a - 0 = a"}, {"line": "simpa only [zero_add] using add_sub_cancel 0 a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_self (a : Ordinal) : a - a = 0 := by simpa only [add_zero] using add_sub_cancel a 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a - a = 0"}, {"line": "simpa only [add_zero] using add_sub_cancel a 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_sub_of_add_le {a b c : Ordinal} (h : b + c \u2264 a) : c \u2264 a - b := by\n  rw [\u2190 add_le_add_iff_left b]\n  exact h.trans (le_add_sub a b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nh : b + c \u2264 a\n\u22a2 c \u2264 a - b"}, {"line": "rw [\u2190 add_le_add_iff_left b]", "tactic_state": "a b c : Ordinal.{u_1}\nh : b + c \u2264 a\n\u22a2 b + c \u2264 b + (a - b)"}, {"line": "exact h.trans (le_add_sub a b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_lt_of_lt_add {a b c : Ordinal} (h : a < b + c) (hc : 0 < c) : a - b < c := by\n  obtain hab | hba := lt_or_le a b\n  \u00b7 rwa [Ordinal.sub_eq_zero_iff_le.2 hab.le]\n  \u00b7 rwa [sub_lt_of_le hba]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nh : a < b + c\nhc : 0 < c\n\u22a2 a - b < c"}, {"line": "obtain hab | hba := lt_or_le a b", "tactic_state": "case inl\na b c : Ordinal.{u_1}\nh : a < b + c\nhc : 0 < c\nhab : a < b\n\u22a2 a - b < c\n---\ncase inr\na b c : Ordinal.{u_1}\nh : a < b + c\nhc : 0 < c\nhba : b \u2264 a\n\u22a2 a - b < c"}, {"line": "\u00b7 rwa [Ordinal.sub_eq_zero_iff_le.2 hab.le]", "tactic_state": "case inr\na b c : Ordinal.{u_1}\nh : a < b + c\nhc : 0 < c\nhba : b \u2264 a\n\u22a2 a - b < c"}, {"line": "\u00b7 rwa [sub_lt_of_le hba]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_add_iff {a b c : Ordinal} (hc : c \u2260 0) : a < b + c \u2194 \u2203 d < c, a \u2264 b + d := by\n  use fun h \u21a6 \u27e8_, sub_lt_of_lt_add h hc.bot_lt, le_add_sub a b\u27e9\n  rintro \u27e8d, hd, ha\u27e9\n  exact ha.trans_lt (add_lt_add_left hd b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 a < b + c \u2194 \u2203 d < c, a \u2264 b + d"}, {"line": "use fun h \u21a6 \u27e8_, sub_lt_of_lt_add h hc.bot_lt, le_add_sub a b\u27e9", "tactic_state": "case mpr\na b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 (\u2203 d < c, a \u2264 b + d) \u2192 a < b + c\n---\ncase mp\na b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 a < b + c \u2192 \u2203 d < c, a \u2264 b + d"}, {"line": "rintro \u27e8d, hd, ha\u27e9", "tactic_state": "case mpr.intro.intro\na b c : Ordinal.{u_1}\nhc : c \u2260 0\nd : Ordinal.{u_1}\nhd : d < c\nha : a \u2264 b + d\n\u22a2 a < b + c\n---\ncase mp\na b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 a < b + c \u2192 \u2203 d < c, a \u2264 b + d"}, {"line": "exact ha.trans_lt (add_lt_add_left hd b)", "tactic_state": "case mp\na b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 a < b + c \u2192 \u2203 d < c, a \u2264 b + d"}]}
{"declaration": "theorem add_le_iff {a b c : Ordinal} (hb : b \u2260 0) : a + b \u2264 c \u2194 \u2200 d < b, a + d < c := by\n  simpa using (lt_add_iff hb).not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nhb : b \u2260 0\n\u22a2 a + b \u2264 c \u2194 \u2200 d < b, a + d < c"}, {"line": "simpa using (lt_add_iff hb).not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_mul_left (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a \u2264 a * b := by\n  convert mul_le_mul_left' (one_le_iff_pos.2 hb) a\n  rw [mul_one a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nhb : 0 < b\n\u22a2 a \u2264 a * b"}, {"line": "convert mul_le_mul_left' (one_le_iff_pos.2 hb) a", "tactic_state": "case h.e'_3\na b : Ordinal.{u_1}\nhb : 0 < b\n\u22a2 a = a * 1"}, {"line": "rw [mul_one a]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_mul_right (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a \u2264 b * a := by\n  convert mul_le_mul_right' (one_le_iff_pos.2 hb) a\n  rw [one_mul a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nhb : 0 < b\n\u22a2 a \u2264 b * a"}, {"line": "convert mul_le_mul_right' (one_le_iff_pos.2 hb) a", "tactic_state": "case h.e'_3\na b : Ordinal.{u_1}\nhb : 0 < b\n\u22a2 a = 1 * a"}, {"line": "rw [one_mul a]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_pos {a b : Ordinal} (h\u2081 : 0 < a) (h\u2082 : 0 < b) : 0 < a * b := by\n  simpa only [mul_zero] using mul_lt_mul_of_pos_left h\u2082 h\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nh\u2081 : 0 < a\nh\u2082 : 0 < b\n\u22a2 0 < a * b"}, {"line": "simpa only [mul_zero] using mul_lt_mul_of_pos_left h\u2082 h\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_mul_div_add (a) {b : Ordinal} (h : b \u2260 0) : a < b * (a / b) + b := by\n  simpa only [mul_succ] using lt_mul_succ_div a h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nh : b \u2260 0\n\u22a2 a < b * (a / b) + b"}, {"line": "simpa only [mul_succ] using lt_mul_succ_div a h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_div_cancel (a) {b : Ordinal} (b0 : b \u2260 0) : b * a / b = a := by\n  simpa only [add_zero,zero_div] using mul_add_div a b0 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nb0 : b \u2260 0\n\u22a2 b * a / b = a"}, {"line": "simpa only [add_zero,zero_div] using mul_add_div a b0 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_add_div_mul {a c : Ordinal} (hc : c < a) (b d : Ordinal) :\n    (a * b + c) / (a * d) = b / d := by\n  have ha : a \u2260 0 := ((Ordinal.zero_le c).trans_lt hc).ne'\n  obtain rfl | hd := eq_or_ne d 0\n  \u00b7 rw [mul_zero, div_zero, div_zero]\n  \u00b7 have H := mul_ne_zero ha hd\n    apply le_antisymm\n    \u00b7 rw [\u2190 lt_succ_iff, div_lt H, mul_assoc]\n      \u00b7 apply (add_lt_add_left hc _).trans_le\n        rw [\u2190 mul_succ]\n        apply mul_le_mul_left'\n        rw [succ_le_iff]\n        exact lt_mul_succ_div b hd\n    \u00b7 rw [le_div H, mul_assoc]\n      exact (mul_le_mul_left' (mul_div_le b d) a).trans (le_add_right _ c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c : Ordinal.{u_1}\nhc : c < a\nb d : Ordinal.{u_1}\n\u22a2 (a * b + c) / (a * d) = b / d"}, {"line": "have ha : a \u2260 0 := ((Ordinal.zero_le c).trans_lt hc).ne'", "tactic_state": "a c : Ordinal.{u_1}\nhc : c < a\nb d : Ordinal.{u_1}\nha : a \u2260 0\n\u22a2 (a * b + c) / (a * d) = b / d"}, {"line": "obtain rfl | hd := eq_or_ne d 0", "tactic_state": "case inl\na c : Ordinal.{u_1}\nhc : c < a\nb : Ordinal.{u_1}\nha : a \u2260 0\n\u22a2 (a * b + c) / (a * 0) = b / 0\n---\ncase inr\na c : Ordinal.{u_1}\nhc : c < a\nb d : Ordinal.{u_1}\nha : a \u2260 0\nhd : d \u2260 0\n\u22a2 (a * b + c) / (a * d) = b / d"}, {"line": "\u00b7 rw [mul_zero, div_zero, div_zero]", "tactic_state": "case inr\na c : Ordinal.{u_1}\nhc : c < a\nb d : Ordinal.{u_1}\nha : a \u2260 0\nhd : d \u2260 0\n\u22a2 (a * b + c) / (a * d) = b / d"}, {"line": "\u00b7 have H := mul_ne_zero ha hd\n    apply le_antisymm\n    \u00b7 rw [\u2190 lt_succ_iff, div_lt H, mul_assoc]\n      \u00b7 apply (add_lt_add_left hc _).trans_le\n        rw [\u2190 mul_succ]\n        apply mul_le_mul_left'\n        rw [succ_le_iff]\n        exact lt_mul_succ_div b hd\n    \u00b7 rw [le_div H, mul_assoc]\n      exact (mul_le_mul_left' (mul_div_le b d) a).trans (le_add_right _ c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_one (a : Ordinal) : a / 1 = a := by\n  simpa only [one_mul] using mul_div_cancel a Ordinal.one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a / 1 = a"}, {"line": "simpa only [one_mul] using mul_div_cancel a Ordinal.one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mod_eq_zero_of_dvd {a b : Ordinal} (H : b \u2223 a) : a % b = 0 := by\n  rcases H with \u27e8c, rfl\u27e9\n  rcases eq_or_ne b 0 with (rfl | hb)\n  \u00b7 simp\n  \u00b7 simp [mod_def, hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nH : b \u2223 a\n\u22a2 a % b = 0"}, {"line": "rcases H with \u27e8c, rfl\u27e9", "tactic_state": "case intro\nb c : Ordinal.{u_1}\n\u22a2 b * c % b = 0"}, {"line": "rcases eq_or_ne b 0 with (rfl | hb)", "tactic_state": "case intro.inl\nc : Ordinal.{u_1}\n\u22a2 0 * c % 0 = 0\n---\ncase intro.inr\nb c : Ordinal.{u_1}\nhb : b \u2260 0\n\u22a2 b * c % b = 0"}, {"line": "\u00b7 simp", "tactic_state": "case intro.inr\nb c : Ordinal.{u_1}\nhb : b \u2260 0\n\u22a2 b * c % b = 0"}, {"line": "\u00b7 simp [mod_def, hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_add_mod_self (x y z : Ordinal) : (x * y + z) % x = z % x := by\n  rcases eq_or_ne x 0 with rfl | hx\n  \u00b7 simp\n  \u00b7 rwa [mod_def, mul_add_div, mul_add, \u2190 sub_sub, add_sub_cancel, mod_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : Ordinal.{u_1}\n\u22a2 (x * y + z) % x = z % x"}, {"line": "rcases eq_or_ne x 0 with rfl | hx", "tactic_state": "case inl\ny z : Ordinal.{u_1}\n\u22a2 (0 * y + z) % 0 = z % 0\n---\ncase inr\nx y z : Ordinal.{u_1}\nhx : x \u2260 0\n\u22a2 (x * y + z) % x = z % x"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nx y z : Ordinal.{u_1}\nhx : x \u2260 0\n\u22a2 (x * y + z) % x = z % x"}, {"line": "\u00b7 rwa [mod_def, mul_add_div, mul_add, \u2190 sub_sub, add_sub_cancel, mod_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_mod (x y : Ordinal) : x * y % x = 0 := by\n  simpa using mul_add_mod_self x y 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Ordinal.{u_1}\n\u22a2 x * y % x = 0"}, {"line": "simpa using mul_add_mod_self x y 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_mod_mul (x y z : Ordinal) : (x * y) % (x * z) = x * (y % z) := by\n  obtain rfl | hx := Ordinal.eq_zero_or_pos x\n  \u00b7 simp\n  \u00b7 convert mul_add_mod_mul hx y z using 1 <;>\n    rw [add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : Ordinal.{u_1}\n\u22a2 x * y % (x * z) = x * (y % z)"}, {"line": "obtain rfl | hx := Ordinal.eq_zero_or_pos x", "tactic_state": "case inl\ny z : Ordinal.{u_1}\n\u22a2 0 * y % (0 * z) = 0 * (y % z)\n---\ncase inr\nx y z : Ordinal.{u_1}\nhx : 0 < x\n\u22a2 x * y % (x * z) = x * (y % z)"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nx y z : Ordinal.{u_1}\nhx : 0 < x\n\u22a2 x * y % (x * z) = x * (y % z)"}, {"line": "\u00b7 convert mul_add_mod_mul hx y z using 1 <;>\n    rw [add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_add_natCast (m : \u2115) : 1 + (m : Ordinal) = succ m := by\n  rw [\u2190 Nat.cast_one]\n  rw [\u2190 Nat.cast_add]\n  rw [add_comm]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 1 + \u2191m = \u2191(succ m)"}, {"line": "rw [\u2190 Nat.cast_one]", "tactic_state": "m : \u2115\n\u22a2 \u21911 + \u2191m = \u2191(succ m)"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "m : \u2115\n\u22a2 \u2191(1 + m) = \u2191(succ m)"}, {"line": "rw [add_comm]", "tactic_state": "m : \u2115\n\u22a2 \u2191(m + 1) = \u2191(succ m)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_sub (m n : \u2115) : ((m - n : \u2115) : Ordinal) = m - n := by\n  rcases le_total m n with h | h\n  \u00b7 rw [tsub_eq_zero_iff_le.2 h, Ordinal.sub_eq_zero_iff_le.2 (Nat.cast_le.2 h), Nat.cast_zero]\n  \u00b7 rw [\u2190 add_left_cancel_iff (a := \u2191n), \u2190 Nat.cast_add, add_tsub_cancel_of_le h,\n      Ordinal.add_sub_cancel_of_le (Nat.cast_le.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 \u2191(m - n) = \u2191m - \u2191n"}, {"line": "rcases le_total m n with h | h", "tactic_state": "case inl\nm n : \u2115\nh : m \u2264 n\n\u22a2 \u2191(m - n) = \u2191m - \u2191n\n---\ncase inr\nm n : \u2115\nh : n \u2264 m\n\u22a2 \u2191(m - n) = \u2191m - \u2191n"}, {"line": "\u00b7 rw [tsub_eq_zero_iff_le.2 h, Ordinal.sub_eq_zero_iff_le.2 (Nat.cast_le.2 h), Nat.cast_zero]", "tactic_state": "case inr\nm n : \u2115\nh : n \u2264 m\n\u22a2 \u2191(m - n) = \u2191m - \u2191n"}, {"line": "\u00b7 rw [\u2190 add_left_cancel_iff (a := \u2191n), \u2190 Nat.cast_add, add_tsub_cancel_of_le h,\n      Ordinal.add_sub_cancel_of_le (Nat.cast_le.2 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_div (m n : \u2115) : ((m / n : \u2115) : Ordinal) = m / n := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  \u00b7 simp\n  \u00b7 have hn' : (n : Ordinal) \u2260 0 := Nat.cast_ne_zero.2 hn\n    apply le_antisymm\n    \u00b7 rw [le_div hn', \u2190 natCast_mul, Nat.cast_le, mul_comm]\n      apply Nat.div_mul_le_self\n    \u00b7 rw [div_le hn', \u2190 add_one_eq_succ, \u2190 Nat.cast_succ, \u2190 natCast_mul, Nat.cast_lt, mul_comm,\n        \u2190 Nat.div_lt_iff_lt_mul (Nat.pos_of_ne_zero hn)]\n      apply Nat.lt_succ_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 \u2191(m / n) = \u2191m / \u2191n"}, {"line": "rcases eq_or_ne n 0 with (rfl | hn)", "tactic_state": "case inl\nm : \u2115\n\u22a2 \u2191(m / 0) = \u2191m / \u21910\n---\ncase inr\nm n : \u2115\nhn : n \u2260 0\n\u22a2 \u2191(m / n) = \u2191m / \u2191n"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nm n : \u2115\nhn : n \u2260 0\n\u22a2 \u2191(m / n) = \u2191m / \u2191n"}, {"line": "\u00b7 have hn' : (n : Ordinal) \u2260 0 := Nat.cast_ne_zero.2 hn\n    apply le_antisymm\n    \u00b7 rw [le_div hn', \u2190 natCast_mul, Nat.cast_le, mul_comm]\n      apply Nat.div_mul_le_self\n    \u00b7 rw [div_le hn', \u2190 add_one_eq_succ, \u2190 Nat.cast_succ, \u2190 natCast_mul, Nat.cast_lt, mul_comm,\n        \u2190 Nat.div_lt_iff_lt_mul (Nat.pos_of_ne_zero hn)]\n      apply Nat.lt_succ_self", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_nat_or_omega0_le (o : Ordinal) : (\u2203 n : \u2115, o = n) \u2228 \u03c9 \u2264 o := by\n  obtain ho | ho := lt_or_le o \u03c9\n  \u00b7 exact Or.inl <| lt_omega0.1 ho\n  \u00b7 exact Or.inr ho\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 (\u2203 n, o = \u2191n) \u2228 Ordinal.omega0 \u2264 o"}, {"line": "obtain ho | ho := lt_or_le o \u03c9", "tactic_state": "case inl\no : Ordinal.{u_1}\nho : o < sorry\n\u22a2 (\u2203 n, o = \u2191n) \u2228 Ordinal.omega0 \u2264 o\n---\ncase inr\no : Ordinal.{u_1}\nho : sorry \u2264 o\n\u22a2 (\u2203 n, o = \u2191n) \u2228 Ordinal.omega0 \u2264 o"}, {"line": "\u00b7 exact Or.inl <| lt_omega0.1 ho", "tactic_state": "case inr\no : Ordinal.{u_1}\nho : sorry \u2264 o\n\u22a2 (\u2203 n, o = \u2191n) \u2228 Ordinal.omega0 \u2264 o"}, {"line": "\u00b7 exact Or.inr ho", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_omega0 : 1 < \u03c9 := by simpa only [Nat.cast_one] using nat_lt_omega0 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 < Ordinal.omega0"}, {"line": "simpa only [Nat.cast_one] using nat_lt_omega0 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_one_of_aleph0_le {c} (h : \u2135\u2080 \u2264 c) : c + 1 = c := by\n  rw [add_comm]\n  rw [\u2190 card_ord c]\n  rw [\u2190 card_one]\n  rw [\u2190 card_add]\n  rw [one_add_of_omega0_le]\n  rwa [\u2190 ord_aleph0, ord_le_ord]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in", "Ordinal", "Ordinal"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_4}\nh : aleph0 \u2264 c\n\u22a2 c + 1 = c"}, {"line": "rw [add_comm]", "tactic_state": "c : Cardinal.{u_4}\nh : aleph0 \u2264 c\n\u22a2 1 + c = c"}, {"line": "rw [\u2190 card_ord c]", "tactic_state": "c : Cardinal.{u_4}\nh : aleph0 \u2264 c\n\u22a2 1 + c.ord.card = c.ord.card"}, {"line": "rw [\u2190 card_one]", "tactic_state": "c : Cardinal.{u_4}\nh : aleph0 \u2264 c\n\u22a2 card 1 + c.ord.card = c.ord.card"}, {"line": "rw [\u2190 card_add]", "tactic_state": "c : Cardinal.{u_4}\nh : aleph0 \u2264 c\n\u22a2 (1 + c.ord).card = c.ord.card"}, {"line": "rw [one_add_of_omega0_le]", "tactic_state": "c : Cardinal.{u_4}\nh : aleph0 \u2264 c\n\u22a2 omega0 \u2264 c.ord"}, {"line": "rwa [\u2190 ord_aleph0, ord_le_ord]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem type_ne_zero_iff_nonempty [IsWellOrder \u03b1 r] : type r \u2260 0 \u2194 Nonempty \u03b1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\ntype : x\u271d\ninst\u271d : IsWellOrder \u03b1 r\n\u22a2 sorry \u2260 0 \u2194 Nonempty \u03b1"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\ntype : x\u271d\ninst\u271d : IsWellOrder \u03b1 r\n\u22a2 \u00acsorry () = 0 \u2194 Nonempty \u03b1"}]}
{"declaration": "theorem type_eq_one_of_unique (r) [IsWellOrder \u03b1 r] [Nonempty \u03b1] [Subsingleton \u03b1] : type r = 1 := by\n  cases nonempty_unique \u03b1\n  exact (RelIso.ofUniqueOfIrrefl r _).ordinal_type_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ntype : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b2 : IsWellOrder \u03b1 r\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Subsingleton \u03b1\n\u22a2 sorry = 1"}, {"line": "cases nonempty_unique \u03b1", "tactic_state": "case zero\n\u03b1 : Type u\nx\u271d : Sort u_1\ntype : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b2 : IsWellOrder \u03b1 r\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Subsingleton \u03b1\n\u22a2 0 = 1\n---\ncase succ\n\u03b1 : Type u\nx\u271d : Sort u_1\ntype : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b2 : IsWellOrder \u03b1 r\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Subsingleton \u03b1\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = 1"}, {"line": "exact (RelIso.ofUniqueOfIrrefl r _).ordinal_type_eq", "tactic_state": "case succ\n\u03b1 : Type u\nx\u271d : Sort u_1\ntype : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b2 : IsWellOrder \u03b1 r\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Subsingleton \u03b1\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = 1"}]}
{"declaration": "theorem enum_zero_le' {o : Ordinal} (h0 : 0 < o) (a : o.toType) :\n    enum (\u03b1 := o.toType) (\u00b7 < \u00b7) \u27e80, type_toType _ \u25b8 h0\u27e9 \u2264 a := by\n  rw [\u2190 not_lt]\n  apply enum_zero_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nenum : x\u271d\no : Ordinal.{u_2}\nh0 : 0 < o\na : o.toType\n\u22a2 sorry \u2264 a"}, {"line": "rw [\u2190 not_lt]", "tactic_state": "x\u271d : Sort u_1\nenum : x\u271d\no : Ordinal.{u_2}\nh0 : 0 < o\na : o.toType\n\u22a2 \u00aca < sorry"}, {"line": "apply enum_zero_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_lt {a b : Ordinal} : lift.{u, v} a < lift.{u, v} b \u2194 a < b := by\n  simp_rw [lt_iff_le_not_le, lift_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 lift.{u, v} sorry < lift.{u, v} sorry \u2194 a < b"}, {"line": "simp_rw [lt_iff_le_not_le, lift_le]", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 sorry \u2264 sorry \u2227 \u00acsorry \u2264 sorry \u2194 a \u2264 b \u2227 \u00acb \u2264 a"}]}
{"declaration": "theorem card_nat (n : \u2115) : card.{u} n = n := by\n  induction n <;> [simp; simp only [card_add, card_one, Nat.cast_succ, *]]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\nn : \u2115\n\u22a2 sorry = n"}, {"line": "induction n <;> [simp; simp only [card_add, card_one, Nat.cast_succ, *]]", "tactic_state": "case zero\nx\u271d : Sort u_1\ncard : x\u271d\n\u22a2 sorry () = 0\n---\ncase succ\nx\u271d : Sort u_1\ncard : x\u271d\nn\u271d : \u2115\na\u271d : sorry = n\u271d\n\u22a2 n\u271d = n\u271d + 1"}]}
{"declaration": "theorem le_add_right (a b : Ordinal) : a \u2264 a + b := by\n  simpa only [add_zero] using add_le_add_left (Ordinal.zero_le b) a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a \u2264 a + b"}, {"line": "simpa only [add_zero] using add_le_add_left (Ordinal.zero_le b) a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_add_left (a b : Ordinal) : a \u2264 b + a := by\n  simpa only [zero_add] using add_le_add_right (Ordinal.zero_le b) a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a \u2264 b + a"}, {"line": "simpa only [zero_add] using add_le_add_right (Ordinal.zero_le b) a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_iff_ne_zero {o : Ordinal} : 1 \u2264 o \u2194 o \u2260 0 := by\n  rw [Order.one_le_iff_pos]\n  rw [Ordinal.pos_iff_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 1 \u2264 o \u2194 o \u2260 0"}, {"line": "rw [Order.one_le_iff_pos]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 0 < o \u2194 o \u2260 0"}, {"line": "rw [Ordinal.pos_iff_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_one_iff_zero {a : Ordinal} : a < 1 \u2194 a = 0 := by\n  simpa using @lt_succ_bot_iff _ _ _ a _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a < 1 \u2194 a = 0"}, {"line": "simpa using @lt_succ_bot_iff _ _ _ a _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem typein_le_typein' (o : Ordinal) {x y : o.toType} :\n    typein (\u03b1 := o.toType) (\u00b7 < \u00b7) x \u2264 typein (\u03b1 := o.toType) (\u00b7 < \u00b7) y \u2194 x \u2264 y := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntypein : x\u271d\no : Ordinal.{u_2}\nx y : o.toType\n\u22a2 sorry \u2264 sorry \u2194 x \u2264 y"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\ntypein : x\u271d\no : Ordinal.{u_2}\nx y : o.toType\n\u22a2 sorry () \u2264 sorry () \u2194 x \u2264 y"}]}
{"declaration": "theorem card_le_iff {o : Ordinal} {c : Cardinal} : o.card \u2264 c \u2194 o < (succ c).ord := by\n  rw [lt_ord]\n  rw [lt_succ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nc : Cardinal.{u_1}\n\u22a2 o.card \u2264 c \u2194 o < (succ c).ord"}, {"line": "rw [lt_ord]", "tactic_state": "o : Ordinal.{u_1}\nc : Cardinal.{u_1}\n\u22a2 o.card \u2264 c \u2194 o.card < succ c"}, {"line": "rw [lt_succ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ord_one : ord 1 = 1 := by simpa using ord_nat 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ord 1 = 1"}, {"line": "simpa using ord_nat 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_ord_toType (c : Cardinal) : #c.ord.toType = c := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 Cardinal.mk c.ord.toType = c"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ord_injective : Injective ord := by\n  intro c c' h\n  rw [\u2190 card_ord c]\n  rw [\u2190 card_ord c']\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Injective ord"}, {"line": "intro c c' h", "tactic_state": "c c' : Cardinal.{u_1}\nh : c.ord = c'.ord\n\u22a2 c = c'"}, {"line": "rw [\u2190 card_ord c]", "tactic_state": "c c' : Cardinal.{u_1}\nh : c.ord = c'.ord\n\u22a2 c.ord.card = c'"}, {"line": "rw [\u2190 card_ord c']", "tactic_state": "c c' : Cardinal.{u_1}\nh : c.ord = c'.ord\n\u22a2 c.ord.card = c'.ord.card"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_card {o} : 1 \u2264 card o \u2194 1 \u2264 o := by\n  simpa using nat_le_card (n := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 1 \u2264 sorry \u2194 1 \u2264 o"}, {"line": "simpa using nat_le_card (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_lt_card {o} : 0 < card o \u2194 0 < o := by\n  simpa using nat_lt_card (n := 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 0 < sorry \u2194 0 < o"}, {"line": "simpa using nat_lt_card (n := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_card {o} : 1 < card o \u2194 1 < o := by\n  simpa using nat_lt_card (n := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 1 < sorry \u2194 1 < o"}, {"line": "simpa using nat_lt_card (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_le_one {o} : card o \u2264 1 \u2194 o \u2264 1 := by\n  simpa using card_le_nat (n := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 sorry \u2264 1 \u2194 o \u2264 1"}, {"line": "simpa using card_le_nat (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_zero {o} : card o = 0 \u2194 o = 0 := by\n  simpa using card_eq_nat (n := 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 sorry = 0 \u2194 o = 0"}, {"line": "simpa using card_eq_nat (n := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_one {o} : card o = 1 \u2194 o = 1 := by\n  simpa using card_eq_nat (n := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 sorry = 1 \u2194 o = 1"}, {"line": "simpa using card_eq_nat (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem type_fin (n : \u2115) : typeLT (Fin n) = n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntypeLT : x\u271d\nn : \u2115\n\u22a2 sorry = n"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\ntypeLT : x\u271d\nn : \u2115\n\u22a2 sorry () = n"}]}
{"declaration": "theorem zero_CNF {o : Ordinal} (ho : o \u2260 0) : CNF 0 o = [(0, o)] := by simp [CNF_ne_zero ho]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/CantorNormalForm.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCNF : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 sorry = [(0, o)]"}, {"line": "simp [CNF_ne_zero ho]", "tactic_state": "x\u271d : Sort u_1\nCNF : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 sorry () = [(0, o)]"}]}
{"declaration": "theorem one_CNF {o : Ordinal} (ho : o \u2260 0) : CNF 1 o = [(0, o)] := by simp [CNF_ne_zero ho]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/CantorNormalForm.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCNF : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 sorry = [(0, o)]"}, {"line": "simp [CNF_ne_zero ho]", "tactic_state": "x\u271d : Sort u_1\nCNF : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 sorry () = [(0, o)]"}]}
{"declaration": "private theorem enumOrd_nonempty (hs : \u00ac BddAbove s) (o : Ordinal) :\n    (s \u2229 { b | \u2200 c, c < o \u2192 enumOrd s c < b }).Nonempty := by\n  rw [not_bddAbove_iff] at hs\n  obtain \u27e8a, ha\u27e9 := bddAbove_of_small (enumOrd s '' Iio o)\n  obtain \u27e8b, hb, hba\u27e9 := hs a\n  exact \u27e8b, hb, fun c hc \u21a6 (ha (mem_image_of_mem _ hc)).trans_lt hba\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Enum.lean", "context": {"open": ["Order Set"], "variables": ["{o a b : Ordinal.{u}}", "{s : Set Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set Ordinal.{u}\nx\u271d : Sort u_1\nenumOrd : x\u271d\nhs : \u00acBddAbove s\no : Ordinal.{u_2}\n\u22a2 (s \u2229 {b | \u2200 c < o, sorry < b}).Nonempty"}, {"line": "rw [not_bddAbove_iff] at hs", "tactic_state": "s : Set Ordinal.{u}\nx\u271d : Sort u_1\nenumOrd : x\u271d\nhs : \u2200 (x : Ordinal.{u}), \u2203 y \u2208 s, x < y\no : Ordinal.{u_2}\n\u22a2 (s \u2229 {b | \u2200 c < o, sorry < b}).Nonempty"}, {"line": "obtain \u27e8a, ha\u27e9 := bddAbove_of_small (enumOrd s '' Iio o)", "tactic_state": "case mk.mk\ns : Set Ordinal.{u}\nx\u271d\u00b9 : Sort u_1\nenumOrd : x\u271d\u00b9\nhs : \u2200 (x : Ordinal.{u}), \u2203 y \u2208 s, x < y\no : Ordinal.{u_2}\nx\u271d : Ordinal.{u}\na : Type u\nha : a \u2192 a \u2192 Prop\nwo\u271d : IsWellOrder a ha\n\u22a2 (s \u2229 {b | \u2200 c < o, Quot.mk \u21d1Ordinal.isEquivalent { \u03b1 := a, r := ha, wo := wo\u271d } < b}).Nonempty"}, {"line": "obtain \u27e8b, hb, hba\u27e9 := hs a", "tactic_state": "case mk.mk.intro.intro\ns : Set Ordinal.{u}\nx\u271d\u00b9 : Sort u_1\nenumOrd : x\u271d\u00b9\nhs : \u2200 (x : Ordinal.{u}), \u2203 y \u2208 s, x < y\no : Ordinal.{u_2}\nx\u271d : Ordinal.{u}\na : Type u\nha : a \u2192 a \u2192 Prop\nwo\u271d : IsWellOrder a ha\nb : Ordinal.{u}\nhb : b \u2208 s\nhba : sorry < b\n\u22a2 (s \u2229 {b | \u2200 c < o, Quot.mk \u21d1Ordinal.isEquivalent { \u03b1 := a, r := ha, wo := wo\u271d } < b}).Nonempty"}, {"line": "exact \u27e8b, hb, fun c hc \u21a6 (ha (mem_image_of_mem _ hc)).trans_lt hba\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem opow_zero (a : Ordinal) : a ^ (0 : Ordinal) = 1 := by\n  obtain rfl | h := eq_or_ne a 0\n  \u00b7 rw [zero_opow', Ordinal.sub_zero]\n  \u00b7 rw [opow_of_ne_zero h, limitRecOn_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a ^ 0 = 1"}, {"line": "obtain rfl | h := eq_or_ne a 0", "tactic_state": "case inl\n\u22a2 0 ^ 0 = 1\n---\ncase inr\na : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 a ^ 0 = 1"}, {"line": "\u00b7 rw [zero_opow', Ordinal.sub_zero]", "tactic_state": "case inr\na : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 a ^ 0 = 1"}, {"line": "\u00b7 rw [opow_of_ne_zero h, limitRecOn_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem opow_succ (a b : Ordinal) : a ^ succ b = a ^ b * a := by\n  obtain rfl | h := eq_or_ne a 0\n  \u00b7 rw [zero_opow (succ_ne_zero b), mul_zero]\n  \u00b7 rw [opow_of_ne_zero h, opow_of_ne_zero h, limitRecOn_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a ^ succ b = a ^ b * a"}, {"line": "obtain rfl | h := eq_or_ne a 0", "tactic_state": "case inl\nb : Ordinal.{u_1}\n\u22a2 0 ^ succ b = 0 ^ b * 0\n---\ncase inr\na b : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 a ^ succ b = a ^ b * a"}, {"line": "\u00b7 rw [zero_opow (succ_ne_zero b), mul_zero]", "tactic_state": "case inr\na b : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 a ^ succ b = a ^ b * a"}, {"line": "\u00b7 rw [opow_of_ne_zero h, opow_of_ne_zero h, limitRecOn_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem opow_eq_zero {a b : Ordinal} : a ^ b = 0 \u2194 a = 0 \u2227 b \u2260 0 := by\n  obtain rfl | ha := eq_or_ne a 0\n  \u00b7 obtain rfl | hb := eq_or_ne b 0\n    \u00b7 simp\n    \u00b7 simp [hb]\n  \u00b7 simp [opow_ne_zero b ha, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a ^ b = 0 \u2194 a = 0 \u2227 b \u2260 0"}, {"line": "obtain rfl | ha := eq_or_ne a 0", "tactic_state": "case inl\nb : Ordinal.{u_1}\n\u22a2 0 ^ b = 0 \u2194 0 = 0 \u2227 b \u2260 0\n---\ncase inr\na b : Ordinal.{u_1}\nha : a \u2260 0\n\u22a2 a ^ b = 0 \u2194 a = 0 \u2227 b \u2260 0"}, {"line": "\u00b7 obtain rfl | hb := eq_or_ne b 0\n    \u00b7 simp\n    \u00b7 simp [hb]", "tactic_state": "case inr\na b : Ordinal.{u_1}\nha : a \u2260 0\n\u22a2 a ^ b = 0 \u2194 a = 0 \u2227 b \u2260 0"}, {"line": "\u00b7 simp [opow_ne_zero b ha, ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem opow_le_opow_right {a b c : Ordinal} (h\u2081 : 0 < a) (h\u2082 : b \u2264 c) : a ^ b \u2264 a ^ c := by\n  rcases lt_or_eq_of_le (one_le_iff_pos.2 h\u2081) with h\u2081 | h\u2081\n  \u00b7 exact (opow_le_opow_iff_right h\u2081).2 h\u2082\n  \u00b7 subst a\n    -- Porting note: `le_refl` is required.\n    simp only [one_opow]\n    simp only [le_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nh\u2081 : 0 < a\nh\u2082 : b \u2264 c\n\u22a2 a ^ b \u2264 a ^ c"}, {"line": "rcases lt_or_eq_of_le (one_le_iff_pos.2 h\u2081) with h\u2081 | h\u2081", "tactic_state": "case inl\na b c : Ordinal.{u_1}\nh\u2081\u271d : 0 < a\nh\u2082 : b \u2264 c\nh\u2081 : 1 < a\n\u22a2 a ^ b \u2264 a ^ c\n---\ncase inr\na b c : Ordinal.{u_1}\nh\u2081\u271d : 0 < a\nh\u2082 : b \u2264 c\nh\u2081 : 1 = a\n\u22a2 a ^ b \u2264 a ^ c"}, {"line": "\u00b7 exact (opow_le_opow_iff_right h\u2081).2 h\u2082", "tactic_state": "case inr\na b c : Ordinal.{u_1}\nh\u2081\u271d : 0 < a\nh\u2082 : b \u2264 c\nh\u2081 : 1 = a\n\u22a2 a ^ b \u2264 a ^ c"}, {"line": "\u00b7 subst a\n    simp only [one_opow]\n    simp only [le_refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_le_self (b x : Ordinal) : log b x \u2264 x := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 rw [log_zero_right]\n  \u00b7 obtain hb | hb := lt_or_le 1 b\n    \u00b7 exact (right_le_opow _ hb).trans (opow_log_le_self b hx)\n    \u00b7 simp_rw [log_of_left_le_one hb, Ordinal.zero_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nx : Ordinal.{u_3}\n\u22a2 sorry \u2264 x"}, {"line": "obtain rfl | hx := eq_or_ne x 0", "tactic_state": "case inl\nx\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\n\u22a2 sorry \u2264 0\n---\ncase inr\nx\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nx : Ordinal.{u_3}\nhx : x \u2260 0\n\u22a2 sorry \u2264 x"}, {"line": "\u00b7 rw [log_zero_right]", "tactic_state": "case inr\nx\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nx : Ordinal.{u_3}\nhx : x \u2260 0\n\u22a2 sorry \u2264 x"}, {"line": "\u00b7 obtain hb | hb := lt_or_le 1 b\n    \u00b7 exact (right_le_opow _ hb).trans (opow_log_le_self b hx)\n    \u00b7 simp_rw [log_of_left_le_one hb, Ordinal.zero_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_one_right (b : Ordinal) : log b 1 = 0 := by\n  obtain hb | hb := lt_or_le 1 b\n  \u00b7 exact log_eq_zero hb\n  \u00b7 exact log_of_left_le_one hb 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\n\u22a2 sorry = 0"}, {"line": "obtain hb | hb := lt_or_le 1 b", "tactic_state": "case inl\nx\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nhb : 1 < b\n\u22a2 sorry = 0\n---\ncase inr\nx\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nhb : b \u2264 1\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact log_eq_zero hb", "tactic_state": "case inr\nx\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nhb : b \u2264 1\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact log_of_left_le_one hb 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mod_opow_log_lt_self (b : Ordinal) {o : Ordinal} (ho : o \u2260 0) : o % (b ^ log b o) < o := by\n  rcases eq_or_ne b 0 with (rfl | hb)\n  \u00b7 simpa using Ordinal.pos_iff_ne_zero.2 ho\n  \u00b7 exact (mod_lt _ <| opow_ne_zero _ hb).trans_le (opow_log_le_self _ ho)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb o : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 o % b ^ sorry < o"}, {"line": "rcases eq_or_ne b 0 with (rfl | hb)", "tactic_state": "case inl\nx\u271d : Sort u_1\nlog : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 o % 0 ^ sorry < o\n---\ncase inr\nx\u271d : Sort u_1\nlog : x\u271d\nb o : Ordinal.{u_2}\nho : o \u2260 0\nhb : b \u2260 0\n\u22a2 o % b ^ sorry < o"}, {"line": "\u00b7 simpa using Ordinal.pos_iff_ne_zero.2 ho", "tactic_state": "case inr\nx\u271d : Sort u_1\nlog : x\u271d\nb o : Ordinal.{u_2}\nho : o \u2260 0\nhb : b \u2260 0\n\u22a2 o % b ^ sorry < o"}, {"line": "\u00b7 exact (mod_lt _ <| opow_ne_zero _ hb).trans_le (opow_log_le_self _ ho)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_opow_mul {b v : Ordinal} (hb : 1 < b) (u : Ordinal) (hv : v \u2260 0) :\n    log b (b ^ u * v) = u + log b v := by\n  simpa using log_opow_mul_add hb hv (opow_pos u (bot_lt_of_lt hb))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nv : Ordinal.{u_3}\nhb : 1 < b\nu : Ordinal.{u_4}\nhv : v \u2260 0\n\u22a2 sorry = u + sorry"}, {"line": "simpa using log_opow_mul_add hb hv (opow_pos u (bot_lt_of_lt hb))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_eq_zero_iff {\u03b9} {f : \u03b9 \u2192 Ordinal.{u}} [Small.{u} \u03b9] :\n    iSup f = 0 \u2194 \u2200 i, f i = 0 := by\n  refine\n    \u27e8fun h i => ?_, fun h =>\n      le_antisymm (Ordinal.iSup_le fun i => Ordinal.le_zero.2 (h i)) (Ordinal.zero_le _)\u27e9\n  rw [\u2190 Ordinal.le_zero]\n  rw [\u2190 h]\n  exact Ordinal.le_iSup f i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Family.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nf : \u03b9 \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_4} \u03b9\n\u22a2 iSup f = 0 \u2194 \u2200 (i : \u03b9), f i = 0"}, {"line": "refine\n    \u27e8fun h i => ?_, fun h =>\n      le_antisymm (Ordinal.iSup_le fun i => Ordinal.le_zero.2 (h i)) (Ordinal.zero_le _)\u27e9", "tactic_state": "\u03b9 : Type u_4\nf : \u03b9 \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_4} \u03b9\nh : iSup f = 0\ni : \u03b9\n\u22a2 f i = 0"}, {"line": "rw [\u2190 Ordinal.le_zero]", "tactic_state": "\u03b9 : Type u_4\nf : \u03b9 \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_4} \u03b9\nh : iSup f = 0\ni : \u03b9\n\u22a2 f i \u2264 0"}, {"line": "rw [\u2190 h]", "tactic_state": "\u03b9 : Type u_4\nf : \u03b9 \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_4} \u03b9\nh : iSup f = 0\ni : \u03b9\n\u22a2 f i \u2264 iSup f"}, {"line": "exact Ordinal.le_iSup f i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_succ (o : Ordinal) : \u2a06 a : Iio o, succ a.1 = o := by\n  apply (le_of_forall_lt _).antisymm'\n  \u00b7 simp [Ordinal.iSup_le_iff]\n  \u00b7 exact fun a ha \u21a6 (lt_succ a).trans_le <| Ordinal.le_iSup (fun x : Iio _ \u21a6 _) \u27e8a, ha\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Family.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_4}\n\u22a2 \u2a06 a, succ \u2191a = o"}, {"line": "apply (le_of_forall_lt _).antisymm'", "tactic_state": "o : Ordinal.{u_4}\n\u22a2 \u2a06 a, succ \u2191a \u2264 o\n---\no : Ordinal.{u_4}\n\u22a2 \u2200 c < o, c < \u2a06 a, succ \u2191a"}, {"line": "\u00b7 simp [Ordinal.iSup_le_iff]", "tactic_state": "o : Ordinal.{u_4}\n\u22a2 \u2200 c < o, c < \u2a06 a, succ \u2191a"}, {"line": "\u00b7 exact fun a ha \u21a6 (lt_succ a).trans_le <| Ordinal.le_iSup (fun x : Iio _ \u21a6 _) \u27e8a, ha\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bsup_congr {o\u2081 o\u2082 : Ordinal.{u}} (f : \u2200 a < o\u2081, Ordinal.{max u v}) (ho : o\u2081 = o\u2082) :\n    bsup.{_, v} o\u2081 f = bsup.{_, v} o\u2082 fun a h => f a (h.trans_eq ho.symm) := by\n  subst ho\n  -- Porting note: `rfl` is required.\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Family.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nbsup : x\u271d\no\u2081 o\u2082 : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o\u2081 \u2192 Ordinal.{max u v}\nho : o\u2081 = o\u2082\n\u22a2 sorry = sorry"}, {"line": "subst ho", "tactic_state": "x\u271d : Sort u_4\nbsup : x\u271d\no\u2081 : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o\u2081 \u2192 Ordinal.{max u v}\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blsub_congr {o\u2081 o\u2082 : Ordinal.{u}} (f : \u2200 a < o\u2081, Ordinal.{max u v}) (ho : o\u2081 = o\u2082) :\n    blsub.{_, v} o\u2081 f = blsub.{_, v} o\u2082 fun a h => f a (h.trans_eq ho.symm) := by\n  subst ho\n  -- Porting note: `rfl` is required.\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Family.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nblsub : x\u271d\no\u2081 o\u2082 : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o\u2081 \u2192 Ordinal.{max u v}\nho : o\u2081 = o\u2082\n\u22a2 sorry = sorry"}, {"line": "subst ho", "tactic_state": "x\u271d : Sort u_4\nblsub : x\u271d\no\u2081 : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o\u2081 \u2192 Ordinal.{max u v}\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nfpFamily_le_apply [Nonempty \u03b9] [Small.{u} \u03b9] (H : \u2200 i, IsNormal (f i)) {a b} :\n    (\u2203 i, nfpFamily f a \u2264 f i b) \u2194 nfpFamily f a \u2264 b := by\n  rw [\u2190 not_iff_not]\n  push_neg\n  exact apply_lt_nfpFamily_iff H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/FixedPoint.lean", "context": {"open": ["Function Order"], "variables": ["{\u03b9 : Type*} {f : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_2\nnfpFamily : x\u271d\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : ?m.1241 H\nb : Ordinal.{u}\n\u22a2 (\u2203 i, sorry \u2264 f i b) \u2194 sorry \u2264 b"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_2\nnfpFamily : x\u271d\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : ?m.1241 H\nb : Ordinal.{u}\n\u22a2 (\u00ac\u2203 i, sorry \u2264 f i b) \u2194 \u00acsorry \u2264 b"}, {"line": "push_neg", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_2\nnfpFamily : x\u271d\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : ?m.1241 H\nb : Ordinal.{u}\n\u22a2 (\u2200 (i : \u03b9), f i b < sorry) \u2194 b < sorry"}, {"line": "exact apply_lt_nfpFamily_iff H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_bddAbove_fp_family [Small.{u} \u03b9] (H : \u2200 i, IsNormal (f i)) :\n    \u00ac BddAbove (\u22c2 i, Function.fixedPoints (f i)) := by\n  rw [not_bddAbove_iff]\n  refine fun a \u21a6 \u27e8nfpFamily f (succ a), ?_, (lt_succ a).trans_le (le_nfpFamily f _)\u27e9\n  rintro _ \u27e8i, rfl\u27e9\n  exact nfpFamily_fp (H i) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/FixedPoint.lean", "context": {"open": ["Function Order"], "variables": ["{\u03b9 : Type*} {f : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 \u00acBddAbove (\u22c2 i, fixedPoints (f i))"}, {"line": "rw [not_bddAbove_iff]", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 \u2200 (x : Ordinal.{u}), \u2203 y \u2208 \u22c2 i, fixedPoints (f i), x < y"}, {"line": "refine fun a \u21a6 \u27e8nfpFamily f (succ a), ?_, (lt_succ a).trans_le (le_nfpFamily f _)\u27e9", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{u}\n\u22a2 sorry \u2208 \u22c2 i, fixedPoints (f i)"}, {"line": "rintro _ \u27e8i, rfl\u27e9", "tactic_state": "case intro\n\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{u}\ni : \u03b9\n\u22a2 sorry \u2208 (fun i => fixedPoints (f i)) i"}, {"line": "exact nfpFamily_fp (H i) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_nadd_iff : a < b \u266f c \u2194 (\u2203 b' < b, a \u2264 b' \u266f c) \u2228 \u2203 c' < c, a \u2264 b \u266f c' := by\n  rw [nadd]\n  simp [Ordinal.lt_iSup_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u}\n\u22a2 a < b.nadd c \u2194 (\u2203 b' < b, a \u2264 b'.nadd c) \u2228 \u2203 c' < c, a \u2264 b.nadd c'"}, {"line": "rw [nadd]", "tactic_state": "a b c : Ordinal.{u}\n\u22a2 a < max (\u2a06 x, succ ((\u2191x).nadd c)) (\u2a06 x, succ (b.nadd \u2191x)) \u2194 (\u2203 b' < b, a \u2264 b'.nadd c) \u2228 \u2203 c' < c, a \u2264 b.nadd c'"}, {"line": "simp [Ordinal.lt_iSup_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_le_iff : b \u266f c \u2264 a \u2194 (\u2200 b' < b, b' \u266f c < a) \u2227 \u2200 c' < c, b \u266f c' < a := by\n  rw [\u2190 not_lt]\n  rw [lt_nadd_iff]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u}\n\u22a2 b.nadd c \u2264 a \u2194 (\u2200 b' < b, b'.nadd c < a) \u2227 \u2200 c' < c, b.nadd c' < a"}, {"line": "rw [\u2190 not_lt]", "tactic_state": "a b c : Ordinal.{u}\n\u22a2 \u00aca < b.nadd c \u2194 (\u2200 b' < b, b'.nadd c < a) \u2227 \u2200 c' < c, b.nadd c' < a"}, {"line": "rw [lt_nadd_iff]", "tactic_state": "a b c : Ordinal.{u}\n\u22a2 \u00ac((\u2203 b' < b, a \u2264 b'.nadd c) \u2228 \u2203 c' < c, a \u2264 b.nadd c') \u2194 (\u2200 b' < b, b'.nadd c < a) \u2227 \u2200 c' < c, b.nadd c' < a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_le_nadd_left (h : b \u2264 c) (a) : a \u266f b \u2264 a \u266f c := by\n  rcases lt_or_eq_of_le h with (h | rfl)\n  \u00b7 exact (nadd_lt_nadd_left h a).le\n  \u00b7 exact le_rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b c : Ordinal.{u}\nh : b \u2264 c\na : Ordinal.{u}\n\u22a2 a.nadd b \u2264 a.nadd c"}, {"line": "rcases lt_or_eq_of_le h with (h | rfl)", "tactic_state": "case inl\nb c : Ordinal.{u}\nh\u271d : b \u2264 c\na : Ordinal.{u}\nh : b < c\n\u22a2 a.nadd b \u2264 a.nadd c\n---\ncase inr\nb a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 a.nadd b \u2264 a.nadd b"}, {"line": "\u00b7 exact (nadd_lt_nadd_left h a).le", "tactic_state": "case inr\nb a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 a.nadd b \u2264 a.nadd b"}, {"line": "\u00b7 exact le_rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_le_nadd_right (h : b \u2264 c) (a) : b \u266f a \u2264 c \u266f a := by\n  rcases lt_or_eq_of_le h with (h | rfl)\n  \u00b7 exact (nadd_lt_nadd_right h a).le\n  \u00b7 exact le_rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b c : Ordinal.{u}\nh : b \u2264 c\na : Ordinal.{u}\n\u22a2 b.nadd a \u2264 c.nadd a"}, {"line": "rcases lt_or_eq_of_le h with (h | rfl)", "tactic_state": "case inl\nb c : Ordinal.{u}\nh\u271d : b \u2264 c\na : Ordinal.{u}\nh : b < c\n\u22a2 b.nadd a \u2264 c.nadd a\n---\ncase inr\nb a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 b.nadd a \u2264 b.nadd a"}, {"line": "\u00b7 exact (nadd_lt_nadd_right h a).le", "tactic_state": "case inr\nb a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 b.nadd a \u2264 b.nadd a"}, {"line": "\u00b7 exact le_rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_comm (a b) : a \u266f b = b \u266f a := by\n  rw [nadd]\n  rw [nadd]\n  rw [max_comm]\n  congr <;> ext x <;> cases x <;> apply congr_arg _ (nadd_comm _ _)", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a.nadd b = b.nadd a"}, {"line": "rw [nadd]", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ ((\u2191x).nadd b)) (\u2a06 x, succ (a.nadd \u2191x)) = b.nadd a"}, {"line": "rw [nadd]", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ ((\u2191x).nadd b)) (\u2a06 x, succ (a.nadd \u2191x)) = max (\u2a06 x, succ ((\u2191x).nadd a)) (\u2a06 x, succ (b.nadd \u2191x))"}, {"line": "rw [max_comm]", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ (a.nadd \u2191x)) (\u2a06 x, succ ((\u2191x).nadd b)) = max (\u2a06 x, succ ((\u2191x).nadd a)) (\u2a06 x, succ (b.nadd \u2191x))"}, {"line": "congr <;> ext x <;> cases x <;> apply congr_arg _ (nadd_comm _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_zero (a : Ordinal) : a \u266f 0 = a := by\n  rw [nadd]\n  rw [ciSup_of_empty fun _ : Iio 0 \u21a6 _]\n  rw [sup_bot_eq]\n  convert iSup_succ a\n  rename_i x\n  cases x\n  exact nadd_zero _", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a.nadd 0 = a"}, {"line": "rw [nadd]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ ((\u2191x).nadd 0)) (\u2a06 x, succ (a.nadd \u2191x)) = a"}, {"line": "rw [ciSup_of_empty fun _ : Iio 0 \u21a6 _]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ ((\u2191x).nadd 0)) \u22a5 = a"}, {"line": "rw [sup_bot_eq]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 \u2a06 x, succ ((\u2191x).nadd 0) = a"}, {"line": "convert iSup_succ a", "tactic_state": "case h.e'_2.h.e'_4.h.h.e'_4\na : Ordinal.{u_1}\nx\u271d : \u2191(Iio a)\n\u22a2 (\u2191x\u271d).nadd 0 = \u2191x\u271d"}, {"line": "rename_i x", "tactic_state": "case h.e'_2.h.e'_4.h.h.e'_4\na : Ordinal.{u_1}\nx : \u2191(Iio a)\n\u22a2 (\u2191x).nadd 0 = \u2191x"}, {"line": "cases x", "tactic_state": "case h.e'_2.h.e'_4.h.h.e'_4.mk\na val\u271d : Ordinal.{u_1}\nproperty\u271d : val\u271d \u2208 Iio a\n\u22a2 (\u2191\u27e8val\u271d, property\u271d\u27e9).nadd 0 = \u2191\u27e8val\u271d, property\u271d\u27e9"}, {"line": "exact nadd_zero _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_nadd : 0 \u266f a = a := by rw [nadd_comm, nadd_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u}\n\u22a2 nadd 0 a = a"}, {"line": "rw [nadd_comm, nadd_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_one (a : Ordinal) : a \u266f 1 = succ a := by\n  rw [nadd]\n  rw [ciSup_unique (s := fun _ : Iio 1 \u21a6 _)]\n  rw [Iio_one_default_eq]\n  rw [nadd_zero]\n  rw [max_eq_right_iff]\n  rw [Ordinal.iSup_le_iff]\n  rintro \u27e8i, hi\u27e9\n  rwa [nadd_one, succ_le_succ_iff, succ_le_iff]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a.nadd 1 = succ a"}, {"line": "rw [nadd]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ ((\u2191x).nadd 1)) (\u2a06 x, succ (a.nadd \u2191x)) = succ a"}, {"line": "rw [ciSup_unique (s := fun _ : Iio 1 \u21a6 _)]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ ((\u2191x).nadd 1)) (succ (a.nadd \u2191default)) = succ a"}, {"line": "rw [Iio_one_default_eq]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ ((\u2191x).nadd 1)) (succ (a.nadd \u2191\u27e80, \u22ef\u27e9)) = succ a"}, {"line": "rw [nadd_zero]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ ((\u2191x).nadd 1)) (succ a) = succ a"}, {"line": "rw [max_eq_right_iff]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 \u2a06 x, succ ((\u2191x).nadd 1) \u2264 succ a"}, {"line": "rw [Ordinal.iSup_le_iff]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 \u2200 (i : \u2191(Iio a)), succ ((\u2191i).nadd 1) \u2264 succ a"}, {"line": "rintro \u27e8i, hi\u27e9", "tactic_state": "case mk\na i : Ordinal.{u_1}\nhi : i \u2208 Iio a\n\u22a2 succ ((\u2191\u27e8i, hi\u27e9).nadd 1) \u2264 succ a"}, {"line": "rwa [nadd_one, succ_le_succ_iff, succ_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_nadd : 1 \u266f a = succ a := by rw [nadd_comm, nadd_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u}\n\u22a2 nadd 1 a = succ a"}, {"line": "rw [nadd_comm, nadd_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_nat (n : \u2115) : a \u266f n = a + n := by\n  induction' n with n hn\n  \u00b7 simp\n  \u00b7 rw [Nat.cast_succ, add_one_eq_succ, nadd_succ, add_succ, hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u}\nn : \u2115\n\u22a2 a.nadd \u2191n = a + \u2191n"}, {"line": "induction' n with n hn", "tactic_state": "case zero\na : Ordinal.{u}\n\u22a2 a.nadd \u21910 = a + \u21910\n---\ncase succ\na : Ordinal.{u}\nn : \u2115\nhn : a.nadd \u2191n = a + \u2191n\n\u22a2 a.nadd \u2191(n + 1) = a + \u2191(n + 1)"}, {"line": "\u00b7 simp", "tactic_state": "case succ\na : Ordinal.{u}\nn : \u2115\nhn : a.nadd \u2191n = a + \u2191n\n\u22a2 a.nadd \u2191(n + 1) = a + \u2191(n + 1)"}, {"line": "\u00b7 rw [Nat.cast_succ, add_one_eq_succ, nadd_succ, add_succ, hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_nadd (n : \u2115) : \u2191n \u266f a = a + n := by rw [nadd_comm, nadd_nat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u}\nn : \u2115\n\u22a2 (\u2191n).nadd a = a + \u2191n"}, {"line": "rw [nadd_comm, nadd_nat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNatOrdinal_natCast (n : \u2115) : toNatOrdinal n = n := by\n  rw [\u2190 toOrdinal_natCast n]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 toNatOrdinal \u2191n = \u2191n"}, {"line": "rw [\u2190 toOrdinal_natCast n]", "tactic_state": "n : \u2115\n\u22a2 toNatOrdinal (toOrdinal \u2191n) = \u2191n"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_nadd_self {a b} : a \u2264 b \u266f a := by simpa using nadd_le_nadd_right (Ordinal.zero_le b) a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a \u2264 b.nadd a"}, {"line": "simpa using nadd_le_nadd_right (Ordinal.zero_le b) a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_self_nadd {a b} : a \u2264 a \u266f b := by simpa using nadd_le_nadd_left (Ordinal.zero_le b) a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a \u2264 a.nadd b"}, {"line": "simpa using nadd_le_nadd_left (Ordinal.zero_le b) a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_def (a b : Ordinal) :\n    a \u2a33 b = sInf {c | \u2200 a' < a, \u2200 b' < b, a' \u2a33 b \u266f a \u2a33 b' < c \u266f a' \u2a33 b'} := by\n  rw [nmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a.nmul b = sInf {c | \u2200 a' < a, \u2200 b' < b, (a'.nmul b).nadd (a.nmul b') < c.nadd (a'.nmul b')}"}, {"line": "rw [nmul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_nadd_lt {a' b' : Ordinal} (ha : a' < a) (hb : b' < b) :\n    a' \u2a33 b \u266f a \u2a33 b' < a \u2a33 b \u266f a' \u2a33 b' := by\n  conv_rhs => rw [nmul]\n  exact csInf_mem (nmul_nonempty a b) a' ha b' hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b a' b' : Ordinal.{u}\nha : a' < a\nhb : b' < b\n\u22a2 (a'.nmul b).nadd (a.nmul b') < (a.nmul b).nadd (a'.nmul b')"}, {"line": "conv_rhs => rw [nmul]", "tactic_state": "a b a' b' : Ordinal.{u}\nha : a' < a\nhb : b' < b\n\u22a2 (a'.nmul b).nadd (a.nmul b') <\n    (sInf {c | \u2200 a' < a, \u2200 b' < b, (a'.nmul b).nadd (a.nmul b') < c.nadd (a'.nmul b')}).nadd (a'.nmul b')"}, {"line": "exact csInf_mem (nmul_nonempty a b) a' ha b' hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_zero (a) : a \u2a33 0 = 0 := by\n  rw [\u2190 Ordinal.le_zero]\n  rw [nmul_le_iff]\n  exact fun _ _ a ha => (Ordinal.not_lt_zero a ha).elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a.nmul 0 = 0"}, {"line": "rw [\u2190 Ordinal.le_zero]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a.nmul 0 \u2264 0"}, {"line": "rw [nmul_le_iff]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 \u2200 a' < a, \u2200 b' < 0, (a'.nmul 0).nadd (a.nmul b') < nadd 0 (a'.nmul b')"}, {"line": "exact fun _ _ a ha => (Ordinal.not_lt_zero a ha).elim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_one (a : Ordinal) : a \u2a33 1 = a := by\n  rw [nmul]\n  convert csInf_Ici\n  ext b\n  refine \u27e8fun H \u21a6 le_of_forall_lt (a := a) fun c hc \u21a6 ?_, fun ha c hc \u21a6 ?_\u27e9\n  -- Porting note: had to add arguments to `nmul_one` in the next two lines\n  -- for the termination checker.\n  \u00b7 simpa [nmul_one c] using H c hc\n  \u00b7 simpa [nmul_one c] using hc.trans_le ha", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a.nmul 1 = a"}, {"line": "rw [nmul]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 sInf {c | \u2200 a' < a, \u2200 b' < 1, (a'.nmul 1).nadd (a.nmul b') < c.nadd (a'.nmul b')} = a"}, {"line": "convert csInf_Ici", "tactic_state": "case h.e'_2.h.e'_3\na : Ordinal.{u_1}\n\u22a2 {c | \u2200 a' < a, \u2200 b' < 1, (a'.nmul 1).nadd (a.nmul b') < c.nadd (a'.nmul b')} = Ici a"}, {"line": "ext b", "tactic_state": "case h.e'_2.h.e'_3.h\na b : Ordinal.{u_1}\n\u22a2 b \u2208 {c | \u2200 a' < a, \u2200 b' < 1, (a'.nmul 1).nadd (a.nmul b') < c.nadd (a'.nmul b')} \u2194 b \u2208 Ici a"}, {"line": "refine \u27e8fun H \u21a6 le_of_forall_lt (a := a) fun c hc \u21a6 ?_, fun ha c hc \u21a6 ?_\u27e9", "tactic_state": "case h.e'_2.h.e'_3.h.refine_1\na b : Ordinal.{u_1}\nH : b \u2208 {c | \u2200 a' < a, \u2200 b' < 1, (a'.nmul 1).nadd (a.nmul b') < c.nadd (a'.nmul b')}\nc : Ordinal.{u_1}\nhc : c < a\n\u22a2 c < b\n---\ncase h.e'_2.h.e'_3.h.refine_2\na b : Ordinal.{u_1}\nha : b \u2208 Ici a\nc : Ordinal.{u_1}\nhc : c < a\n\u22a2 \u2200 b' < 1, (c.nmul 1).nadd (a.nmul b') < b.nadd (c.nmul b')"}, {"line": "\u00b7 simpa [nmul_one c] using H c hc", "tactic_state": "case h.e'_2.h.e'_3.h.refine_2\na b : Ordinal.{u_1}\nha : b \u2208 Ici a\nc : Ordinal.{u_1}\nhc : c < a\n\u22a2 \u2200 b' < 1, (c.nmul 1).nadd (a.nmul b') < b.nadd (c.nmul b')"}, {"line": "\u00b7 simpa [nmul_one c] using hc.trans_le ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_nmul (a) : 1 \u2a33 a = a := by rw [nmul_comm, nmul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 nmul 1 a = a"}, {"line": "rw [nmul_comm, nmul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_le_nmul_left (h : a \u2264 b) (c) : c \u2a33 a \u2264 c \u2a33 b := by\n  rcases lt_or_eq_of_le h with (h\u2081 | rfl) <;> rcases (eq_zero_or_pos c).symm with (h\u2082 | rfl)\n  \u00b7 exact (nmul_lt_nmul_of_pos_left h\u2081 h\u2082).le\n  all_goals simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u}\nh : a \u2264 b\nc : Ordinal.{u}\n\u22a2 c.nmul a \u2264 c.nmul b"}, {"line": "rcases lt_or_eq_of_le h with (h\u2081 | rfl) <;> rcases (eq_zero_or_pos c).symm with (h\u2082 | rfl)", "tactic_state": "case inl.inl\na b : Ordinal.{u}\nh : a \u2264 b\nc : Ordinal.{u}\nh\u2081 : a < b\nh\u2082 : 0 < c\n\u22a2 c.nmul a \u2264 c.nmul b\n---\ncase inl.inr\na b : Ordinal.{u}\nh : a \u2264 b\nh\u2081 : a < b\n\u22a2 nmul 0 a \u2264 nmul 0 b\n---\ncase inr.inl\na c : Ordinal.{u}\nh : a \u2264 a\nh\u2082 : 0 < c\n\u22a2 c.nmul a \u2264 c.nmul a\n---\ncase inr.inr\na : Ordinal.{u}\nh : a \u2264 a\n\u22a2 nmul 0 a \u2264 nmul 0 a"}, {"line": "\u00b7 exact (nmul_lt_nmul_of_pos_left h\u2081 h\u2082).le", "tactic_state": "case inl.inr\na b : Ordinal.{u}\nh : a \u2264 b\nh\u2081 : a < b\n\u22a2 nmul 0 a \u2264 nmul 0 b\n---\ncase inr.inl\na c : Ordinal.{u}\nh : a \u2264 a\nh\u2082 : 0 < c\n\u22a2 c.nmul a \u2264 c.nmul a\n---\ncase inr.inr\na : Ordinal.{u}\nh : a \u2264 a\n\u22a2 nmul 0 a \u2264 nmul 0 a"}, {"line": "all_goals simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_le_nmul_right (h : a \u2264 b) (c) : a \u2a33 c \u2264 b \u2a33 c := by\n  rw [nmul_comm]\n  rw [nmul_comm b]\n  exact nmul_le_nmul_left h c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u}\nh : a \u2264 b\nc : Ordinal.{u}\n\u22a2 a.nmul c \u2264 b.nmul c"}, {"line": "rw [nmul_comm]", "tactic_state": "a b : Ordinal.{u}\nh : a \u2264 b\nc : Ordinal.{u}\n\u22a2 c.nmul a \u2264 b.nmul c"}, {"line": "rw [nmul_comm b]", "tactic_state": "a b : Ordinal.{u}\nh : a \u2264 b\nc : Ordinal.{u}\n\u22a2 c.nmul a \u2264 c.nmul b"}, {"line": "exact nmul_le_nmul_left h c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_nmul (a b c) : (a \u266f b) \u2a33 c = a \u2a33 c \u266f b \u2a33 c := by\n  rw [nmul_comm]\n  rw [nmul_nadd]\n  rw [nmul_comm]\n  rw [nmul_comm c]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\n\u22a2 (a.nadd b).nmul c = (a.nmul c).nadd (b.nmul c)"}, {"line": "rw [nmul_comm]", "tactic_state": "a b c : Ordinal.{u_1}\n\u22a2 c.nmul (a.nadd b) = (a.nmul c).nadd (b.nmul c)"}, {"line": "rw [nmul_nadd]", "tactic_state": "a b c : Ordinal.{u_1}\n\u22a2 (c.nmul a).nadd (c.nmul b) = (a.nmul c).nadd (b.nmul c)"}, {"line": "rw [nmul_comm]", "tactic_state": "a b c : Ordinal.{u_1}\n\u22a2 (a.nmul c).nadd (c.nmul b) = (a.nmul c).nadd (b.nmul c)"}, {"line": "rw [nmul_comm c]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_nadd_lt\u2083 {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :\n    a' \u2a33 b \u2a33 c \u266f a \u2a33 b' \u2a33 c \u266f a \u2a33 b \u2a33 c' \u266f a' \u2a33 b' \u2a33 c' <\n      a \u2a33 b \u2a33 c \u266f a' \u2a33 b' \u2a33 c \u266f a' \u2a33 b \u2a33 c' \u266f a \u2a33 b' \u2a33 c' := by\n  simpa only [nadd_nmul,\u2190 nadd_assoc] using nmul_nadd_lt (nmul_nadd_lt ha hb) hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c a' b' c' : Ordinal.{u}\nha : a' < a\nhb : b' < b\nhc : c' < c\n\u22a2 ((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c') <\n    ((((a.nmul b).nmul c).nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c')"}, {"line": "simpa only [nadd_nmul,\u2190 nadd_assoc] using nmul_nadd_lt (nmul_nadd_lt ha hb) hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_nadd_le\u2083 {a' b' c' : Ordinal} (ha : a' \u2264 a) (hb : b' \u2264 b) (hc : c' \u2264 c) :\n    a' \u2a33 b \u2a33 c \u266f a \u2a33 b' \u2a33 c \u266f a \u2a33 b \u2a33 c' \u266f a' \u2a33 b' \u2a33 c' \u2264\n      a \u2a33 b \u2a33 c \u266f a' \u2a33 b' \u2a33 c \u266f a' \u2a33 b \u2a33 c' \u266f a \u2a33 b' \u2a33 c' := by\n  simpa only [nadd_nmul,\u2190 nadd_assoc] using nmul_nadd_le (nmul_nadd_le ha hb) hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c a' b' c' : Ordinal.{u}\nha : a' \u2264 a\nhb : b' \u2264 b\nhc : c' \u2264 c\n\u22a2 ((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c') \u2264\n    ((((a.nmul b).nmul c).nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c')"}, {"line": "simpa only [nadd_nmul,\u2190 nadd_assoc] using nmul_nadd_le (nmul_nadd_le ha hb) hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_le_iff\u2083 : a \u2a33 b \u2a33 c \u2264 d \u2194 \u2200 a' < a, \u2200 b' < b, \u2200 c' < c,\n    a' \u2a33 b \u2a33 c \u266f a \u2a33 b' \u2a33 c \u266f a \u2a33 b \u2a33 c' \u266f a' \u2a33 b' \u2a33 c' <\n      d \u266f a' \u2a33 b' \u2a33 c \u266f a' \u2a33 b \u2a33 c' \u266f a \u2a33 b' \u2a33 c' := by\n  simpa using lt_nmul_iff\u2083.not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Ordinal.{u}\n\u22a2 (a.nmul b).nmul c \u2264 d \u2194\n    \u2200 a' < a,\n      \u2200 b' < b,\n        \u2200 c' < c,\n          ((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c') <\n            ((d.nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c')"}, {"line": "simpa using lt_nmul_iff\u2083.not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_nmul_iff\u2083' : d < a \u2a33 (b \u2a33 c) \u2194 \u2203 a' < a, \u2203 b' < b, \u2203 c' < c,\n    d \u266f a' \u2a33 (b' \u2a33 c) \u266f a' \u2a33 (b \u2a33 c') \u266f a \u2a33 (b' \u2a33 c') \u2264\n      a' \u2a33 (b \u2a33 c) \u266f a \u2a33 (b' \u2a33 c) \u266f a \u2a33 (b \u2a33 c') \u266f a' \u2a33 (b' \u2a33 c') := by\n  simpa using nmul_le_iff\u2083'.not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Ordinal.{u}\n\u22a2 d < a.nmul (b.nmul c) \u2194\n    \u2203 a' < a,\n      \u2203 b' < b,\n        \u2203 c' < c,\n          ((d.nadd (a'.nmul (b'.nmul c))).nadd (a'.nmul (b.nmul c'))).nadd (a.nmul (b'.nmul c')) \u2264\n            (((a'.nmul (b.nmul c)).nadd (a.nmul (b'.nmul c))).nadd (a.nmul (b.nmul c'))).nadd (a'.nmul (b'.nmul c'))"}, {"line": "simpa using nmul_le_iff\u2083'.not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_succ (a b) : a \u2a33 succ b = a \u2a33 b \u266f a := by rw [\u2190 nadd_one, nmul_nadd_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps", "Ordinal"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a.nmul (succ b) = (a.nmul b).nadd a"}, {"line": "rw [\u2190 nadd_one, nmul_nadd_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_nmul (a b) : succ a \u2a33 b = a \u2a33 b \u266f b := by rw [\u2190 nadd_one, nadd_one_nmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps", "Ordinal"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 (succ a).nmul b = (a.nmul b).nadd b"}, {"line": "rw [\u2190 nadd_one, nadd_one_nmul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NF.zero_of_zero {e n a} (h : NF (ONote.oadd e n a)) (e0 : e = 0) : a = 0 := by\n  simpa [e0, NFBelow_zero] using h.snd'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nNF : x\u271d\ne : \u2115\nn : ?m.959\na : \u2115\nh : sorry\ne0 : e = 0\n\u22a2 a = 0"}, {"line": "simpa [e0, NFBelow_zero] using h.snd'", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem exists_lt_mul_omega0' {o : Ordinal} \u2983a\u2984 (h : a < o * \u03c9) :\n    \u2203 i : \u2115, a < o * \u2191i + o := by\n  obtain \u27e8i, hi, h'\u27e9 := (lt_mul_of_limit isLimit_omega0).1 h\n  obtain \u27e8i, rfl\u27e9 := lt_omega0.1 hi\n  exact \u27e8i, h'.trans_le (le_add_right _ _)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o a : Ordinal.{u_1}\nh : a < o * omega0\n\u22a2 \u2203 i, a < o * \u2191i + o"}, {"line": "obtain \u27e8i, hi, h'\u27e9 := (lt_mul_of_limit isLimit_omega0).1 h", "tactic_state": "case intro.intro\no a : Ordinal.{u_1}\nh : a < o * omega0\ni : Ordinal.{u_1}\nhi : i < omega0\nh' : a < o * i\n\u22a2 \u2203 i, a < o * \u2191i + o"}, {"line": "obtain \u27e8i, rfl\u27e9 := lt_omega0.1 hi", "tactic_state": "case intro.intro.intro\no a : Ordinal.{u_1}\nh : a < o * omega0\ni : \u2115\nhi : \u2191i < omega0\nh' : a < o * \u2191i\n\u22a2 \u2203 i, a < o * \u2191i + o"}, {"line": "exact \u27e8i, h'.trans_le (le_add_right _ _)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem exists_lt_omega0_opow' {\u03b1} {o b : Ordinal} (hb : 1 < b) (ho : o.IsLimit)\n    {f : \u03b1 \u2192 Ordinal} (H : \u2200 \u2983a\u2984, a < o \u2192 \u2203 i, a < f i) \u2983a\u2984 (h : a < b ^ o) :\n        \u2203 i, a < b ^ f i := by\n  obtain \u27e8d, hd, h'\u27e9 := (lt_opow_of_limit (zero_lt_one.trans hb).ne' ho).1 h\n  exact (H hd).imp fun i hi => h'.trans <| (opow_lt_opow_iff_right hb).2 hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\no b : Ordinal.{u_2}\nhb : 1 < b\nho : o.IsLimit\nf : \u03b1 \u2192 Ordinal.{u_2}\nH : \u2200 \u2983a : Ordinal.{u_2}\u2984, a < o \u2192 \u2203 i, a < f i\na : Ordinal.{u_2}\nh : a < b ^ o\n\u22a2 \u2203 i, a < b ^ f i"}, {"line": "obtain \u27e8d, hd, h'\u27e9 := (lt_opow_of_limit (zero_lt_one.trans hb).ne' ho).1 h", "tactic_state": "case intro.intro\n\u03b1 : Sort u_1\no b : Ordinal.{u_2}\nhb : 1 < b\nho : o.IsLimit\nf : \u03b1 \u2192 Ordinal.{u_2}\nH : \u2200 \u2983a : Ordinal.{u_2}\u2984, a < o \u2192 \u2203 i, a < f i\na : Ordinal.{u_2}\nh : a < b ^ o\nd : Ordinal.{u_2}\nhd : d < o\nh' : a < b ^ d\n\u22a2 \u2203 i, a < b ^ f i"}, {"line": "exact (H hd).imp fun i hi => h'.trans <| (opow_lt_opow_iff_right hb).2 hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fastGrowing\u03b5\u2080_zero : fastGrowing\u03b5\u2080 0 = 1 := by simp [fastGrowing\u03b5\u2080]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfastGrowing\u03b5\u2080 : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [fastGrowing\u03b5\u2080]", "tactic_state": "x\u271d : Sort u_1\nfastGrowing\u03b5\u2080 : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem fastGrowing\u03b5\u2080_one : fastGrowing\u03b5\u2080 1 = 2 := by\n  simp [fastGrowing\u03b5\u2080, show oadd 0 1 0 = 1 from rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfastGrowing\u03b5\u2080 : x\u271d\n\u22a2 sorry = 2"}, {"line": "simp [fastGrowing\u03b5\u2080, show oadd 0 1 0 = 1 from rfl]", "tactic_state": "x\u271d : Sort u_1\nfastGrowing\u03b5\u2080 : x\u271d\n\u22a2 sorry () = 2"}]}
{"declaration": "theorem fastGrowing\u03b5\u2080_two : fastGrowing\u03b5\u2080 2 = 2048 := by\n  norm_num [fastGrowing\u03b5\u2080, show oadd 0 1 0 = 1 from rfl, @fastGrowing_limit (oadd 1 1 0) _ rfl,\n    show oadd 0 (2 : Nat).succPNat 0 = 3 from rfl, @fastGrowing_succ 3 2 rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfastGrowing\u03b5\u2080 : x\u271d\n\u22a2 sorry = 2048"}, {"line": "norm_num [fastGrowing\u03b5\u2080, show oadd 0 1 0 = 1 from rfl, @fastGrowing_limit (oadd 1 1 0) _ rfl,\n    show oadd 0 (2 : Nat).succPNat 0 = 3 from rfl, @fastGrowing_succ 3 2 rfl]", "tactic_state": "x\u271d : Sort u_1\nfastGrowing\u03b5\u2080 : x\u271d\n\u22a2 sorry () = 2048"}]}
{"declaration": "theorem not_principal_iff : \u00ac Principal op o \u2194 \u2203 a < o, \u2203 b < o, o \u2264 op a b := by\n  simp [Principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Principal.lean", "context": {"open": ["Order"], "variables": ["{a b c o : Ordinal.{u}}", "{op : Ordinal \u2192 Ordinal \u2192 Ordinal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\nop : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_1\nPrincipal : x\u271d\n\u22a2 \u00acsorry \u2194 \u2203 a < o, \u2203 b < o, o \u2264 op a b"}, {"line": "simp [Principal]", "tactic_state": "o : Ordinal.{u}\nop : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_1\nPrincipal : x\u271d\n\u22a2 \u00acsorry () \u2194 \u2203 a < o, \u2203 b < o, o \u2264 op a b"}]}
{"declaration": "theorem not_principal_iff_of_monotone\n    (h\u2081 : \u2200 a, Monotone (op a)) (h\u2082 : \u2200 a, Monotone (Function.swap op a)) :\n    \u00ac Principal op o \u2194 \u2203 a < o, o \u2264 op a a := by\n  simp [principal_iff_of_monotone h\u2081 h\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Principal.lean", "context": {"open": ["Order"], "variables": ["{a b c o : Ordinal.{u}}", "{op : Ordinal \u2192 Ordinal \u2192 Ordinal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\nop : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_1\nPrincipal : x\u271d\nh\u2081 : \u2200 (a : Ordinal.{u}), Monotone (op a)\nh\u2082 : \u2200 (a : Ordinal.{u}), Monotone (Function.swap op a)\n\u22a2 \u00acsorry \u2194 \u2203 a < o, o \u2264 op a a"}, {"line": "simp [principal_iff_of_monotone h\u2081 h\u2082]", "tactic_state": "o : Ordinal.{u}\nop : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_1\nPrincipal : x\u271d\nh\u2081 : \u2200 (a : Ordinal.{u}), Monotone (op a)\nh\u2082 : \u2200 (a : Ordinal.{u}), Monotone (Function.swap op a)\n\u22a2 \u00acsorry () \u2194 \u2203 a < o, o \u2264 op a a"}]}
{"declaration": "theorem not_bddAbove_principal (op : Ordinal \u2192 Ordinal \u2192 Ordinal) :\n    \u00ac BddAbove { o | Principal op o } := by\n  rintro \u27e8a, ha\u27e9\n  exact ((le_nfp _ _).trans (ha (principal_nfp_iSup op (succ a)))).not_lt (lt_succ a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Principal.lean", "context": {"open": ["Order"], "variables": ["{a b c o : Ordinal.{u}}", "{op : Ordinal \u2192 Ordinal \u2192 Ordinal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nPrincipal : x\u271d\nop : Ordinal.{u_2} \u2192 Ordinal.{u_3} \u2192 Ordinal.{u_4}\n\u22a2 \u00acBddAbove {o | sorry}"}, {"line": "rintro \u27e8a, ha\u27e9", "tactic_state": "case intro\nx\u271d : Sort u_1\nPrincipal : x\u271d\nop : Ordinal.{u_2} \u2192 Ordinal.{u_3} \u2192 Ordinal.{u_4}\na : ?m.1310 op\nha : a \u2208 upperBounds {o | sorry}\n\u22a2 False"}, {"line": "exact ((le_nfp _ _).trans (ha (principal_nfp_iSup op (succ a)))).not_lt (lt_succ a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem moveLeft_neg_toLeftMovesNeg {x : PGame} (i) :\n    (-x).moveLeft (toLeftMovesNeg i) = -x.moveRight i := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.6605\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.6605\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveRight_neg_toRightMovesNeg {x : PGame} (i) :\n    (-x).moveRight (toRightMovesNeg i) = -x.moveLeft i := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.6605\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.6605\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveLeft_neg_symm {x : PGame} (i) :\n    x.moveLeft (toRightMovesNeg.symm i) = -(-x).moveRight i := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveLeft_neg_symm' {x : PGame} (i) :\n    x.moveLeft i = -(-x).moveRight (toRightMovesNeg i) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveRight_neg_symm {x : PGame} (i) :\n    x.moveRight (toLeftMovesNeg.symm i) = -(-x).moveLeft i := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveRight_neg_symm' {x : PGame} (i) :\n    x.moveRight i = -(-x).moveLeft (toLeftMovesNeg i) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "lemma bddAbove_of_small (s : Set PGame.{u}) [Small.{u} s] : BddAbove s := by\n  simpa using bddAbove_range_of_small (Subtype.val : s \u2192 PGame.{u})\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Order.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nPGame : x\u271d\ns : Set sorry\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry"}, {"line": "simpa using bddAbove_range_of_small (Subtype.val : s \u2192 PGame.{u})", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bddBelow_of_small (s : Set PGame.{u}) [Small.{u} s] : BddBelow s := by\n  simpa using bddBelow_range_of_small (Subtype.val : s \u2192 PGame.{u})\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Order.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nPGame : x\u271d\ns : Set sorry\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry"}, {"line": "simpa using bddBelow_range_of_small (Subtype.val : s \u2192 PGame.{u})", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mulOption_lt_iff_P1 {i j k l} :\n    (\u27e6mulOption x y i k\u27e7 : Game) < -\u27e6mulOption x (-y) j l\u27e7 \u2194\n    P1 (x.moveLeft i) x (x.moveLeft j) y (y.moveLeft k) (-(-y).moveLeft l) := by\n  dsimp only [P1, mulOption, quot_sub, quot_add]\n  simp_rw [neg_sub', neg_add, quot_mul_neg, neg_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Multiplication.lean", "context": {"open": ["SetTheory Game PGame WellFounded"], "variables": ["{x x\u2081 x\u2082 x\u2083 x' y y\u2081 y\u2082 y\u2083 y' : PGame.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : PGame\nx\u271d : Sort u_1\nP1 : x\u271d\ni j : x.LeftMoves\nk : y.LeftMoves\nl : (-y).LeftMoves\n\u22a2 \u27e6x.mulOption y i k\u27e7 < -\u27e6x.mulOption (-y) j l\u27e7 \u2194 sorry"}, {"line": "dsimp only [P1, mulOption, quot_sub, quot_add]", "tactic_state": "x y : PGame\nx\u271d : Sort u_1\nP1 : x\u271d\ni j : x.LeftMoves\nk : y.LeftMoves\nl : (-y).LeftMoves\n\u22a2 \u27e6x.moveLeft i * y\u27e7 + \u27e6x * y.moveLeft k\u27e7 - \u27e6x.moveLeft i * y.moveLeft k\u27e7 <\n      -(\u27e6x.moveLeft j * -y\u27e7 + \u27e6x * (-y).moveLeft l\u27e7 - \u27e6x.moveLeft j * (-y).moveLeft l\u27e7) \u2194\n    sorry"}, {"line": "simp_rw [neg_sub', neg_add, quot_mul_neg, neg_neg]", "tactic_state": "x y : PGame\nx\u271d : Sort u_1\nP1 : x\u271d\ni j : x.LeftMoves\nk : y.LeftMoves\nl : (-y).LeftMoves\n\u22a2 \u27e6x.moveLeft i * y\u27e7 + \u27e6x * y.moveLeft k\u27e7 - \u27e6x.moveLeft i * y.moveLeft k\u27e7 <\n      \u27e6x.moveLeft j * y\u27e7 + -\u27e6x * (-y).moveLeft l\u27e7 - -\u27e6x.moveLeft j * (-y).moveLeft l\u27e7 \u2194\n    sorry"}]}
{"declaration": "lemma Args.numeric_P1 {x y} : (Args.P1 x y).Numeric \u2194 x.Numeric \u2227 y.Numeric := by\n  simp [Args.Numeric, Args.toMultiset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Multiplication.lean", "context": {"open": ["SetTheory Game PGame WellFounded"], "variables": ["{x x\u2081 x\u2082 x\u2083 x' y y\u2081 y\u2082 y\u2083 y' : PGame.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ?m.42\ny : ?m.61\n\u22a2 sorry \u2194 sorry \u2227 sorry"}, {"line": "simp [Args.Numeric, Args.toMultiset]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Args.numeric_P24 {x\u2081 x\u2082 y} :\n    (Args.P24 x\u2081 x\u2082 y).Numeric \u2194 x\u2081.Numeric \u2227 x\u2082.Numeric \u2227 y.Numeric := by\n  simp [Args.Numeric, Args.toMultiset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Multiplication.lean", "context": {"open": ["SetTheory Game PGame WellFounded"], "variables": ["{x x\u2081 x\u2082 x\u2083 x' y y\u2081 y\u2082 y\u2083 y' : PGame.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u2081 : ?m.42\nx\u2082 : ?m.65\ny : ?m.66\n\u22a2 sorry \u2194 sorry \u2227 sorry \u2227 sorry"}, {"line": "simp [Args.Numeric, Args.toMultiset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem P3_of_lt_of_lt (hx\u2081 : x\u2081.Numeric) (hx\u2082 : x\u2082.Numeric) (hy\u2081 : y\u2081.Numeric) (hy\u2082 : y\u2082.Numeric)\n    (hx : x\u2081 < x\u2082) (hy : y\u2081 < y\u2082) : P3 x\u2081 x\u2082 y\u2081 y\u2082 := by\n  revert x\u2081 x\u2082\n  rw [\u2190 Prod.forall']\n  refine (wf_isOption.prod_gameAdd wf_isOption).fix ?_\n  rintro \u27e8x\u2081, x\u2082\u27e9 ih hx\u2081 hx\u2082 hx\n  refine P3_of_lt ?_ ?_ hx <;> intro i\n  \u00b7 have hi := hx\u2082.moveLeft i\n    exact \u27e8(P24 hx\u2081 hi hy\u2081).1, (P24 hx\u2081 hi hy\u2082).1,\n      P3_comm.2 <| ((P24 hy\u2081 hy\u2082 hx\u2082).2 hy).1 _,\n      ih _ (snd <| IsOption.moveLeft i) hx\u2081 hi\u27e9\n  \u00b7 have hi := hx\u2081.neg.moveLeft i\n    exact \u27e8(P24 hx\u2082.neg hi hy\u2081).1, (P24 hx\u2082.neg hi hy\u2082).1,\n      P3_comm.2 <| ((P24 hy\u2081 hy\u2082 hx\u2081).2 hy).2 _, by\n        rw [moveLeft_neg]\n        rw [\u2190 P3_neg]\n        rw [neg_lt_neg_iff]\n        exact ih _ (fst <| IsOption.moveRight _) (hx\u2081.moveRight _) hx\u2082\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Multiplication.lean", "context": {"open": ["SetTheory Game PGame WellFounded", "Relation", "Surreal.Multiplication", "Prod.GameAdd"], "variables": ["{x x\u2081 x\u2082 x\u2083 x' y y\u2081 y\u2082 y\u2083 y' : PGame.{u}}", "{x x\u2081 x\u2082 y y\u2081 y\u2082 : PGame.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u2081 x\u2082 y\u2081 y\u2082 : PGame\nhx\u2081 : x\u2081.Numeric\nhx\u2082 : x\u2082.Numeric\nhy\u2081 : y\u2081.Numeric\nhy\u2082 : y\u2082.Numeric\nhx : x\u2081 < x\u2082\nhy : y\u2081 < y\u2082\n\u22a2 P3 x\u2081 x\u2082 y\u2081 y\u2082"}, {"line": "revert x\u2081 x\u2082", "tactic_state": "y\u2081 y\u2082 : PGame\nhy\u2081 : y\u2081.Numeric\nhy\u2082 : y\u2082.Numeric\nhy : y\u2081 < y\u2082\n\u22a2 \u2200 {x\u2081 x\u2082 : PGame}, x\u2081.Numeric \u2192 x\u2082.Numeric \u2192 x\u2081 < x\u2082 \u2192 P3 x\u2081 x\u2082 y\u2081 y\u2082"}, {"line": "rw [\u2190 Prod.forall']", "tactic_state": "y\u2081 y\u2082 : PGame\nhy\u2081 : y\u2081.Numeric\nhy\u2082 : y\u2082.Numeric\nhy : y\u2081 < y\u2082\n\u22a2 \u2200 (x : PGame \u00d7 PGame), x.1.Numeric \u2192 x.2.Numeric \u2192 x.1 < x.2 \u2192 P3 x.1 x.2 y\u2081 y\u2082"}, {"line": "refine (wf_isOption.prod_gameAdd wf_isOption).fix ?_", "tactic_state": "y\u2081 y\u2082 : PGame\nhy\u2081 : y\u2081.Numeric\nhy\u2082 : y\u2082.Numeric\nhy : y\u2081 < y\u2082\n\u22a2 \u2200 (x : PGame \u00d7 PGame),\n    (\u2200 (y : PGame \u00d7 PGame),\n        Prod.GameAdd IsOption IsOption y x \u2192 y.1.Numeric \u2192 y.2.Numeric \u2192 y.1 < y.2 \u2192 P3 y.1 y.2 y\u2081 y\u2082) \u2192\n      x.1.Numeric \u2192 x.2.Numeric \u2192 x.1 < x.2 \u2192 P3 x.1 x.2 y\u2081 y\u2082"}, {"line": "rintro \u27e8x\u2081, x\u2082\u27e9 ih hx\u2081 hx\u2082 hx", "tactic_state": "case mk\ny\u2081 y\u2082 : PGame\nhy\u2081 : y\u2081.Numeric\nhy\u2082 : y\u2082.Numeric\nhy : y\u2081 < y\u2082\nx\u2081 x\u2082 : PGame\nih :\n  \u2200 (y : PGame \u00d7 PGame),\n    Prod.GameAdd IsOption IsOption y (x\u2081, x\u2082) \u2192 y.1.Numeric \u2192 y.2.Numeric \u2192 y.1 < y.2 \u2192 P3 y.1 y.2 y\u2081 y\u2082\nhx\u2081 : (x\u2081, x\u2082).1.Numeric\nhx\u2082 : (x\u2081, x\u2082).2.Numeric\nhx : (x\u2081, x\u2082).1 < (x\u2081, x\u2082).2\n\u22a2 P3 (x\u2081, x\u2082).1 (x\u2081, x\u2082).2 y\u2081 y\u2082"}, {"line": "refine P3_of_lt ?_ ?_ hx <;> intro i", "tactic_state": "case mk.refine_1\ny\u2081 y\u2082 : PGame\nhy\u2081 : y\u2081.Numeric\nhy\u2082 : y\u2082.Numeric\nhy : y\u2081 < y\u2082\nx\u2081 x\u2082 : PGame\nih :\n  \u2200 (y : PGame \u00d7 PGame),\n    Prod.GameAdd IsOption IsOption y (x\u2081, x\u2082) \u2192 y.1.Numeric \u2192 y.2.Numeric \u2192 y.1 < y.2 \u2192 P3 y.1 y.2 y\u2081 y\u2082\nhx\u2081 : (x\u2081, x\u2082).1.Numeric\nhx\u2082 : (x\u2081, x\u2082).2.Numeric\nhx : (x\u2081, x\u2082).1 < (x\u2081, x\u2082).2\ni : (x\u2081, x\u2082).2.LeftMoves\n\u22a2 IH3 (x\u2081, x\u2082).1 ((x\u2081, x\u2082).2.moveLeft i) (x\u2081, x\u2082).2 y\u2081 y\u2082\n---\ncase mk.refine_2\ny\u2081 y\u2082 : PGame\nhy\u2081 : y\u2081.Numeric\nhy\u2082 : y\u2082.Numeric\nhy : y\u2081 < y\u2082\nx\u2081 x\u2082 : PGame\nih :\n  \u2200 (y : PGame \u00d7 PGame),\n    Prod.GameAdd IsOption IsOption y (x\u2081, x\u2082) \u2192 y.1.Numeric \u2192 y.2.Numeric \u2192 y.1 < y.2 \u2192 P3 y.1 y.2 y\u2081 y\u2082\nhx\u2081 : (x\u2081, x\u2082).1.Numeric\nhx\u2082 : (x\u2081, x\u2082).2.Numeric\nhx : (x\u2081, x\u2082).1 < (x\u2081, x\u2082).2\ni : (-(x\u2081, x\u2082).1).LeftMoves\n\u22a2 IH3 (-(x\u2081, x\u2082).2) ((-(x\u2081, x\u2082).1).moveLeft i) (-(x\u2081, x\u2082).1) y\u2081 y\u2082"}, {"line": "\u00b7 have hi := hx\u2082.moveLeft i\n    exact \u27e8(P24 hx\u2081 hi hy\u2081).1, (P24 hx\u2081 hi hy\u2082).1,\n      P3_comm.2 <| ((P24 hy\u2081 hy\u2082 hx\u2082).2 hy).1 _,\n      ih _ (snd <| IsOption.moveLeft i) hx\u2081 hi\u27e9", "tactic_state": "case mk.refine_2\ny\u2081 y\u2082 : PGame\nhy\u2081 : y\u2081.Numeric\nhy\u2082 : y\u2082.Numeric\nhy : y\u2081 < y\u2082\nx\u2081 x\u2082 : PGame\nih :\n  \u2200 (y : PGame \u00d7 PGame),\n    Prod.GameAdd IsOption IsOption y (x\u2081, x\u2082) \u2192 y.1.Numeric \u2192 y.2.Numeric \u2192 y.1 < y.2 \u2192 P3 y.1 y.2 y\u2081 y\u2082\nhx\u2081 : (x\u2081, x\u2082).1.Numeric\nhx\u2082 : (x\u2081, x\u2082).2.Numeric\nhx : (x\u2081, x\u2082).1 < (x\u2081, x\u2082).2\ni : (-(x\u2081, x\u2082).1).LeftMoves\n\u22a2 IH3 (-(x\u2081, x\u2082).2) ((-(x\u2081, x\u2082).1).moveLeft i) (-(x\u2081, x\u2082).1) y\u2081 y\u2082"}, {"line": "\u00b7 have hi := hx\u2081.neg.moveLeft i\n    exact \u27e8(P24 hx\u2082.neg hi hy\u2081).1, (P24 hx\u2082.neg hi hy\u2082).1,\n      P3_comm.2 <| ((P24 hy\u2081 hy\u2082 hx\u2081).2 hy).2 _, by\n        rw [moveLeft_neg]\n        rw [\u2190 P3_neg]\n        rw [neg_lt_neg_iff]\n        exact ih _ (fst <| IsOption.moveRight _) (hx\u2081.moveRight _) hx\u2082\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Numeric.mul_pos (hx\u2081 : x\u2081.Numeric) (hx\u2082 : x\u2082.Numeric) (hp\u2081 : 0 < x\u2081) (hp\u2082 : 0 < x\u2082) :\n    0 < x\u2081 * x\u2082 := by\n  rw [lt_iff_game_lt]\n  have := P3_of_lt_of_lt numeric_zero hx\u2081 numeric_zero hx\u2082 hp\u2081 hp\u2082\n  simp_rw [P3, quot_zero_mul, quot_mul_zero, add_lt_add_iff_left] at this\n  exact this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Multiplication.lean", "context": {"open": ["SetTheory Game PGame WellFounded", "Relation", "Surreal.Multiplication", "Prod.GameAdd"], "variables": ["{x x\u2081 x\u2082 x\u2083 x' y y\u2081 y\u2082 y\u2083 y' : PGame.{u}}", "{x x\u2081 x\u2082 y y\u2081 y\u2082 : PGame.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u2081 x\u2082 : PGame\nhx\u2081 : x\u2081.Numeric\nhx\u2082 : x\u2082.Numeric\nhp\u2081 : 0 < x\u2081\nhp\u2082 : 0 < x\u2082\n\u22a2 0 < x\u2081 * x\u2082"}, {"line": "rw [lt_iff_game_lt]", "tactic_state": "x\u2081 x\u2082 : PGame\nhx\u2081 : x\u2081.Numeric\nhx\u2082 : x\u2082.Numeric\nhp\u2081 : 0 < x\u2081\nhp\u2082 : 0 < x\u2082\n\u22a2 \u27e60\u27e7 < \u27e6x\u2081 * x\u2082\u27e7"}, {"line": "have := P3_of_lt_of_lt numeric_zero hx\u2081 numeric_zero hx\u2082 hp\u2081 hp\u2082", "tactic_state": "x\u2081 x\u2082 : PGame\nhx\u2081 : x\u2081.Numeric\nhx\u2082 : x\u2082.Numeric\nhp\u2081 : 0 < x\u2081\nhp\u2082 : 0 < x\u2082\nthis : P3 0 x\u2081 0 x\u2082\n\u22a2 \u27e60\u27e7 < \u27e6x\u2081 * x\u2082\u27e7"}, {"line": "simp_rw [P3, quot_zero_mul, quot_mul_zero, add_lt_add_iff_left] at this", "tactic_state": "x\u2081 x\u2082 : PGame\nhx\u2081 : x\u2081.Numeric\nhx\u2082 : x\u2082.Numeric\nhp\u2081 : 0 < x\u2081\nhp\u2082 : 0 < x\u2082\nthis : 0 < \u27e6x\u2081 * x\u2082\u27e7\n\u22a2 \u27e60\u27e7 < \u27e6x\u2081 * x\u2082\u27e7"}, {"line": "exact this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_iff_forall_lt {x y : PGame} (ox : x.Numeric) (oy : y.Numeric) :\n    x \u2264 y \u2194 (\u2200 i, x.moveLeft i < y) \u2227 \u2200 j, x < y.moveRight j := by\n  refine le_iff_forall_lf.trans (and_congr ?_ ?_) <;>\n      refine forall_congr' fun i => lf_iff_lt ?_ ?_ <;>\n    apply_rules [Numeric.moveLeft, Numeric.moveRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Basic.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx y : PGame\nox : sorry\noy : sorry\n\u22a2 sorry \u2194 (?m.556 ox oy \u2192 sorry) \u2227 (?m.557 ox oy \u2192 sorry)"}, {"line": "refine le_iff_forall_lf.trans (and_congr ?_ ?_) <;>\n      refine forall_congr' fun i => lf_iff_lt ?_ ?_ <;>\n    apply_rules [Numeric.moveLeft, Numeric.moveRight]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_add {x y : PGame} (hx : x.Numeric) (hy : y.Numeric) :\n    Surreal.mk (x + y) (hx.add hy) = Surreal.mk x hx + Surreal.mk y hy := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Basic.lean", "context": {"open": ["scoped PGame", "SetTheory PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : PGame\nhx : x.Numeric\nhy : y.Numeric\n\u22a2 Surreal.mk (x + y) \u22ef = Surreal.mk x hx + Surreal.mk y hy"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_sub {x y : PGame} (hx : x.Numeric) (hy : y.Numeric) :\n    Surreal.mk (x - y) (hx.sub hy) = Surreal.mk x hx - Surreal.mk y hy := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Basic.lean", "context": {"open": ["scoped PGame", "SetTheory PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : PGame\nhx : x.Numeric\nhy : y.Numeric\n\u22a2 Surreal.mk (x - y) \u22ef = Surreal.mk x hx - Surreal.mk y hy"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nsmul_pow_two_powHalf (n : \u2115) : 2 ^ n * powHalf n = 1 := by\n  induction' n with n hn\n  \u00b7 simp only [pow_zero, powHalf_zero, mul_one]\n  \u00b7 rw [\u2190 hn, \u2190 double_powHalf_succ_eq_powHalf n, \u2190 mul_assoc (2 ^ n) 2 (powHalf (n + 1)),\n      pow_succ', mul_comm 2 (2 ^ n)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Dyadic.lean", "context": {"open": ["SetTheory PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry"}, {"line": "induction' n with n hn", "tactic_state": "case zero\n\u22a2 sorry\n---\ncase succ\nn : \u2115\nhn : sorry\n\u22a2 sorry"}, {"line": "\u00b7 simp only [pow_zero, powHalf_zero, mul_one]", "tactic_state": "case succ\nn : \u2115\nhn : sorry\n\u22a2 sorry"}, {"line": "\u00b7 rw [\u2190 hn, \u2190 double_powHalf_succ_eq_powHalf n, \u2190 mul_assoc (2 ^ n) 2 (powHalf (n + 1)),\n      pow_succ', mul_comm 2 (2 ^ n)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_subset_iff {x y : ZFSet} : x.toSet \u2286 y.toSet \u2194 x \u2286 y := by\n  simp [subset_def, Set.subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u_1}\n\u22a2 x.toSet \u2286 y.toSet \u2194 x \u2286 y"}, {"line": "simp [subset_def, Set.subset_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_empty : toSet \u2205 = \u2205 := by simp [toSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u2205"}, {"line": "simp [toSet]", "tactic_state": "\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem not_nonempty_empty : \u00acZFSet.Nonempty \u2205 := by simp [ZFSet.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00ac\u2205.Nonempty"}, {"line": "simp [ZFSet.Nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_mk_iff {x : PSet} : (mk x).Nonempty \u2194 x.Nonempty := by\n  refine \u27e8?_, fun \u27e8a, h\u27e9 => \u27e8mk a, h\u27e9\u27e9\n  rintro \u27e8a, h\u27e9\n  induction a using Quotient.inductionOn\n  exact \u27e8_, h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : PSet.{u_1}\n\u22a2 (ZFSet.mk x).Nonempty \u2194 x.Nonempty"}, {"line": "refine \u27e8?_, fun \u27e8a, h\u27e9 => \u27e8mk a, h\u27e9\u27e9", "tactic_state": "x : PSet.{u_1}\n\u22a2 (ZFSet.mk x).Nonempty \u2192 x.Nonempty"}, {"line": "rintro \u27e8a, h\u27e9", "tactic_state": "case intro\nx : PSet.{u_1}\na : ZFSet.{u_1}\nh : a \u2208 (ZFSet.mk x).toSet\n\u22a2 x.Nonempty"}, {"line": "induction a using Quotient.inductionOn", "tactic_state": "case intro.h\nx a\u271d : PSet.{u_1}\nh : \u27e6a\u271d\u27e7 \u2208 (ZFSet.mk x).toSet\n\u22a2 x.Nonempty"}, {"line": "exact \u27e8_, h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_empty (x : ZFSet.{u}) : x = \u2205 \u2194 \u2200 y : ZFSet.{u}, y \u2209 x := by\n  simp [ZFSet.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ZFSet.{u}\n\u22a2 x = \u2205 \u2194 \u2200 (y : ZFSet.{u}), y \u2209 x"}, {"line": "simp [ZFSet.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_empty_or_nonempty (u : ZFSet) : u = \u2205 \u2228 u.Nonempty := by\n  rw [eq_empty]\n  rw [\u2190 not_exists]\n  apply em'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : ZFSet.{u_1}\n\u22a2 u = \u2205 \u2228 u.Nonempty"}, {"line": "rw [eq_empty]", "tactic_state": "u : ZFSet.{u_1}\n\u22a2 (\u2200 (y : ZFSet.{u_1}), y \u2209 u) \u2228 u.Nonempty"}, {"line": "rw [\u2190 not_exists]", "tactic_state": "u : ZFSet.{u_1}\n\u22a2 (\u00ac\u2203 x, x \u2208 u) \u2228 u.Nonempty"}, {"line": "apply em'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_insert (x y : ZFSet) : (insert x y).toSet = insert x y.toSet := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u_1}\n\u22a2 (insert x y).toSet = insert x y.toSet"}, {"line": "ext", "tactic_state": "case h\nx y x\u271d : ZFSet.{u_1}\n\u22a2 x\u271d \u2208 (insert x y).toSet \u2194 x\u271d \u2208 insert x y.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_singleton (x : ZFSet) : ({x} : ZFSet).toSet = {x} := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ZFSet.{u_1}\n\u22a2 {x}.toSet = {x}"}, {"line": "ext", "tactic_state": "case h\nx x\u271d : ZFSet.{u_1}\n\u22a2 x\u271d \u2208 {x}.toSet \u2194 x\u271d \u2208 {x}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_pair {x y z : ZFSet.{u}} : x \u2208 ({y, z} : ZFSet) \u2194 x = y \u2228 x = z := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u}\n\u22a2 x \u2208 {y, z} \u2194 x = y \u2228 x = z"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pair_eq_singleton (x : ZFSet) : {x, x} = ({x} : ZFSet) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ZFSet.{u_1}\n\u22a2 {x, x} = {x}"}, {"line": "ext", "tactic_state": "case a\nx z\u271d : ZFSet.{u_1}\n\u22a2 z\u271d \u2208 {x, x} \u2194 z\u271d \u2208 {x}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_eq_pair_iff {x y z : ZFSet} : ({x} : ZFSet) = {y, z} \u2194 x = y \u2227 x = z := by\n  rw [eq_comm]\n  rw [pair_eq_singleton_iff]\n  simp_rw [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u_1}\n\u22a2 {x} = {y, z} \u2194 x = y \u2227 x = z"}, {"line": "rw [eq_comm]", "tactic_state": "x y z : ZFSet.{u_1}\n\u22a2 {y, z} = {x} \u2194 x = y \u2227 x = z"}, {"line": "rw [pair_eq_singleton_iff]", "tactic_state": "x y z : ZFSet.{u_1}\n\u22a2 y = x \u2227 z = x \u2194 x = y \u2227 x = z"}, {"line": "simp_rw [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_empty : \u22c2\u2080 (\u2205 : ZFSet) = \u2205 := by simp [sInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u2205"}, {"line": "simp [sInter]", "tactic_state": "\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem mem_of_mem_sInter {x y z : ZFSet} (hy : y \u2208 \u22c2\u2080 x) (hz : z \u2208 x) : y \u2208 z := by\n  rcases eq_empty_or_nonempty x with (rfl | hx)\n  \u00b7 exact (not_mem_empty z hz).elim\n  \u00b7 exact (mem_sInter hx).1 hy z hz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u_1}\nhy : y \u2208 sorry\nhz : z \u2208 x\n\u22a2 y \u2208 z"}, {"line": "rcases eq_empty_or_nonempty x with (rfl | hx)", "tactic_state": "case inl\ny z : ZFSet.{u_1}\nhy : y \u2208 sorry\nhz : z \u2208 \u2205\n\u22a2 y \u2208 z\n---\ncase inr\nx y z : ZFSet.{u_1}\nhy : y \u2208 sorry\nhz : z \u2208 x\nhx : x.Nonempty\n\u22a2 y \u2208 z"}, {"line": "\u00b7 exact (not_mem_empty z hz).elim", "tactic_state": "case inr\nx y z : ZFSet.{u_1}\nhy : y \u2208 sorry\nhz : z \u2208 x\nhx : x.Nonempty\n\u22a2 y \u2208 z"}, {"line": "\u00b7 exact (mem_sInter hx).1 hy z hz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_union (x y : ZFSet.{u}) : (x \u222a y).toSet = x.toSet \u222a y.toSet := by\n  change (\u22c3\u2080 {x, y}).toSet = _\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (x \u222a y).toSet = x.toSet \u222a y.toSet"}, {"line": "change (\u22c3\u2080 {x, y}).toSet = _", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (\u22c3\u2080 {x, y}).toSet = x.toSet \u222a y.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_inter (x y : ZFSet.{u}) : (x \u2229 y).toSet = x.toSet \u2229 y.toSet := by\n  change (ZFSet.sep (fun z => z \u2208 y) x).toSet = _\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (x \u2229 y).toSet = x.toSet \u2229 y.toSet"}, {"line": "change (ZFSet.sep (fun z => z \u2208 y) x).toSet = _", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (ZFSet.sep (fun z => z \u2208 y) x).toSet = x.toSet \u2229 y.toSet"}, {"line": "ext", "tactic_state": "case h\nx y x\u271d : ZFSet.{u}\n\u22a2 x\u271d \u2208 (ZFSet.sep (fun z => z \u2208 y) x).toSet \u2194 x\u271d \u2208 x.toSet \u2229 y.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_sdiff (x y : ZFSet.{u}) : (x \\ y).toSet = x.toSet \\ y.toSet := by\n  change (ZFSet.sep (fun z => z \u2209 y) x).toSet = _\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (x \\ y).toSet = x.toSet \\ y.toSet"}, {"line": "change (ZFSet.sep (fun z => z \u2209 y) x).toSet = _", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (ZFSet.sep (fun z => z \u2209 y) x).toSet = x.toSet \\ y.toSet"}, {"line": "ext", "tactic_state": "case h\nx y x\u271d : ZFSet.{u}\n\u22a2 x\u271d \u2208 (ZFSet.sep (fun z => z \u2209 y) x).toSet \u2194 x\u271d \u2208 x.toSet \\ y.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_image (f : ZFSet \u2192 ZFSet) [Definable\u2081 f] (x : ZFSet) :\n    (image f x).toSet = f '' x.toSet := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : ZFSet.{u_1} \u2192 ZFSet.{u_1}\ninst\u271d : Definable\u2081 f\nx : ZFSet.{u_1}\n\u22a2 (ZFSet.image f x).toSet = f '' x.toSet"}, {"line": "ext", "tactic_state": "case h\nf : ZFSet.{u_1} \u2192 ZFSet.{u_1}\ninst\u271d : Definable\u2081 f\nx x\u271d : ZFSet.{u_1}\n\u22a2 x\u271d \u2208 (ZFSet.image f x).toSet \u2194 x\u271d \u2208 f '' x.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_range {\u03b1} [Small.{u} \u03b1] (f : \u03b1 \u2192 ZFSet.{u}) :\n    (range f).toSet = Set.range f := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Small.{u, u_1} \u03b1\nf : \u03b1 \u2192 ZFSet.{u}\n\u22a2 (range f).toSet = Set.range f"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : Small.{u, u_1} \u03b1\nf : \u03b1 \u2192 ZFSet.{u}\nx\u271d : ZFSet.{u}\n\u22a2 x\u271d \u2208 (range f).toSet \u2194 x\u271d \u2208 Set.range f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_pair (x y : ZFSet.{u}) : (pair x y).toSet = {{x}, {x, y}} := by simp [pair]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (x.pair y).toSet = {{x}, {x, y}}"}, {"line": "simp [pair]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_prod {x y z : ZFSet.{u}} : z \u2208 prod x y \u2194 \u2203 a \u2208 x, \u2203 b \u2208 y, z = pair a b := by\n  simp [prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u}\n\u22a2 z \u2208 x.prod y \u2194 \u2203 a \u2208 x, \u2203 b \u2208 y, z = a.pair b"}, {"line": "simp [prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pair_mem_prod {x y a b : ZFSet.{u}} : pair a b \u2208 prod x y \u2194 a \u2208 x \u2227 b \u2208 y := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y a b : ZFSet.{u}\n\u22a2 a.pair b \u2208 x.prod y \u2194 a \u2208 x \u2227 b \u2208 y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_funs {x y f : ZFSet.{u}} : f \u2208 funs x y \u2194 IsFunc x y f := by simp [funs, IsFunc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y f : ZFSet.{u}\n\u22a2 f \u2208 x.funs y \u2194 x.IsFunc y f"}, {"line": "simp [funs, IsFunc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hereditarily_iff : Hereditarily p x \u2194 p x \u2227 \u2200 y \u2208 x, Hereditarily p y := by\n  rw [\u2190 Hereditarily]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": ["{p : ZFSet.{u} \u2192 Prop} {x y : ZFSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ZFSet.{u} \u2192 Prop\nx : ZFSet.{u}\n\u22a2 Hereditarily p x \u2194 p x \u2227 \u2200 y \u2208 x, Hereditarily p y"}, {"line": "rw [\u2190 Hereditarily]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Hereditarily.empty : Hereditarily p x \u2192 p \u2205 := by\n  apply @ZFSet.inductionOn _ x\n  intro y IH h\n  rcases ZFSet.eq_empty_or_nonempty y with (rfl | \u27e8a, ha\u27e9)\n  \u00b7 exact h.self\n  \u00b7 exact IH a ha (h.mem ha)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": ["{p : ZFSet.{u} \u2192 Prop} {x y : ZFSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ZFSet.{u} \u2192 Prop\nx : ZFSet.{u}\n\u22a2 Hereditarily p x \u2192 p \u2205"}, {"line": "apply @ZFSet.inductionOn _ x", "tactic_state": "p : ZFSet.{u} \u2192 Prop\nx : ZFSet.{u}\n\u22a2 \u2200 (x : ZFSet.{u}), (\u2200 y \u2208 x, Hereditarily p y \u2192 p \u2205) \u2192 Hereditarily p x \u2192 p \u2205"}, {"line": "intro y IH h", "tactic_state": "p : ZFSet.{u} \u2192 Prop\nx y : ZFSet.{u}\nIH : \u2200 y_1 \u2208 y, Hereditarily p y_1 \u2192 p \u2205\nh : Hereditarily p y\n\u22a2 p \u2205"}, {"line": "rcases ZFSet.eq_empty_or_nonempty y with (rfl | \u27e8a, ha\u27e9)", "tactic_state": "case inl\np : ZFSet.{u} \u2192 Prop\nx : ZFSet.{u}\nIH : \u2200 y \u2208 \u2205, Hereditarily p y \u2192 p \u2205\nh : Hereditarily p \u2205\n\u22a2 p \u2205\n---\ncase inr.intro\np : ZFSet.{u} \u2192 Prop\nx y : ZFSet.{u}\nIH : \u2200 y_1 \u2208 y, Hereditarily p y_1 \u2192 p \u2205\nh : Hereditarily p y\na : ZFSet.{u}\nha : a \u2208 y.toSet\n\u22a2 p \u2205"}, {"line": "\u00b7 exact h.self", "tactic_state": "case inr.intro\np : ZFSet.{u} \u2192 Prop\nx y : ZFSet.{u}\nIH : \u2200 y_1 \u2208 y, Hereditarily p y_1 \u2192 p \u2205\nh : Hereditarily p y\na : ZFSet.{u}\nha : a \u2208 y.toSet\n\u22a2 p \u2205"}, {"line": "\u00b7 exact IH a ha (h.mem ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_apply {x : Class} {y : ZFSet} : (\u22c3\u2080 x) y \u2194 \u2203 z : ZFSet, x z \u2227 y \u2208 z := by\n  constructor\n  \u00b7 rintro \u27e8-, \u27e8z, rfl, hxz\u27e9, hyz\u27e9\n    exact \u27e8z, hxz, hyz\u27e9\n  \u00b7 exact fun \u27e8z, hxz, hyz\u27e9 => \u27e8_, coe_mem.2 hxz, hyz\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Class.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Class.{u_1}\ny : ZFSet.{u_1}\n\u22a2 (\u22c3\u2080 x) y \u2194 \u2203 z, x z \u2227 y \u2208 z"}, {"line": "constructor", "tactic_state": "case mp\nx : Class.{u_1}\ny : ZFSet.{u_1}\n\u22a2 (\u22c3\u2080 x) y \u2192 \u2203 z, x z \u2227 y \u2208 z\n---\ncase mpr\nx : Class.{u_1}\ny : ZFSet.{u_1}\n\u22a2 (\u2203 z, x z \u2227 y \u2208 z) \u2192 (\u22c3\u2080 x) y"}, {"line": "\u00b7 rintro \u27e8-, \u27e8z, rfl, hxz\u27e9, hyz\u27e9\n    exact \u27e8z, hxz, hyz\u27e9", "tactic_state": "case mpr\nx : Class.{u_1}\ny : ZFSet.{u_1}\n\u22a2 (\u2203 z, x z \u2227 y \u2208 z) \u2192 (\u22c3\u2080 x) y"}, {"line": "\u00b7 exact fun \u27e8z, hxz, hyz\u27e9 => \u27e8_, coe_mem.2 hxz, hyz\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_apply {x : Class.{u}} {y : ZFSet.{u}} : (\u22c2\u2080 x) y \u2194 \u2200 z : ZFSet.{u}, x z \u2192 y \u2208 z := by\n  refine \u27e8fun hxy z hxz => hxy _ \u27e8z, rfl, hxz\u27e9, ?_\u27e9\n  rintro H - \u27e8z, rfl, hxz\u27e9\n  exact H _ hxz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Class.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Class.{u}\ny : ZFSet.{u}\n\u22a2 (\u22c2\u2080 x) y \u2194 \u2200 (z : ZFSet.{u}), x z \u2192 y \u2208 z"}, {"line": "refine \u27e8fun hxy z hxz => hxy _ \u27e8z, rfl, hxz\u27e9, ?_\u27e9", "tactic_state": "x : Class.{u}\ny : ZFSet.{u}\n\u22a2 (\u2200 (z : ZFSet.{u}), x z \u2192 y \u2208 z) \u2192 (\u22c2\u2080 x) y"}, {"line": "rintro H - \u27e8z, rfl, hxz\u27e9", "tactic_state": "case intro.intro\nx : Class.{u}\ny : ZFSet.{u}\nH : \u2200 (z : ZFSet.{u}), x z \u2192 y \u2208 z\nz : ZFSet.{u}\nhxz : x z\n\u22a2 y \u2208 \u2191z"}, {"line": "exact H _ hxz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_of_mem_sInter {x y z : Class} (hy : y \u2208 \u22c2\u2080 x) (hz : z \u2208 x) : y \u2208 z := by\n  obtain \u27e8w, rfl, hw\u27e9 := hy\n  exact coe_mem.2 (hw z hz)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Class.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : Class.{u_1}\nhy : y \u2208 \u22c2\u2080 x\nhz : z \u2208 x\n\u22a2 y \u2208 z"}, {"line": "obtain \u27e8w, rfl, hw\u27e9 := hy", "tactic_state": "case intro.intro\nx z : Class.{u_1}\nhz : z \u2208 x\nw : ZFSet.{u_1}\nhw : (\u22c2\u2080 x) w\n\u22a2 \u2191w \u2208 z"}, {"line": "exact coe_mem.2 (hw z hz)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_empty : \u22c3\u2080 (\u2205 : Class.{u}) = (\u2205 : Class.{u}) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Class.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u22c3\u2080 \u2205 = \u2205"}, {"line": "ext", "tactic_state": "case a\nz\u271d : ZFSet.{u}\n\u22a2 (\u22c3\u2080 \u2205) z\u271d \u2194 \u2205 z\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.ZFSet.isOrdinal_iff_isTrans :\n    x.IsOrdinal \u2194 x.IsTransitive \u2227 IsTrans _ (Subrel (\u00b7 \u2208 \u00b7) (\u00b7 \u2208 x)) where\n  mp h := \u27e8h.isTransitive, h.isTrans\u27e9\n  mpr := by\n    rintro \u27e8h\u2081, \u27e8h\u2082\u27e9\u27e9\n    refine \u27e8h\u2081, fun {y z w} hyz hzw hwx \u21a6 ?_\u27e9\n    have hzx := h\u2081.mem_trans hzw hwx\n    exact h\u2082 \u27e8y, h\u2081.mem_trans hyz hzx\u27e9 \u27e8z, hzx\u27e9 \u27e8w, hwx\u27e9 hyz hzw\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Ordinal.lean", "context": {"open": [], "variables": ["{x y z w : ZFSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ZFSet.{u}\n\u22a2 x.IsTransitive \u2227 IsTrans { x_1 // x_1 \u2208 x } (Subrel (fun x1 x2 => x1 \u2208 x2) fun x_1 => x_1 \u2208 x) \u2192 x.IsOrdinal"}, {"line": "rintro \u27e8h\u2081, \u27e8h\u2082\u27e9\u27e9", "tactic_state": "case intro.mk\nx : ZFSet.{u}\nh\u2081 : x.IsTransitive\nh\u2082 :\n  \u2200 (a b c : { x_1 // x_1 \u2208 x }),\n    Subrel (fun x1 x2 => x1 \u2208 x2) (fun x_1 => x_1 \u2208 x) a b \u2192\n      Subrel (fun x1 x2 => x1 \u2208 x2) (fun x_1 => x_1 \u2208 x) b c \u2192 Subrel (fun x1 x2 => x1 \u2208 x2) (fun x_1 => x_1 \u2208 x) a c\n\u22a2 x.IsOrdinal"}, {"line": "refine \u27e8h\u2081, fun {y z w} hyz hzw hwx \u21a6 ?_\u27e9", "tactic_state": "case intro.mk\nx : ZFSet.{u}\nh\u2081 : x.IsTransitive\nh\u2082 :\n  \u2200 (a b c : { x_1 // x_1 \u2208 x }),\n    Subrel (fun x1 x2 => x1 \u2208 x2) (fun x_1 => x_1 \u2208 x) a b \u2192\n      Subrel (fun x1 x2 => x1 \u2208 x2) (fun x_1 => x_1 \u2208 x) b c \u2192 Subrel (fun x1 x2 => x1 \u2208 x2) (fun x_1 => x_1 \u2208 x) a c\ny z w : ZFSet.{u}\nhyz : y \u2208 z\nhzw : z \u2208 w\nhwx : w \u2208 x\n\u22a2 y \u2208 w"}, {"line": "have hzx := h\u2081.mem_trans hzw hwx", "tactic_state": "case intro.mk\nx : ZFSet.{u}\nh\u2081 : x.IsTransitive\nh\u2082 :\n  \u2200 (a b c : { x_1 // x_1 \u2208 x }),\n    Subrel (fun x1 x2 => x1 \u2208 x2) (fun x_1 => x_1 \u2208 x) a b \u2192\n      Subrel (fun x1 x2 => x1 \u2208 x2) (fun x_1 => x_1 \u2208 x) b c \u2192 Subrel (fun x1 x2 => x1 \u2208 x2) (fun x_1 => x_1 \u2208 x) a c\ny z w : ZFSet.{u}\nhyz : y \u2208 z\nhzw : z \u2208 w\nhwx : w \u2208 x\nhzx : z \u2208 x\n\u22a2 y \u2208 w"}, {"line": "exact h\u2082 \u27e8y, h\u2081.mem_trans hyz hzx\u27e9 \u27e8z, hzx\u27e9 \u27e8w, hwx\u27e9 hyz hzw", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_of_subset_of_mem (h : x.IsOrdinal) (hz : z.IsOrdinal) (hx : x \u2286 y) (hy : y \u2208 z) :\n    x \u2208 z := by\n  obtain rfl | hx := h.eq_or_mem_of_subset (hz.mem hy) hx\n  \u00b7 exact hy\n  \u00b7 exact hz.mem_trans hx hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Ordinal.lean", "context": {"open": [], "variables": ["{x y z w : ZFSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u}\nh : x.IsOrdinal\nhz : z.IsOrdinal\nhx : x \u2286 y\nhy : y \u2208 z\n\u22a2 x \u2208 z"}, {"line": "obtain rfl | hx := h.eq_or_mem_of_subset (hz.mem hy) hx", "tactic_state": "case inl\nx z : ZFSet.{u}\nh : x.IsOrdinal\nhz : z.IsOrdinal\nhx : x \u2286 x\nhy : x \u2208 z\n\u22a2 x \u2208 z\n---\ncase inr\nx y z : ZFSet.{u}\nh : x.IsOrdinal\nhz : z.IsOrdinal\nhx\u271d : x \u2286 y\nhy : y \u2208 z\nhx : x \u2208 y\n\u22a2 x \u2208 z"}, {"line": "\u00b7 exact hy", "tactic_state": "case inr\nx y z : ZFSet.{u}\nh : x.IsOrdinal\nhz : z.IsOrdinal\nhx\u271d : x \u2286 y\nhy : y \u2208 z\nhx : x \u2208 y\n\u22a2 x \u2208 z"}, {"line": "\u00b7 exact hz.mem_trans hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem func_mem (x : PSet) (i : x.Type) : x.Func i \u2208 x := by\n  cases x\n  apply Mem.mk\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : PSet.{u_1}\ni : x.Type\n\u22a2 x.Func i \u2208 x"}, {"line": "cases x", "tactic_state": "case mk\n\u03b1\u271d : Type u_1\nA\u271d : \u03b1\u271d \u2192 PSet.{u_1}\ni : (PSet.mk \u03b1\u271d A\u271d).Type\n\u22a2 (PSet.mk \u03b1\u271d A\u271d).Func i \u2208 PSet.mk \u03b1\u271d A\u271d"}, {"line": "apply Mem.mk", "tactic_state": "No Goals!"}]}
{"declaration": "theorem empty_def : (\u2205 : PSet) = \u27e8_, PEmpty.elim\u27e9 := by\n  simp [EmptyCollection.emptyCollection, PSet.empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2205 = PSet.mk PEmpty.{u_1 + 1} PEmpty.elim"}, {"line": "simp [EmptyCollection.emptyCollection, PSet.empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_empty : toSet \u2205 = \u2205 := by simp [toSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoSet : x\u271d\n\u22a2 sorry = \u2205"}, {"line": "simp [toSet]", "tactic_state": "x\u271d : Sort u_1\ntoSet : x\u271d\n\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem not_nonempty_empty : \u00acPSet.Nonempty \u2205 := by simp [PSet.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00ac\u2205.Nonempty"}, {"line": "simp [PSet.Nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_pair {x y z : PSet} : x \u2208 ({y, z} : PSet) \u2194 Equiv x y \u2228 Equiv x z := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : PSet.{u_1}\n\u22a2 x \u2208 {y, z} \u2194 sorry \u2228 sorry"}, {"line": "simp", "tactic_state": "x y z : PSet.{u_1}\n\u22a2 x.Equiv y \u2228 x.Equiv z \u2194 sorry ()"}]}
{"declaration": "theorem toSet_sUnion (x : PSet.{u}) : (\u22c3\u2080 x).toSet = \u22c3\u2080 (toSet '' x.toSet) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u_1\ntoSet : PSet.{u} \u2192 Set \u03b1\u271d\nx : PSet.{u}\n\u22a2 (\u22c3\u2080 x).toSet = sorry"}, {"line": "ext", "tactic_state": "case h\n\u03b1\u271d : Type u_1\ntoSet : PSet.{u} \u2192 Set \u03b1\u271d\nx x\u271d : PSet.{u}\n\u22a2 x\u271d \u2208 (\u22c3\u2080 x).toSet \u2194 x\u271d \u2208 sorry"}, {"line": "simp", "tactic_state": "case h\n\u03b1\u271d : Type u_1\ntoSet : PSet.{u} \u2192 Set \u03b1\u271d\nx x\u271d : PSet.{u}\n\u22a2 (\u2203 i \u2208 x, x\u271d \u2208 i) \u2194 x\u271d \u2208 sorry ()"}]}
{"declaration": "theorem rank_empty : rank \u2205 = 0 := by simp [empty_def, rank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Rank.lean", "context": {"open": ["Ordinal Order"], "variables": ["{x y : PSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [empty_def, rank]", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem rank_pair (x y : PSet) : rank {x, y} = max (succ (rank x)) (succ (rank y)) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Rank.lean", "context": {"open": ["Ordinal Order"], "variables": ["{x y : PSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\nx : PSet.{u_2}\ny : PSet.{u_3}\n\u22a2 sorry = succ sorry \u2294 succ sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\nx : PSet.{u_2}\ny : PSet.{u_3}\n\u22a2 sorry () = succ (sorry ()) \u2294 succ (sorry ())"}]}
{"declaration": "example : True := by\n  #adaptation_note /-- This is a test -/\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/AdaptationNote.lean", "context": {"open": ["Lean"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "#adaptation_note /-- This is a test -/", "tactic_state": "\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_mul_add_of_le_natDegree_of_eq_ite {d df dg : \u2115} {a b : R} {f g : R[X]}\n    (h_mul_left : natDegree f \u2264 df) (h_mul_right : natDegree g \u2264 dg)\n    (h_mul_left : f.coeff df = a) (h_mul_right : g.coeff dg = b) (ddf : df + dg \u2264 d) :\n    (f * g).coeff d = if d = df + dg then a * b else 0 := by\n  split_ifs with h\n  \u00b7 subst h_mul_left h_mul_right h\n    exact coeff_mul_of_natDegree_le \u2039_\u203a \u2039_\u203a\n  \u00b7 apply coeff_eq_zero_of_natDegree_lt\n    apply lt_of_le_of_lt ?_ (lt_of_le_of_ne ddf ?_)\n    \u00b7 exact natDegree_mul_le_of_le \u2039_\u203a \u2039_\u203a\n    \u00b7 exact ne_comm.mp h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nd df dg : \u2115\na b : R\nf g : Polynomial R\nh_mul_left\u271d : f.natDegree \u2264 df\nh_mul_right\u271d : g.natDegree \u2264 dg\nh_mul_left : f.coeff df = a\nh_mul_right : g.coeff dg = b\nddf : df + dg \u2264 d\n\u22a2 (f * g).coeff d = if d = df + dg then a * b else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nd df dg : \u2115\na b : R\nf g : Polynomial R\nh_mul_left\u271d : f.natDegree \u2264 df\nh_mul_right\u271d : g.natDegree \u2264 dg\nh_mul_left : f.coeff df = a\nh_mul_right : g.coeff dg = b\nddf : df + dg \u2264 d\nh : d = df + dg\n\u22a2 (f * g).coeff d = a * b\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nd df dg : \u2115\na b : R\nf g : Polynomial R\nh_mul_left\u271d : f.natDegree \u2264 df\nh_mul_right\u271d : g.natDegree \u2264 dg\nh_mul_left : f.coeff df = a\nh_mul_right : g.coeff dg = b\nddf : df + dg \u2264 d\nh : \u00acd = df + dg\n\u22a2 (f * g).coeff d = 0"}, {"line": "\u00b7 subst h_mul_left h_mul_right h\n    exact coeff_mul_of_natDegree_le \u2039_\u203a \u2039_\u203a", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nd df dg : \u2115\na b : R\nf g : Polynomial R\nh_mul_left\u271d : f.natDegree \u2264 df\nh_mul_right\u271d : g.natDegree \u2264 dg\nh_mul_left : f.coeff df = a\nh_mul_right : g.coeff dg = b\nddf : df + dg \u2264 d\nh : \u00acd = df + dg\n\u22a2 (f * g).coeff d = 0"}, {"line": "\u00b7 apply coeff_eq_zero_of_natDegree_lt\n    apply lt_of_le_of_lt ?_ (lt_of_le_of_ne ddf ?_)\n    \u00b7 exact natDegree_mul_le_of_le \u2039_\u203a \u2039_\u203a\n    \u00b7 exact ne_comm.mp h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_pow_of_natDegree_le_of_eq_ite' {m n o : \u2115} {a : R} {p : R[X]}\n    (h_pow : natDegree p \u2264 n) (h_exp : m * n \u2264 o) (h_pow_bas : coeff p n = a) :\n    coeff (p ^ m) o = if o = m * n then a ^ m else 0 := by\n  split_ifs with h\n  \u00b7 subst h h_pow_bas\n    exact coeff_pow_of_natDegree_le \u2039_\u203a\n  \u00b7 apply coeff_eq_zero_of_natDegree_lt\n    apply lt_of_le_of_lt ?_ (lt_of_le_of_ne \u2039_\u203a ?_)\n    \u00b7 exact natDegree_pow_le_of_le m \u2039_\u203a\n    \u00b7 exact Iff.mp ne_comm h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nm n o : \u2115\na : R\np : Polynomial R\nh_pow : p.natDegree \u2264 n\nh_exp : m * n \u2264 o\nh_pow_bas : p.coeff n = a\n\u22a2 (p ^ m).coeff o = if o = m * n then a ^ m else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nm n o : \u2115\na : R\np : Polynomial R\nh_pow : p.natDegree \u2264 n\nh_exp : m * n \u2264 o\nh_pow_bas : p.coeff n = a\nh : o = m * n\n\u22a2 (p ^ m).coeff o = a ^ m\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nm n o : \u2115\na : R\np : Polynomial R\nh_pow : p.natDegree \u2264 n\nh_exp : m * n \u2264 o\nh_pow_bas : p.coeff n = a\nh : \u00aco = m * n\n\u22a2 (p ^ m).coeff o = 0"}, {"line": "\u00b7 subst h h_pow_bas\n    exact coeff_pow_of_natDegree_le \u2039_\u203a", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nm n o : \u2115\na : R\np : Polynomial R\nh_pow : p.natDegree \u2264 n\nh_exp : m * n \u2264 o\nh_pow_bas : p.coeff n = a\nh : \u00aco = m * n\n\u22a2 (p ^ m).coeff o = 0"}, {"line": "\u00b7 apply coeff_eq_zero_of_natDegree_lt\n    apply lt_of_le_of_lt ?_ (lt_of_le_of_ne \u2039_\u203a ?_)\n    \u00b7 exact natDegree_pow_le_of_le m \u2039_\u203a\n    \u00b7 exact Iff.mp ne_comm h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_eq_of_le_of_coeff_ne_zero' {deg m o : \u2115} {c : R} {p : R[X]}\n    (h_natDeg_le : natDegree p \u2264 m) (coeff_eq : coeff p o = c)\n    (coeff_ne_zero : c \u2260 0) (deg_eq_deg : m = deg) (coeff_eq_deg : o = deg) :\n    natDegree p = deg := by\n  subst coeff_eq deg_eq_deg coeff_eq_deg\n  exact natDegree_eq_of_le_of_coeff_ne_zero \u2039_\u203a \u2039_\u203a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\ndeg m o : \u2115\nc : R\np : Polynomial R\nh_natDeg_le : p.natDegree \u2264 m\ncoeff_eq : p.coeff o = c\ncoeff_ne_zero : c \u2260 0\ndeg_eq_deg : m = deg\ncoeff_eq_deg : o = deg\n\u22a2 p.natDegree = deg"}, {"line": "subst coeff_eq deg_eq_deg coeff_eq_deg", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\no : \u2115\np : Polynomial R\ncoeff_ne_zero : p.coeff o \u2260 0\nh_natDeg_le : p.natDegree \u2264 o\n\u22a2 p.natDegree = o"}, {"line": "exact natDegree_eq_of_le_of_coeff_ne_zero \u2039_\u203a \u2039_\u203a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_eq_of_le_of_coeff_ne_zero' {deg m o : WithBot \u2115} {c : R} {p : R[X]}\n    (h_deg_le : degree p \u2264 m) (coeff_eq : coeff p (WithBot.unbotD 0 deg) = c)\n    (coeff_ne_zero : c \u2260 0) (deg_eq_deg : m = deg) (coeff_eq_deg : o = deg) :\n    degree p = deg := by\n  subst coeff_eq coeff_eq_deg deg_eq_deg\n  rcases eq_or_ne m \u22a5 with rfl|hh\n  \u00b7 exact bot_unique h_deg_le\n  \u00b7 obtain \u27e8m, rfl\u27e9 := WithBot.ne_bot_iff_exists.mp hh\n    exact degree_eq_of_le_of_coeff_ne_zero \u2039_\u203a \u2039_\u203a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\ndeg m o : WithBot \u2115\nc : R\np : Polynomial R\nh_deg_le : p.degree \u2264 m\ncoeff_eq : p.coeff (WithBot.unbotD 0 deg) = c\ncoeff_ne_zero : c \u2260 0\ndeg_eq_deg : m = deg\ncoeff_eq_deg : o = deg\n\u22a2 p.degree = deg"}, {"line": "subst coeff_eq coeff_eq_deg deg_eq_deg", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nm : WithBot \u2115\np : Polynomial R\nh_deg_le : p.degree \u2264 m\ncoeff_ne_zero : p.coeff (WithBot.unbotD 0 m) \u2260 0\n\u22a2 p.degree = m"}, {"line": "rcases eq_or_ne m \u22a5 with rfl|hh", "tactic_state": "case inl\nR : Type u_1\ninst\u271d : Semiring R\np : Polynomial R\nh_deg_le : p.degree \u2264 \u22a5\ncoeff_ne_zero : p.coeff (WithBot.unbotD 0 \u22a5) \u2260 0\n\u22a2 p.degree = \u22a5\n---\ncase inr\nR : Type u_1\ninst\u271d : Semiring R\nm : WithBot \u2115\np : Polynomial R\nh_deg_le : p.degree \u2264 m\ncoeff_ne_zero : p.coeff (WithBot.unbotD 0 m) \u2260 0\nhh : m \u2260 \u22a5\n\u22a2 p.degree = m"}, {"line": "\u00b7 exact bot_unique h_deg_le", "tactic_state": "case inr\nR : Type u_1\ninst\u271d : Semiring R\nm : WithBot \u2115\np : Polynomial R\nh_deg_le : p.degree \u2264 m\ncoeff_ne_zero : p.coeff (WithBot.unbotD 0 m) \u2260 0\nhh : m \u2260 \u22a5\n\u22a2 p.degree = m"}, {"line": "\u00b7 obtain \u27e8m, rfl\u27e9 := WithBot.ne_bot_iff_exists.mp hh\n    exact degree_eq_of_le_of_coeff_ne_zero \u2039_\u203a \u2039_\u203a", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem implies_congr' {\u03b1 \u03b1' : Sort u} {\u03b2 \u03b2' : Sort v} (h : \u03b1 = \u03b1') (h' : \u03b1' \u2192 \u03b2 = \u03b2') :\n    (\u03b1 \u2192 \u03b2) = (\u03b1' \u2192 \u03b2') := by\n  cases h\n  show (\u2200 (x : \u03b1), (fun _ => \u03b2) x) = _\n  rw [funext h']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CongrExclamation.lean", "context": {"open": ["Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b1' : Sort u\n\u03b2 \u03b2' : Sort v\nh : \u03b1 = \u03b1'\nh' : \u03b1' \u2192 \u03b2 = \u03b2'\n\u22a2 (\u03b1 \u2192 \u03b2) = (\u03b1' \u2192 \u03b2')"}, {"line": "cases h", "tactic_state": "case refl\n\u03b1 : Sort u\n\u03b2 \u03b2' : Sort v\nh' : \u03b1 \u2192 \u03b2 = \u03b2'\n\u22a2 (\u03b1 \u2192 \u03b2) = (\u03b1 \u2192 \u03b2')"}, {"line": "show (\u2200 (x : \u03b1), (fun _ => \u03b2) x) = _", "tactic_state": "case refl\n\u03b1 : Sort u\n\u03b2 \u03b2' : Sort v\nh' : \u03b1 \u2192 \u03b2 = \u03b2'\n\u22a2 ((x : \u03b1) \u2192 (fun x => \u03b2) x) = (\u03b1 \u2192 \u03b2')"}, {"line": "rw [funext h']", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem heq_imp_of_eq_imp {\u03b1 : Sort*} {x y : \u03b1} {p : HEq x y \u2192 Prop}\n    (h : (he : x = y) \u2192 p (heq_of_eq he)) (he : HEq x y) : p he := by\n  cases he\n  exact h rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CongrExclamation.lean", "context": {"open": ["Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx y : \u03b1\np : HEq x y \u2192 Prop\nh : \u2200 (he : x = y), p \u22ef\nhe : HEq x y\n\u22a2 p he"}, {"line": "cases he", "tactic_state": "case refl\n\u03b1 : Sort u_1\nx : \u03b1\np : HEq x x \u2192 Prop\nh : \u2200 (he : x = x), p \u22ef\n\u22a2 p \u22ef"}, {"line": "exact h rfl", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem eq_imp_of_iff_imp {x y : Prop} {p : x = y \u2192 Prop}\n    (h : (he : x \u2194 y) \u2192 p (propext he)) (he : x = y) : p he := by\n  cases he\n  exact h Iff.rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CongrExclamation.lean", "context": {"open": ["Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Prop\np : x = y \u2192 Prop\nh : \u2200 (he : x \u2194 y), p \u22ef\nhe : x = y\n\u22a2 p he"}, {"line": "cases he", "tactic_state": "case refl\nx : Prop\np : x = x \u2192 Prop\nh : \u2200 (he : x \u2194 x), p \u22ef\n\u22a2 p \u22ef"}, {"line": "exact h Iff.rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : \u2115} (h : a = b) : (fun y : \u2115 => \u2200 z, a + a = z) = (fun x => \u2200 z, b + a = z) := by\n  congrm fun x => \u2200 w, ?_ + a = w\n  -- \u22a2 a = b\n  exact h", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CongrM.lean", "context": {"open": ["Lean Parser Tactic Elab Tactic Meta"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 (fun y => \u2200 (z : \u2115), a + a = z) = fun x => \u2200 (z : \u2115), b + a = z"}, {"line": "congrm fun x => \u2200 w, ?_ + a = w", "tactic_state": "a b : \u2115\nh : a = b\nx w : \u2115\n\u22a2 a = b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem cons_eq_imp_init {p : Prop} {a b b' : \u2115}\n    (h : b = b' \u2192 p) : Nat.pair a b = Nat.pair a b' \u2192 p := by\n  simpa [Nat.pair_eq_pair, and_imp] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/DeriveCountable.lean", "context": {"open": ["Lean Parser.Term Elab Deriving Meta"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\na b b' : \u2115\nh : b = b' \u2192 p\n\u22a2 Nat.pair a b = Nat.pair a b' \u2192 p"}, {"line": "simpa [Nat.pair_eq_pair, and_imp] using h", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem cons_eq_imp {p : Prop} {a b a' b' : \u2115}\n    (h : a = a' \u2192 b = b' \u2192 p) : Nat.pair a b = Nat.pair a' b' \u2192 p := by\n  rwa [Nat.pair_eq_pair, and_imp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/DeriveCountable.lean", "context": {"open": ["Lean Parser.Term Elab Deriving Meta"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\na b a' b' : \u2115\nh : a = a' \u2192 b = b' \u2192 p\n\u22a2 Nat.pair a b = Nat.pair a' b' \u2192 p"}, {"line": "rwa [Nat.pair_eq_pair, and_imp]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma nat_unpair_lt_2 {n : \u2115} (h : (Nat.unpair n).1 \u2260 0) : (Nat.unpair n).2 < n := by\n  obtain \u27e8\u27e8a, b\u27e9, rfl\u27e9 := Nat.pairEquiv.surjective n\n  simp only [Nat.pairEquiv_apply] at *\n  simp only [Function.uncurry_apply_pair] at *\n  simp only [Nat.unpair_pair] at *\n  unfold Nat.pair\n  have := Nat.le_mul_self a\n  have := Nat.le_mul_self b\n  split <;> omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/DeriveEncodable.lean", "context": {"open": ["Lean Parser.Term Elab Deriving Meta"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : (Nat.unpair n).1 \u2260 0\n\u22a2 (Nat.unpair n).2 < n"}, {"line": "obtain \u27e8\u27e8a, b\u27e9, rfl\u27e9 := Nat.pairEquiv.surjective n", "tactic_state": "case intro.mk\na b : \u2115\nh : (Nat.unpair (Nat.pairEquiv (a, b))).1 \u2260 0\n\u22a2 (Nat.unpair (Nat.pairEquiv (a, b))).2 < Nat.pairEquiv (a, b)"}, {"line": "simp only [Nat.pairEquiv_apply] at *", "tactic_state": "case intro.mk\na b : \u2115\nh : (Nat.unpair (Function.uncurry Nat.pair (a, b))).1 \u2260 0\n\u22a2 (Nat.unpair (Function.uncurry Nat.pair (a, b))).2 < Function.uncurry Nat.pair (a, b)"}, {"line": "simp only [Function.uncurry_apply_pair] at *", "tactic_state": "case intro.mk\na b : \u2115\nh : (Nat.unpair (Nat.pair a b)).1 \u2260 0\n\u22a2 (Nat.unpair (Nat.pair a b)).2 < Nat.pair a b"}, {"line": "simp only [Nat.unpair_pair] at *", "tactic_state": "case intro.mk\na b : \u2115\nh : a \u2260 0\n\u22a2 b < Nat.pair a b"}, {"line": "unfold Nat.pair", "tactic_state": "case intro.mk\na b : \u2115\nh : a \u2260 0\n\u22a2 b < if a < b then b * b + a else a * a + a + b"}, {"line": "have := Nat.le_mul_self a", "tactic_state": "case intro.mk\na b : \u2115\nh : a \u2260 0\nthis : a \u2264 a * a\n\u22a2 b < if a < b then b * b + a else a * a + a + b"}, {"line": "have := Nat.le_mul_self b", "tactic_state": "case intro.mk\na b : \u2115\nh : a \u2260 0\nthis\u271d : a \u2264 a * a\nthis : b \u2264 b * b\n\u22a2 b < if a < b then b * b + a else a * a + a + b"}, {"line": "split <;> omega", "tactic_state": "No Goals!"}]}
{"declaration": "example {z : Int} : \u2203 n : Nat, \u2191n = z := by\n  extract_goal  -- produces `int_eq_nat`\n  apply int_eq_nat  -- works", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\n\u22a2 \u2203 n, \u2191n = z"}, {"line": "extract_goal  -- produces `int_eq_nat`", "tactic_state": "z : \u2124\n\u22a2 \u2203 n, \u2191n = z"}, {"line": "apply int_eq_nat  -- works", "tactic_state": "No Goals!"}]}
{"declaration": "example {z : Int} : \u2203 n : Nat, \u2191n = z := by\n  extract_goal\n  apply extracted_1", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\n\u22a2 \u2203 n, \u2191n = z"}, {"line": "extract_goal", "tactic_state": "z : \u2124\n\u22a2 \u2203 n, \u2191n = z"}, {"line": "apply extracted_1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zpow_trick {G : Type*} [Group G] (a b : G) (n m : \u2124) :\n    a * b ^ n * b ^ m = a * b ^ (n + m) := by rw [mul_assoc, \u2190 zpow_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Group.lean", "context": {"open": ["Lean", "Lean.Meta", "Lean.Parser.Tactic", "Lean.Elab.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na b : G\nn m : \u2124\n\u22a2 a * b ^ n * b ^ m = a * b ^ (n + m)"}, {"line": "rw [mul_assoc, \u2190 zpow_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zpow_trick_one {G : Type*} [Group G] (a b : G) (m : \u2124) :\n    a * b * b ^ m = a * b ^ (m + 1) := by rw [mul_assoc, mul_self_zpow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Group.lean", "context": {"open": ["Lean", "Lean.Meta", "Lean.Parser.Tactic", "Lean.Elab.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na b : G\nm : \u2124\n\u22a2 a * b * b ^ m = a * b ^ (m + 1)"}, {"line": "rw [mul_assoc, mul_self_zpow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zpow_trick_one' {G : Type*} [Group G] (a b : G) (n : \u2124) :\n    a * b ^ n * b = a * b ^ (n + 1) := by rw [mul_assoc, mul_zpow_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Group.lean", "context": {"open": ["Lean", "Lean.Meta", "Lean.Parser.Tactic", "Lean.Elab.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na b : G\nn : \u2124\n\u22a2 a * b ^ n * b = a * b ^ (n + 1)"}, {"line": "rw [mul_assoc, mul_zpow_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem const_add_term {\u03b1} [AddCommMonoid \u03b1] (k n x a a') (h : k + a = a') :\n    k + @term \u03b1 _ n x a = term n x a' := by\n  simp [h.symm, term, add_comm, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nk : ?m.2232\nn : ?m.2233 k\nx : ?m.2234 k n\na : ?m.2235 k n x\na' : ?m.2236 k n x a\nh : k + a = a'\n\u22a2 k + sorry = sorry"}, {"line": "simp [h.symm, term, add_comm, add_assoc]", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nk : ?m.2232\nn : ?m.2233 k\nx : ?m.2234 k n\na : ?m.2235 k n x\na' : ?m.2236 k n x a\nh : k + a = a'\n\u22a2 k + sorry () = sorry ()"}]}
{"declaration": "theorem const_add_termg {\u03b1} [AddCommGroup \u03b1] (k n x a a') (h : k + a = a') :\n    k + @termg \u03b1 _ n x a = termg n x a' := by\n  simp [h.symm, termg, add_comm, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nk : ?m.2232\nn : ?m.2233 k\nx : ?m.2234 k n\na : ?m.2235 k n x\na' : ?m.2236 k n x a\nh : k + a = a'\n\u22a2 k + sorry = sorry"}, {"line": "simp [h.symm, termg, add_comm, add_assoc]", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nk : ?m.2232\nn : ?m.2233 k\nx : ?m.2234 k n\na : ?m.2235 k n x\na' : ?m.2236 k n x a\nh : k + a = a'\n\u22a2 k + sorry () = sorry ()"}]}
{"declaration": "theorem term_add_const {\u03b1} [AddCommMonoid \u03b1] (n x a k a') (h : a + k = a') :\n    @term \u03b1 _ n x a + k = term n x a' := by\n  simp [h.symm, term, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nn : ?m.2232\nx : ?m.2233 n\na : ?m.2234 n x\nk : ?m.2235 n x a\na' : ?m.2236 n x a k\nh : a + k = a'\n\u22a2 sorry + k = sorry"}, {"line": "simp [h.symm, term, add_assoc]", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nn : ?m.2232\nx : ?m.2233 n\na : ?m.2234 n x\nk : ?m.2235 n x a\na' : ?m.2236 n x a k\nh : a + k = a'\n\u22a2 sorry () + k = sorry ()"}]}
{"declaration": "theorem term_add_constg {\u03b1} [AddCommGroup \u03b1] (n x a k a') (h : a + k = a') :\n    @termg \u03b1 _ n x a + k = termg n x a' := by\n  simp [h.symm, termg, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nn : ?m.2232\nx : ?m.2233 n\na : ?m.2234 n x\nk : ?m.2235 n x a\na' : ?m.2236 n x a k\nh : a + k = a'\n\u22a2 sorry + k = sorry"}, {"line": "simp [h.symm, termg, add_assoc]", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nn : ?m.2232\nx : ?m.2233 n\na : ?m.2234 n x\nk : ?m.2235 n x a\na' : ?m.2236 n x a k\nh : a + k = a'\n\u22a2 sorry () + k = sorry ()"}]}
{"declaration": "theorem term_add_term {\u03b1} [AddCommMonoid \u03b1] (n\u2081 x a\u2081 n\u2082 a\u2082 n' a') (h\u2081 : n\u2081 + n\u2082 = n')\n    (h\u2082 : a\u2081 + a\u2082 = a') : @term \u03b1 _ n\u2081 x a\u2081 + @term \u03b1 _ n\u2082 x a\u2082 = term n' x a' := by\n  simp [h\u2081.symm, h\u2082.symm, term, add_nsmul, add_assoc, add_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nn\u2081 : ?m.3341\nx : ?m.3342 n\u2081\na\u2081 : ?m.3343 n\u2081 x\nn\u2082 : ?m.3344 n\u2081 x a\u2081\na\u2082 : ?m.3345 n\u2081 x a\u2081 n\u2082\nn' : ?m.3346 n\u2081 x a\u2081 n\u2082 a\u2082\na' : ?m.3347 n\u2081 x a\u2081 n\u2082 a\u2082 n'\nh\u2081 : n\u2081 + n\u2082 = n'\nh\u2082 : a\u2081 + a\u2082 = a'\n\u22a2 sorry + sorry = sorry"}, {"line": "simp [h\u2081.symm, h\u2082.symm, term, add_nsmul, add_assoc, add_left_comm]", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nn\u2081 : ?m.3341\nx : ?m.3342 n\u2081\na\u2081 : ?m.3343 n\u2081 x\nn\u2082 : ?m.3344 n\u2081 x a\u2081\na\u2082 : ?m.3345 n\u2081 x a\u2081 n\u2082\nn' : ?m.3346 n\u2081 x a\u2081 n\u2082 a\u2082\na' : ?m.3347 n\u2081 x a\u2081 n\u2082 a\u2082 n'\nh\u2081 : n\u2081 + n\u2082 = n'\nh\u2082 : a\u2081 + a\u2082 = a'\n\u22a2 sorry () + sorry () = sorry ()"}]}
{"declaration": "theorem zero_term {\u03b1} [AddCommMonoid \u03b1] (x a) : @term \u03b1 _ 0 x a = a := by\n  simp [term, zero_nsmul, one_nsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nx : ?m.444\na : ?m.445 x\n\u22a2 sorry = a"}, {"line": "simp [term, zero_nsmul, one_nsmul]", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nx : ?m.444\na : ?m.445 x\n\u22a2 sorry () = a"}]}
{"declaration": "theorem zero_termg {\u03b1} [AddCommGroup \u03b1] (x a) : @termg \u03b1 _ 0 x a = a := by\n  simp [termg, zero_zsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nx : ?m.444\na : ?m.445 x\n\u22a2 sorry = a"}, {"line": "simp [termg, zero_zsmul]", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nx : ?m.444\na : ?m.445 x\n\u22a2 sorry () = a"}]}
{"declaration": "theorem zero_smul {\u03b1} [AddCommMonoid \u03b1] (c) : smul c (0 : \u03b1) = 0 := by\n  simp [smul, nsmul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsmul : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nc : ?m.687\n\u22a2 sorry = 0"}, {"line": "simp [smul, nsmul_zero]", "tactic_state": "x\u271d : Sort u_1\nsmul : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nc : ?m.687\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem zero_smulg {\u03b1} [AddCommGroup \u03b1] (c) : smulg c (0 : \u03b1) = 0 := by\n  simp [smulg, zsmul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsmulg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nc : ?m.687\n\u22a2 sorry = 0"}, {"line": "simp [smulg, zsmul_zero]", "tactic_state": "x\u271d : Sort u_1\nsmulg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nc : ?m.687\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem term_smul {\u03b1} [AddCommMonoid \u03b1] (c n x a n' a')\n    (h\u2081 : c * n = n') (h\u2082 : smul c a = a') :\n    smul c (@term \u03b1 _ n x a) = term n' x a' := by\n  simp [h\u2082.symm, h\u2081.symm, term, smul, nsmul_add, mul_nsmul']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nsmul : x\u271d\u00b9\nx\u271d : Sort u_2\nterm : x\u271d\n\u03b1 : Type u_3\ninst\u271d : AddCommMonoid \u03b1\nc : ?m.5168\nn : ?m.5169 c\nx : ?m.5170 c n\na : ?m.5171 c n x\nn' : ?m.5172 c n x a\na' : ?m.5173 c n x a n'\nh\u2081 : c * n = n'\nh\u2082 : sorry = a'\n\u22a2 sorry = sorry"}, {"line": "simp [h\u2082.symm, h\u2081.symm, term, smul, nsmul_add, mul_nsmul']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem term_smulg {\u03b1} [AddCommGroup \u03b1] (c n x a n' a')\n    (h\u2081 : c * n = n') (h\u2082 : smulg c a = a') :\n    smulg c (@termg \u03b1 _ n x a) = termg n' x a' := by\n  simp [h\u2082.symm, h\u2081.symm, termg, smulg, zsmul_add, mul_zsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nsmulg : x\u271d\u00b9\nx\u271d : Sort u_2\ntermg : x\u271d\n\u03b1 : Type u_3\ninst\u271d : AddCommGroup \u03b1\nc : ?m.5184\nn : ?m.5185 c\nx : ?m.5186 c n\na : ?m.5187 c n x\nn' : ?m.5188 c n x a\na' : ?m.5189 c n x a n'\nh\u2081 : c * n = n'\nh\u2082 : sorry = a'\n\u22a2 sorry = sorry"}, {"line": "simp [h\u2082.symm, h\u2081.symm, termg, smulg, zsmul_add, mul_zsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem term_atom {\u03b1} [AddCommMonoid \u03b1] (x : \u03b1) : x = term 1 x 0 := by simp [term]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nx : \u03b1\n\u22a2 x = sorry"}, {"line": "simp [term]", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nx : \u03b1\n\u22a2 x = sorry ()"}]}
{"declaration": "theorem term_atomg {\u03b1} [AddCommGroup \u03b1] (x : \u03b1) : x = termg 1 x 0 := by simp [termg]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\n\u22a2 x = sorry"}, {"line": "simp [termg]", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\n\u22a2 x = sorry ()"}]}
{"declaration": "theorem term_atom_pf {\u03b1} [AddCommMonoid \u03b1] (x x' : \u03b1) (h : x = x') : x = term 1 x' 0 := by\n  simp [term, h]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nx x' : \u03b1\nh : x = x'\n\u22a2 x = sorry"}, {"line": "simp [term, h]", "tactic_state": "x\u271d : Sort u_1\nterm : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nx x' : \u03b1\nh : x = x'\n\u22a2 x' = sorry ()"}]}
{"declaration": "theorem term_atom_pfg {\u03b1} [AddCommGroup \u03b1] (x x' : \u03b1) (h : x = x') : x = termg 1 x' 0 := by\n  simp [termg, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nx x' : \u03b1\nh : x = x'\n\u22a2 x = sorry"}, {"line": "simp [termg, h]", "tactic_state": "x\u271d : Sort u_1\ntermg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nx x' : \u03b1\nh : x = x'\n\u22a2 x' = sorry ()"}]}
{"declaration": "theorem unfold_sub {\u03b1} [SubtractionMonoid \u03b1] (a b c : \u03b1) (h : a + -b = c) : a - b = c := by\n  rw [sub_eq_add_neg]\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : SubtractionMonoid \u03b1\na b c : \u03b1\nh : a + -b = c\n\u22a2 a - b = c"}, {"line": "rw [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : SubtractionMonoid \u03b1\na b c : \u03b1\nh : a + -b = c\n\u22a2 a + -b = c"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subst_into_smul {\u03b1} [AddCommMonoid \u03b1]\n    (l r tl tr t) (prl : l = tl) (prr : r = tr)\n    (prt : @smul \u03b1 _ tl tr = t) : smul l r = t := by simp [prl, prr, prt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsmul : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\nl : ?m.897\nr : ?m.898 l\ntl : ?m.897\ntr : ?m.898 l\nt : ?m.899 l r tl tr\nprl : l = tl\nprr : r = tr\nprt : sorry = t\n\u22a2 sorry = t"}, {"line": "simp [prl, prr, prt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subst_into_smulg {\u03b1} [AddCommGroup \u03b1]\n    (l r tl tr t) (prl : l = tl) (prr : r = tr)\n    (prt : @smulg \u03b1 _ tl tr = t) : smulg l r = t := by simp [prl, prr, prt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsmulg : x\u271d\n\u03b1 : Type u_2\ninst\u271d : AddCommGroup \u03b1\nl : ?m.897\nr : ?m.898 l\ntl : ?m.897\ntr : ?m.898 l\nt : ?m.899 l r tl tr\nprl : l = tl\nprr : r = tr\nprt : sorry = t\n\u22a2 sorry = t"}, {"line": "simp [prl, prr, prt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subst_into_smul_upcast {\u03b1} [AddCommGroup \u03b1]\n    (l r tl zl tr t) (prl\u2081 : l = tl) (prl\u2082 : \u2191tl = zl) (prr : r = tr)\n    (prt : @smulg \u03b1 _ zl tr = t) : smul l r = t := by\n  simp [\u2190 prt, prl\u2081, \u2190 prl\u2082, prr, smul, smulg, natCast_zsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nsmulg : x\u271d\u00b9\nx\u271d : Sort u_2\nsmul : x\u271d\n\u03b1 : Type u_3\ninst\u271d : AddCommGroup \u03b1\nl : ?m.1383\nr : ?m.1384 l\ntl zl : ?m.1383\ntr : ?m.1384 l\nt : ?m.1385 l r tl zl tr\nprl\u2081 : l = tl\nprl\u2082 : tl = zl\nprr : r = tr\nprt : sorry = t\n\u22a2 sorry = t"}, {"line": "simp [\u2190 prt, prl\u2081, \u2190 prl\u2082, prr, smul, smulg, natCast_zsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subst_into_add {\u03b1} [AddCommMonoid \u03b1] (l r tl tr t)\n    (prl : (l : \u03b1) = tl) (prr : r = tr) (prt : tl + tr = t) : l + r = t := by\n  rw [prl]\n  rw [prr]\n  rw [prt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\nl r tl tr t : \u03b1\nprl : l = tl\nprr : r = tr\nprt : tl + tr = t\n\u22a2 l + r = t"}, {"line": "rw [prl]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\nl r tl tr t : \u03b1\nprl : l = tl\nprr : r = tr\nprt : tl + tr = t\n\u22a2 tl + r = t"}, {"line": "rw [prr]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommMonoid \u03b1\nl r tl tr t : \u03b1\nprl : l = tl\nprr : r = tr\nprt : tl + tr = t\n\u22a2 tl + tr = t"}, {"line": "rw [prt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subst_into_addg {\u03b1} [AddCommGroup \u03b1] (l r tl tr t)\n    (prl : (l : \u03b1) = tl) (prr : r = tr) (prt : tl + tr = t) : l + r = t := by\n  rw [prl]\n  rw [prr]\n  rw [prt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\nl r tl tr t : \u03b1\nprl : l = tl\nprr : r = tr\nprt : tl + tr = t\n\u22a2 l + r = t"}, {"line": "rw [prl]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\nl r tl tr t : \u03b1\nprl : l = tl\nprr : r = tr\nprt : tl + tr = t\n\u22a2 tl + r = t"}, {"line": "rw [prr]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\nl r tl tr t : \u03b1\nprl : l = tl\nprr : r = tr\nprt : tl + tr = t\n\u22a2 tl + tr = t"}, {"line": "rw [prt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subst_into_negg {\u03b1} [AddCommGroup \u03b1] (a ta t : \u03b1)\n    (pra : a = ta) (prt : -ta = t) : -a = t := by\n  simp [pra, prt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Abel.lean", "context": {"open": ["Lean Elab Meta Tactic Qq", "NormalExpr"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\na ta t : \u03b1\npra : a = ta\nprt : -ta = t\n\u22a2 -a = t"}, {"line": "simp [pra, prt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Subtype.exists_pi_extension {\u03b9 : Sort*} {\u03b1 : \u03b9 \u2192 Sort*} [ne : \u2200 i, Nonempty (\u03b1 i)]\n    {p : \u03b9 \u2192 Prop} (f : \u2200 i : Subtype p, \u03b1 i) :\n    \u2203 g : \u2200 i : \u03b9, \u03b1 i, (fun i : Subtype p => g i) = f := by\n  haveI : DecidablePred p := fun i \u21a6 Classical.propDecidable (p i)\n  exact \u27e8fun i => if hi : p i then f \u27e8i, hi\u27e9 else Classical.choice (ne i),\n    funext fun i \u21a6 dif_pos i.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\n\u03b1 : \u03b9 \u2192 Sort u_2\nne : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\np : \u03b9 \u2192 Prop\nf : (i : Subtype p) \u2192 \u03b1 \u2191i\n\u22a2 \u2203 g, (fun i => g \u2191i) = f"}, {"line": "haveI : DecidablePred p := fun i \u21a6 Classical.propDecidable (p i)", "tactic_state": "\u03b9 : Sort u_1\n\u03b1 : \u03b9 \u2192 Sort u_2\nne : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\np : \u03b9 \u2192 Prop\nf : (i : Subtype p) \u2192 \u03b1 \u2191i\nthis : DecidablePred p\n\u22a2 \u2203 g, (fun i => g \u2191i) = f"}, {"line": "exact \u27e8fun i => if hi : p i then f \u27e8i, hi\u27e9 else Classical.choice (ne i),\n    funext fun i \u21a6 dif_pos i.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y z : \u211d) (ha : x + 2*y - z = 4) (hb : 2*x + y + z = -2)\n    (hc : x + 2*y + z = 2) :\n    -3*x - 3*y - 4*z = 2 := by\n  linear_combination' ha - hb - 2*hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/LinearCombination'.lean", "context": {"open": ["Lean", "Elab Meta Term"], "variables": ["{\u03b1 : Type*} {a a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1\nx y z : \u211d\nha : x + 2 * y - z = 4\nhb : 2 * x + y + z = -2\nhc : x + 2 * y + z = 2\n\u22a2 -3 * x - 3 * y - 4 * z = 2"}, {"line": "linear_combination' ha - hb - 2*hc", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y : \u211a) (h1 : x + y = 3) (h2 : 3*x = 7) :\n    x*x*y + y*x*y + 6*x = 3*x*y + 14 := by\n  linear_combination' x*y*h1 + 2*h2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/LinearCombination'.lean", "context": {"open": ["Lean", "Elab Meta Term"], "variables": ["{\u03b1 : Type*} {a a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1\nx y : \u211a\nh1 : x + y = 3\nh2 : 3 * x = 7\n\u22a2 x * x * y + y * x * y + 6 * x = 3 * x * y + 14"}, {"line": "linear_combination' x*y*h1 + 2*h2", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y : \u2124) (h1 : x = -3) (h2 : y = 10) : 2*x = -6 := by\n  linear_combination' (norm := skip) 2*h1\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/LinearCombination'.lean", "context": {"open": ["Lean", "Elab Meta Term"], "variables": ["{\u03b1 : Type*} {a a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1\nx y : \u2124\nh1 : x = -3\nh2 : y = 10\n\u22a2 2 * x = -6"}, {"line": "linear_combination' (norm := skip) 2*h1", "tactic_state": "case a\n\u03b1 : Type u_1\na a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1\nx y : \u2124\nh1 : x = -3\nh2 : y = 10\n\u22a2 2 * x - -6 - (2 * x - 2 * -3) = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem atom_eq_eval [AddMonoid M] (x : M) : x = NF.eval [(1, x)] := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Module.lean", "context": {"open": ["Lean hiding Module", "Meta Elab Qq Mathlib.Tactic List"], "variables": ["{S : Type*} {R : Type*} {M : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d : AddMonoid M\nx : M\n\u22a2 x = sorry"}, {"line": "simp [eval]", "tactic_state": "M : Type u_3\ninst\u271d : AddMonoid M\nx : M\n\u22a2 x = sorry ()"}]}
{"declaration": "theorem zero_sub_eq_eval [AddCommGroup M] [Ring R] [Module R M] (l : NF R M) :\n    0 - l.eval = (-l).eval := by\n  simp [eval_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Module.lean", "context": {"open": ["Lean hiding Module", "Meta Elab Qq Mathlib.Tactic List"], "variables": ["{S : Type*} {R : Type*} {M : Type*}", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nM : Type u_3\nx\u271d : Sort u_4\nNF : x\u271d\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Ring R\ninst\u271d : Module R M\nl : sorry\n\u22a2 0 - sorry = sorry"}, {"line": "simp [eval_neg]", "tactic_state": "R : Type u_2\nM : Type u_3\nx\u271d : Sort u_4\nNF : x\u271d\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Ring R\ninst\u271d : Module R M\nl : sorry\n\u22a2 0 = sorry ()"}]}
{"declaration": "example (a b c : Nat) : (a + b) + c = (b + a) + c := by\n  nth_rewrite 2 [Nat.add_comm] -- \u22a2 (b + a) + c = (b + a) + c", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NthRewrite.lean", "context": {"open": ["Lean Elab Tactic Meta Parser.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 a + b + c = b + a + c"}, {"line": "nth_rewrite 2 [Nat.add_comm] -- \u22a2 (b + a) + c = (b + a) + c", "tactic_state": "a b c : \u2115\n\u22a2 b + a + c = b + a + c"}]}
{"declaration": "example (h : a = a + b) : a + a + a + a + a = 0 := by\n  nth_rewrite 3 [h, h]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NthRewrite.lean", "context": {"open": ["Lean Elab Tactic Meta Parser.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = a + b\n\u22a2 a + a + a + a + a = 0"}, {"line": "nth_rewrite 3 [h, h]", "tactic_state": "a b : \u2115\nh : a = a + b\n\u22a2 a + a + (a + b + b) + a + a = 0"}]}
{"declaration": "example (a b c : Nat) : (a + b) + c = (b + a) + c := by\n  nth_rewrite 2 [Nat.add_comm] -- \u22a2 (b + a) + c = (b + a) + c", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NthRewrite.lean", "context": {"open": ["Lean Elab Tactic Meta Parser.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 a + b + c = b + a + c"}, {"line": "nth_rewrite 2 [Nat.add_comm] -- \u22a2 (b + a) + c = (b + a) + c", "tactic_state": "a b c : \u2115\n\u22a2 b + a + c = b + a + c"}]}
{"declaration": "example (h : a = a + b) : a + a + a + a + a = 0 := by\n  nth_rw 3 [h, h]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NthRewrite.lean", "context": {"open": ["Lean Elab Tactic Meta Parser.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = a + b\n\u22a2 a + a + a + a + a = 0"}, {"line": "nth_rw 3 [h, h]", "tactic_state": "a b : \u2115\nh : a = a + b\n\u22a2 a + a + (a + b + b) + a + a = 0"}]}
{"declaration": "theorem not_nonempty_eq (s : Set \u03b2) : (\u00ac s.Nonempty) = (s = \u2205) := by\n  have A : \u2200 (x : \u03b2), \u00ac(x \u2208 (\u2205 : Set \u03b2)) := fun x \u21a6 id\n  simp only [Set.Nonempty]\n  simp only [not_exists]\n  simp only [eq_iff_iff]\n  exact \u27e8fun h \u21a6 Set.ext (fun x \u21a6 by simp only [h x, false_iff, A]), fun h \u21a6 by rwa [h]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Push.lean", "context": {"open": ["Lean Meta Elab.Tactic Parser.Tactic"], "variables": ["(p q : Prop) {\u03b1 : Sort*} {\u03b2 : Type*} (s : \u03b1 \u2192 Prop)", "[LinearOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b2\n\u22a2 (\u00acs.Nonempty) = (s = \u2205)"}, {"line": "have A : \u2200 (x : \u03b2), \u00ac(x \u2208 (\u2205 : Set \u03b2)) := fun x \u21a6 id", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b2\nA : \u2200 (x : \u03b2), x \u2209 \u2205\n\u22a2 (\u00acs.Nonempty) = (s = \u2205)"}, {"line": "simp only [Set.Nonempty]", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b2\nA : \u2200 (x : \u03b2), x \u2209 \u2205\n\u22a2 (\u00ac\u2203 x, x \u2208 s) = (s = \u2205)"}, {"line": "simp only [not_exists]", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b2\nA : \u2200 (x : \u03b2), x \u2209 \u2205\n\u22a2 (\u2200 (x : \u03b2), x \u2209 s) = (s = \u2205)"}, {"line": "simp only [eq_iff_iff]", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b2\nA : \u2200 (x : \u03b2), x \u2209 \u2205\n\u22a2 (\u2200 (x : \u03b2), x \u2209 s) \u2194 s = \u2205"}, {"line": "exact \u27e8fun h \u21a6 Set.ext (fun x \u21a6 by simp only [h x, false_iff, A]), fun h \u21a6 by rwa [h]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_inj (m n : PNat) : m = n \u2194 (m : \u2115) = (n : \u2115) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/PNatToNat.lean", "context": {"open": ["private getElimNameInfo generalizeTargets generalizeVars from Lean.Elab.Tactic.Induction", "Lean Meta Elab Tactic Qq Mathlib.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115+\n\u22a2 m = n \u2194 \u2191m = \u2191n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_le_coe (m n : PNat) : m \u2264 n \u2194 (m : \u2115) \u2264 (n : \u2115) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/PNatToNat.lean", "context": {"open": ["private getElimNameInfo generalizeTargets generalizeVars from Lean.Elab.Tactic.Induction", "Lean Meta Elab Tactic Qq Mathlib.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115+\n\u22a2 m \u2264 n \u2194 \u2191m \u2264 \u2191n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_lt_coe (m n : PNat) : m < n \u2194 (m : \u2115) < (n : \u2115) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/PNatToNat.lean", "context": {"open": ["private getElimNameInfo generalizeTargets generalizeVars from Lean.Elab.Tactic.Induction", "Lean Meta Elab Tactic Qq Mathlib.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115+\n\u22a2 m < n \u2194 \u2191m < \u2191n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma and_imp_left_of_imp_imp {p q r : Prop} (h : r \u2192 p \u2192 q) : r \u2227 p \u2192 r \u2227 q := by tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Peel.lean", "context": {"open": ["Lean Expr Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\nh : r \u2192 p \u2192 q\n\u22a2 r \u2227 p \u2192 r \u2227 q"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u2124) (h : a / b = c) (hab : b \u2223 a) (hb : b \u2260 0) : a = c * b := by\n  qify [hab] at h hb \u22a2\n  exact (div_eq_iff hb).1 h", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Qify.lean", "context": {"open": ["Lean", "Lean.Meta", "Lean.Parser.Tactic", "Lean.Elab.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2124\nh : a / b = c\nhab : b \u2223 a\nhb : b \u2260 0\n\u22a2 a = c * b"}, {"line": "qify [hab] at h hb \u22a2", "tactic_state": "a b c : \u2124\nhab : b \u2223 a\nh : \u2191a / \u2191b = \u2191c\nhb : \u2191b \u2260 0\n\u22a2 \u2191a = \u2191c * \u2191b"}, {"line": "exact (div_eq_iff hb).1 h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u2115) (h : a - b < c) (hab : b \u2264 a) : a < b + c := by\n  rify [hab] at h \u22a2\n  linarith", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Rify.lean", "context": {"open": ["Lean", "Lean.Meta", "Lean.Parser.Tactic", "Lean.Elab.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a - b < c\nhab : b \u2264 a\n\u22a2 a < b + c"}, {"line": "rify [hab] at h \u22a2", "tactic_state": "a b c : \u2115\nhab : b \u2264 a\nh : \u2191a - \u2191b < \u2191c\n\u22a2 \u2191a < \u2191b + \u2191c"}, {"line": "linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_subst {\u03b1} [Ring \u03b1] {n e1 e2 t1 t2 : \u03b1} (h1 : n * e1 = t1) (h2 : n * e2 = t2) :\n    n * (e1 + e2) = t1 + t2 := by simp [left_distrib, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CancelDenoms/Core.lean", "context": {"open": ["Lean Parser Tactic Mathlib Meta NormNum Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\nn e1 e2 t1 t2 : \u03b1\nh1 : n * e1 = t1\nh2 : n * e2 = t2\n\u22a2 n * (e1 + e2) = t1 + t2"}, {"line": "simp [left_distrib, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_subst {\u03b1} [Ring \u03b1] {n e1 e2 t1 t2 : \u03b1} (h1 : n * e1 = t1) (h2 : n * e2 = t2) :\n    n * (e1 - e2) = t1 - t2 := by simp [left_distrib, *, sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CancelDenoms/Core.lean", "context": {"open": ["Lean Parser Tactic Mathlib Meta NormNum Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\nn e1 e2 t1 t2 : \u03b1\nh1 : n * e1 = t1\nh2 : n * e2 = t2\n\u22a2 n * (e1 - e2) = t1 - t2"}, {"line": "simp [left_distrib, *, sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\nn e1 e2 t1 t2 : \u03b1\nh1 : n * e1 = t1\nh2 : n * e2 = t2\n\u22a2 t1 + n * -e2 = t1 + -t2"}]}
{"declaration": "lemma insert_id_lhs {C : Type*} [Category C] {X Y : C} (f g : X \u27f6 Y) (w : f \u226b \ud835\udfd9 _ = g) :\n    f = g := by\n  simpa using w\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory FreeMonoidalCategory", "scoped MonoidalCategory", "Lean Meta Elab Tactic", "Mathlib.Tactic.BicategoryCoherence"], "variables": ["{C : Type u} [Category.{v} C]", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nX Y : C\nf g : X \u27f6 Y\nw : CategoryStruct.comp f (CategoryStruct.id Y) = g\n\u22a2 f = g"}, {"line": "simpa using w", "tactic_state": "No Goals!"}]}
{"declaration": "lemma insert_id_rhs {C : Type*} [Category C] {X Y : C} (f g : X \u27f6 Y) (w : f = g \u226b \ud835\udfd9 _) :\n    f = g := by\n  simpa using w\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Coherence.lean", "context": {"open": ["CategoryTheory FreeMonoidalCategory", "scoped MonoidalCategory", "Lean Meta Elab Tactic", "Mathlib.Tactic.BicategoryCoherence"], "variables": ["{C : Type u} [Category.{v} C]", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nX Y : C\nf g : X \u27f6 Y\nw : f = CategoryStruct.comp g (CategoryStruct.id Y)\n\u22a2 f = g"}, {"line": "simpa using w", "tactic_state": "No Goals!"}]}
{"declaration": "theorem structuralIso_inv {f g : a \u27f6 b} (\u03b7 : f \u2245 g) :\n    \u03b7.symm.hom = \u03b7.inv := by\n  simp only [Iso.symm_hom]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B] {a b c : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g : a \u27f6 b\n\u03b7 : f \u2245 g\n\u22a2 \u03b7.symm.hom = \u03b7.inv"}, {"line": "simp only [Iso.symm_hom]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem structuralIsoOfExpr_comp {f g h : a \u27f6 b}\n    (\u03b7 : f \u27f6 g) (\u03b7' : f \u2245 g) (ih_\u03b7 : \u03b7'.hom = \u03b7)\n    (\u03b8 : g \u27f6 h) (\u03b8' : g \u2245 h) (ih_\u03b8 : \u03b8'.hom = \u03b8) :\n    (\u03b7' \u226a\u226b \u03b8').hom  = \u03b7 \u226b \u03b8 := by\n  simp [ih_\u03b7, ih_\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B] {a b c : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g h : a \u27f6 b\n\u03b7 : f \u27f6 g\n\u03b7' : f \u2245 g\nih_\u03b7 : \u03b7'.hom = \u03b7\n\u03b8 : g \u27f6 h\n\u03b8' : g \u2245 h\nih_\u03b8 : \u03b8'.hom = \u03b8\n\u22a2 (\u03b7' \u226a\u226b \u03b8').hom = CategoryStruct.comp \u03b7 \u03b8"}, {"line": "simp [ih_\u03b7, ih_\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem structuralIsoOfExpr_whiskerLeft (f : a \u27f6 b) {g h : b \u27f6 c}\n    (\u03b7 : g \u27f6 h) (\u03b7' : g \u2245 h) (ih_\u03b7 : \u03b7'.hom = \u03b7) :\n    (whiskerLeftIso f \u03b7').hom = f \u25c1 \u03b7 := by\n  simp [ih_\u03b7]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B] {a b c : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c : B\nf : a \u27f6 b\ng h : b \u27f6 c\n\u03b7 : g \u27f6 h\n\u03b7' : g \u2245 h\nih_\u03b7 : \u03b7'.hom = \u03b7\n\u22a2 (whiskerLeftIso f \u03b7').hom = Bicategory.whiskerLeft f \u03b7"}, {"line": "simp [ih_\u03b7]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem structuralIsoOfExpr_whiskerRight {f g : a \u27f6 b} (h : b \u27f6 c)\n    (\u03b7 : f \u27f6 g) (\u03b7' : f \u2245 g) (ih_\u03b7 : \u03b7'.hom = \u03b7) :\n    (whiskerRightIso \u03b7' h).hom = \u03b7 \u25b7 h := by\n  simp [ih_\u03b7]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B] {a b c : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c : B\nf g : a \u27f6 b\nh : b \u27f6 c\n\u03b7 : f \u27f6 g\n\u03b7' : f \u2245 g\nih_\u03b7 : \u03b7'.hom = \u03b7\n\u22a2 (whiskerRightIso \u03b7' h).hom = Bicategory.whiskerRight \u03b7 h"}, {"line": "simp [ih_\u03b7]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StructuralOfExpr_bicategoricalComp {f g h i : a \u27f6 b} [BicategoricalCoherence g h]\n    (\u03b7 : f \u27f6 g) (\u03b7' : f \u2245 g) (ih_\u03b7 : \u03b7'.hom = \u03b7) (\u03b8 : h \u27f6 i) (\u03b8' : h \u2245 i) (ih_\u03b8 : \u03b8'.hom = \u03b8) :\n    (bicategoricalIsoComp \u03b7' \u03b8').hom = \u03b7 \u2297\u226b \u03b8 := by\n  simp [ih_\u03b7, ih_\u03b8, bicategoricalIsoComp, bicategoricalComp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B] {a b c : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d\u00b9 : Bicategory B\na b : B\nf g h i : a \u27f6 b\ninst\u271d : BicategoricalCoherence g h\n\u03b7 : f \u27f6 g\n\u03b7' : f \u2245 g\nih_\u03b7 : \u03b7'.hom = \u03b7\n\u03b8 : h \u27f6 i\n\u03b8' : h \u2245 i\nih_\u03b8 : \u03b8'.hom = \u03b8\n\u22a2 (bicategoricalIsoComp \u03b7' \u03b8').hom = bicategoricalComp \u03b7 \u03b8"}, {"line": "simp [ih_\u03b7, ih_\u03b8, bicategoricalIsoComp, bicategoricalComp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalComp_nil_nil (\u03b1 : f \u2245 g) (\u03b2 : g \u2245 h) :\n    (\u03b1 \u226a\u226b \u03b2).hom = (\u03b1 \u226a\u226b \u03b2).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g h : a \u27f6 b\n\u03b1 : f \u2245 g\n\u03b2 : g \u2245 h\n\u22a2 (\u03b1 \u226a\u226b \u03b2).hom = (\u03b1 \u226a\u226b \u03b2).hom"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalComp_nil_cons (\u03b1 : f \u2245 g) (\u03b2 : g \u2245 h) (\u03b7 : h \u27f6 i) (\u03b7s : i \u27f6 j) :\n    \u03b1.hom \u226b (\u03b2.hom \u226b \u03b7 \u226b \u03b7s) = (\u03b1 \u226a\u226b \u03b2).hom \u226b \u03b7 \u226b \u03b7s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g h i j : a \u27f6 b\n\u03b1 : f \u2245 g\n\u03b2 : g \u2245 h\n\u03b7 : h \u27f6 i\n\u03b7s : i \u27f6 j\n\u22a2 CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b2.hom (CategoryStruct.comp \u03b7 \u03b7s)) =\n    CategoryStruct.comp (\u03b1 \u226a\u226b \u03b2).hom (CategoryStruct.comp \u03b7 \u03b7s)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalComp_cons (\u03b1 : f \u2245 g) (\u03b7 : g \u27f6 h) {\u03b7s : h \u27f6 i} {\u03b8 : i \u27f6 j} {\u03b9 : h \u27f6 j}\n    (e_\u03b9 : \u03b7s \u226b \u03b8 = \u03b9) :\n    (\u03b1.hom \u226b \u03b7 \u226b \u03b7s) \u226b \u03b8 = \u03b1.hom \u226b \u03b7 \u226b \u03b9 := by\n  simp [e_\u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g h i j : a \u27f6 b\n\u03b1 : f \u2245 g\n\u03b7 : g \u27f6 h\n\u03b7s : h \u27f6 i\n\u03b8 : i \u27f6 j\n\u03b9 : h \u27f6 j\ne_\u03b9 : CategoryStruct.comp \u03b7s \u03b8 = \u03b9\n\u22a2 CategoryStruct.comp (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b7s)) \u03b8 =\n    CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b9)"}, {"line": "simp [e_\u03b9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_comp\n    {\u03b7 \u03b7' : f \u27f6 g} {\u03b8 \u03b8' : g \u27f6 h} {\u03b9 : f \u27f6 h}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : \u03b8 = \u03b8') (e_\u03b7\u03b8 : \u03b7' \u226b \u03b8' = \u03b9) :\n    \u03b7 \u226b \u03b8 = \u03b9 := by\n  simp [e_\u03b7, e_\u03b8, e_\u03b7\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g h : a \u27f6 b\n\u03b7 \u03b7' : f \u27f6 g\n\u03b8 \u03b8' : g \u27f6 h\n\u03b9 : f \u27f6 h\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : \u03b8 = \u03b8'\ne_\u03b7\u03b8 : CategoryStruct.comp \u03b7' \u03b8' = \u03b9\n\u22a2 CategoryStruct.comp \u03b7 \u03b8 = \u03b9"}, {"line": "simp [e_\u03b7, e_\u03b8, e_\u03b7\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_of (\u03b7 : f \u27f6 g) :\n    \u03b7 = (Iso.refl _).hom \u226b \u03b7 \u226b (Iso.refl _).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g : a \u27f6 b\n\u03b7 : f \u27f6 g\n\u22a2 \u03b7 = CategoryStruct.comp (Iso.refl f).hom (CategoryStruct.comp \u03b7 (Iso.refl g).hom)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_monoidalComp\n    {\u03b7 \u03b7' : f \u27f6 g} {\u03b1 : g \u2245 h} {\u03b8 \u03b8' : h \u27f6 i} {\u03b1\u03b8 : g \u27f6 i} {\u03b7\u03b1\u03b8 : f \u27f6 i}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : \u03b8 = \u03b8') (e_\u03b1\u03b8 : \u03b1.hom \u226b \u03b8' = \u03b1\u03b8) (e_\u03b7\u03b1\u03b8 : \u03b7' \u226b \u03b1\u03b8 = \u03b7\u03b1\u03b8) :\n    \u03b7 \u226b \u03b1.hom \u226b \u03b8 = \u03b7\u03b1\u03b8 := by\n  simp [e_\u03b7, e_\u03b8, e_\u03b1\u03b8, e_\u03b7\u03b1\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g h i : a \u27f6 b\n\u03b7 \u03b7' : f \u27f6 g\n\u03b1 : g \u2245 h\n\u03b8 \u03b8' : h \u27f6 i\n\u03b1\u03b8 : g \u27f6 i\n\u03b7\u03b1\u03b8 : f \u27f6 i\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : \u03b8 = \u03b8'\ne_\u03b1\u03b8 : CategoryStruct.comp \u03b1.hom \u03b8' = \u03b1\u03b8\ne_\u03b7\u03b1\u03b8 : CategoryStruct.comp \u03b7' \u03b1\u03b8 = \u03b7\u03b1\u03b8\n\u22a2 CategoryStruct.comp \u03b7 (CategoryStruct.comp \u03b1.hom \u03b8) = \u03b7\u03b1\u03b8"}, {"line": "simp [e_\u03b7, e_\u03b8, e_\u03b1\u03b8, e_\u03b7\u03b1\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerLeft_nil (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b1 : g \u2245 h) :\n    (whiskerLeftIso f \u03b1).hom = (whiskerLeftIso f \u03b1).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c : B\nf : a \u27f6 b\ng h : b \u27f6 c\n\u03b1 : g \u2245 h\n\u22a2 (whiskerLeftIso f \u03b1).hom = (whiskerLeftIso f \u03b1).hom"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerLeft_of_cons\n    {f : a \u27f6 b} {g h i j : b \u27f6 c}\n    (\u03b1 : g \u2245 h) (\u03b7 : h \u27f6 i) {\u03b7s : i \u27f6 j} {\u03b8 : f \u226b i \u27f6 f \u226b j} (e_\u03b8 : f \u25c1 \u03b7s = \u03b8) :\n    f \u25c1 (\u03b1.hom \u226b \u03b7 \u226b \u03b7s) = (whiskerLeftIso f \u03b1).hom \u226b f \u25c1 \u03b7 \u226b \u03b8 := by\n  simp [e_\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c : B\nf : a \u27f6 b\ng h i j : b \u27f6 c\n\u03b1 : g \u2245 h\n\u03b7 : h \u27f6 i\n\u03b7s : i \u27f6 j\n\u03b8 : CategoryStruct.comp f i \u27f6 CategoryStruct.comp f j\ne_\u03b8 : Bicategory.whiskerLeft f \u03b7s = \u03b8\n\u22a2 Bicategory.whiskerLeft f (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b7s)) =\n    CategoryStruct.comp (whiskerLeftIso f \u03b1).hom (CategoryStruct.comp (Bicategory.whiskerLeft f \u03b7) \u03b8)"}, {"line": "simp [e_\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerLeft_comp\n    {f : a \u27f6 b} {g : b \u27f6 c} {h i : c \u27f6 d}\n    {\u03b7 : h \u27f6 i} {\u03b7\u2081 : g \u226b h \u27f6 g \u226b i} {\u03b7\u2082 : f \u226b g \u226b h \u27f6 f \u226b g \u226b i}\n    {\u03b7\u2083 : f \u226b g \u226b h \u27f6 (f \u226b g) \u226b i} {\u03b7\u2084 : (f \u226b g) \u226b h \u27f6 (f \u226b g) \u226b i}\n    (e_\u03b7\u2081 : g \u25c1 \u03b7 = \u03b7\u2081) (e_\u03b7\u2082 : f \u25c1 \u03b7\u2081 = \u03b7\u2082)\n    (e_\u03b7\u2083 : \u03b7\u2082 \u226b (\u03b1_ _ _ _).inv = \u03b7\u2083) (e_\u03b7\u2084 : (\u03b1_ _ _ _).hom \u226b \u03b7\u2083 = \u03b7\u2084) :\n    (f \u226b g) \u25c1 \u03b7 = \u03b7\u2084 := by\n  simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7\u2083, e_\u03b7\u2084]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c d : B\nf : a \u27f6 b\ng : b \u27f6 c\nh i : c \u27f6 d\n\u03b7 : h \u27f6 i\n\u03b7\u2081 : CategoryStruct.comp g h \u27f6 CategoryStruct.comp g i\n\u03b7\u2082 : CategoryStruct.comp f (CategoryStruct.comp g h) \u27f6 CategoryStruct.comp f (CategoryStruct.comp g i)\n\u03b7\u2083 : CategoryStruct.comp f (CategoryStruct.comp g h) \u27f6 CategoryStruct.comp (CategoryStruct.comp f g) i\n\u03b7\u2084 : CategoryStruct.comp (CategoryStruct.comp f g) h \u27f6 CategoryStruct.comp (CategoryStruct.comp f g) i\ne_\u03b7\u2081 : Bicategory.whiskerLeft g \u03b7 = \u03b7\u2081\ne_\u03b7\u2082 : Bicategory.whiskerLeft f \u03b7\u2081 = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp \u03b7\u2082 (associator f g i).inv = \u03b7\u2083\ne_\u03b7\u2084 : CategoryStruct.comp (associator f g h).hom \u03b7\u2083 = \u03b7\u2084\n\u22a2 Bicategory.whiskerLeft (CategoryStruct.comp f g) \u03b7 = \u03b7\u2084"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7\u2083, e_\u03b7\u2084]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerLeft_id {\u03b7 : f \u27f6 g}\n    {\u03b7\u2081 : f \u27f6 \ud835\udfd9 a \u226b g} {\u03b7\u2082 : \ud835\udfd9 a \u226b f \u27f6 \ud835\udfd9 a \u226b g}\n    (e_\u03b7\u2081 : \u03b7 \u226b (\u03bb_ _).inv = \u03b7\u2081) (e_\u03b7\u2082 : (\u03bb_ _).hom \u226b \u03b7\u2081 = \u03b7\u2082) :\n    \ud835\udfd9 a \u25c1 \u03b7 = \u03b7\u2082 := by\n  simp [e_\u03b7\u2081, e_\u03b7\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g : a \u27f6 b\n\u03b7 : f \u27f6 g\n\u03b7\u2081 : f \u27f6 CategoryStruct.comp (CategoryStruct.id a) g\n\u03b7\u2082 : CategoryStruct.comp (CategoryStruct.id a) f \u27f6 CategoryStruct.comp (CategoryStruct.id a) g\ne_\u03b7\u2081 : CategoryStruct.comp \u03b7 (leftUnitor g).inv = \u03b7\u2081\ne_\u03b7\u2082 : CategoryStruct.comp (leftUnitor f).hom \u03b7\u2081 = \u03b7\u2082\n\u22a2 Bicategory.whiskerLeft (CategoryStruct.id a) \u03b7 = \u03b7\u2082"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_whiskerLeft\n    {f : a \u27f6 b} {g h : b \u27f6 c}\n    {\u03b7 \u03b7' : g \u27f6 h} {\u03b8 : f \u226b g \u27f6 f \u226b h}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : f \u25c1 \u03b7' = \u03b8) :\n    f \u25c1 \u03b7 = \u03b8 := by\n  simp [e_\u03b7, e_\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c : B\nf : a \u27f6 b\ng h : b \u27f6 c\n\u03b7 \u03b7' : g \u27f6 h\n\u03b8 : CategoryStruct.comp f g \u27f6 CategoryStruct.comp f h\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : Bicategory.whiskerLeft f \u03b7' = \u03b8\n\u22a2 Bicategory.whiskerLeft f \u03b7 = \u03b8"}, {"line": "simp [e_\u03b7, e_\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_whiskerRight\n    {f g : a \u27f6 b} {h : b \u27f6 c}\n    {\u03b7 \u03b7' : f \u27f6 g} {\u03b8 : f \u226b h \u27f6 g \u226b h}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : \u03b7' \u25b7 h = \u03b8) :\n    \u03b7 \u25b7 h = \u03b8 := by\n  simp [e_\u03b7, e_\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c : B\nf g : a \u27f6 b\nh : b \u27f6 c\n\u03b7 \u03b7' : f \u27f6 g\n\u03b8 : CategoryStruct.comp f h \u27f6 CategoryStruct.comp g h\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : Bicategory.whiskerRight \u03b7' h = \u03b8\n\u22a2 Bicategory.whiskerRight \u03b7 h = \u03b8"}, {"line": "simp [e_\u03b7, e_\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_nil (\u03b1 : f \u2245 g) (h : b \u27f6 c) :\n    \u03b1.hom \u25b7 h = \u03b1.hom \u25b7 h := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c : B\nf g : a \u27f6 b\n\u03b1 : f \u2245 g\nh : b \u27f6 c\n\u22a2 Bicategory.whiskerRight \u03b1.hom h = Bicategory.whiskerRight \u03b1.hom h"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRightAux_of {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) (h : b \u27f6 c) :\n    \u03b7 \u25b7 h = (Iso.refl _).hom \u226b \u03b7 \u25b7 h \u226b (Iso.refl _).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c : B\nf g : a \u27f6 b\n\u03b7 : f \u27f6 g\nh : b \u27f6 c\n\u22a2 Bicategory.whiskerRight \u03b7 h =\n    CategoryStruct.comp (Iso.refl (CategoryStruct.comp f h)).hom\n      (CategoryStruct.comp (Bicategory.whiskerRight \u03b7 h) (Iso.refl (CategoryStruct.comp g h)).hom)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_cons_of_of\n    {f g h i : a \u27f6 b} {j : b \u27f6 c}\n    {\u03b1 : f \u2245 g} {\u03b7 : g \u27f6 h} {\u03b7s : h \u27f6 i} {\u03b7s\u2081 : h \u226b j \u27f6 i \u226b j}\n    {\u03b7\u2081 : g \u226b j \u27f6 h \u226b j} {\u03b7\u2082 : g \u226b j \u27f6 i \u226b j} {\u03b7\u2083 : f \u226b j \u27f6 i \u226b j}\n    (e_\u03b7s\u2081 : \u03b7s \u25b7 j = \u03b7s\u2081) (e_\u03b7\u2081 : \u03b7 \u25b7 j = \u03b7\u2081)\n    (e_\u03b7\u2082 : \u03b7\u2081 \u226b \u03b7s\u2081 = \u03b7\u2082) (e_\u03b7\u2083 : (whiskerRightIso \u03b1 j).hom \u226b \u03b7\u2082 = \u03b7\u2083) :\n    (\u03b1.hom \u226b \u03b7 \u226b \u03b7s) \u25b7 j = \u03b7\u2083 := by\n  simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c : B\nf g h i : a \u27f6 b\nj : b \u27f6 c\n\u03b1 : f \u2245 g\n\u03b7 : g \u27f6 h\n\u03b7s : h \u27f6 i\n\u03b7s\u2081 : CategoryStruct.comp h j \u27f6 CategoryStruct.comp i j\n\u03b7\u2081 : CategoryStruct.comp g j \u27f6 CategoryStruct.comp h j\n\u03b7\u2082 : CategoryStruct.comp g j \u27f6 CategoryStruct.comp i j\n\u03b7\u2083 : CategoryStruct.comp f j \u27f6 CategoryStruct.comp i j\ne_\u03b7s\u2081 : Bicategory.whiskerRight \u03b7s j = \u03b7s\u2081\ne_\u03b7\u2081 : Bicategory.whiskerRight \u03b7 j = \u03b7\u2081\ne_\u03b7\u2082 : CategoryStruct.comp \u03b7\u2081 \u03b7s\u2081 = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp (whiskerRightIso \u03b1 j).hom \u03b7\u2082 = \u03b7\u2083\n\u22a2 Bicategory.whiskerRight (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b7s)) j = \u03b7\u2083"}, {"line": "simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_cons_whisker\n    {f : a \u27f6 b} {g : a \u27f6 c} {h i : b \u27f6 c} {j : a \u27f6 c} {k : c \u27f6 d}\n    {\u03b1 : g \u2245 f \u226b h} {\u03b7 : h \u27f6 i} {\u03b7s : f \u226b i \u27f6 j}\n    {\u03b7\u2081 : h \u226b k \u27f6 i \u226b k} {\u03b7\u2082 : f \u226b (h \u226b k) \u27f6 f \u226b (i \u226b k)} {\u03b7s\u2081 : (f \u226b i) \u226b k \u27f6 j \u226b k}\n    {\u03b7s\u2082 : f \u226b (i \u226b k) \u27f6 j \u226b k} {\u03b7\u2083 : f \u226b (h \u226b k) \u27f6 j \u226b k} {\u03b7\u2084 : (f \u226b h) \u226b k \u27f6 j \u226b k}\n    {\u03b7\u2085 : g \u226b k \u27f6 j \u226b k}\n    (e_\u03b7\u2081 : ((Iso.refl _).hom \u226b \u03b7 \u226b (Iso.refl _).hom) \u25b7 k = \u03b7\u2081) (e_\u03b7\u2082 : f \u25c1 \u03b7\u2081 = \u03b7\u2082)\n    (e_\u03b7s\u2081 : \u03b7s \u25b7 k = \u03b7s\u2081) (e_\u03b7s\u2082 : (\u03b1_ _ _ _).inv \u226b \u03b7s\u2081 = \u03b7s\u2082)\n    (e_\u03b7\u2083 : \u03b7\u2082 \u226b \u03b7s\u2082 = \u03b7\u2083) (e_\u03b7\u2084 : (\u03b1_ _ _ _).hom \u226b \u03b7\u2083 = \u03b7\u2084)\n    (e_\u03b7\u2085 : (whiskerRightIso \u03b1 k).hom \u226b \u03b7\u2084 = \u03b7\u2085) :\n    (\u03b1.hom \u226b (f \u25c1 \u03b7) \u226b \u03b7s) \u25b7 k = \u03b7\u2085 := by\n  simp at e_\u03b7\u2081 e_\u03b7\u2085\n  simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7s\u2081, e_\u03b7s\u2082, e_\u03b7\u2083, e_\u03b7\u2084, e_\u03b7\u2085]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c d : B\nf : a \u27f6 b\ng : a \u27f6 c\nh i : b \u27f6 c\nj : a \u27f6 c\nk : c \u27f6 d\n\u03b1 : g \u2245 CategoryStruct.comp f h\n\u03b7 : h \u27f6 i\n\u03b7s : CategoryStruct.comp f i \u27f6 j\n\u03b7\u2081 : CategoryStruct.comp h k \u27f6 CategoryStruct.comp i k\n\u03b7\u2082 : CategoryStruct.comp f (CategoryStruct.comp h k) \u27f6 CategoryStruct.comp f (CategoryStruct.comp i k)\n\u03b7s\u2081 : CategoryStruct.comp (CategoryStruct.comp f i) k \u27f6 CategoryStruct.comp j k\n\u03b7s\u2082 : CategoryStruct.comp f (CategoryStruct.comp i k) \u27f6 CategoryStruct.comp j k\n\u03b7\u2083 : CategoryStruct.comp f (CategoryStruct.comp h k) \u27f6 CategoryStruct.comp j k\n\u03b7\u2084 : CategoryStruct.comp (CategoryStruct.comp f h) k \u27f6 CategoryStruct.comp j k\n\u03b7\u2085 : CategoryStruct.comp g k \u27f6 CategoryStruct.comp j k\ne_\u03b7\u2081 : Bicategory.whiskerRight (CategoryStruct.comp (Iso.refl h).hom (CategoryStruct.comp \u03b7 (Iso.refl i).hom)) k = \u03b7\u2081\ne_\u03b7\u2082 : Bicategory.whiskerLeft f \u03b7\u2081 = \u03b7\u2082\ne_\u03b7s\u2081 : Bicategory.whiskerRight \u03b7s k = \u03b7s\u2081\ne_\u03b7s\u2082 : CategoryStruct.comp (associator f i k).inv \u03b7s\u2081 = \u03b7s\u2082\ne_\u03b7\u2083 : CategoryStruct.comp \u03b7\u2082 \u03b7s\u2082 = \u03b7\u2083\ne_\u03b7\u2084 : CategoryStruct.comp (associator f h k).hom \u03b7\u2083 = \u03b7\u2084\ne_\u03b7\u2085 : CategoryStruct.comp (whiskerRightIso \u03b1 k).hom \u03b7\u2084 = \u03b7\u2085\n\u22a2 Bicategory.whiskerRight (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp (Bicategory.whiskerLeft f \u03b7) \u03b7s)) k = \u03b7\u2085"}, {"line": "simp at e_\u03b7\u2081 e_\u03b7\u2085", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c d : B\nf : a \u27f6 b\ng : a \u27f6 c\nh i : b \u27f6 c\nj : a \u27f6 c\nk : c \u27f6 d\n\u03b1 : g \u2245 CategoryStruct.comp f h\n\u03b7 : h \u27f6 i\n\u03b7s : CategoryStruct.comp f i \u27f6 j\n\u03b7\u2081 : CategoryStruct.comp h k \u27f6 CategoryStruct.comp i k\n\u03b7\u2082 : CategoryStruct.comp f (CategoryStruct.comp h k) \u27f6 CategoryStruct.comp f (CategoryStruct.comp i k)\n\u03b7s\u2081 : CategoryStruct.comp (CategoryStruct.comp f i) k \u27f6 CategoryStruct.comp j k\n\u03b7s\u2082 : CategoryStruct.comp f (CategoryStruct.comp i k) \u27f6 CategoryStruct.comp j k\n\u03b7\u2083 : CategoryStruct.comp f (CategoryStruct.comp h k) \u27f6 CategoryStruct.comp j k\n\u03b7\u2084 : CategoryStruct.comp (CategoryStruct.comp f h) k \u27f6 CategoryStruct.comp j k\n\u03b7\u2085 : CategoryStruct.comp g k \u27f6 CategoryStruct.comp j k\ne_\u03b7\u2082 : Bicategory.whiskerLeft f \u03b7\u2081 = \u03b7\u2082\ne_\u03b7s\u2081 : Bicategory.whiskerRight \u03b7s k = \u03b7s\u2081\ne_\u03b7s\u2082 : CategoryStruct.comp (associator f i k).inv \u03b7s\u2081 = \u03b7s\u2082\ne_\u03b7\u2083 : CategoryStruct.comp \u03b7\u2082 \u03b7s\u2082 = \u03b7\u2083\ne_\u03b7\u2084 : CategoryStruct.comp (associator f h k).hom \u03b7\u2083 = \u03b7\u2084\ne_\u03b7\u2085 : CategoryStruct.comp (Bicategory.whiskerRight \u03b1.hom k) \u03b7\u2084 = \u03b7\u2085\ne_\u03b7\u2081 : Bicategory.whiskerRight \u03b7 k = \u03b7\u2081\n\u22a2 Bicategory.whiskerRight (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp (Bicategory.whiskerLeft f \u03b7) \u03b7s)) k = \u03b7\u2085"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7s\u2081, e_\u03b7s\u2082, e_\u03b7\u2083, e_\u03b7\u2084, e_\u03b7\u2085]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_comp\n    {f f' : a \u27f6 b} {g : b \u27f6 c} {h : c \u27f6 d}\n    {\u03b7 : f \u27f6 f'} {\u03b7\u2081 : f \u226b g \u27f6 f' \u226b g} {\u03b7\u2082 : (f \u226b g) \u226b h \u27f6 (f' \u226b g) \u226b h}\n    {\u03b7\u2083 : (f \u226b g) \u226b h \u27f6 f' \u226b (g \u226b h)} {\u03b7\u2084 : f \u226b (g \u226b h) \u27f6 f' \u226b (g \u226b h)}\n    (e_\u03b7\u2081 : \u03b7 \u25b7 g = \u03b7\u2081) (e_\u03b7\u2082 : \u03b7\u2081 \u25b7 h = \u03b7\u2082)\n    (e_\u03b7\u2083 : \u03b7\u2082 \u226b (\u03b1_ _ _ _).hom = \u03b7\u2083) (e_\u03b7\u2084 : (\u03b1_ _ _ _).inv \u226b \u03b7\u2083 = \u03b7\u2084) :\n    \u03b7 \u25b7 (g \u226b h) = \u03b7\u2084 := by\n  simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7\u2083, e_\u03b7\u2084]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b c d : B\nf f' : a \u27f6 b\ng : b \u27f6 c\nh : c \u27f6 d\n\u03b7 : f \u27f6 f'\n\u03b7\u2081 : CategoryStruct.comp f g \u27f6 CategoryStruct.comp f' g\n\u03b7\u2082 : CategoryStruct.comp (CategoryStruct.comp f g) h \u27f6 CategoryStruct.comp (CategoryStruct.comp f' g) h\n\u03b7\u2083 : CategoryStruct.comp (CategoryStruct.comp f g) h \u27f6 CategoryStruct.comp f' (CategoryStruct.comp g h)\n\u03b7\u2084 : CategoryStruct.comp f (CategoryStruct.comp g h) \u27f6 CategoryStruct.comp f' (CategoryStruct.comp g h)\ne_\u03b7\u2081 : Bicategory.whiskerRight \u03b7 g = \u03b7\u2081\ne_\u03b7\u2082 : Bicategory.whiskerRight \u03b7\u2081 h = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp \u03b7\u2082 (associator f' g h).hom = \u03b7\u2083\ne_\u03b7\u2084 : CategoryStruct.comp (associator f g h).inv \u03b7\u2083 = \u03b7\u2084\n\u22a2 Bicategory.whiskerRight \u03b7 (CategoryStruct.comp g h) = \u03b7\u2084"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7\u2083, e_\u03b7\u2084]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_id\n    {\u03b7 : f \u27f6 g} {\u03b7\u2081 : f \u27f6 g \u226b \ud835\udfd9 b} {\u03b7\u2082 : f \u226b \ud835\udfd9 b \u27f6 g \u226b \ud835\udfd9 b}\n    (e_\u03b7\u2081 : \u03b7 \u226b (\u03c1_ _).inv = \u03b7\u2081) (e_\u03b7\u2082 : (\u03c1_ _).hom \u226b \u03b7\u2081 = \u03b7\u2082) :\n    \u03b7 \u25b7 \ud835\udfd9 b = \u03b7\u2082 := by\n  simp [e_\u03b7\u2081, e_\u03b7\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g : a \u27f6 b\n\u03b7 : f \u27f6 g\n\u03b7\u2081 : f \u27f6 CategoryStruct.comp g (CategoryStruct.id b)\n\u03b7\u2082 : CategoryStruct.comp f (CategoryStruct.id b) \u27f6 CategoryStruct.comp g (CategoryStruct.id b)\ne_\u03b7\u2081 : CategoryStruct.comp \u03b7 (rightUnitor g).inv = \u03b7\u2081\ne_\u03b7\u2082 : CategoryStruct.comp (rightUnitor f).hom \u03b7\u2081 = \u03b7\u2082\n\u22a2 Bicategory.whiskerRight \u03b7 (CategoryStruct.id b) = \u03b7\u2082"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_bicategoricalComp\n    {\u03b7 \u03b7' : f \u27f6 g} {\u03b1 : g \u2245 h} {\u03b8 \u03b8' : h \u27f6 i} {\u03b1\u03b8 : g \u27f6 i} {\u03b7\u03b1\u03b8 : f \u27f6 i}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : \u03b8 = \u03b8') (e_\u03b1\u03b8 : \u03b1.hom \u226b \u03b8' = \u03b1\u03b8) (e_\u03b7\u03b1\u03b8 : \u03b7' \u226b \u03b1\u03b8 = \u03b7\u03b1\u03b8) :\n    \u03b7 \u226b \u03b1.hom \u226b \u03b8 = \u03b7\u03b1\u03b8 := by\n  simp [e_\u03b7, e_\u03b8, e_\u03b1\u03b8, e_\u03b7\u03b1\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Bicategory/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B]", "{a b c d : B}", "{f f' g g' h i j : a \u27f6 b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\ninst\u271d : Bicategory B\na b : B\nf g h i : a \u27f6 b\n\u03b7 \u03b7' : f \u27f6 g\n\u03b1 : g \u2245 h\n\u03b8 \u03b8' : h \u27f6 i\n\u03b1\u03b8 : g \u27f6 i\n\u03b7\u03b1\u03b8 : f \u27f6 i\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : \u03b8 = \u03b8'\ne_\u03b1\u03b8 : CategoryStruct.comp \u03b1.hom \u03b8' = \u03b1\u03b8\ne_\u03b7\u03b1\u03b8 : CategoryStruct.comp \u03b7' \u03b1\u03b8 = \u03b7\u03b1\u03b8\n\u22a2 CategoryStruct.comp \u03b7 (CategoryStruct.comp \u03b1.hom \u03b8) = \u03b7\u03b1\u03b8"}, {"line": "simp [e_\u03b7, e_\u03b8, e_\u03b1\u03b8, e_\u03b7\u03b1\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_eq {\u03b1 : Type _} (a b a' b' : \u03b1) (ha : a = a') (hb : b = b') (h : a' = b') : a = b := by\n  simp [h, ha, hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Coherence/Basic.lean", "context": {"open": ["Lean Meta Elab", "CategoryTheory Mathlib.Tactic.BicategoryLike"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b a' b' : \u03b1\nha : a = a'\nhb : b = b'\nh : a' = b'\n\u22a2 a = b"}, {"line": "simp [h, ha, hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_eq_of_cons {C : Type u} [CategoryStruct.{v} C]\n    {f\u2081 f\u2082 f\u2083 f\u2084 : C}\n    (\u03b1 \u03b1' : f\u2081 \u27f6 f\u2082) (\u03b7 \u03b7' : f\u2082 \u27f6 f\u2083) (\u03b7s \u03b7s' : f\u2083 \u27f6 f\u2084)\n    (e_\u03b1 : \u03b1 = \u03b1') (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b7s : \u03b7s = \u03b7s') :\n    \u03b1 \u226b \u03b7 \u226b \u03b7s = \u03b1' \u226b \u03b7' \u226b \u03b7s' := by\n  simp [e_\u03b1, e_\u03b7, e_\u03b7s]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Coherence/Basic.lean", "context": {"open": ["Lean Meta Elab", "CategoryTheory Mathlib.Tactic.BicategoryLike"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : CategoryStruct.{v, u} C\nf\u2081 f\u2082 f\u2083 f\u2084 : C\n\u03b1 \u03b1' : f\u2081 \u27f6 f\u2082\n\u03b7 \u03b7' : f\u2082 \u27f6 f\u2083\n\u03b7s \u03b7s' : f\u2083 \u27f6 f\u2084\ne_\u03b1 : \u03b1 = \u03b1'\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b7s : \u03b7s = \u03b7s'\n\u22a2 CategoryStruct.comp \u03b1 (CategoryStruct.comp \u03b7 \u03b7s) = CategoryStruct.comp \u03b1' (CategoryStruct.comp \u03b7' \u03b7s')"}, {"line": "simp [e_\u03b1, e_\u03b7, e_\u03b7s]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem structuralIsoOfExpr_comp {f g h : C}\n    (\u03b7 : f \u27f6 g) (\u03b7' : f \u2245 g) (ih_\u03b7 : \u03b7'.hom = \u03b7)\n    (\u03b8 : g \u27f6 h) (\u03b8' : g \u2245 h) (ih_\u03b8 : \u03b8'.hom = \u03b8) :\n    (\u03b7' \u226a\u226b \u03b8').hom  = \u03b7 \u226b \u03b8 := by\n  simp [ih_\u03b7, ih_\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nf g h : C\n\u03b7 : f \u27f6 g\n\u03b7' : f \u2245 g\nih_\u03b7 : \u03b7'.hom = \u03b7\n\u03b8 : g \u27f6 h\n\u03b8' : g \u2245 h\nih_\u03b8 : \u03b8'.hom = \u03b8\n\u22a2 (\u03b7' \u226a\u226b \u03b8').hom = CategoryStruct.comp \u03b7 \u03b8"}, {"line": "simp [ih_\u03b7, ih_\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StructuralOfExpr_monoidalComp {f g h i : C} [MonoidalCoherence g h]\n    (\u03b7 : f \u27f6 g) (\u03b7' : f \u2245 g) (ih_\u03b7 : \u03b7'.hom = \u03b7) (\u03b8 : h \u27f6 i) (\u03b8' : h \u2245 i) (ih_\u03b8 : \u03b8'.hom = \u03b8) :\n    (\u03b7' \u226a\u2297\u226b \u03b8').hom = \u03b7 \u2297\u226b \u03b8 := by\n  simp [ih_\u03b7, ih_\u03b8, monoidalIsoComp, monoidalComp, MonoidalCoherence.iso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nf g h i : C\ninst\u271d : MonoidalCoherence g h\n\u03b7 : f \u27f6 g\n\u03b7' : f \u2245 g\nih_\u03b7 : \u03b7'.hom = \u03b7\n\u03b8 : h \u27f6 i\n\u03b8' : h \u2245 i\nih_\u03b8 : \u03b8'.hom = \u03b8\n\u22a2 (monoidalIsoComp \u03b7' \u03b8').hom = monoidalComp \u03b7 \u03b8"}, {"line": "simp [ih_\u03b7, ih_\u03b8, monoidalIsoComp, monoidalComp, MonoidalCoherence.iso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem structuralIsoOfExpr_whiskerLeft (f : C) {g h : C}\n    (\u03b7 : g \u27f6 h) (\u03b7' : g \u2245 h) (ih_\u03b7 : \u03b7'.hom = \u03b7) :\n    (whiskerLeftIso f \u03b7').hom = f \u25c1 \u03b7 := by\n  simp [ih_\u03b7]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h : C\n\u03b7 : g \u27f6 h\n\u03b7' : g \u2245 h\nih_\u03b7 : \u03b7'.hom = \u03b7\n\u22a2 (whiskerLeftIso f \u03b7').hom = MonoidalCategoryStruct.whiskerLeft f \u03b7"}, {"line": "simp [ih_\u03b7]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem structuralIsoOfExpr_whiskerRight {f g : C} (h : C)\n    (\u03b7 : f \u27f6 g) (\u03b7' : f \u2245 g) (ih_\u03b7 : \u03b7'.hom = \u03b7) :\n    (whiskerRightIso \u03b7' h).hom = \u03b7 \u25b7 h := by\n  simp [ih_\u03b7]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h : C\n\u03b7 : f \u27f6 g\n\u03b7' : f \u2245 g\nih_\u03b7 : \u03b7'.hom = \u03b7\n\u22a2 (whiskerRightIso \u03b7' h).hom = MonoidalCategoryStruct.whiskerRight \u03b7 h"}, {"line": "simp [ih_\u03b7]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem structuralIsoOfExpr_horizontalComp {f\u2081 g\u2081 f\u2082 g\u2082 : C}\n    (\u03b7 : f\u2081 \u27f6 g\u2081) (\u03b7' : f\u2081 \u2245 g\u2081) (ih_\u03b7 : \u03b7'.hom = \u03b7)\n    (\u03b8 : f\u2082 \u27f6 g\u2082) (\u03b8' : f\u2082 \u2245 g\u2082) (ih_\u03b8 : \u03b8'.hom = \u03b8) :\n    (\u03b7' \u2297 \u03b8').hom = \u03b7 \u2297 \u03b8 := by\n  simp [ih_\u03b7, ih_\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Datatypes.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf\u2081 g\u2081 f\u2082 g\u2082 : C\n\u03b7 : f\u2081 \u27f6 g\u2081\n\u03b7' : f\u2081 \u2245 g\u2081\nih_\u03b7 : \u03b7'.hom = \u03b7\n\u03b8 : f\u2082 \u27f6 g\u2082\n\u03b8' : f\u2082 \u2245 g\u2082\nih_\u03b8 : \u03b8'.hom = \u03b8\n\u22a2 (tensorIso \u03b7' \u03b8').hom = tensorHom \u03b7 \u03b8"}, {"line": "simp [ih_\u03b7, ih_\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalComp_nil_nil {f g h : C} (\u03b1 : f \u2245 g) (\u03b2 : g \u2245 h) :\n    (\u03b1 \u226a\u226b \u03b2).hom = (\u03b1 \u226a\u226b \u03b2).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nf g h : C\n\u03b1 : f \u2245 g\n\u03b2 : g \u2245 h\n\u22a2 (\u03b1 \u226a\u226b \u03b2).hom = (\u03b1 \u226a\u226b \u03b2).hom"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalComp_nil_cons {f g h i j : C} (\u03b1 : f \u2245 g) (\u03b2 : g \u2245 h) (\u03b7 : h \u27f6 i) (\u03b7s : i \u27f6 j) :\n    \u03b1.hom \u226b (\u03b2.hom \u226b \u03b7 \u226b \u03b7s) = (\u03b1 \u226a\u226b \u03b2).hom \u226b \u03b7 \u226b \u03b7s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nf g h i j : C\n\u03b1 : f \u2245 g\n\u03b2 : g \u2245 h\n\u03b7 : h \u27f6 i\n\u03b7s : i \u27f6 j\n\u22a2 CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b2.hom (CategoryStruct.comp \u03b7 \u03b7s)) =\n    CategoryStruct.comp (\u03b1 \u226a\u226b \u03b2).hom (CategoryStruct.comp \u03b7 \u03b7s)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalComp_cons {f g h i j : C} (\u03b1 : f \u2245 g) (\u03b7 : g \u27f6 h) {\u03b7s : h \u27f6 i} {\u03b8 : i \u27f6 j} {\u03b9 : h \u27f6 j}\n    (e_\u03b9 : \u03b7s \u226b \u03b8 = \u03b9) :\n    (\u03b1.hom \u226b \u03b7 \u226b \u03b7s) \u226b \u03b8 = \u03b1.hom \u226b \u03b7 \u226b \u03b9 := by\n  simp [e_\u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nf g h i j : C\n\u03b1 : f \u2245 g\n\u03b7 : g \u27f6 h\n\u03b7s : h \u27f6 i\n\u03b8 : i \u27f6 j\n\u03b9 : h \u27f6 j\ne_\u03b9 : CategoryStruct.comp \u03b7s \u03b8 = \u03b9\n\u22a2 CategoryStruct.comp (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b7s)) \u03b8 =\n    CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b9)"}, {"line": "simp [e_\u03b9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_comp\n    {\u03b7 \u03b7' : f \u27f6 g} {\u03b8 \u03b8' : g \u27f6 h} {\u03b9 : f \u27f6 h}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : \u03b8 = \u03b8') (e_\u03b7\u03b8 : \u03b7' \u226b \u03b8' = \u03b9) :\n    \u03b7 \u226b \u03b8 = \u03b9 := by\n  simp [e_\u03b7, e_\u03b8, e_\u03b7\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nf g h : C\n\u03b7 \u03b7' : f \u27f6 g\n\u03b8 \u03b8' : g \u27f6 h\n\u03b9 : f \u27f6 h\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : \u03b8 = \u03b8'\ne_\u03b7\u03b8 : CategoryStruct.comp \u03b7' \u03b8' = \u03b9\n\u22a2 CategoryStruct.comp \u03b7 \u03b8 = \u03b9"}, {"line": "simp [e_\u03b7, e_\u03b8, e_\u03b7\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_of (\u03b7 : f \u27f6 g) :\n    \u03b7 = (Iso.refl _).hom \u226b \u03b7 \u226b (Iso.refl _).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nf g : C\n\u03b7 : f \u27f6 g\n\u22a2 \u03b7 = CategoryStruct.comp (Iso.refl f).hom (CategoryStruct.comp \u03b7 (Iso.refl g).hom)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_monoidalComp\n    {\u03b7 \u03b7' : f \u27f6 g} {\u03b1 : g \u2245 h} {\u03b8 \u03b8' : h \u27f6 i} {\u03b1\u03b8 : g \u27f6 i} {\u03b7\u03b1\u03b8 : f \u27f6 i}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : \u03b8 = \u03b8') (e_\u03b1\u03b8 : \u03b1.hom \u226b \u03b8' = \u03b1\u03b8) (e_\u03b7\u03b1\u03b8 : \u03b7' \u226b \u03b1\u03b8 = \u03b7\u03b1\u03b8) :\n    \u03b7 \u226b \u03b1.hom \u226b \u03b8 = \u03b7\u03b1\u03b8 := by\n  simp [e_\u03b7, e_\u03b8, e_\u03b1\u03b8, e_\u03b7\u03b1\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nf g h i : C\n\u03b7 \u03b7' : f \u27f6 g\n\u03b1 : g \u2245 h\n\u03b8 \u03b8' : h \u27f6 i\n\u03b1\u03b8 : g \u27f6 i\n\u03b7\u03b1\u03b8 : f \u27f6 i\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : \u03b8 = \u03b8'\ne_\u03b1\u03b8 : CategoryStruct.comp \u03b1.hom \u03b8' = \u03b1\u03b8\ne_\u03b7\u03b1\u03b8 : CategoryStruct.comp \u03b7' \u03b1\u03b8 = \u03b7\u03b1\u03b8\n\u22a2 CategoryStruct.comp \u03b7 (CategoryStruct.comp \u03b1.hom \u03b8) = \u03b7\u03b1\u03b8"}, {"line": "simp [e_\u03b7, e_\u03b8, e_\u03b1\u03b8, e_\u03b7\u03b1\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerLeft_nil (f : C) {g h : C} (\u03b1 : g \u2245 h) :\n    (whiskerLeftIso f \u03b1).hom = (whiskerLeftIso f \u03b1).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h : C\n\u03b1 : g \u2245 h\n\u22a2 (whiskerLeftIso f \u03b1).hom = (whiskerLeftIso f \u03b1).hom"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerLeft_of_cons {f g h i j : C}\n    (\u03b1 : g \u2245 h) (\u03b7 : h \u27f6 i) {\u03b7s : i \u27f6 j} {\u03b8 : f \u2297 i \u27f6 f \u2297 j} (e_\u03b8 : f \u25c1 \u03b7s = \u03b8) :\n    f \u25c1 (\u03b1.hom \u226b \u03b7 \u226b \u03b7s) = (whiskerLeftIso f \u03b1).hom \u226b f \u25c1 \u03b7 \u226b \u03b8 := by\n  simp [e_\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h i j : C\n\u03b1 : g \u2245 h\n\u03b7 : h \u27f6 i\n\u03b7s : i \u27f6 j\n\u03b8 : tensorObj f i \u27f6 tensorObj f j\ne_\u03b8 : MonoidalCategoryStruct.whiskerLeft f \u03b7s = \u03b8\n\u22a2 MonoidalCategoryStruct.whiskerLeft f (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b7s)) =\n    CategoryStruct.comp (whiskerLeftIso f \u03b1).hom (CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft f \u03b7) \u03b8)"}, {"line": "simp [e_\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerLeft_comp {f g h i : C}\n    {\u03b7 : h \u27f6 i} {\u03b7\u2081 : g \u2297 h \u27f6 g \u2297 i} {\u03b7\u2082 : f \u2297 g \u2297 h \u27f6 f \u2297 g \u2297 i}\n    {\u03b7\u2083 : f \u2297 g \u2297 h \u27f6 (f \u2297 g) \u2297 i} {\u03b7\u2084 : (f \u2297 g) \u2297 h \u27f6 (f \u2297 g) \u2297 i}\n    (e_\u03b7\u2081 : g \u25c1 \u03b7 = \u03b7\u2081) (e_\u03b7\u2082 : f \u25c1 \u03b7\u2081 = \u03b7\u2082)\n    (e_\u03b7\u2083 : \u03b7\u2082 \u226b (\u03b1_ _ _ _).inv = \u03b7\u2083) (e_\u03b7\u2084 : (\u03b1_ _ _ _).hom \u226b \u03b7\u2083 = \u03b7\u2084) :\n    (f \u2297 g) \u25c1 \u03b7 = \u03b7\u2084 := by\n  simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7\u2083, e_\u03b7\u2084]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h i : C\n\u03b7 : h \u27f6 i\n\u03b7\u2081 : tensorObj g h \u27f6 tensorObj g i\n\u03b7\u2082 : tensorObj f (tensorObj g h) \u27f6 tensorObj f (tensorObj g i)\n\u03b7\u2083 : tensorObj f (tensorObj g h) \u27f6 tensorObj (tensorObj f g) i\n\u03b7\u2084 : tensorObj (tensorObj f g) h \u27f6 tensorObj (tensorObj f g) i\ne_\u03b7\u2081 : MonoidalCategoryStruct.whiskerLeft g \u03b7 = \u03b7\u2081\ne_\u03b7\u2082 : MonoidalCategoryStruct.whiskerLeft f \u03b7\u2081 = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp \u03b7\u2082 (associator f g i).inv = \u03b7\u2083\ne_\u03b7\u2084 : CategoryStruct.comp (associator f g h).hom \u03b7\u2083 = \u03b7\u2084\n\u22a2 MonoidalCategoryStruct.whiskerLeft (tensorObj f g) \u03b7 = \u03b7\u2084"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7\u2083, e_\u03b7\u2084]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerLeft_id {f g : C} {\u03b7 : f \u27f6 g}\n    {\u03b7\u2081 : f \u27f6 \ud835\udfd9_ C \u2297 g} {\u03b7\u2082 : \ud835\udfd9_ C \u2297 f \u27f6 \ud835\udfd9_ C \u2297 g}\n    (e_\u03b7\u2081 : \u03b7 \u226b (\u03bb_ _).inv = \u03b7\u2081) (e_\u03b7\u2082 : (\u03bb_ _).hom \u226b \u03b7\u2081 = \u03b7\u2082) :\n    \ud835\udfd9_ C \u25c1 \u03b7 = \u03b7\u2082 := by\n  simp [e_\u03b7\u2081, e_\u03b7\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g : C\n\u03b7 : f \u27f6 g\n\u03b7\u2081 : f \u27f6 tensorObj (tensorUnit C) g\n\u03b7\u2082 : tensorObj (tensorUnit C) f \u27f6 tensorObj (tensorUnit C) g\ne_\u03b7\u2081 : CategoryStruct.comp \u03b7 (leftUnitor g).inv = \u03b7\u2081\ne_\u03b7\u2082 : CategoryStruct.comp (leftUnitor f).hom \u03b7\u2081 = \u03b7\u2082\n\u22a2 MonoidalCategoryStruct.whiskerLeft (tensorUnit C) \u03b7 = \u03b7\u2082"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_whiskerLeft {f g h : C}\n    {\u03b7 \u03b7' : g \u27f6 h} {\u03b8 : f \u2297 g \u27f6 f \u2297 h}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : f \u25c1 \u03b7' = \u03b8) :\n    f \u25c1 \u03b7 = \u03b8 := by\n  simp [e_\u03b7, e_\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h : C\n\u03b7 \u03b7' : g \u27f6 h\n\u03b8 : tensorObj f g \u27f6 tensorObj f h\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : MonoidalCategoryStruct.whiskerLeft f \u03b7' = \u03b8\n\u22a2 MonoidalCategoryStruct.whiskerLeft f \u03b7 = \u03b8"}, {"line": "simp [e_\u03b7, e_\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_whiskerRight {f g h : C}\n    {\u03b7 \u03b7' : f \u27f6 g} {\u03b8 : f \u2297 h \u27f6 g \u2297 h}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : \u03b7' \u25b7 h = \u03b8) :\n    \u03b7 \u25b7 h = \u03b8 := by\n  simp [e_\u03b7, e_\u03b8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h : C\n\u03b7 \u03b7' : f \u27f6 g\n\u03b8 : tensorObj f h \u27f6 tensorObj g h\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : MonoidalCategoryStruct.whiskerRight \u03b7' h = \u03b8\n\u22a2 MonoidalCategoryStruct.whiskerRight \u03b7 h = \u03b8"}, {"line": "simp [e_\u03b7, e_\u03b8]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_tensorHom {f g h i : C}\n    {\u03b7 \u03b7' : f \u27f6 g} {\u03b8 \u03b8' : h \u27f6 i} {\u03b9 : f \u2297 h \u27f6 g \u2297 i}\n    (e_\u03b7 : \u03b7 = \u03b7') (e_\u03b8 : \u03b8 = \u03b8') (e_\u03b9 : \u03b7' \u2297 \u03b8' = \u03b9) :\n    \u03b7 \u2297 \u03b8 = \u03b9 := by\n  simp [e_\u03b7, e_\u03b8, e_\u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h i : C\n\u03b7 \u03b7' : f \u27f6 g\n\u03b8 \u03b8' : h \u27f6 i\n\u03b9 : tensorObj f h \u27f6 tensorObj g i\ne_\u03b7 : \u03b7 = \u03b7'\ne_\u03b8 : \u03b8 = \u03b8'\ne_\u03b9 : tensorHom \u03b7' \u03b8' = \u03b9\n\u22a2 tensorHom \u03b7 \u03b8 = \u03b9"}, {"line": "simp [e_\u03b7, e_\u03b8, e_\u03b9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_nil {f g : C} (\u03b1 : f \u2245 g) (h : C) :\n    (whiskerRightIso \u03b1 h).hom = (whiskerRightIso \u03b1 h).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g : C\n\u03b1 : f \u2245 g\nh : C\n\u22a2 (whiskerRightIso \u03b1 h).hom = (whiskerRightIso \u03b1 h).hom"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_cons_of_of {f g h i j : C}\n    {\u03b1 : f \u2245 g} {\u03b7 : g \u27f6 h} {\u03b7s : h \u27f6 i} {\u03b7s\u2081 : h \u2297 j \u27f6 i \u2297 j}\n    {\u03b7\u2081 : g \u2297 j \u27f6 h \u2297 j} {\u03b7\u2082 : g \u2297 j \u27f6 i \u2297 j} {\u03b7\u2083 : f \u2297 j \u27f6 i \u2297 j}\n    (e_\u03b7s\u2081 : \u03b7s \u25b7 j = \u03b7s\u2081) (e_\u03b7\u2081 : \u03b7 \u25b7 j = \u03b7\u2081)\n    (e_\u03b7\u2082 : \u03b7\u2081 \u226b \u03b7s\u2081 = \u03b7\u2082) (e_\u03b7\u2083 : (whiskerRightIso \u03b1 j).hom \u226b \u03b7\u2082 = \u03b7\u2083) :\n    (\u03b1.hom \u226b \u03b7 \u226b \u03b7s) \u25b7 j = \u03b7\u2083 := by\n  simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h i j : C\n\u03b1 : f \u2245 g\n\u03b7 : g \u27f6 h\n\u03b7s : h \u27f6 i\n\u03b7s\u2081 : tensorObj h j \u27f6 tensorObj i j\n\u03b7\u2081 : tensorObj g j \u27f6 tensorObj h j\n\u03b7\u2082 : tensorObj g j \u27f6 tensorObj i j\n\u03b7\u2083 : tensorObj f j \u27f6 tensorObj i j\ne_\u03b7s\u2081 : MonoidalCategoryStruct.whiskerRight \u03b7s j = \u03b7s\u2081\ne_\u03b7\u2081 : MonoidalCategoryStruct.whiskerRight \u03b7 j = \u03b7\u2081\ne_\u03b7\u2082 : CategoryStruct.comp \u03b7\u2081 \u03b7s\u2081 = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp (whiskerRightIso \u03b1 j).hom \u03b7\u2082 = \u03b7\u2083\n\u22a2 MonoidalCategoryStruct.whiskerRight (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b7s)) j = \u03b7\u2083"}, {"line": "simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_cons_whisker {f g h i j k : C}\n    {\u03b1 : g \u2245 f \u2297 h} {\u03b7 : h \u27f6 i} {\u03b7s : f \u2297 i \u27f6 j}\n    {\u03b7\u2081 : h \u2297 k \u27f6 i \u2297 k} {\u03b7\u2082 : f \u2297 (h \u2297 k) \u27f6 f \u2297 (i \u2297 k)} {\u03b7s\u2081 : (f \u2297 i) \u2297 k \u27f6 j \u2297 k}\n    {\u03b7s\u2082 : f \u2297 (i \u2297 k) \u27f6 j \u2297 k} {\u03b7\u2083 : f \u2297 (h \u2297 k) \u27f6 j \u2297 k} {\u03b7\u2084 : (f \u2297 h) \u2297 k \u27f6 j \u2297 k}\n    {\u03b7\u2085 : g \u2297 k \u27f6 j \u2297 k}\n    (e_\u03b7\u2081 : ((Iso.refl _).hom \u226b \u03b7 \u226b (Iso.refl _).hom) \u25b7 k = \u03b7\u2081) (e_\u03b7\u2082 : f \u25c1 \u03b7\u2081 = \u03b7\u2082)\n    (e_\u03b7s\u2081 : \u03b7s \u25b7 k = \u03b7s\u2081) (e_\u03b7s\u2082 : (\u03b1_ _ _ _).inv \u226b \u03b7s\u2081 = \u03b7s\u2082)\n    (e_\u03b7\u2083 : \u03b7\u2082 \u226b \u03b7s\u2082 = \u03b7\u2083) (e_\u03b7\u2084 : (\u03b1_ _ _ _).hom \u226b \u03b7\u2083 = \u03b7\u2084)\n    (e_\u03b7\u2085 : (whiskerRightIso \u03b1 k).hom \u226b \u03b7\u2084 = \u03b7\u2085) :\n    (\u03b1.hom \u226b (f \u25c1 \u03b7) \u226b \u03b7s) \u25b7 k = \u03b7\u2085 := by\n  simp at e_\u03b7\u2081 e_\u03b7\u2085\n  simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7s\u2081, e_\u03b7s\u2082, e_\u03b7\u2083, e_\u03b7\u2084, e_\u03b7\u2085]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h i j k : C\n\u03b1 : g \u2245 tensorObj f h\n\u03b7 : h \u27f6 i\n\u03b7s : tensorObj f i \u27f6 j\n\u03b7\u2081 : tensorObj h k \u27f6 tensorObj i k\n\u03b7\u2082 : tensorObj f (tensorObj h k) \u27f6 tensorObj f (tensorObj i k)\n\u03b7s\u2081 : tensorObj (tensorObj f i) k \u27f6 tensorObj j k\n\u03b7s\u2082 : tensorObj f (tensorObj i k) \u27f6 tensorObj j k\n\u03b7\u2083 : tensorObj f (tensorObj h k) \u27f6 tensorObj j k\n\u03b7\u2084 : tensorObj (tensorObj f h) k \u27f6 tensorObj j k\n\u03b7\u2085 : tensorObj g k \u27f6 tensorObj j k\ne_\u03b7\u2081 :\n  MonoidalCategoryStruct.whiskerRight (CategoryStruct.comp (Iso.refl h).hom (CategoryStruct.comp \u03b7 (Iso.refl i).hom))\n      k =\n    \u03b7\u2081\ne_\u03b7\u2082 : MonoidalCategoryStruct.whiskerLeft f \u03b7\u2081 = \u03b7\u2082\ne_\u03b7s\u2081 : MonoidalCategoryStruct.whiskerRight \u03b7s k = \u03b7s\u2081\ne_\u03b7s\u2082 : CategoryStruct.comp (associator f i k).inv \u03b7s\u2081 = \u03b7s\u2082\ne_\u03b7\u2083 : CategoryStruct.comp \u03b7\u2082 \u03b7s\u2082 = \u03b7\u2083\ne_\u03b7\u2084 : CategoryStruct.comp (associator f h k).hom \u03b7\u2083 = \u03b7\u2084\ne_\u03b7\u2085 : CategoryStruct.comp (whiskerRightIso \u03b1 k).hom \u03b7\u2084 = \u03b7\u2085\n\u22a2 MonoidalCategoryStruct.whiskerRight\n      (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft f \u03b7) \u03b7s)) k =\n    \u03b7\u2085"}, {"line": "simp at e_\u03b7\u2081 e_\u03b7\u2085", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h i j k : C\n\u03b1 : g \u2245 tensorObj f h\n\u03b7 : h \u27f6 i\n\u03b7s : tensorObj f i \u27f6 j\n\u03b7\u2081 : tensorObj h k \u27f6 tensorObj i k\n\u03b7\u2082 : tensorObj f (tensorObj h k) \u27f6 tensorObj f (tensorObj i k)\n\u03b7s\u2081 : tensorObj (tensorObj f i) k \u27f6 tensorObj j k\n\u03b7s\u2082 : tensorObj f (tensorObj i k) \u27f6 tensorObj j k\n\u03b7\u2083 : tensorObj f (tensorObj h k) \u27f6 tensorObj j k\n\u03b7\u2084 : tensorObj (tensorObj f h) k \u27f6 tensorObj j k\n\u03b7\u2085 : tensorObj g k \u27f6 tensorObj j k\ne_\u03b7\u2082 : MonoidalCategoryStruct.whiskerLeft f \u03b7\u2081 = \u03b7\u2082\ne_\u03b7s\u2081 : MonoidalCategoryStruct.whiskerRight \u03b7s k = \u03b7s\u2081\ne_\u03b7s\u2082 : CategoryStruct.comp (associator f i k).inv \u03b7s\u2081 = \u03b7s\u2082\ne_\u03b7\u2083 : CategoryStruct.comp \u03b7\u2082 \u03b7s\u2082 = \u03b7\u2083\ne_\u03b7\u2084 : CategoryStruct.comp (associator f h k).hom \u03b7\u2083 = \u03b7\u2084\ne_\u03b7\u2085 : CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight \u03b1.hom k) \u03b7\u2084 = \u03b7\u2085\ne_\u03b7\u2081 : MonoidalCategoryStruct.whiskerRight \u03b7 k = \u03b7\u2081\n\u22a2 MonoidalCategoryStruct.whiskerRight\n      (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft f \u03b7) \u03b7s)) k =\n    \u03b7\u2085"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7s\u2081, e_\u03b7s\u2082, e_\u03b7\u2083, e_\u03b7\u2084, e_\u03b7\u2085]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_comp {f f' g h : C}\n    {\u03b7 : f \u27f6 f'} {\u03b7\u2081 : f \u2297 g \u27f6 f' \u2297 g} {\u03b7\u2082 : (f \u2297 g) \u2297 h \u27f6 (f' \u2297 g) \u2297 h}\n    {\u03b7\u2083 : (f \u2297 g) \u2297 h \u27f6 f' \u2297 (g \u2297 h)} {\u03b7\u2084 : f \u2297 (g \u2297 h) \u27f6 f' \u2297 (g \u2297 h)}\n    (e_\u03b7\u2081 : \u03b7 \u25b7 g = \u03b7\u2081) (e_\u03b7\u2082 : \u03b7\u2081 \u25b7 h = \u03b7\u2082)\n    (e_\u03b7\u2083 : \u03b7\u2082 \u226b (\u03b1_ _ _ _).hom = \u03b7\u2083) (e_\u03b7\u2084 : (\u03b1_ _ _ _).inv \u226b \u03b7\u2083 = \u03b7\u2084) :\n    \u03b7 \u25b7 (g \u2297 h) = \u03b7\u2084 := by\n  simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7\u2083, e_\u03b7\u2084]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf f' g h : C\n\u03b7 : f \u27f6 f'\n\u03b7\u2081 : tensorObj f g \u27f6 tensorObj f' g\n\u03b7\u2082 : tensorObj (tensorObj f g) h \u27f6 tensorObj (tensorObj f' g) h\n\u03b7\u2083 : tensorObj (tensorObj f g) h \u27f6 tensorObj f' (tensorObj g h)\n\u03b7\u2084 : tensorObj f (tensorObj g h) \u27f6 tensorObj f' (tensorObj g h)\ne_\u03b7\u2081 : MonoidalCategoryStruct.whiskerRight \u03b7 g = \u03b7\u2081\ne_\u03b7\u2082 : MonoidalCategoryStruct.whiskerRight \u03b7\u2081 h = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp \u03b7\u2082 (associator f' g h).hom = \u03b7\u2083\ne_\u03b7\u2084 : CategoryStruct.comp (associator f g h).inv \u03b7\u2083 = \u03b7\u2084\n\u22a2 MonoidalCategoryStruct.whiskerRight \u03b7 (tensorObj g h) = \u03b7\u2084"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082, e_\u03b7\u2083, e_\u03b7\u2084]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_id {f g : C}\n    {\u03b7 : f \u27f6 g} {\u03b7\u2081 : f \u27f6 g \u2297 \ud835\udfd9_ C} {\u03b7\u2082 : f \u2297 \ud835\udfd9_ C \u27f6 g \u2297 \ud835\udfd9_ C}\n    (e_\u03b7\u2081 : \u03b7 \u226b (\u03c1_ _).inv = \u03b7\u2081) (e_\u03b7\u2082 : (\u03c1_ _).hom \u226b \u03b7\u2081 = \u03b7\u2082) :\n    \u03b7 \u25b7 \ud835\udfd9_ C = \u03b7\u2082 := by\n  simp [e_\u03b7\u2081, e_\u03b7\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g : C\n\u03b7 : f \u27f6 g\n\u03b7\u2081 : f \u27f6 tensorObj g (tensorUnit C)\n\u03b7\u2082 : tensorObj f (tensorUnit C) \u27f6 tensorObj g (tensorUnit C)\ne_\u03b7\u2081 : CategoryStruct.comp \u03b7 (rightUnitor g).inv = \u03b7\u2081\ne_\u03b7\u2082 : CategoryStruct.comp (rightUnitor f).hom \u03b7\u2081 = \u03b7\u2082\n\u22a2 MonoidalCategoryStruct.whiskerRight \u03b7 (tensorUnit C) = \u03b7\u2082"}, {"line": "simp [e_\u03b7\u2081, e_\u03b7\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRightAux_of {f g : C} (\u03b7 : f \u27f6 g) (h : C) :\n    \u03b7 \u25b7 h = (Iso.refl _).hom \u226b \u03b7 \u25b7 h \u226b (Iso.refl _).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g : C\n\u03b7 : f \u27f6 g\nh : C\n\u22a2 MonoidalCategoryStruct.whiskerRight \u03b7 h =\n    CategoryStruct.comp (Iso.refl (tensorObj f h)).hom\n      (CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight \u03b7 h) (Iso.refl (tensorObj g h)).hom)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRightAux_cons {f g h i j : C} {\u03b7 : g \u27f6 h} {\u03b7s : i \u27f6 j}\n    {\u03b7s' : i \u2297 f \u27f6 j \u2297 f} {\u03b7\u2081 : g \u2297 (i \u2297 f) \u27f6 h \u2297 (j \u2297 f)}\n    {\u03b7\u2082 : g \u2297 (i \u2297 f) \u27f6 (h \u2297 j) \u2297 f} {\u03b7\u2083 : (g \u2297 i) \u2297 f \u27f6 (h \u2297 j) \u2297 f}\n    (e_\u03b7s' : \u03b7s \u25b7 f = \u03b7s') (e_\u03b7\u2081 : ((Iso.refl _).hom \u226b \u03b7 \u226b (Iso.refl _).hom) \u2297 \u03b7s' = \u03b7\u2081)\n    (e_\u03b7\u2082 : \u03b7\u2081 \u226b (\u03b1_ _ _ _).inv = \u03b7\u2082) (e_\u03b7\u2083 : (\u03b1_ _ _ _).hom \u226b \u03b7\u2082 = \u03b7\u2083) :\n    (\u03b7 \u2297 \u03b7s) \u25b7 f = \u03b7\u2083 := by\n  simp [\u2190 e_\u03b7s', \u2190 e_\u03b7\u2081, \u2190 e_\u03b7\u2082, \u2190 e_\u03b7\u2083, MonoidalCategory.tensorHom_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h i j : C\n\u03b7 : g \u27f6 h\n\u03b7s : i \u27f6 j\n\u03b7s' : tensorObj i f \u27f6 tensorObj j f\n\u03b7\u2081 : tensorObj g (tensorObj i f) \u27f6 tensorObj h (tensorObj j f)\n\u03b7\u2082 : tensorObj g (tensorObj i f) \u27f6 tensorObj (tensorObj h j) f\n\u03b7\u2083 : tensorObj (tensorObj g i) f \u27f6 tensorObj (tensorObj h j) f\ne_\u03b7s' : MonoidalCategoryStruct.whiskerRight \u03b7s f = \u03b7s'\ne_\u03b7\u2081 : tensorHom (CategoryStruct.comp (Iso.refl g).hom (CategoryStruct.comp \u03b7 (Iso.refl h).hom)) \u03b7s' = \u03b7\u2081\ne_\u03b7\u2082 : CategoryStruct.comp \u03b7\u2081 (associator h j f).inv = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp (associator g i f).hom \u03b7\u2082 = \u03b7\u2083\n\u22a2 MonoidalCategoryStruct.whiskerRight (tensorHom \u03b7 \u03b7s) f = \u03b7\u2083"}, {"line": "simp [\u2190 e_\u03b7s', \u2190 e_\u03b7\u2081, \u2190 e_\u03b7\u2082, \u2190 e_\u03b7\u2083, MonoidalCategory.tensorHom_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalWhiskerRight_cons_of {f f' g h i : C} {\u03b1 : f' \u2245 g} {\u03b7 : g \u27f6 h} {\u03b7s : h \u27f6 i}\n    {\u03b7s\u2081 : h \u2297 f \u27f6 i \u2297 f} {\u03b7\u2081 : g \u2297 f \u27f6 h \u2297 f} {\u03b7\u2082 : g \u2297 f \u27f6 i \u2297 f}\n    {\u03b7\u2083 : f' \u2297 f \u27f6 i \u2297 f}\n    (e_\u03b7s\u2081 : \u03b7s \u25b7 f = \u03b7s\u2081) (e_\u03b7\u2081 : \u03b7 \u25b7 f = \u03b7\u2081)\n    (e_\u03b7\u2082 : \u03b7\u2081 \u226b \u03b7s\u2081 = \u03b7\u2082) (e_\u03b7\u2083 : (whiskerRightIso \u03b1 f).hom \u226b \u03b7\u2082 = \u03b7\u2083) :\n    (\u03b1.hom \u226b \u03b7 \u226b \u03b7s) \u25b7 f = \u03b7\u2083 := by\n  simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf f' g h i : C\n\u03b1 : f' \u2245 g\n\u03b7 : g \u27f6 h\n\u03b7s : h \u27f6 i\n\u03b7s\u2081 : tensorObj h f \u27f6 tensorObj i f\n\u03b7\u2081 : tensorObj g f \u27f6 tensorObj h f\n\u03b7\u2082 : tensorObj g f \u27f6 tensorObj i f\n\u03b7\u2083 : tensorObj f' f \u27f6 tensorObj i f\ne_\u03b7s\u2081 : MonoidalCategoryStruct.whiskerRight \u03b7s f = \u03b7s\u2081\ne_\u03b7\u2081 : MonoidalCategoryStruct.whiskerRight \u03b7 f = \u03b7\u2081\ne_\u03b7\u2082 : CategoryStruct.comp \u03b7\u2081 \u03b7s\u2081 = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp (whiskerRightIso \u03b1 f).hom \u03b7\u2082 = \u03b7\u2083\n\u22a2 MonoidalCategoryStruct.whiskerRight (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b7s)) f = \u03b7\u2083"}, {"line": "simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalHorizontalCompAux_of {f g h i : C} (\u03b7 : f \u27f6 g) (\u03b8 : h \u27f6 i) :\n    \u03b7 \u2297 \u03b8 = (Iso.refl _).hom \u226b (\u03b7 \u2297 \u03b8) \u226b (Iso.refl _).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h i : C\n\u03b7 : f \u27f6 g\n\u03b8 : h \u27f6 i\n\u22a2 tensorHom \u03b7 \u03b8 =\n    CategoryStruct.comp (Iso.refl (tensorObj f h)).hom\n      (CategoryStruct.comp (tensorHom \u03b7 \u03b8) (Iso.refl (tensorObj g i)).hom)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalHorizontalComp_nil_nil {f g h i : C} (\u03b1 : f \u2245 g) (\u03b2 : h \u2245 i) :\n    (\u03b1 \u2297 \u03b2).hom = (\u03b1 \u2297 \u03b2).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf g h i : C\n\u03b1 : f \u2245 g\n\u03b2 : h \u2245 i\n\u22a2 (tensorIso \u03b1 \u03b2).hom = (tensorIso \u03b1 \u03b2).hom"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalHorizontalComp_nil_cons {f f' g g' h i : C}\n    {\u03b1 : f \u2245 g} {\u03b2 : f' \u2245 g'} {\u03b7 : g' \u27f6 h} {\u03b7s : h \u27f6 i}\n    {\u03b7\u2081 : g \u2297 g' \u27f6 g \u2297 h} {\u03b7s\u2081 : g \u2297 h \u27f6 g \u2297 i}\n    {\u03b7\u2082 : g \u2297 g' \u27f6 g \u2297 i} {\u03b7\u2083 : f \u2297 f' \u27f6 g \u2297 i}\n    (e_\u03b7\u2081 : g \u25c1 ((Iso.refl _).hom \u226b \u03b7 \u226b (Iso.refl _).hom) = \u03b7\u2081)\n    (e_\u03b7s\u2081 : g \u25c1 \u03b7s = \u03b7s\u2081) (e_\u03b7\u2082 : \u03b7\u2081 \u226b \u03b7s\u2081 = \u03b7\u2082)\n    (e_\u03b7\u2083 : (\u03b1 \u2297 \u03b2).hom \u226b \u03b7\u2082 = \u03b7\u2083) :\n    \u03b1.hom \u2297 (\u03b2.hom \u226b \u03b7 \u226b \u03b7s) = \u03b7\u2083 := by\n  simp_all [MonoidalCategory.tensorHom_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf f' g g' h i : C\n\u03b1 : f \u2245 g\n\u03b2 : f' \u2245 g'\n\u03b7 : g' \u27f6 h\n\u03b7s : h \u27f6 i\n\u03b7\u2081 : tensorObj g g' \u27f6 tensorObj g h\n\u03b7s\u2081 : tensorObj g h \u27f6 tensorObj g i\n\u03b7\u2082 : tensorObj g g' \u27f6 tensorObj g i\n\u03b7\u2083 : tensorObj f f' \u27f6 tensorObj g i\ne_\u03b7\u2081 :\n  MonoidalCategoryStruct.whiskerLeft g\n      (CategoryStruct.comp (Iso.refl g').hom (CategoryStruct.comp \u03b7 (Iso.refl h).hom)) =\n    \u03b7\u2081\ne_\u03b7s\u2081 : MonoidalCategoryStruct.whiskerLeft g \u03b7s = \u03b7s\u2081\ne_\u03b7\u2082 : CategoryStruct.comp \u03b7\u2081 \u03b7s\u2081 = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp (tensorIso \u03b1 \u03b2).hom \u03b7\u2082 = \u03b7\u2083\n\u22a2 tensorHom \u03b1.hom (CategoryStruct.comp \u03b2.hom (CategoryStruct.comp \u03b7 \u03b7s)) = \u03b7\u2083"}, {"line": "simp_all [MonoidalCategory.tensorHom_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalHorizontalComp_cons_nil {f f' g g' h i : C}\n    {\u03b1 : f \u2245 g} {\u03b7 : g \u27f6 h} {\u03b7s : h \u27f6 i} {\u03b2 : f' \u2245 g'}\n    {\u03b7\u2081 : g \u2297 g' \u27f6 h \u2297 g'} {\u03b7s\u2081 : h \u2297 g' \u27f6 i \u2297 g'} {\u03b7\u2082 : g \u2297 g' \u27f6 i \u2297 g'} {\u03b7\u2083 : f \u2297 f' \u27f6 i \u2297 g'}\n    (e_\u03b7\u2081 : ((Iso.refl _).hom \u226b \u03b7 \u226b (Iso.refl _).hom) \u25b7 g' = \u03b7\u2081) (e_\u03b7s\u2081 : \u03b7s \u25b7 g' = \u03b7s\u2081)\n    (e_\u03b7\u2082 : \u03b7\u2081 \u226b \u03b7s\u2081 = \u03b7\u2082) (e_\u03b7\u2083 : (\u03b1 \u2297 \u03b2).hom \u226b \u03b7\u2082 = \u03b7\u2083) :\n    (\u03b1.hom \u226b \u03b7 \u226b \u03b7s) \u2297 \u03b2.hom = \u03b7\u2083 := by\n  simp_all [MonoidalCategory.tensorHom_def']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf f' g g' h i : C\n\u03b1 : f \u2245 g\n\u03b7 : g \u27f6 h\n\u03b7s : h \u27f6 i\n\u03b2 : f' \u2245 g'\n\u03b7\u2081 : tensorObj g g' \u27f6 tensorObj h g'\n\u03b7s\u2081 : tensorObj h g' \u27f6 tensorObj i g'\n\u03b7\u2082 : tensorObj g g' \u27f6 tensorObj i g'\n\u03b7\u2083 : tensorObj f f' \u27f6 tensorObj i g'\ne_\u03b7\u2081 :\n  MonoidalCategoryStruct.whiskerRight (CategoryStruct.comp (Iso.refl g).hom (CategoryStruct.comp \u03b7 (Iso.refl h).hom))\n      g' =\n    \u03b7\u2081\ne_\u03b7s\u2081 : MonoidalCategoryStruct.whiskerRight \u03b7s g' = \u03b7s\u2081\ne_\u03b7\u2082 : CategoryStruct.comp \u03b7\u2081 \u03b7s\u2081 = \u03b7\u2082\ne_\u03b7\u2083 : CategoryStruct.comp (tensorIso \u03b1 \u03b2).hom \u03b7\u2082 = \u03b7\u2083\n\u22a2 tensorHom (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b7s)) \u03b2.hom = \u03b7\u2083"}, {"line": "simp_all [MonoidalCategory.tensorHom_def']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem evalHorizontalComp_cons_cons {f f' g g' h h' i i' : C}\n    {\u03b1 : f \u2245 g} {\u03b7 : g \u27f6 h} {\u03b7s : h \u27f6 i}\n    {\u03b2 : f' \u2245 g'} {\u03b8 : g' \u27f6 h'} {\u03b8s : h' \u27f6 i'}\n    {\u03b7\u03b8 : g \u2297 g' \u27f6 h \u2297 h'} {\u03b7\u03b8s : h \u2297 h' \u27f6 i \u2297 i'}\n    {\u03b7\u03b8\u2081 : g \u2297 g' \u27f6 i \u2297 i'} {\u03b7\u03b8\u2082 : f \u2297 f' \u27f6 i \u2297 i'}\n    (e_\u03b7\u03b8 : \u03b7 \u2297 \u03b8 = \u03b7\u03b8) (e_\u03b7\u03b8s : \u03b7s \u2297 \u03b8s = \u03b7\u03b8s)\n    (e_\u03b7\u03b8\u2081 : \u03b7\u03b8 \u226b \u03b7\u03b8s = \u03b7\u03b8\u2081) (e_\u03b7\u03b8\u2082 : (\u03b1 \u2297 \u03b2).hom \u226b \u03b7\u03b8\u2081 = \u03b7\u03b8\u2082) :\n    (\u03b1.hom \u226b \u03b7 \u226b \u03b7s) \u2297 (\u03b2.hom \u226b \u03b8 \u226b \u03b8s) = \u03b7\u03b8\u2082 := by\n  simp [\u2190 e_\u03b7\u03b8 , \u2190 e_\u03b7\u03b8s , \u2190 e_\u03b7\u03b8\u2081, \u2190 e_\u03b7\u03b8\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.lean", "context": {"open": ["Lean Meta Elab Qq", "CategoryTheory Mathlib.Tactic.BicategoryLike MonoidalCategory"], "variables": ["{C : Type u} [Category.{v} C]", "{f f' g g' h h' i i' j : C}", "[MonoidalCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nf f' g g' h h' i i' : C\n\u03b1 : f \u2245 g\n\u03b7 : g \u27f6 h\n\u03b7s : h \u27f6 i\n\u03b2 : f' \u2245 g'\n\u03b8 : g' \u27f6 h'\n\u03b8s : h' \u27f6 i'\n\u03b7\u03b8 : tensorObj g g' \u27f6 tensorObj h h'\n\u03b7\u03b8s : tensorObj h h' \u27f6 tensorObj i i'\n\u03b7\u03b8\u2081 : tensorObj g g' \u27f6 tensorObj i i'\n\u03b7\u03b8\u2082 : tensorObj f f' \u27f6 tensorObj i i'\ne_\u03b7\u03b8 : tensorHom \u03b7 \u03b8 = \u03b7\u03b8\ne_\u03b7\u03b8s : tensorHom \u03b7s \u03b8s = \u03b7\u03b8s\ne_\u03b7\u03b8\u2081 : CategoryStruct.comp \u03b7\u03b8 \u03b7\u03b8s = \u03b7\u03b8\u2081\ne_\u03b7\u03b8\u2082 : CategoryStruct.comp (tensorIso \u03b1 \u03b2).hom \u03b7\u03b8\u2081 = \u03b7\u03b8\u2082\n\u22a2 tensorHom (CategoryStruct.comp \u03b1.hom (CategoryStruct.comp \u03b7 \u03b7s))\n      (CategoryStruct.comp \u03b2.hom (CategoryStruct.comp \u03b8 \u03b8s)) =\n    \u03b7\u03b8\u2082"}, {"line": "simp [\u2190 e_\u03b7\u03b8 , \u2190 e_\u03b7\u03b8s , \u2190 e_\u03b7\u03b8\u2081, \u2190 e_\u03b7\u03b8\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_eq_of_eq {\u03b1} [Semiring \u03b1] {a b : \u03b1} (ha : a = 0) (hb : b = 0) : a + b = 0 := by\n  simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Linarith/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Semiring \u03b1\na b : \u03b1\nha : a = 0\nhb : b = 0\n\u22a2 a + b = 0"}, {"line": "simp [*]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Semiring \u03b1\na b : \u03b1\nha : a = 0\nhb : b = 0\n\u22a2 0 + 0 = 0"}]}
{"declaration": "theorem le_of_eq_of_le {a b : \u03b1} (ha : a = 0) (hb : b \u2264 0) : a + b \u2264 0 := by\n  simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Linarith/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Semiring \u03b1] [PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nha : a = 0\nhb : b \u2264 0\n\u22a2 a + b \u2264 0"}, {"line": "simp [*]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nha : a = 0\nhb : b \u2264 0\n\u22a2 0 + b \u2264 0"}]}
{"declaration": "theorem lt_of_eq_of_lt {a b : \u03b1} (ha : a = 0) (hb : b < 0) : a + b < 0 := by\n  simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Linarith/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Semiring \u03b1] [PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nha : a = 0\nhb : b < 0\n\u22a2 a + b < 0"}, {"line": "simp [*]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nha : a = 0\nhb : b < 0\n\u22a2 0 + b < 0"}]}
{"declaration": "theorem le_of_le_of_eq {a b : \u03b1} (ha : a \u2264 0) (hb : b = 0) : a + b \u2264 0 := by\n  simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Linarith/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Semiring \u03b1] [PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nha : a \u2264 0\nhb : b = 0\n\u22a2 a + b \u2264 0"}, {"line": "simp [*]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nha : a \u2264 0\nhb : b = 0\n\u22a2 a + 0 \u2264 0"}]}
{"declaration": "theorem lt_of_lt_of_eq {a b : \u03b1} (ha : a < 0) (hb : b = 0) : a + b < 0 := by\n  simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Linarith/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Semiring \u03b1] [PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nha : a < 0\nhb : b = 0\n\u22a2 a + b < 0"}, {"line": "simp [*]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nha : a < 0\nhb : b = 0\n\u22a2 a + 0 < 0"}]}
{"declaration": "theorem mul_eq [IsOrderedRing \u03b1] {a b : \u03b1} (ha : a = 0) (_ : 0 < b) : b * a = 0 := by\n  simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Linarith/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} [Semiring \u03b1] [PartialOrder \u03b1]", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedRing \u03b1\na b : \u03b1\nha : a = 0\nx\u271d : 0 < b\n\u22a2 b * a = 0"}, {"line": "simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_zero_eq {\u03b1} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} [Semiring \u03b1] {a b : \u03b1} (_ : R a 0) (h : b = 0) :\n    a * b = 0 := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Linarith/Lemmas.lean", "context": {"open": ["Mathlib in"], "variables": ["{\u03b1 : Type u} [Semiring \u03b1] [PartialOrder \u03b1]", "(\u03b1) in", "{\u03b1 : Type u} [Ring \u03b1] [PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Semiring \u03b1\na b : \u03b1\nx\u271d : R a 0\nh : b = 0\n\u22a2 a * b = 0"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zero_mul_eq {\u03b1} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} [Semiring \u03b1] {a b : \u03b1} (h : a = 0) (_ : R b 0) :\n    a * b = 0 := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Linarith/Lemmas.lean", "context": {"open": ["Mathlib in"], "variables": ["{\u03b1 : Type u} [Semiring \u03b1] [PartialOrder \u03b1]", "(\u03b1) in", "{\u03b1 : Type u} [Ring \u03b1] [PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Semiring \u03b1\na b : \u03b1\nh : a = 0\nx\u271d : R b 0\n\u22a2 a * b = 0"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem without_one_mul {M : Type*} [MulOneClass M] {a b : M} (h : 1 * a = b) : a = b := by\n  rwa [one_mul] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Linarith/Preprocessing.lean", "context": {"open": ["Lean", "Elab Tactic Meta", "Qq", "Mathlib", "Mathlib.Tactic (AtomM)", "Std (TreeSet)", "Mathlib.Tactic.Zify"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : MulOneClass M\na b : M\nh : 1 * a = b\n\u22a2 a = b"}, {"line": "rwa [one_mul] at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_eq [Add \u03b1] [IsRightCancelAdd \u03b1] (p : (a : \u03b1) = b) (H : a' + b = b' + a) :\n    a' = b' := by\n  rw [p] at H\n  exact add_right_cancel H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/LinearCombination/Lemmas.lean", "context": {"open": ["Lean"], "variables": ["{\u03b1 : Type*} {a a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1}", "{K : Type*} {t s : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na a' b b' : \u03b1\ninst\u271d\u00b9 : Add \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\np : a = b\nH : a' + b = b' + a\n\u22a2 a' = b'"}, {"line": "rw [p] at H", "tactic_state": "\u03b1 : Type u_1\na a' b b' : \u03b1\ninst\u271d\u00b9 : Add \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\np : a = b\nH : a' + b = b' + b\n\u22a2 a' = b'"}, {"line": "exact add_right_cancel H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_of_eq [AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelAddMonoid \u03b1]\n    (p : (a : \u03b1) = b) (H : a' + b \u2264 b' + a) :\n    a' \u2264 b' := by\n  rwa [p, add_le_add_iff_right] at H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/LinearCombination/Lemmas.lean", "context": {"open": ["Lean"], "variables": ["{\u03b1 : Type*} {a a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1}", "{K : Type*} {t s : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na a' b b' : \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelAddMonoid \u03b1\np : a = b\nH : a' + b \u2264 b' + a\n\u22a2 a' \u2264 b'"}, {"line": "rwa [p, add_le_add_iff_right] at H", "tactic_state": "\u03b1 : Type u_1\na a' b b' : \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelAddMonoid \u03b1\np : a = b\nH : a' + b \u2264 b' + b\n\u22a2 AddRightMono \u03b1\n---\n\u03b1 : Type u_1\na a' b b' : \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelAddMonoid \u03b1\np : a = b\nH : a' + b \u2264 b' + b\n\u22a2 AddRightReflectLE \u03b1"}]}
{"declaration": "theorem lt_of_eq [AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelAddMonoid \u03b1]\n    (p : (a : \u03b1) = b) (H : a' + b < b' + a) :\n    a' < b' := by\n  rwa [p, add_lt_add_iff_right] at H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/LinearCombination/Lemmas.lean", "context": {"open": ["Lean"], "variables": ["{\u03b1 : Type*} {a a' a\u2081 a\u2082 b b' b\u2081 b\u2082 c : \u03b1}", "{K : Type*} {t s : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na a' b b' : \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelAddMonoid \u03b1\np : a = b\nH : a' + b < b' + a\n\u22a2 a' < b'"}, {"line": "rwa [p, add_lt_add_iff_right] at H", "tactic_state": "\u03b1 : Type u_1\na a' b b' : \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelAddMonoid \u03b1\np : a = b\nH : a' + b < b' + b\n\u22a2 AddRightStrictMono \u03b1\n---\n\u03b1 : Type u_1\na a' b b' : \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelAddMonoid \u03b1\np : a = b\nH : a' + b < b' + b\n\u22a2 AddRightReflectLT \u03b1"}]}
{"declaration": "theorem ble_eq_false {x y : \u2115} : x.ble y = false \u2194 y < x := by\n  rw [\u2190 Nat.not_le]\n  rw [\u2190 Bool.not_eq_true]\n  rw [Nat.ble_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/Basic.lean", "context": {"open": ["Lean", "Meta", "Qq"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 x.ble y = false \u2194 y < x"}, {"line": "rw [\u2190 Nat.not_le]", "tactic_state": "x y : \u2115\n\u22a2 x.ble y = false \u2194 \u00acx \u2264 y"}, {"line": "rw [\u2190 Bool.not_eq_true]", "tactic_state": "x y : \u2115\n\u22a2 \u00acx.ble y = true \u2194 \u00acx \u2264 y"}, {"line": "rw [Nat.ble_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem int_not_isCoprime_helper (x y : \u2124) (d : \u2115) (hd : Int.gcd x y = d)\n    (h : Nat.beq d 1 = false) : \u00ac IsCoprime x y := by\n  rw [Int.isCoprime_iff_gcd_eq_one]\n  rw [hd]\n  exact Nat.ne_of_beq_eq_false h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/IsCoprime.lean", "context": {"open": ["Qq Lean Elab.Tactic Mathlib.Meta.NormNum"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2124\nd : \u2115\nhd : x.gcd y = d\nh : d.beq 1 = false\n\u22a2 \u00acIsCoprime x y"}, {"line": "rw [Int.isCoprime_iff_gcd_eq_one]", "tactic_state": "x y : \u2124\nd : \u2115\nhd : x.gcd y = d\nh : d.beq 1 = false\n\u22a2 \u00acx.gcd y = 1"}, {"line": "rw [hd]", "tactic_state": "x y : \u2124\nd : \u2115\nhd : x.gcd y = d\nh : d.beq 1 = false\n\u22a2 \u00acd = 1"}, {"line": "exact Nat.ne_of_beq_eq_false h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem jacobiSymNat.odd_even (a b c : \u2115) (r : \u2124) (ha : a % 2 = 1) (hb : b % 2 = 0) (hc : b / 2 = c)\n    (hr : jacobiSymNat a c = r) : jacobiSymNat a b = r := by\n  have ha' : legendreSym 2 a = 1 := by\n    simp only [legendreSym.mod 2 a]\n    simp only [Int.ofNat_mod_ofNat]\n    simp only [ha]\n    decide\n  rcases eq_or_ne c 0 with (rfl | hc')\n  \u00b7 rw [\u2190 hr, Nat.eq_zero_of_dvd_of_div_eq_zero (Nat.dvd_of_mod_eq_zero hb) hc]\n  \u00b7 haveI : NeZero c := \u27e8hc'\u27e9\n    -- for `jacobiSym.mul_right`\n    rwa [\u2190 Nat.mod_add_div b 2, hb, hc, Nat.zero_add, jacobiSymNat, jacobiSym.mul_right,\n      \u2190 jacobiSym.legendreSym.to_jacobiSym, ha', one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/LegendreSymbol.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\njacobiSymNat : x\u271d\na b c : \u2115\nr : \u2124\nha : a % 2 = 1\nhb : b % 2 = 0\nhc : b / 2 = c\nhr : sorry = r\n\u22a2 sorry = r"}, {"line": "have ha' : legendreSym 2 a = 1 := by\n    simp only [legendreSym.mod 2 a]\n    simp only [Int.ofNat_mod_ofNat]\n    simp only [ha]\n    decide", "tactic_state": "x\u271d : Sort u_1\njacobiSymNat : x\u271d\na b c : \u2115\nr : \u2124\nha : a % 2 = 1\nhb : b % 2 = 0\nhc : b / 2 = c\nhr : sorry = r\nha' : legendreSym 2 \u2191a = 1\n\u22a2 sorry = r"}, {"line": "rcases eq_or_ne c 0 with (rfl | hc')", "tactic_state": "case inl\nx\u271d : Sort u_1\njacobiSymNat : x\u271d\na b : \u2115\nr : \u2124\nha : a % 2 = 1\nhb : b % 2 = 0\nhr : sorry = r\nha' : legendreSym 2 \u2191a = 1\nhc : b / 2 = 0\n\u22a2 sorry = r\n---\ncase inr\nx\u271d : Sort u_1\njacobiSymNat : x\u271d\na b c : \u2115\nr : \u2124\nha : a % 2 = 1\nhb : b % 2 = 0\nhc : b / 2 = c\nhr : sorry = r\nha' : legendreSym 2 \u2191a = 1\nhc' : c \u2260 0\n\u22a2 sorry = r"}, {"line": "\u00b7 rw [\u2190 hr, Nat.eq_zero_of_dvd_of_div_eq_zero (Nat.dvd_of_mod_eq_zero hb) hc]", "tactic_state": "case inr\nx\u271d : Sort u_1\njacobiSymNat : x\u271d\na b c : \u2115\nr : \u2124\nha : a % 2 = 1\nhb : b % 2 = 0\nhc : b / 2 = c\nhr : sorry = r\nha' : legendreSym 2 \u2191a = 1\nhc' : c \u2260 0\n\u22a2 sorry = r"}, {"line": "\u00b7 haveI : NeZero c := \u27e8hc'\u27e9\n    rwa [\u2190 Nat.mod_add_div b 2, hb, hc, Nat.zero_add, jacobiSymNat, jacobiSym.mul_right,\n      \u2190 jacobiSym.legendreSym.to_jacobiSym, ha', one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma nat_log_helper0 (b n : Nat) (hl : Nat.blt n b = true) :\n    Nat.log b n = 0 := by\n  rw [Nat.blt_eq] at hl\n  simp [hl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/NatLog.lean", "context": {"open": ["Qq Lean Elab.Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b n : \u2115\nhl : n.blt b = true\n\u22a2 Nat.log b n = 0"}, {"line": "rw [Nat.blt_eq] at hl", "tactic_state": "b n : \u2115\nhl : n < b\n\u22a2 Nat.log b n = 0"}, {"line": "simp [hl]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nat_sqrt_helper {x y r : \u2115} (hr : y * y + r = x) (hle : Nat.ble r (2 * y)) :\n    Nat.sqrt x = y := by\n  rw [\u2190 hr]\n  rw [\u2190 pow_two]\n  rw [two_mul] at hle\n  exact Nat.sqrt_add_eq' _ (Nat.le_of_ble_eq_true hle)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/NatSqrt.lean", "context": {"open": ["Qq Lean Elab.Tactic Mathlib.Meta.NormNum"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y r : \u2115\nhr : y * y + r = x\nhle : r.ble (2 * y) = true\n\u22a2 x.sqrt = y"}, {"line": "rw [\u2190 hr]", "tactic_state": "x y r : \u2115\nhr : y * y + r = x\nhle : r.ble (2 * y) = true\n\u22a2 (y * y + r).sqrt = y"}, {"line": "rw [\u2190 pow_two]", "tactic_state": "x y r : \u2115\nhr : y * y + r = x\nhle : r.ble (2 * y) = true\n\u22a2 (y ^ 2 + r).sqrt = y"}, {"line": "rw [two_mul] at hle", "tactic_state": "x y r : \u2115\nhr : y * y + r = x\nhle : r.ble (y + y) = true\n\u22a2 (y ^ 2 + r).sqrt = y"}, {"line": "exact Nat.sqrt_add_eq' _ (Nat.le_of_ble_eq_true hle)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intPow_negOfNat_bit0 {b' c' : \u2115} (h1 : Nat.pow a b' = c')\n    (hb : nat_lit 2 * b' = b) (hc : c' * c' = c) :\n    Int.pow (Int.negOfNat a) b = Int.ofNat c := by\n  rw [\u2190 hb]\n  rw [Int.negOfNat_eq]\n  rw [Int.pow_eq]\n  rw [pow_mul]\n  rw [neg_pow_two]\n  rw [\u2190 pow_mul]\n  rw [two_mul]\n  rw [pow_add]\n  rw [\u2190 hc]\n  rw [\u2190 h1]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/Pow.lean", "context": {"open": ["Lean", "Meta", "Qq"], "variables": ["{a b c : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 (Int.negOfNat a).pow b = Int.ofNat c"}, {"line": "rw [\u2190 hb]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 (Int.negOfNat a).pow (2 * b') = Int.ofNat c"}, {"line": "rw [Int.negOfNat_eq]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 (-Int.ofNat a).pow (2 * b') = Int.ofNat c"}, {"line": "rw [Int.pow_eq]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 (-Int.ofNat a) ^ (2 * b') = Int.ofNat c"}, {"line": "rw [pow_mul]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 ((-Int.ofNat a) ^ 2) ^ b' = Int.ofNat c"}, {"line": "rw [neg_pow_two]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 (Int.ofNat a ^ 2) ^ b' = Int.ofNat c"}, {"line": "rw [\u2190 pow_mul]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 Int.ofNat a ^ (2 * b') = Int.ofNat c"}, {"line": "rw [two_mul]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 Int.ofNat a ^ (b' + b') = Int.ofNat c"}, {"line": "rw [pow_add]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 Int.ofNat a ^ b' * Int.ofNat a ^ b' = Int.ofNat c"}, {"line": "rw [\u2190 hc]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 Int.ofNat a ^ b' * Int.ofNat a ^ b' = Int.ofNat (c' * c')"}, {"line": "rw [\u2190 h1]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' = b\nhc : c' * c' = c\n\u22a2 Int.ofNat a ^ b' * Int.ofNat a ^ b' = Int.ofNat (a.pow b' * a.pow b')"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intPow_negOfNat_bit1 {b' c' : \u2115} (h1 : Nat.pow a b' = c')\n    (hb : nat_lit 2 * b' + nat_lit 1 = b) (hc : c' * (c' * a) = c) :\n    Int.pow (Int.negOfNat a) b = Int.negOfNat c := by\n  rw [\u2190 hb]\n  rw [Int.negOfNat_eq]\n  rw [Int.negOfNat_eq]\n  rw [Int.pow_eq]\n  rw [pow_succ]\n  rw [pow_mul]\n  rw [neg_pow_two]\n  rw [\u2190 pow_mul]\n  rw [two_mul]\n  rw [pow_add]\n  rw [\u2190 hc]\n  rw [\u2190 h1]\n  simp [mul_assoc, mul_comm, mul_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/Pow.lean", "context": {"open": ["Lean", "Meta", "Qq"], "variables": ["{a b c : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 (Int.negOfNat a).pow b = Int.negOfNat c"}, {"line": "rw [\u2190 hb]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 (Int.negOfNat a).pow (2 * b' + 1) = Int.negOfNat c"}, {"line": "rw [Int.negOfNat_eq]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 (-Int.ofNat a).pow (2 * b' + 1) = Int.negOfNat c"}, {"line": "rw [Int.negOfNat_eq]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 (-Int.ofNat a).pow (2 * b' + 1) = -Int.ofNat c"}, {"line": "rw [Int.pow_eq]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 (-Int.ofNat a) ^ (2 * b' + 1) = -Int.ofNat c"}, {"line": "rw [pow_succ]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 (-Int.ofNat a) ^ (2 * b') * -Int.ofNat a = -Int.ofNat c"}, {"line": "rw [pow_mul]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 ((-Int.ofNat a) ^ 2) ^ b' * -Int.ofNat a = -Int.ofNat c"}, {"line": "rw [neg_pow_two]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 (Int.ofNat a ^ 2) ^ b' * -Int.ofNat a = -Int.ofNat c"}, {"line": "rw [\u2190 pow_mul]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 Int.ofNat a ^ (2 * b') * -Int.ofNat a = -Int.ofNat c"}, {"line": "rw [two_mul]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 Int.ofNat a ^ (b' + b') * -Int.ofNat a = -Int.ofNat c"}, {"line": "rw [pow_add]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 Int.ofNat a ^ b' * Int.ofNat a ^ b' * -Int.ofNat a = -Int.ofNat c"}, {"line": "rw [\u2190 hc]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 Int.ofNat a ^ b' * Int.ofNat a ^ b' * -Int.ofNat a = -Int.ofNat (c' * (c' * a))"}, {"line": "rw [\u2190 h1]", "tactic_state": "a b c b' c' : \u2115\nh1 : a.pow b' = c'\nhb : 2 * b' + 1 = b\nhc : c' * (c' * a) = c\n\u22a2 Int.ofNat a ^ b' * Int.ofNat a ^ b' * -Int.ofNat a = -Int.ofNat (a.pow b' * (a.pow b' * a))"}, {"line": "simp [mul_assoc, mul_comm, mul_left_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natPow_zero_natMod_zero : Nat.mod (Nat.pow a (nat_lit 0)) (nat_lit 0) = nat_lit 1 := by\n  simp [Nat.mod, Nat.modCore]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/PowMod.lean", "context": {"open": ["Lean", "Meta", "Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 (a.pow 0).mod 0 = 1"}, {"line": "simp [Nat.mod, Nat.modCore]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natPow_zero_natMod_one : Nat.mod (Nat.pow a (nat_lit 0)) (nat_lit 1) = nat_lit 0 := by\n  simp [Nat.mod, Nat.modCore_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/PowMod.lean", "context": {"open": ["Lean", "Meta", "Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 (a.pow 0).mod 1 = 0"}, {"line": "simp [Nat.mod, Nat.modCore_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNat_realSqrt_of_isRat_negOfNat {x : \u211d} {num : \u2115} {denom : \u2115}\n    (h : IsRat x (.negOfNat num) denom) : IsNat \u221ax (nat_lit 0) := by\n  refine \u27e8?_\u27e9\n  obtain \u27e8inv, rfl\u27e9 := h\n  have h\u2081 : 0 \u2264 (num : \u211a) * \u215f(denom : \u211d) :=\n    mul_nonneg (Nat.cast_nonneg' _) (invOf_nonneg.2 <| Nat.cast_nonneg' _)\n  simpa [Nat.cast_zero, Real.sqrt_eq_zero', Int.cast_negOfNat, neg_mul, neg_nonpos] using h\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/RealSqrt.lean", "context": {"open": ["Qq Lean Lean.Meta Elab.Tactic Mathlib.Meta.NormNum NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nnum denom : \u2115\nh : IsRat x (Int.negOfNat num) denom\n\u22a2 IsNat (\u221ax) 0"}, {"line": "refine \u27e8?_\u27e9", "tactic_state": "x : \u211d\nnum denom : \u2115\nh : IsRat x (Int.negOfNat num) denom\n\u22a2 \u221ax = \u21910"}, {"line": "obtain \u27e8inv, rfl\u27e9 := h", "tactic_state": "case mk\nnum denom : \u2115\ninv : Invertible \u2191denom\n\u22a2 \u221a(\u2191(Int.negOfNat num) * \u215f \u2191denom) = \u21910"}, {"line": "have h\u2081 : 0 \u2264 (num : \u211a) * \u215f(denom : \u211d) :=\n    mul_nonneg (Nat.cast_nonneg' _) (invOf_nonneg.2 <| Nat.cast_nonneg' _)", "tactic_state": "case mk\nnum denom : \u2115\ninv : Invertible \u2191denom\nh\u2081 : 0 \u2264 \u2191\u2191num * \u215f \u2191denom\n\u22a2 \u221a(\u2191(Int.negOfNat num) * \u215f \u2191denom) = \u21910"}, {"line": "simpa [Nat.cast_zero, Real.sqrt_eq_zero', Int.cast_negOfNat, neg_mul, neg_nonpos] using h\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isRat_realSqrt_of_isRat_ofNat {x : \u211d} {n sn : \u2115} {d sd : \u2115} (hn : sn * sn = n)\n    (hd : sd * sd = d) (h : IsRat x (.ofNat n) d) :\n    IsRat \u221ax (.ofNat sn) sd := by\n  obtain \u27e8_, rfl\u27e9 := h\n  refine \u27e8?_, ?out\u27e9\n  \u00b7 apply invertibleOfNonzero\n    rw [\u2190 mul_self_ne_zero]\n    rw [\u2190 Nat.cast_mul]\n    rw [hd]\n    exact Invertible.ne_zero _\n  \u00b7 simp [\u2190 hn, \u2190 hd, Real.sqrt_mul (mul_self_nonneg \u2191sn)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/RealSqrt.lean", "context": {"open": ["Qq Lean Lean.Meta Elab.Tactic Mathlib.Meta.NormNum NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn sn d sd : \u2115\nhn : sn * sn = n\nhd : sd * sd = d\nh : IsRat x (Int.ofNat n) d\n\u22a2 IsRat (\u221ax) (Int.ofNat sn) sd"}, {"line": "obtain \u27e8_, rfl\u27e9 := h", "tactic_state": "case mk\nn sn d sd : \u2115\nhn : sn * sn = n\nhd : sd * sd = d\ninv\u271d : Invertible \u2191d\n\u22a2 IsRat (\u221a(\u2191(Int.ofNat n) * \u215f \u2191d)) (Int.ofNat sn) sd"}, {"line": "refine \u27e8?_, ?out\u27e9", "tactic_state": "case mk\nn sn d sd : \u2115\nhn : sn * sn = n\nhd : sd * sd = d\ninv\u271d : Invertible \u2191d\n\u22a2 Invertible \u2191sd\n---\ncase out\nn sn d sd : \u2115\nhn : sn * sn = n\nhd : sd * sd = d\ninv\u271d : Invertible \u2191d\n\u22a2 \u221a(\u2191(Int.ofNat n) * \u215f \u2191d) = \u2191(Int.ofNat sn) * \u215f \u2191sd"}, {"line": "\u00b7 apply invertibleOfNonzero\n    rw [\u2190 mul_self_ne_zero]\n    rw [\u2190 Nat.cast_mul]\n    rw [hd]\n    exact Invertible.ne_zero _", "tactic_state": "case out\nn sn d sd : \u2115\nhn : sn * sn = n\nhd : sd * sd = d\ninv\u271d : Invertible \u2191d\n\u22a2 \u221a(\u2191(Int.ofNat n) * \u215f \u2191d) = \u2191(Int.ofNat sn) * \u215f \u2191sd"}, {"line": "\u00b7 simp [\u2190 hn, \u2190 hd, Real.sqrt_mul (mul_self_nonneg \u2191sn)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem int_gcd_helper' {d : \u2115} {x y : \u2124} (a b : \u2124) (h\u2081 : (d : \u2124) \u2223 x) (h\u2082 : (d : \u2124) \u2223 y)\n    (h\u2083 : x * a + y * b = d) : Int.gcd x y = d := by\n  refine Nat.dvd_antisymm ?_ (Int.natCast_dvd_natCast.1 (Int.dvd_coe_gcd h\u2081 h\u2082))\n  rw [\u2190 Int.natCast_dvd_natCast]\n  rw [\u2190 h\u2083]\n  apply dvd_add\n  \u00b7 exact Int.gcd_dvd_left.mul_right _\n  \u00b7 exact Int.gcd_dvd_right.mul_right _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/GCD.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2115\nx y a b : \u2124\nh\u2081 : \u2191d \u2223 x\nh\u2082 : \u2191d \u2223 y\nh\u2083 : x * a + y * b = \u2191d\n\u22a2 x.gcd y = d"}, {"line": "refine Nat.dvd_antisymm ?_ (Int.natCast_dvd_natCast.1 (Int.dvd_coe_gcd h\u2081 h\u2082))", "tactic_state": "d : \u2115\nx y a b : \u2124\nh\u2081 : \u2191d \u2223 x\nh\u2082 : \u2191d \u2223 y\nh\u2083 : x * a + y * b = \u2191d\n\u22a2 x.gcd y \u2223 d"}, {"line": "rw [\u2190 Int.natCast_dvd_natCast]", "tactic_state": "d : \u2115\nx y a b : \u2124\nh\u2081 : \u2191d \u2223 x\nh\u2082 : \u2191d \u2223 y\nh\u2083 : x * a + y * b = \u2191d\n\u22a2 \u2191(x.gcd y) \u2223 \u2191d"}, {"line": "rw [\u2190 h\u2083]", "tactic_state": "d : \u2115\nx y a b : \u2124\nh\u2081 : \u2191d \u2223 x\nh\u2082 : \u2191d \u2223 y\nh\u2083 : x * a + y * b = \u2191d\n\u22a2 \u2191(x.gcd y) \u2223 x * a + y * b"}, {"line": "apply dvd_add", "tactic_state": "case h\u2081\nd : \u2115\nx y a b : \u2124\nh\u2081 : \u2191d \u2223 x\nh\u2082 : \u2191d \u2223 y\nh\u2083 : x * a + y * b = \u2191d\n\u22a2 \u2191(x.gcd y) \u2223 x * a\n---\ncase h\u2082\nd : \u2115\nx y a b : \u2124\nh\u2081 : \u2191d \u2223 x\nh\u2082 : \u2191d \u2223 y\nh\u2083 : x * a + y * b = \u2191d\n\u22a2 \u2191(x.gcd y) \u2223 y * b"}, {"line": "\u00b7 exact Int.gcd_dvd_left.mul_right _", "tactic_state": "case h\u2082\nd : \u2115\nx y a b : \u2124\nh\u2081 : \u2191d \u2223 x\nh\u2082 : \u2191d \u2223 y\nh\u2083 : x * a + y * b = \u2191d\n\u22a2 \u2191(x.gcd y) \u2223 y * b"}, {"line": "\u00b7 exact Int.gcd_dvd_right.mul_right _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma asc_factorial_aux (n l m a b : \u2115) (h\u2081 : n.ascFactorial l = a)\n    (h\u2082 : (n + l).ascFactorial m = b) : n.ascFactorial (l + m) = a * b := by\n  rw [\u2190 h\u2081]\n  rw [\u2190 h\u2082]\n  symm\n  apply ascFactorial_mul_ascFactorial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/NatFactorial.lean", "context": {"open": ["Nat Qq Lean Elab.Tactic Qq Meta"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n l m a b : \u2115\nh\u2081 : n.ascFactorial l = a\nh\u2082 : (n + l).ascFactorial m = b\n\u22a2 n.ascFactorial (l + m) = a * b"}, {"line": "rw [\u2190 h\u2081]", "tactic_state": "n l m a b : \u2115\nh\u2081 : n.ascFactorial l = a\nh\u2082 : (n + l).ascFactorial m = b\n\u22a2 n.ascFactorial (l + m) = n.ascFactorial l * b"}, {"line": "rw [\u2190 h\u2082]", "tactic_state": "n l m a b : \u2115\nh\u2081 : n.ascFactorial l = a\nh\u2082 : (n + l).ascFactorial m = b\n\u22a2 n.ascFactorial (l + m) = n.ascFactorial l * (n + l).ascFactorial m"}, {"line": "symm", "tactic_state": "n l m a b : \u2115\nh\u2081 : n.ascFactorial l = a\nh\u2082 : (n + l).ascFactorial m = b\n\u22a2 n.ascFactorial l * (n + l).ascFactorial m = n.ascFactorial (l + m)"}, {"line": "apply ascFactorial_mul_ascFactorial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MinFacHelper.one_lt {n k : \u2115} (h : MinFacHelper n k) : 1 < n := by\n  have : 2 < minFac n := h.1.trans_le h.2.2\n  obtain rfl | h := n.eq_zero_or_pos\n  \u00b7 contradiction\n  rcases (succ_le_of_lt h).eq_or_lt with rfl|h\n  \u00b7 simp_all\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/NormNum/Prime.lean", "context": {"open": ["Nat Qq Lean Meta"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nMinFacHelper : x\u271d\nn k : \u2115\nh : sorry\n\u22a2 1 < n"}, {"line": "have : 2 < minFac n := h.1.trans_le h.2.2", "tactic_state": "x\u271d : Sort u_1\nMinFacHelper : x\u271d\nn k : \u2115\nh : sorry\nthis : 2 < n.minFac\n\u22a2 1 < n"}, {"line": "obtain rfl | h := n.eq_zero_or_pos", "tactic_state": "case inl\nx\u271d : Sort u_1\nMinFacHelper : x\u271d\nk : \u2115\nh : sorry\nthis : 2 < minFac 0\n\u22a2 1 < 0\n---\ncase inr\nx\u271d : Sort u_1\nMinFacHelper : x\u271d\nn k : \u2115\nh\u271d : sorry\nthis : 2 < n.minFac\nh : n > 0\n\u22a2 1 < n"}, {"line": "\u00b7 contradiction", "tactic_state": "case inr\nx\u271d : Sort u_1\nMinFacHelper : x\u271d\nn k : \u2115\nh\u271d : sorry\nthis : 2 < n.minFac\nh : n > 0\n\u22a2 1 < n"}, {"line": "rcases (succ_le_of_lt h).eq_or_lt with rfl|h", "tactic_state": "case inr.inl\nx\u271d : Sort u_1\nMinFacHelper : x\u271d\nk : \u2115\nh\u271d : sorry\nthis : 2 < (succ 0).minFac\nh : succ 0 > 0\n\u22a2 1 < succ 0\n---\ncase inr.inr\nx\u271d : Sort u_1\nMinFacHelper : x\u271d\nn k : \u2115\nh\u271d\u00b9 : sorry\nthis : 2 < n.minFac\nh\u271d : n > 0\nh : succ 0 < n\n\u22a2 1 < n"}, {"line": "\u00b7 simp_all", "tactic_state": "case inr.inr\nx\u271d : Sort u_1\nMinFacHelper : x\u271d\nn k : \u2115\nh\u271d\u00b9 : sorry\nthis : 2 < n.minFac\nh\u271d : n > 0\nh : succ 0 < n\n\u22a2 1 < n"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example : 0 \u2264 #s := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Finset.lean", "context": {"open": ["Qq Lean Meta Finset"], "variables": ["{\u03b1 : Type*} {s : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\n\u22a2 0 \u2264 s.card"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (hs : s.Nonempty) : 0 < #s := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Finset.lean", "context": {"open": ["Qq Lean Meta Finset"], "variables": ["{\u03b1 : Type*} {s : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\nhs : s.Nonempty\n\u22a2 0 < s.card"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example : 0 \u2264 Fintype.card \u03b1 := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Finset.lean", "context": {"open": ["Qq Lean Meta Finset"], "variables": ["{\u03b1 : Type*} {s : Finset \u03b1}", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\n\u22a2 0 \u2264 Fintype.card \u03b1"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example : 0 \u2264 dens s := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Finset.lean", "context": {"open": ["Qq Lean Meta Finset"], "variables": ["{\u03b1 : Type*} {s : Finset \u03b1}", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\n\u22a2 0 \u2264 s.dens"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (hs : s.Nonempty) : 0 < dens s := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Finset.lean", "context": {"open": ["Qq Lean Meta Finset"], "variables": ["{\u03b1 : Type*} {s : Finset \u03b1}", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\nhs : s.Nonempty\n\u22a2 0 < s.dens"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (hs : s.Nonempty) : dens s \u2260 0 := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Finset.lean", "context": {"open": ["Qq Lean Meta Finset"], "variables": ["{\u03b1 : Type*} {s : Finset \u03b1}", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\nhs : s.Nonempty\n\u22a2 s.dens \u2260 0"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example {G : Type*} {A : Finset G} :\n  let f := fun _ : G \u21a6 1; (\u2200 s, f s ^ 2 = 1) \u2192 0 \u2264 #A := by\n  intros\n  positivity -- Should succeed despite failing to prove `A` is nonempty.\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Finset.lean", "context": {"open": ["Qq Lean Meta Finset"], "variables": ["{\u03b1 : Type*} {s : Finset \u03b1}", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\nG : Type u_2\nA : Finset G\n\u22a2 let f := fun x => 1;\n  (\u2200 (s : G), f s ^ 2 = 1) \u2192 0 \u2264 A.card"}, {"line": "intros", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\nG : Type u_2\nA : Finset G\nf\u271d : G \u2192 \u2115 := fun x => 1\na\u271d : \u2200 (s : G), f\u271d s ^ 2 = 1\n\u22a2 0 \u2264 A.card"}, {"line": "positivity -- Should succeed despite failing to prove `A` is nonempty.", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma ite_pos [LT \u03b1] (ha : 0 < a) (hb : 0 < b) : 0 < ite p a b := by\n  by_cases p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Basic.lean", "context": {"open": ["Lean Meta Qq Function"], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1] (p : Prop) [Decidable p] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Zero \u03b1\np : Prop\ninst\u271d\u00b9 : Decidable p\na b : \u03b1\ninst\u271d : LT \u03b1\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < if p then a else b"}, {"line": "by_cases p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma ite_nonneg [LE \u03b1] (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 ite p a b := by\n  by_cases p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Basic.lean", "context": {"open": ["Lean Meta Qq Function"], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1] (p : Prop) [Decidable p] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Zero \u03b1\np : Prop\ninst\u271d\u00b9 : Decidable p\na b : \u03b1\ninst\u271d : LE \u03b1\nha : 0 \u2264 a\nhb : 0 \u2264 b\n\u22a2 0 \u2264 if p then a else b"}, {"line": "by_cases p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma ite_ne_zero (ha : a \u2260 0) (hb : b \u2260 0) : ite p a b \u2260 0 := by by_cases p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Basic.lean", "context": {"open": ["Lean Meta Qq Function"], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1] (p : Prop) [Decidable p] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Zero \u03b1\np : Prop\ninst\u271d : Decidable p\na b : \u03b1\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 (if p then a else b) \u2260 0"}, {"line": "by_cases p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "example (hq : 0 < q) : 0 < q.num := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Basic.lean", "context": {"open": ["Lean Meta Qq Function", "NNRat"], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1] (p : Prop) [Decidable p] {a b : \u03b1}", "{R : Type*} [LinearOrder R] {a b c : R}", "{q : \u211a\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Zero \u03b1\np : Prop\ninst\u271d\u00b9 : Decidable p\na\u271d b\u271d : \u03b1\nR : Type u_2\ninst\u271d : LinearOrder R\na b c : R\nq : \u211a\u22650\nhq : 0 < q\n\u22a2 0 < q.num"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (hq : q \u2260 0) : q.num \u2260 0 := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Basic.lean", "context": {"open": ["Lean Meta Qq Function", "NNRat"], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1] (p : Prop) [Decidable p] {a b : \u03b1}", "{R : Type*} [LinearOrder R] {a b c : R}", "{q : \u211a\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Zero \u03b1\np : Prop\ninst\u271d\u00b9 : Decidable p\na\u271d b\u271d : \u03b1\nR : Type u_2\ninst\u271d : LinearOrder R\na b c : R\nq : \u211a\u22650\nhq : q \u2260 0\n\u22a2 q.num \u2260 0"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example : 0 < q.den := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Positivity/Basic.lean", "context": {"open": ["Lean Meta Qq Function", "NNRat"], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1] (p : Prop) [Decidable p] {a b : \u03b1}", "{R : Type*} [LinearOrder R] {a b c : R}", "{q : \u211a\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Zero \u03b1\np : Prop\ninst\u271d\u00b9 : Decidable p\na\u271d b\u271d : \u03b1\nR : Type u_2\ninst\u271d : LinearOrder R\na b c : R\nq : \u211a\u22650\n\u22a2 0 < q.den"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_pf_add_lt (a\u2081 : R) (_ : a\u2082 + b = c) : (a\u2081 + a\u2082) + b = a\u2081 + c := by simp [*, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na\u2082 b c a\u2081 : R\nx\u271d : a\u2082 + b = c\n\u22a2 a\u2081 + a\u2082 + b = a\u2081 + c"}, {"line": "simp [*, add_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_mul (a : R) : (nat_lit 1).rawCast * a = a := by simp [Nat.rawCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 Nat.rawCast 1 * a = a"}, {"line": "simp [Nat.rawCast]", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 1 * a = a"}]}
{"declaration": "theorem mul_one (a : R) : a * (nat_lit 1).rawCast = a := by simp [Nat.rawCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 a * Nat.rawCast 1 = a"}, {"line": "simp [Nat.rawCast]", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 a * 1 = a"}]}
{"declaration": "theorem mul_zero (a : R) : a * 0 = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 a * 0 = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_mul (b : R) : 0 * b = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nb : R\n\u22a2 0 * b = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_nat (n) : ((Nat.rawCast n : \u2115) : R) = Nat.rawCast n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nn : \u2115\n\u22a2 \u2191n.rawCast = n.rawCast"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_zero {R} [Ring R] : -(0 : R) = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d : Ring R\n\u22a2 -0 = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_prod_atom (a : R) (b) : a ^ b = (a + 0) ^ b * (nat_lit 1).rawCast := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\nb : \u2115\n\u22a2 a ^ b = (a + 0) ^ b * Nat.rawCast 1"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\nb : \u2115\n\u22a2 a ^ b = (a + 0) ^ b * 1"}]}
{"declaration": "theorem pow_atom (a : R) (b) : a ^ b = a ^ b * (nat_lit 1).rawCast + 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\nb : \u2115\n\u22a2 a ^ b = a ^ b * Nat.rawCast 1 + 0"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\nb : \u2115\n\u22a2 a ^ b = a ^ b * 1 + 0"}]}
{"declaration": "theorem pow_one (a : R) : a ^ nat_lit 1 = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 a ^ 1 = a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_one (k : \u2115) : k.rawCast = (nat_lit 1).rawCast * k := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\n\u22a2 k.rawCast = Nat.rawCast 1 * k"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_one_cast (a : R) : a ^ (nat_lit 1).rawCast = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 a ^ Nat.rawCast 1 = a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_zero (a : R) : a ^ 0 = (nat_lit 1).rawCast + 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 a ^ 0 = Nat.rawCast 1 + 0"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 1 = 1 + 0"}]}
{"declaration": "theorem toProd_pf (p : (a : R) = a') :\n    a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast := by simp [*]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na a' : R\np : a = a'\n\u22a2 a = a' ^ Nat.rawCast 1 * Nat.rawCast 1"}, {"line": "simp [*]", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na a' : R\np : a = a'\n\u22a2 a' = a' * 1"}]}
{"declaration": "theorem atom_pf (a : R) : a = a ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0 := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na : R\n\u22a2 a = a * 1 + 0"}]}
{"declaration": "theorem atom_pf' (p : (a : R) = a') :\n    a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0 := by simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Basic.lean", "context": {"open": ["Mathlib.Meta Qq NormNum Lean.Meta AtomM", "Lean (MetaM Expr mkRawNatLit)"], "variables": ["{u : Lean.Level} {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)}", "{u : Lean.Level}", "{\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) {R : Type*} [CommSemiring R]", "{a a' a\u2081 a\u2082 a\u2083 b b' b\u2081 b\u2082 b\u2083 c c\u2081 c\u2082 : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na a' : R\np : a = a'\n\u22a2 a = a' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0"}, {"line": "simp [*]", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\na a' : R\np : a = a'\n\u22a2 a' = a' * 1 + 0"}]}
{"declaration": "theorem le_congr {\u03b1 : Type*} [LE \u03b1] {a b c d : \u03b1} (h1 : a = b) (h2 : b \u2264 c) (h3 : d = c) :\n    a \u2264 d := by\n  rwa [h1, h3]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Compare.lean", "context": {"open": ["Lean Qq Meta"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\na b c d : \u03b1\nh1 : a = b\nh2 : b \u2264 c\nh3 : d = c\n\u22a2 a \u2264 d"}, {"line": "rwa [h1, h3]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_congr {\u03b1 : Type*} [LT \u03b1] {a b c d : \u03b1} (h1 : a = b) (h2 : b < c) (h3 : d = c) :\n    a < d := by\n  rwa [h1, h3]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/Compare.lean", "context": {"open": ["Lean Qq Meta"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b c d : \u03b1\nh1 : a = b\nh2 : b < c\nh3 : d = c\n\u22a2 a < d"}, {"line": "rwa [h1, h3]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_rawCast_0 : (Nat.rawCast 0 : R) = 0 := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/RingNF.lean", "context": {"open": ["Lean", "Qq Meta", "Ring"], "variables": ["{u : Level} {arg : Q(Type u)} {s\u03b1 : Q(CommSemiring $arg)} {a : Q($arg)}", "{R : Type*} [CommSemiring R] {n d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\n\u22a2 Nat.rawCast 0 = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_rawCast_1 : (Nat.rawCast 1 : R) = 1 := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/RingNF.lean", "context": {"open": ["Lean", "Qq Meta", "Ring"], "variables": ["{u : Level} {arg : Q(Type u)} {s\u03b1 : Q(CommSemiring $arg)} {a : Q($arg)}", "{R : Type*} [CommSemiring R] {n d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\n\u22a2 Nat.rawCast 1 = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem int_rawCast_neg {R} [Ring R] : (Int.rawCast (.negOfNat n) : R) = -Nat.rawCast n := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/RingNF.lean", "context": {"open": ["Lean", "Qq Meta", "Ring"], "variables": ["{u : Level} {arg : Q(Type u)} {s\u03b1 : Q(CommSemiring $arg)} {a : Q($arg)}", "{R : Type*} [CommSemiring R] {n d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR : Type u_2\ninst\u271d : Ring R\n\u22a2 (Int.negOfNat n).rawCast = -n.rawCast"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rat_rawCast_pos {R} [DivisionRing R] :\n    (Rat.rawCast (.ofNat n) d : R) = Nat.rawCast n / Nat.rawCast d := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/RingNF.lean", "context": {"open": ["Lean", "Qq Meta", "Ring"], "variables": ["{u : Level} {arg : Q(Type u)} {s\u03b1 : Q(CommSemiring $arg)} {a : Q($arg)}", "{R : Type*} [CommSemiring R] {n d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n d : \u2115\nR : Type u_2\ninst\u271d : DivisionRing R\n\u22a2 Rat.rawCast (Int.ofNat n) d = n.rawCast / d.rawCast"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rat_rawCast_neg {R} [DivisionRing R] :\n    (Rat.rawCast (.negOfNat n) d : R) = Int.rawCast (.negOfNat n) / Nat.rawCast d := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Tactic/Ring/RingNF.lean", "context": {"open": ["Lean", "Qq Meta", "Ring"], "variables": ["{u : Level} {arg : Q(Type u)} {s\u03b1 : Q(CommSemiring $arg)} {a : Q($arg)}", "{R : Type*} [CommSemiring R] {n d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n d : \u2115\nR : Type u_2\ninst\u271d : DivisionRing R\n\u22a2 Rat.rawCast (Int.negOfNat n) d = (Int.negOfNat n).rawCast / d.rawCast"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_prod_subset (W : Clopens (X \u00d7 Y)) {a : X \u00d7 Y} (h : a \u2208 W) :\n    \u2203 U : Clopens X, a.1 \u2208 U \u2227 \u2203 V : Clopens Y, a.2 \u2208 V \u2227 U \u00d7\u02e2 V \u2264 W := by\n  have hp : Continuous (fun y : Y \u21a6 (a.1, y)) := .prodMk_right _\n  let V : Set Y := {y | (a.1, y) \u2208 W}\n  have hV : IsCompact V := (W.2.1.preimage hp).isCompact\n  let U : Set X := {x | MapsTo (Prod.mk x) V W}\n  have hUV : U \u00d7\u02e2 V \u2286 W := fun \u27e8_, _\u27e9 hw \u21a6 hw.1 hw.2\n  exact \u27e8\u27e8U, (ContinuousMap.isClopen_setOf_mapsTo hV W.2).preimage\n    (ContinuousMap.id (X \u00d7 Y)).curry.2\u27e9, by simp [U, V, MapsTo], \u27e8V, W.2.preimage hp\u27e9, h, hUV\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClopenBox.lean", "context": {"open": ["Function Set Filter TopologicalSpace", "scoped Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [CompactSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : CompactSpace Y\nW : Clopens (X \u00d7 Y)\na : X \u00d7 Y\nh : a \u2208 W\n\u22a2 \u2203 U, a.1 \u2208 U \u2227 \u2203 V, a.2 \u2208 V \u2227 U \u00d7\u02e2 V \u2264 W"}, {"line": "have hp : Continuous (fun y : Y \u21a6 (a.1, y)) := .prodMk_right _", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : CompactSpace Y\nW : Clopens (X \u00d7 Y)\na : X \u00d7 Y\nh : a \u2208 W\nhp : sorry\n\u22a2 \u2203 U, a.1 \u2208 U \u2227 \u2203 V, a.2 \u2208 V \u2227 U \u00d7\u02e2 V \u2264 W"}, {"line": "let V : Set Y := {y | (a.1, y) \u2208 W}", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : CompactSpace Y\nW : Clopens (X \u00d7 Y)\na : X \u00d7 Y\nh : a \u2208 W\nhp : sorry\nV : Set Y := {y | (a.1, y) \u2208 W}\n\u22a2 \u2203 U, a.1 \u2208 U \u2227 \u2203 V, a.2 \u2208 V \u2227 U \u00d7\u02e2 V \u2264 W"}, {"line": "have hV : IsCompact V := (W.2.1.preimage hp).isCompact", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : CompactSpace Y\nW : Clopens (X \u00d7 Y)\na : X \u00d7 Y\nh : a \u2208 W\nhp : sorry\nV : Set Y := {y | (a.1, y) \u2208 W}\nhV : sorry\n\u22a2 \u2203 U, a.1 \u2208 U \u2227 \u2203 V, a.2 \u2208 V \u2227 U \u00d7\u02e2 V \u2264 W"}, {"line": "let U : Set X := {x | MapsTo (Prod.mk x) V W}", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : CompactSpace Y\nW : Clopens (X \u00d7 Y)\na : X \u00d7 Y\nh : a \u2208 W\nhp : sorry\nV : Set Y := {y | (a.1, y) \u2208 W}\nhV : sorry\nU : Set X := {x | MapsTo (Prod.mk x) V \u2191W}\n\u22a2 \u2203 U, a.1 \u2208 U \u2227 \u2203 V, a.2 \u2208 V \u2227 U \u00d7\u02e2 V \u2264 W"}, {"line": "have hUV : U \u00d7\u02e2 V \u2286 W := fun \u27e8_, _\u27e9 hw \u21a6 hw.1 hw.2", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : CompactSpace Y\nW : Clopens (X \u00d7 Y)\na : X \u00d7 Y\nh : a \u2208 W\nhp : sorry\nV : Set Y := {y | (a.1, y) \u2208 W}\nhV : sorry\nU : Set X := {x | MapsTo (Prod.mk x) V \u2191W}\nhUV : U \u00d7\u02e2 V \u2286 \u2191W\n\u22a2 \u2203 U, a.1 \u2208 U \u2227 \u2203 V, a.2 \u2208 V \u2227 U \u00d7\u02e2 V \u2264 W"}, {"line": "exact \u27e8\u27e8U, (ContinuousMap.isClopen_setOf_mapsTo hV W.2).preimage\n    (ContinuousMap.id (X \u00d7 Y)).curry.2\u27e9, by simp [U, V, MapsTo], \u27e8V, W.2.preimage hp\u27e9, h, hUV\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_of_mem_irreducibleComponents (s) (H : s \u2208 irreducibleComponents X) :\n    IsClosed s := by\n  rw [\u2190 closure_eq_iff_isClosed]\n  rw [eq_comm]\n  exact subset_closure.antisymm (H.2 H.1.closure subset_closure)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Irreducible.lean", "context": {"open": ["Set Topology"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nH : s \u2208 irreducibleComponents X\n\u22a2 IsClosed s"}, {"line": "rw [\u2190 closure_eq_iff_isClosed]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nH : s \u2208 irreducibleComponents X\n\u22a2 closure s = s"}, {"line": "rw [eq_comm]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nH : s \u2208 irreducibleComponents X\n\u22a2 s = closure s"}, {"line": "exact subset_closure.antisymm (H.2 H.1.closure subset_closure)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_preirreducible_inter [PreirreducibleSpace X] :\n    IsOpen s \u2192 IsOpen t \u2192 s.Nonempty \u2192 t.Nonempty \u2192 (s \u2229 t).Nonempty := by\n  simpa only [univ_inter,univ_subset_iff] using\n    @PreirreducibleSpace.isPreirreducible_univ X _ _ s t\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Irreducible.lean", "context": {"open": ["Set Topology"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ns t : Set X\ninst\u271d : PreirreducibleSpace X\n\u22a2 IsOpen s \u2192 IsOpen t \u2192 s.Nonempty \u2192 t.Nonempty \u2192 (s \u2229 t).Nonempty"}, {"line": "simpa only [univ_inter,univ_subset_iff] using\n    @PreirreducibleSpace.isPreirreducible_univ X _ _ s t", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPreirreducible.image (H : IsPreirreducible s) (f : X \u2192 Y) (hf : ContinuousOn f s) :\n    IsPreirreducible (f '' s) := by\n  rintro u v hu hv \u27e8_, \u27e8\u27e8x, hx, rfl\u27e9, hxu\u27e9\u27e9 \u27e8_, \u27e8\u27e8y, hy, rfl\u27e9, hyv\u27e9\u27e9\n  rw [\u2190 mem_preimage] at hxu hyv\n  rcases continuousOn_iff'.1 hf u hu with \u27e8u', hu', u'_eq\u27e9\n  rcases continuousOn_iff'.1 hf v hv with \u27e8v', hv', v'_eq\u27e9\n  have := H u' v' hu' hv'\n  rw [inter_comm s u'] at this\n  rw [\u2190 u'_eq] at this\n  rw [inter_comm s v'] at this\n  rw [\u2190 v'_eq] at this\n  rcases this \u27e8x, hxu, hx\u27e9 \u27e8y, hyv, hy\u27e9 with \u27e8x, hxs, hxu', hxv'\u27e9\n  refine \u27e8f x, mem_image_of_mem f hxs, ?_, ?_\u27e9\n  all_goals\n    rw [\u2190 mem_preimage]\n    apply mem_of_mem_inter_left\n    show x \u2208 _ \u2229 s\n    simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Irreducible.lean", "context": {"open": ["Set Topology"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\n\u22a2 IsPreirreducible (f '' s)"}, {"line": "rintro u v hu hv \u27e8_, \u27e8\u27e8x, hx, rfl\u27e9, hxu\u27e9\u27e9 \u27e8_, \u27e8\u27e8y, hy, rfl\u27e9, hyv\u27e9\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx : X\nhx : x \u2208 s\nhxu : f x \u2208 u\ny : X\nhy : y \u2208 s\nhyv : f y \u2208 v\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [\u2190 mem_preimage] at hxu hyv", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx : X\nhx : x \u2208 s\nhxu : x \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rcases continuousOn_iff'.1 hf u hu with \u27e8u', hu', u'_eq\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx : X\nhx : x \u2208 s\nhxu : x \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rcases continuousOn_iff'.1 hf v hv with \u27e8v', hv', v'_eq\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx : X\nhx : x \u2208 s\nhxu : x \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set X\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "have := H u' v' hu' hv'", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx : X\nhx : x \u2208 s\nhxu : x \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set X\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nthis : (s \u2229 u').Nonempty \u2192 (s \u2229 v').Nonempty \u2192 (s \u2229 (u' \u2229 v')).Nonempty\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [inter_comm s u'] at this", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx : X\nhx : x \u2208 s\nhxu : x \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set X\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nthis : (u' \u2229 s).Nonempty \u2192 (s \u2229 v').Nonempty \u2192 (s \u2229 (u' \u2229 v')).Nonempty\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [\u2190 u'_eq] at this", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx : X\nhx : x \u2208 s\nhxu : x \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set X\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nthis : (f \u207b\u00b9' u \u2229 s).Nonempty \u2192 (s \u2229 v').Nonempty \u2192 (s \u2229 (u' \u2229 v')).Nonempty\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [inter_comm s v'] at this", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx : X\nhx : x \u2208 s\nhxu : x \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set X\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nthis : (f \u207b\u00b9' u \u2229 s).Nonempty \u2192 (v' \u2229 s).Nonempty \u2192 (s \u2229 (u' \u2229 v')).Nonempty\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [\u2190 v'_eq] at this", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx : X\nhx : x \u2208 s\nhxu : x \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set X\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nthis : (f \u207b\u00b9' u \u2229 s).Nonempty \u2192 (f \u207b\u00b9' v \u2229 s).Nonempty \u2192 (s \u2229 (u' \u2229 v')).Nonempty\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rcases this \u27e8x, hxu, hx\u27e9 \u27e8y, hyv, hy\u27e9 with \u27e8x, hxs, hxu', hxv'\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx\u271d : X\nhx : x\u271d \u2208 s\nhxu : x\u271d \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set X\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nthis : (f \u207b\u00b9' u \u2229 s).Nonempty \u2192 (f \u207b\u00b9' v \u2229 s).Nonempty \u2192 (s \u2229 (u' \u2229 v')).Nonempty\nx : X\nhxs : x \u2208 s\nhxu' : x \u2208 u'\nhxv' : x \u2208 v'\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "refine \u27e8f x, mem_image_of_mem f hxs, ?_, ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_1\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx\u271d : X\nhx : x\u271d \u2208 s\nhxu : x\u271d \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set X\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nthis : (f \u207b\u00b9' u \u2229 s).Nonempty \u2192 (f \u207b\u00b9' v \u2229 s).Nonempty \u2192 (s \u2229 (u' \u2229 v')).Nonempty\nx : X\nhxs : x \u2208 s\nhxu' : x \u2208 u'\nhxv' : x \u2208 v'\n\u22a2 f x \u2208 u\n---\ncase intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_2\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nH : IsPreirreducible s\nf : X \u2192 Y\nhf : ContinuousOn f s\nu v : Set Y\nhu : IsOpen u\nhv : IsOpen v\nx\u271d : X\nhx : x\u271d \u2208 s\nhxu : x\u271d \u2208 f \u207b\u00b9' u\ny : X\nhy : y \u2208 s\nhyv : y \u2208 f \u207b\u00b9' v\nu' : Set X\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set X\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nthis : (f \u207b\u00b9' u \u2229 s).Nonempty \u2192 (f \u207b\u00b9' v \u2229 s).Nonempty \u2192 (s \u2229 (u' \u2229 v')).Nonempty\nx : X\nhxs : x \u2208 s\nhxu' : x \u2208 u'\nhxv' : x \u2208 v'\n\u22a2 f x \u2208 v"}, {"line": "all_goals\n    rw [\u2190 mem_preimage]\n    apply mem_of_mem_inter_left\n    show x \u2208 _ \u2229 s\n    simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Subtype.preirreducibleSpace (h : IsPreirreducible s) : PreirreducibleSpace s where\n  isPreirreducible_univ := by\n    rintro _ _ \u27e8u, hu, rfl\u27e9 \u27e8v, hv, rfl\u27e9 \u27e8\u27e8x, hxs\u27e9, -, hxu\u27e9 \u27e8\u27e8y, hys\u27e9, -, hyv\u27e9\n    rcases h u v hu hv \u27e8x, hxs, hxu\u27e9 \u27e8y, hys, hyv\u27e9 with \u27e8x, hxs, \u27e8hxu, hxv\u27e9\u27e9\n    exact \u27e8\u27e8x, hxs\u27e9, \u27e8Set.mem_univ _, \u27e8hxu, hxv\u27e9\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Irreducible.lean", "context": {"open": ["Set Topology"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nh : IsPreirreducible s\n\u22a2 IsPreirreducible univ"}, {"line": "rintro _ _ \u27e8u, hu, rfl\u27e9 \u27e8v, hv, rfl\u27e9 \u27e8\u27e8x, hxs\u27e9, -, hxu\u27e9 \u27e8\u27e8y, hys\u27e9, -, hyv\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.mk.intro.intro.mk.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nh : IsPreirreducible s\nu : Set X\nhu : IsOpen u\nv : Set X\nhv : IsOpen v\nx : X\nhxs : x \u2208 s\nhxu : \u27e8x, hxs\u27e9 \u2208 val \u207b\u00b9' u\ny : X\nhys : y \u2208 s\nhyv : \u27e8y, hys\u27e9 \u2208 val \u207b\u00b9' v\n\u22a2 (univ \u2229 (val \u207b\u00b9' u \u2229 val \u207b\u00b9' v)).Nonempty"}, {"line": "rcases h u v hu hv \u27e8x, hxs, hxu\u27e9 \u27e8y, hys, hyv\u27e9 with \u27e8x, hxs, \u27e8hxu, hxv\u27e9\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.mk.intro.intro.mk.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nh : IsPreirreducible s\nu : Set X\nhu : IsOpen u\nv : Set X\nhv : IsOpen v\nx\u271d : X\nhxs\u271d : x\u271d \u2208 s\nhxu\u271d : \u27e8x\u271d, hxs\u271d\u27e9 \u2208 val \u207b\u00b9' u\ny : X\nhys : y \u2208 s\nhyv : \u27e8y, hys\u27e9 \u2208 val \u207b\u00b9' v\nx : X\nhxs : x \u2208 s\nhxu : x \u2208 u\nhxv : x \u2208 v\n\u22a2 (univ \u2229 (val \u207b\u00b9' u \u2229 val \u207b\u00b9' v)).Nonempty"}, {"line": "exact \u27e8\u27e8x, hxs\u27e9, \u27e8Set.mem_univ _, \u27e8hxu, hxv\u27e9\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPreirreducible_iff_isClosed_union_isClosed :\n    IsPreirreducible s \u2194\n      \u2200 z\u2081 z\u2082 : Set X, IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082 := by\n  refine compl_surjective.forall.trans <| forall_congr' fun z\u2081 => compl_surjective.forall.trans <|\n    forall_congr' fun z\u2082 => ?_\n  simp only [isOpen_compl_iff]\n  simp only [\u2190 compl_union]\n  simp only [inter_compl_nonempty_iff]\n  refine forall\u2082_congr fun _ _ => ?_\n  rw [\u2190 and_imp]\n  rw [\u2190 not_or]\n  rw [not_imp_not]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Irreducible.lean", "context": {"open": ["Set Topology"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsPreirreducible s \u2194 \u2200 (z\u2081 z\u2082 : Set X), IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082"}, {"line": "refine compl_surjective.forall.trans <| forall_congr' fun z\u2081 => compl_surjective.forall.trans <|\n    forall_congr' fun z\u2082 => ?_", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns z\u2081 z\u2082 : Set X\n\u22a2 IsOpen z\u2081\u1d9c \u2192 IsOpen z\u2082\u1d9c \u2192 (s \u2229 z\u2081\u1d9c).Nonempty \u2192 (s \u2229 z\u2082\u1d9c).Nonempty \u2192 (s \u2229 (z\u2081\u1d9c \u2229 z\u2082\u1d9c)).Nonempty \u2194\n    IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082"}, {"line": "simp only [isOpen_compl_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns z\u2081 z\u2082 : Set X\n\u22a2 IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 (s \u2229 z\u2081\u1d9c).Nonempty \u2192 (s \u2229 z\u2082\u1d9c).Nonempty \u2192 (s \u2229 (z\u2081\u1d9c \u2229 z\u2082\u1d9c)).Nonempty \u2194\n    IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082"}, {"line": "simp only [\u2190 compl_union]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns z\u2081 z\u2082 : Set X\n\u22a2 IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 (s \u2229 z\u2081\u1d9c).Nonempty \u2192 (s \u2229 z\u2082\u1d9c).Nonempty \u2192 (s \u2229 (z\u2081 \u222a z\u2082)\u1d9c).Nonempty \u2194\n    IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082"}, {"line": "simp only [inter_compl_nonempty_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns z\u2081 z\u2082 : Set X\n\u22a2 IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 \u00acs \u2286 z\u2081 \u2192 \u00acs \u2286 z\u2082 \u2192 \u00acs \u2286 z\u2081 \u222a z\u2082 \u2194\n    IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082"}, {"line": "refine forall\u2082_congr fun _ _ => ?_", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns z\u2081 z\u2082 : Set X\nx\u271d\u00b9 : IsClosed z\u2081\nx\u271d : IsClosed z\u2082\n\u22a2 \u00acs \u2286 z\u2081 \u2192 \u00acs \u2286 z\u2082 \u2192 \u00acs \u2286 z\u2081 \u222a z\u2082 \u2194 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082"}, {"line": "rw [\u2190 and_imp]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns z\u2081 z\u2082 : Set X\nx\u271d\u00b9 : IsClosed z\u2081\nx\u271d : IsClosed z\u2082\n\u22a2 \u00acs \u2286 z\u2081 \u2227 \u00acs \u2286 z\u2082 \u2192 \u00acs \u2286 z\u2081 \u222a z\u2082 \u2194 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082"}, {"line": "rw [\u2190 not_or]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns z\u2081 z\u2082 : Set X\nx\u271d\u00b9 : IsClosed z\u2081\nx\u271d : IsClosed z\u2082\n\u22a2 \u00ac(s \u2286 z\u2081 \u2228 s \u2286 z\u2082) \u2192 \u00acs \u2286 z\u2081 \u222a z\u2082 \u2194 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082"}, {"line": "rw [not_imp_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIrreducible_iff_sUnion_isClosed :\n    IsIrreducible s \u2194\n      \u2200 t : Finset (Set X), (\u2200 z \u2208 t, IsClosed z) \u2192 (s \u2286 \u22c3\u2080 \u2191t) \u2192 \u2203 z \u2208 t, s \u2286 z := by\n  simp only [isIrreducible_iff_sInter]\n  refine ((@compl_involutive (Set X) _).toPerm _).finsetCongr.forall_congr fun {t} => ?_\n  simp_rw [Equiv.finsetCongr_apply, Finset.forall_mem_map, Finset.mem_map, Finset.coe_map,\n    sUnion_image, Equiv.coe_toEmbedding, Function.Involutive.coe_toPerm, isClosed_compl_iff,\n    exists_exists_and_eq_and]\n  refine forall_congr' fun _ => Iff.trans ?_ not_imp_not\n  simp only [not_exists]\n  simp only [not_and]\n  simp only [\u2190 compl_iInter\u2082]\n  simp only [\u2190 sInter_eq_biInter]\n  simp only [subset_compl_iff_disjoint_right]\n  simp only [not_disjoint_iff_nonempty_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Irreducible.lean", "context": {"open": ["Set Topology"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsIrreducible s \u2194 \u2200 (t : Finset (Set X)), (\u2200 z \u2208 t, IsClosed z) \u2192 s \u2286 \u22c3\u2080 \u2191t \u2192 \u2203 z \u2208 t, s \u2286 z"}, {"line": "simp only [isIrreducible_iff_sInter]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2200 (U : Finset (Set X)), (\u2200 u \u2208 U, IsOpen u) \u2192 (\u2200 u \u2208 U, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191U).Nonempty) \u2194\n    \u2200 (t : Finset (Set X)), (\u2200 z \u2208 t, IsClosed z) \u2192 s \u2286 \u22c3\u2080 \u2191t \u2192 \u2203 z \u2208 t, s \u2286 z"}, {"line": "refine ((@compl_involutive (Set X) _).toPerm _).finsetCongr.forall_congr fun {t} => ?_", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nt : Finset (Set X)\n\u22a2 (\u2200 u \u2208 t, IsOpen u) \u2192 (\u2200 u \u2208 t, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191t).Nonempty \u2194\n    (\u2200 z \u2208 (Equiv.finsetCongr (Function.Involutive.toPerm compl \u22ef)) t, IsClosed z) \u2192\n      s \u2286 \u22c3\u2080 \u2191((Equiv.finsetCongr (Function.Involutive.toPerm compl \u22ef)) t) \u2192\n        \u2203 z \u2208 (Equiv.finsetCongr (Function.Involutive.toPerm compl \u22ef)) t, s \u2286 z"}, {"line": "simp_rw [Equiv.finsetCongr_apply, Finset.forall_mem_map, Finset.mem_map, Finset.coe_map,\n    sUnion_image, Equiv.coe_toEmbedding, Function.Involutive.coe_toPerm, isClosed_compl_iff,\n    exists_exists_and_eq_and]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nt : Finset (Set X)\n\u22a2 (\u2200 u \u2208 t, IsOpen u) \u2192 (\u2200 u \u2208 t, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191t).Nonempty \u2194\n    (\u2200 u \u2208 t, IsOpen u) \u2192 s \u2286 \u22c3 a \u2208 \u2191t, a\u1d9c \u2192 \u2203 a \u2208 t, s \u2286 a\u1d9c"}, {"line": "refine forall_congr' fun _ => Iff.trans ?_ not_imp_not", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nt : Finset (Set X)\nx\u271d : \u2200 u \u2208 t, IsOpen u\n\u22a2 (\u2200 u \u2208 t, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191t).Nonempty \u2194 (\u00ac\u2203 a \u2208 t, s \u2286 a\u1d9c) \u2192 \u00acs \u2286 \u22c3 a \u2208 \u2191t, a\u1d9c"}, {"line": "simp only [not_exists]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nt : Finset (Set X)\nx\u271d : \u2200 u \u2208 t, IsOpen u\n\u22a2 (\u2200 u \u2208 t, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191t).Nonempty \u2194 (\u2200 (x : Set X), \u00ac(x \u2208 t \u2227 s \u2286 x\u1d9c)) \u2192 \u00acs \u2286 \u22c3 a \u2208 \u2191t, a\u1d9c"}, {"line": "simp only [not_and]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nt : Finset (Set X)\nx\u271d : \u2200 u \u2208 t, IsOpen u\n\u22a2 (\u2200 u \u2208 t, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191t).Nonempty \u2194 (\u2200 x \u2208 t, \u00acs \u2286 x\u1d9c) \u2192 \u00acs \u2286 \u22c3 a \u2208 \u2191t, a\u1d9c"}, {"line": "simp only [\u2190 compl_iInter\u2082]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nt : Finset (Set X)\nx\u271d : \u2200 u \u2208 t, IsOpen u\n\u22a2 (\u2200 u \u2208 t, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191t).Nonempty \u2194 (\u2200 x \u2208 t, \u00acs \u2286 x\u1d9c) \u2192 \u00acs \u2286 (\u22c2 i \u2208 \u2191t, i)\u1d9c"}, {"line": "simp only [\u2190 sInter_eq_biInter]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nt : Finset (Set X)\nx\u271d : \u2200 u \u2208 t, IsOpen u\n\u22a2 (\u2200 u \u2208 t, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191t).Nonempty \u2194 (\u2200 x \u2208 t, \u00acs \u2286 x\u1d9c) \u2192 \u00acs \u2286 (\u22c2\u2080 \u2191t)\u1d9c"}, {"line": "simp only [subset_compl_iff_disjoint_right]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\nt : Finset (Set X)\nx\u271d : \u2200 u \u2208 t, IsOpen u\n\u22a2 (\u2200 u \u2208 t, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191t).Nonempty \u2194 (\u2200 x \u2208 t, \u00acDisjoint s x) \u2192 \u00acDisjoint s (\u22c2\u2080 \u2191t)"}, {"line": "simp only [not_disjoint_iff_nonempty_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_closedPoints_subset (hf : Function.Injective f) (hf' : Continuous f) :\n    f \u207b\u00b9' closedPoints Y \u2286 closedPoints X := by\n  intros x hx\n  rw [mem_closedPoints_iff]\n  convert continuous_iff_isClosed.mp hf' _ hx\n  rw [\u2190 Set.image_singleton]\n  rw [Set.preimage_image_eq _ hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/JacobsonSpace.lean", "context": {"open": ["Topology TopologicalSpace"], "variables": ["(X) {Y} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y}", "{X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Function.Injective f\nhf' : Continuous f\n\u22a2 f \u207b\u00b9' closedPoints Y \u2286 closedPoints X"}, {"line": "intros x hx", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Function.Injective f\nhf' : Continuous f\nx : X\nhx : x \u2208 f \u207b\u00b9' closedPoints Y\n\u22a2 x \u2208 closedPoints X"}, {"line": "rw [mem_closedPoints_iff]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Function.Injective f\nhf' : Continuous f\nx : X\nhx : x \u2208 f \u207b\u00b9' closedPoints Y\n\u22a2 IsClosed {x}"}, {"line": "convert continuous_iff_isClosed.mp hf' _ hx", "tactic_state": "case h.e'_3\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Function.Injective f\nhf' : Continuous f\nx : X\nhx : x \u2208 f \u207b\u00b9' closedPoints Y\n\u22a2 {x} = f \u207b\u00b9' {f x}"}, {"line": "rw [\u2190 Set.image_singleton]", "tactic_state": "case h.e'_3\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Function.Injective f\nhf' : Continuous f\nx : X\nhx : x \u2208 f \u207b\u00b9' closedPoints Y\n\u22a2 {x} = f \u207b\u00b9' (f '' {x})"}, {"line": "rw [Set.preimage_image_eq _ hf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Topology.IsClosedEmbedding.preimage_closedPoints (hf : IsClosedEmbedding f) :\n    f \u207b\u00b9' closedPoints Y = closedPoints X := by\n  ext x\n  simp [mem_closedPoints_iff, \u2190 Set.image_singleton, hf.isClosed_iff_image_isClosed]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/JacobsonSpace.lean", "context": {"open": ["Topology TopologicalSpace"], "variables": ["(X) {Y} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y}", "{X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsClosedEmbedding f\n\u22a2 f \u207b\u00b9' closedPoints Y = closedPoints X"}, {"line": "ext x", "tactic_state": "case h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsClosedEmbedding f\nx : X\n\u22a2 x \u2208 f \u207b\u00b9' closedPoints Y \u2194 x \u2208 closedPoints X"}, {"line": "simp [mem_closedPoints_iff, \u2190 Set.image_singleton, hf.isClosed_iff_image_isClosed]", "tactic_state": "case h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsClosedEmbedding f\nx : X\n\u22a2 IsClosed (f '' {x}) \u2194 IsClosed {x}"}]}
{"declaration": "lemma IsRetrocompact.preimage_of_isClosedEmbedding {s : Set Y} (hf : IsClosedEmbedding f)\n    (hf' : IsCompact (range f)\u1d9c) (hs : IsRetrocompact s) : IsRetrocompact (f \u207b\u00b9' s) := by\n  rintro U hUcomp hUopen\n  have hfUopen : IsOpen (f '' U \u222a (range f)\u1d9c) := by\n    simpa [\u2190 range_diff_image hf.injective, sdiff_eq, compl_inter, union_comm]\n      using (hf.isClosedMap _ hUopen.isClosed_compl).isOpen_compl\n  have hfUcomp : IsCompact (f '' U \u222a (range f)\u1d9c) := (hUcomp.image hf.continuous).union hf'\n  simpa [inter_union_distrib_left, inter_left_comm, inter_eq_right.2 (image_subset_range ..),\n    hf.isCompact_iff, image_preimage_inter] using (hs hfUcomp hfUopen).inter_left hf.isClosed_range\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructible.lean", "context": {"open": ["Set TopologicalSpace Topology", "scoped Set.Notation"], "variables": ["{\u03b9 : Sort*} {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y}", "[T2Space X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d : T2Space X\ns : Set Y\nhf : IsClosedEmbedding f\nhf' : IsCompact (range f)\u1d9c\nhs : IsRetrocompact s\n\u22a2 IsRetrocompact (f \u207b\u00b9' s)"}, {"line": "rintro U hUcomp hUopen", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d : T2Space X\ns : Set Y\nhf : IsClosedEmbedding f\nhf' : IsCompact (range f)\u1d9c\nhs : IsRetrocompact s\nU : Set X\nhUcomp : IsCompact U\nhUopen : IsOpen U\n\u22a2 IsCompact (f \u207b\u00b9' s \u2229 U)"}, {"line": "have hfUopen : IsOpen (f '' U \u222a (range f)\u1d9c) := sorry", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d : T2Space X\ns : Set Y\nhf : IsClosedEmbedding f\nhf' : IsCompact (range f)\u1d9c\nhs : IsRetrocompact s\nU : Set X\nhUcomp : IsCompact U\nhUopen : IsOpen U\nhfUopen : sorry\n\u22a2 IsCompact (f \u207b\u00b9' s \u2229 U)"}, {"line": "have hfUcomp : IsCompact (f '' U \u222a (range f)\u1d9c) := (hUcomp.image hf.continuous).union hf'", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d : T2Space X\ns : Set Y\nhf : IsClosedEmbedding f\nhf' : IsCompact (range f)\u1d9c\nhs : IsRetrocompact s\nU : Set X\nhUcomp : IsCompact U\nhUopen : IsOpen U\nhfUopen : sorry\nhfUcomp : sorry\n\u22a2 IsCompact (f \u207b\u00b9' s \u2229 U)"}, {"line": "simpa [inter_union_distrib_left, inter_left_comm, inter_eq_right.2 (image_subset_range ..),\n    hf.isCompact_iff, image_preimage_inter] using (hs hfUcomp hfUopen).inter_left hf.isClosed_range", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLocallyConstructible.preimage_of_isOpenEmbedding {s : Set Y}\n    (hs : IsLocallyConstructible s) (hf : IsOpenEmbedding f) :\n    IsLocallyConstructible (f \u207b\u00b9' s) := by\n  intro x\n  obtain \u27e8U, hxU, hU, H\u27e9 := hs (f x)\n  exact \u27e8f \u207b\u00b9' U, hf.continuous.continuousAt.preimage_mem_nhds hxU, hU.preimage hf.continuous,\n    (H.preimage_of_isOpenEmbedding (hf.restrictPreimage _) :)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructible.lean", "context": {"open": ["Set TopologicalSpace Topology", "scoped Set.Notation"], "variables": ["{\u03b9 : Sort*} {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y}", "[T2Space X]", "[CompactSpace X] {P : \u2200 s : Set X, IsConstructible s \u2192 Prop} {B : Set (Set X)}", "[QuasiSeparatedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : CompactSpace X\ninst\u271d : QuasiSeparatedSpace X\ns : Set Y\nhs : IsLocallyConstructible s\nhf : IsOpenEmbedding f\n\u22a2 IsLocallyConstructible (f \u207b\u00b9' s)"}, {"line": "intro x", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : CompactSpace X\ninst\u271d : QuasiSeparatedSpace X\ns : Set Y\nhs : IsLocallyConstructible s\nhf : IsOpenEmbedding f\nx : X\n\u22a2 \u2203 U \u2208 nhds x, IsOpen U \u2227 IsConstructible (Subtype.val \u207b\u00b9' (f \u207b\u00b9' s))"}, {"line": "obtain \u27e8U, hxU, hU, H\u27e9 := hs (f x)", "tactic_state": "case intro.intro.intro\nX : Type u_2\nY : Type u_3\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : CompactSpace X\ninst\u271d : QuasiSeparatedSpace X\ns : Set Y\nhs : IsLocallyConstructible s\nhf : IsOpenEmbedding f\nx : X\nU : Set Y\nhxU : U \u2208 nhds (f x)\nhU : IsOpen U\nH : IsConstructible (Subtype.val \u207b\u00b9' s)\n\u22a2 \u2203 U \u2208 nhds x, IsOpen U \u2227 IsConstructible (Subtype.val \u207b\u00b9' (f \u207b\u00b9' s))"}, {"line": "exact \u27e8f \u207b\u00b9' U, hf.continuous.continuousAt.preimage_mem_nhds hxU, hU.preimage hf.continuous,\n    (H.preimage_of_isOpenEmbedding (hf.restrictPreimage _) :)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nhds_subtype_eq_comap_nhdsWithin (s : Set X) (x : { x // x \u2208 s }) :\n    \ud835\udcdd x = comap (\u2191) (\ud835\udcdd[s] (x : X)) := by\n  rw [nhds_subtype]\n  rw [\u2190 comap_nhdsWithin_range]\n  rw [Subtype.range_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\ns : Set X\nx : { x // x \u2208 s }\n\u22a2 nhds x = comap Subtype.val (nhdsWithin (\u2191x) s)"}, {"line": "rw [nhds_subtype]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\ns : Set X\nx : { x // x \u2208 s }\n\u22a2 comap Subtype.val (nhds \u2191x) = comap Subtype.val (nhdsWithin (\u2191x) s)"}, {"line": "rw [\u2190 comap_nhdsWithin_range]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\ns : Set X\nx : { x // x \u2208 s }\n\u22a2 comap Subtype.val (nhdsWithin (\u2191x) (range Subtype.val)) = comap Subtype.val (nhdsWithin (\u2191x) s)"}, {"line": "rw [Subtype.range_val]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_subtype_eq_bot_iff {s t : Set X} {x : s} :\n    \ud835\udcdd[((\u2191) : s \u2192 X) \u207b\u00b9' t] x = \u22a5 \u2194 \ud835\udcdd[t] (x : X) \u2293 \ud835\udcdf s = \u22a5 := by\n  rw [inf_principal_eq_bot_iff_comap]\n  rw [nhdsWithin]\n  rw [nhdsWithin]\n  rw [comap_inf]\n  rw [comap_principal]\n  rw [nhds_induced]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\ns t : Set X\nx : \u2191s\n\u22a2 nhdsWithin x (Subtype.val \u207b\u00b9' t) = \u22a5 \u2194 nhdsWithin (\u2191x) t \u2293 principal s = \u22a5"}, {"line": "rw [inf_principal_eq_bot_iff_comap]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\ns t : Set X\nx : \u2191s\n\u22a2 nhdsWithin x (Subtype.val \u207b\u00b9' t) = \u22a5 \u2194 comap Subtype.val (nhdsWithin (\u2191x) t) = \u22a5"}, {"line": "rw [nhdsWithin]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\ns t : Set X\nx : \u2191s\n\u22a2 nhds x \u2293 principal (Subtype.val \u207b\u00b9' t) = \u22a5 \u2194 comap Subtype.val (nhdsWithin (\u2191x) t) = \u22a5"}, {"line": "rw [nhdsWithin]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\ns t : Set X\nx : \u2191s\n\u22a2 nhds x \u2293 principal (Subtype.val \u207b\u00b9' t) = \u22a5 \u2194 comap Subtype.val (nhds \u2191x \u2293 principal t) = \u22a5"}, {"line": "rw [comap_inf]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\ns t : Set X\nx : \u2191s\n\u22a2 nhds x \u2293 principal (Subtype.val \u207b\u00b9' t) = \u22a5 \u2194 comap Subtype.val (nhds \u2191x) \u2293 comap Subtype.val (principal t) = \u22a5"}, {"line": "rw [comap_principal]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\ns t : Set X\nx : \u2191s\n\u22a2 nhds x \u2293 principal (Subtype.val \u207b\u00b9' t) = \u22a5 \u2194 comap Subtype.val (nhds \u2191x) \u2293 principal (Subtype.val \u207b\u00b9' t) = \u22a5"}, {"line": "rw [nhds_induced]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_ne_subtype_eq_bot_iff {S : Set X} {x : S} :\n    \ud835\udcdd[\u2260] x = \u22a5 \u2194 \ud835\udcdd[\u2260] (x : X) \u2293 \ud835\udcdf S = \u22a5 := by\n  rw [\u2190 nhdsWithin_subtype_eq_bot_iff]\n  rw [preimage_compl]\n  rw [\u2190 image_singleton]\n  rw [Subtype.coe_injective.preimage_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\nS : Set X\nx : \u2191S\n\u22a2 nhdsWithin x {x}\u1d9c = \u22a5 \u2194 nhdsWithin \u2191x {\u2191x}\u1d9c \u2293 principal S = \u22a5"}, {"line": "rw [\u2190 nhdsWithin_subtype_eq_bot_iff]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\nS : Set X\nx : \u2191S\n\u22a2 nhdsWithin x {x}\u1d9c = \u22a5 \u2194 nhdsWithin x (Subtype.val \u207b\u00b9' {\u2191x}\u1d9c) = \u22a5"}, {"line": "rw [preimage_compl]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\nS : Set X\nx : \u2191S\n\u22a2 nhdsWithin x {x}\u1d9c = \u22a5 \u2194 nhdsWithin x (Subtype.val \u207b\u00b9' {\u2191x})\u1d9c = \u22a5"}, {"line": "rw [\u2190 image_singleton]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\nS : Set X\nx : \u2191S\n\u22a2 nhdsWithin x {x}\u1d9c = \u22a5 \u2194 nhdsWithin x (Subtype.val \u207b\u00b9' (Subtype.val '' {x}))\u1d9c = \u22a5"}, {"line": "rw [Subtype.coe_injective.preimage_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_ne_subtype_neBot_iff {S : Set X} {x : S} :\n    (\ud835\udcdd[\u2260] x).NeBot \u2194 (\ud835\udcdd[\u2260] (x : X) \u2293 \ud835\udcdf S).NeBot := by\n  rw [neBot_iff]\n  rw [neBot_iff]\n  rw [not_iff_not]\n  rw [nhds_ne_subtype_eq_bot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\nS : Set X\nx : \u2191S\n\u22a2 (nhdsWithin x {x}\u1d9c).NeBot \u2194 (nhdsWithin \u2191x {\u2191x}\u1d9c \u2293 principal S).NeBot"}, {"line": "rw [neBot_iff]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\nS : Set X\nx : \u2191S\n\u22a2 nhdsWithin x {x}\u1d9c \u2260 \u22a5 \u2194 (nhdsWithin \u2191x {\u2191x}\u1d9c \u2293 principal S).NeBot"}, {"line": "rw [neBot_iff]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\nS : Set X\nx : \u2191S\n\u22a2 nhdsWithin x {x}\u1d9c \u2260 \u22a5 \u2194 nhdsWithin \u2191x {\u2191x}\u1d9c \u2293 principal S \u2260 \u22a5"}, {"line": "rw [not_iff_not]", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\nS : Set X\nx : \u2191S\n\u22a2 nhdsWithin x {x}\u1d9c = \u22a5 \u2194 nhdsWithin \u2191x {\u2191x}\u1d9c \u2293 principal S = \u22a5"}, {"line": "rw [nhds_ne_subtype_eq_bot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem discreteTopology_subtype_iff {S : Set X} :\n    DiscreteTopology S \u2194 \u2200 x \u2208 S, \ud835\udcdd[\u2260] x \u2293 \ud835\udcdf S = \u22a5 := by\n  simp_rw [discreteTopology_iff_nhds_ne, SetCoe.forall', nhds_ne_subtype_eq_bot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : Preorder X\ninst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 DiscreteTopology \u2191S \u2194 \u2200 x \u2208 S, nhdsWithin x {x}\u1d9c \u2293 principal S = \u22a5"}, {"line": "simp_rw [discreteTopology_iff_nhds_ne, SetCoe.forall', nhds_ne_subtype_eq_bot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma continuous_bool_rng [TopologicalSpace X] {f : X \u2192 Bool} (b : Bool) :\n    Continuous f \u2194 IsClopen (f \u207b\u00b9' {b}) := by\n  rw [continuous_discrete_rng]\n  rw [Bool.forall_bool' b]\n  rw [IsClopen]\n  rw [\u2190 isOpen_compl_iff]\n  rw [\u2190 preimage_compl]\n  rw [Bool.compl_singleton]\n  rw [and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\nf : X \u2192 Bool\nb : Bool\n\u22a2 Continuous f \u2194 IsClopen (f \u207b\u00b9' {b})"}, {"line": "rw [continuous_discrete_rng]", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\nf : X \u2192 Bool\nb : Bool\n\u22a2 (\u2200 (b : Bool), IsOpen (f \u207b\u00b9' {b})) \u2194 IsClopen (f \u207b\u00b9' {b})"}, {"line": "rw [Bool.forall_bool' b]", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\nf : X \u2192 Bool\nb : Bool\n\u22a2 IsOpen (f \u207b\u00b9' {b}) \u2227 IsOpen (f \u207b\u00b9' {!b}) \u2194 IsClopen (f \u207b\u00b9' {b})"}, {"line": "rw [IsClopen]", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\nf : X \u2192 Bool\nb : Bool\n\u22a2 IsOpen (f \u207b\u00b9' {b}) \u2227 IsOpen (f \u207b\u00b9' {!b}) \u2194 IsClosed (f \u207b\u00b9' {b}) \u2227 IsOpen (f \u207b\u00b9' {b})"}, {"line": "rw [\u2190 isOpen_compl_iff]", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\nf : X \u2192 Bool\nb : Bool\n\u22a2 IsOpen (f \u207b\u00b9' {b}) \u2227 IsOpen (f \u207b\u00b9' {!b}) \u2194 IsOpen (f \u207b\u00b9' {b})\u1d9c \u2227 IsOpen (f \u207b\u00b9' {b})"}, {"line": "rw [\u2190 preimage_compl]", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\nf : X \u2192 Bool\nb : Bool\n\u22a2 IsOpen (f \u207b\u00b9' {b}) \u2227 IsOpen (f \u207b\u00b9' {!b}) \u2194 IsOpen (f \u207b\u00b9' {b}\u1d9c) \u2227 IsOpen (f \u207b\u00b9' {b})"}, {"line": "rw [Bool.compl_singleton]", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\nf : X \u2192 Bool\nb : Bool\n\u22a2 IsOpen (f \u207b\u00b9' {b}) \u2227 IsOpen (f \u207b\u00b9' {!b}) \u2194 IsOpen (f \u207b\u00b9' {!b}) \u2227 IsOpen (f \u207b\u00b9' {b})"}, {"line": "rw [and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_nhds_subtype_val {s : Set X} (x : s) : map ((\u2191) : s \u2192 X) (\ud835\udcdd x) = \ud835\udcdd[s] \u2191x := by\n  rw [IsInducing.subtypeVal.map_nhds_eq]\n  rw [Subtype.range_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set X\nx : \u2191s\n\u22a2 map Subtype.val (nhds x) = nhdsWithin (\u2191x) s"}, {"line": "rw [IsInducing.subtypeVal.map_nhds_eq]", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set X\nx : \u2191s\n\u22a2 nhdsWithin (\u2191x) (range Subtype.val) = nhdsWithin (\u2191x) s"}, {"line": "rw [Subtype.range_val]", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Topology.IsOpenEmbedding.inclusion (hst : s \u2286 t) (hs : IsOpen (t \u2193\u2229 s)) :\n    IsOpenEmbedding (inclusion hst) where\n  toIsEmbedding := .inclusion _\n  isOpen_range := by rwa [range_inclusion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\nhst : s \u2286 t\nhs : IsOpen (Subtype.val \u207b\u00b9' s)\n\u22a2 IsOpen (range (inclusion hst))"}, {"line": "rwa [range_inclusion]", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Topology.IsClosedEmbedding.inclusion (hst : s \u2286 t) (hs : IsClosed (t \u2193\u2229 s)) :\n    IsClosedEmbedding (inclusion hst) where\n  toIsEmbedding := .inclusion _\n  isClosed_range := by rwa [range_inclusion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\nhst : s \u2286 t\nhs : IsClosed (Subtype.val \u207b\u00b9' s)\n\u22a2 IsClosed (range (inclusion hst))"}, {"line": "rwa [range_inclusion]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isClosed_preimage_val {s t : Set X} : IsClosed (s \u2193\u2229 t) \u2194 s \u2229 closure (s \u2229 t) \u2286 t := by\n  rw [\u2190 closure_eq_iff_isClosed]\n  rw [IsEmbedding.subtypeVal.closure_eq_preimage_closure_image]\n  rw [\u2190 Subtype.val_injective.image_injective.eq_iff]\n  rw [Subtype.image_preimage_coe]\n  rw [Subtype.image_preimage_coe]\n  rw [subset_antisymm_iff]\n  rw [and_iff_left]\n  rw [Set.subset_inter_iff]\n  rw [and_iff_right]\n  exacts [Set.inter_subset_left, Set.subset_inter Set.inter_subset_left subset_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 IsClosed (Subtype.val \u207b\u00b9' t) \u2194 s \u2229 closure (s \u2229 t) \u2286 t"}, {"line": "rw [\u2190 closure_eq_iff_isClosed]", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 closure (Subtype.val \u207b\u00b9' t) = Subtype.val \u207b\u00b9' t \u2194 s \u2229 closure (s \u2229 t) \u2286 t"}, {"line": "rw [IsEmbedding.subtypeVal.closure_eq_preimage_closure_image]", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 Subtype.val \u207b\u00b9' closure (Subtype.val '' (Subtype.val \u207b\u00b9' t)) = Subtype.val \u207b\u00b9' t \u2194 s \u2229 closure (s \u2229 t) \u2286 t"}, {"line": "rw [\u2190 Subtype.val_injective.image_injective.eq_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 Subtype.val '' (Subtype.val \u207b\u00b9' closure (Subtype.val '' (Subtype.val \u207b\u00b9' t))) = Subtype.val '' (Subtype.val \u207b\u00b9' t) \u2194\n    s \u2229 closure (s \u2229 t) \u2286 t"}, {"line": "rw [Subtype.image_preimage_coe]", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2229 closure (Subtype.val '' (Subtype.val \u207b\u00b9' t)) = Subtype.val '' (Subtype.val \u207b\u00b9' t) \u2194 s \u2229 closure (s \u2229 t) \u2286 t"}, {"line": "rw [Subtype.image_preimage_coe]", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2229 closure (s \u2229 t) = s \u2229 t \u2194 s \u2229 closure (s \u2229 t) \u2286 t"}, {"line": "rw [subset_antisymm_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2229 closure (s \u2229 t) \u2286 s \u2229 t \u2227 s \u2229 t \u2286 s \u2229 closure (s \u2229 t) \u2194 s \u2229 closure (s \u2229 t) \u2286 t"}, {"line": "rw [and_iff_left]", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2229 closure (s \u2229 t) \u2286 s \u2229 t \u2194 s \u2229 closure (s \u2229 t) \u2286 t\n---\nX : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2229 t \u2286 s \u2229 closure (s \u2229 t)"}, {"line": "rw [Set.subset_inter_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2229 closure (s \u2229 t) \u2286 s \u2227 s \u2229 closure (s \u2229 t) \u2286 t \u2194 s \u2229 closure (s \u2229 t) \u2286 t\n---\nX : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2229 t \u2286 s \u2229 closure (s \u2229 t)"}, {"line": "rw [and_iff_right]", "tactic_state": "X : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2229 closure (s \u2229 t) \u2286 s\n---\nX : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : Preorder X\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2229 t \u2286 s \u2229 closure (s \u2229 t)"}, {"line": "exacts [Set.inter_subset_left, Set.subset_inter Set.inter_subset_left subset_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Pi.induced_precomp' {\u03b9' : Type*} (\u03c6 : \u03b9' \u2192 \u03b9) :\n    induced (fun (f : (\u2200 i, \u03c0 i)) (j : \u03b9') \u21a6 f (\u03c6 j)) Pi.topologicalSpace =\n    \u2a05 i', induced (eval (\u03c6 i')) (T (\u03c6 i')) := by\n  simp [Pi.topologicalSpace, induced_iInf, induced_compose, comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\nx\u271d : Sort u_5\nT : x\u271d\n\u03b9' : Type u_4\n\u03c6 : \u03b9' \u2192 \u03b9\n\u22a2 induced (fun f j => f (\u03c6 j)) sorry = \u2a05 i', induced (eval (\u03c6 i')) sorry"}, {"line": "simp [Pi.topologicalSpace, induced_iInf, induced_compose, comp_def]", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\nx\u271d : Sort u_5\nT : x\u271d\n\u03b9' : Type u_4\n\u03c6 : \u03b9' \u2192 \u03b9\n\u22a2 induced (fun f j => f (\u03c6 j)) (sorry ()) = \u2a05 i', induced (eval (\u03c6 i')) (sorry ())"}]}
{"declaration": "theorem pi_generateFrom_eq {\u03c0 : \u03b9 \u2192 Type*} {g : \u2200 a, Set (Set (\u03c0 a))} :\n    (@Pi.topologicalSpace \u03b9 \u03c0 fun a => generateFrom (g a)) =\n      generateFrom\n        { t | \u2203 (s : \u2200 a, Set (\u03c0 a)) (i : Finset \u03b9), (\u2200 a \u2208 i, s a \u2208 g a) \u2227 t = pi (\u2191i) s } := by\n  refine le_antisymm ?_ ?_\n  \u00b7 apply le_generateFrom\n    rintro _ \u27e8s, i, hi, rfl\u27e9\n    letI := fun a => generateFrom (g a)\n    exact isOpen_set_pi i.finite_toSet (fun a ha => GenerateOpen.basic _ (hi a ha))\n  \u00b7 classical\n    refine le_iInf fun i => coinduced_le_iff_le_induced.1 <| le_generateFrom fun s hs => ?_\n    refine GenerateOpen.basic _ \u27e8update (fun i => univ) i s, {i}, ?_\u27e9\n    simp [hs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_5\ng : (a : \u03b9) \u2192 Set (Set (\u03c0 a))\n\u22a2 Pi.topologicalSpace = generateFrom {t | \u2203 s i, (\u2200 a \u2208 i, s a \u2208 g a) \u2227 t = (\u2191i).pi s}"}, {"line": "refine le_antisymm ?_ ?_", "tactic_state": "case refine_1\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_5\ng : (a : \u03b9) \u2192 Set (Set (\u03c0 a))\n\u22a2 Pi.topologicalSpace \u2264 generateFrom {t | \u2203 s i, (\u2200 a \u2208 i, s a \u2208 g a) \u2227 t = (\u2191i).pi s}\n---\ncase refine_2\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_5\ng : (a : \u03b9) \u2192 Set (Set (\u03c0 a))\n\u22a2 generateFrom {t | \u2203 s i, (\u2200 a \u2208 i, s a \u2208 g a) \u2227 t = (\u2191i).pi s} \u2264 Pi.topologicalSpace"}, {"line": "\u00b7 apply le_generateFrom\n    rintro _ \u27e8s, i, hi, rfl\u27e9\n    letI := fun a => generateFrom (g a)\n    exact isOpen_set_pi i.finite_toSet (fun a ha => GenerateOpen.basic _ (hi a ha))", "tactic_state": "case refine_2\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_5\ng : (a : \u03b9) \u2192 Set (Set (\u03c0 a))\n\u22a2 generateFrom {t | \u2203 s i, (\u2200 a \u2208 i, s a \u2208 g a) \u2227 t = (\u2191i).pi s} \u2264 Pi.topologicalSpace"}, {"line": "\u00b7 classical\n    refine le_iInf fun i => coinduced_le_iff_le_induced.1 <| le_generateFrom fun s hs => ?_\n    refine GenerateOpen.basic _ \u27e8update (fun i => univ) i s, {i}, ?_\u27e9\n    simp [hs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem induced_to_pi {X : Type*} (f : X \u2192 \u2200 i, \u03c0 i) :\n    induced f Pi.topologicalSpace = \u2a05 i, induced (f \u00b7 i) inferInstance := by\n  simp_rw [Pi.topologicalSpace, induced_iInf, induced_compose, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03c0 : Fin (n + 1) \u2192 Type u_4\ninst\u271d : (i : Fin (n + 1)) \u2192 TopologicalSpace (\u03c0 i)\nX : Type u_5\nf : X \u2192 (i : Fin (n + 1)) \u2192 \u03c0 i\n\u22a2 induced f Pi.topologicalSpace = \u2a05 i, induced (fun x => f x i) inferInstance"}, {"line": "simp_rw [Pi.topologicalSpace, induced_iInf, induced_compose, Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_sigma_iff {s : Set (Sigma \u03c3)} : IsOpen s \u2194 \u2200 i, IsOpen (Sigma.mk i \u207b\u00b9' s) := by\n  rw [isOpen_iSup_iff]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[Finite \u03b9] [\u2200 i, DiscreteTopology (\u03c0 i)]", "{\u03b9 \u03ba : Type*} {\u03c3 : \u03b9 \u2192 Type*} {\u03c4 : \u03ba \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\ns : Set (Sigma \u03c3)\n\u22a2 IsOpen s \u2194 \u2200 (i : \u03b9), IsOpen (Sigma.mk i \u207b\u00b9' s)"}, {"line": "rw [isOpen_iSup_iff]", "tactic_state": "\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\ns : Set (Sigma \u03c3)\n\u22a2 (\u2200 (i : \u03b9), IsOpen s) \u2194 \u2200 (i : \u03b9), IsOpen (Sigma.mk i \u207b\u00b9' s)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_sigma_iff {s : Set (Sigma \u03c3)} : IsClosed s \u2194 \u2200 i, IsClosed (Sigma.mk i \u207b\u00b9' s) := by\n  simp only [\u2190 isOpen_compl_iff]\n  simp only [isOpen_sigma_iff]\n  simp only [preimage_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[Finite \u03b9] [\u2200 i, DiscreteTopology (\u03c0 i)]", "{\u03b9 \u03ba : Type*} {\u03c3 : \u03b9 \u2192 Type*} {\u03c4 : \u03ba \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\ns : Set (Sigma \u03c3)\n\u22a2 IsClosed s \u2194 \u2200 (i : \u03b9), IsClosed (Sigma.mk i \u207b\u00b9' s)"}, {"line": "simp only [\u2190 isOpen_compl_iff]", "tactic_state": "\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\ns : Set (Sigma \u03c3)\n\u22a2 IsOpen s\u1d9c \u2194 \u2200 (i : \u03b9), IsOpen (Sigma.mk i \u207b\u00b9' s)\u1d9c"}, {"line": "simp only [isOpen_sigma_iff]", "tactic_state": "\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\ns : Set (Sigma \u03c3)\n\u22a2 (\u2200 (i : \u03b9), IsOpen (Sigma.mk i \u207b\u00b9' s\u1d9c)) \u2194 \u2200 (i : \u03b9), IsOpen (Sigma.mk i \u207b\u00b9' s)\u1d9c"}, {"line": "simp only [preimage_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_sigma_fst_preimage (s : Set \u03b9) : IsOpen (Sigma.fst \u207b\u00b9' s : Set (\u03a3 a, \u03c3 a)) := by\n  rw [\u2190 biUnion_of_singleton s]\n  rw [preimage_iUnion\u2082]\n  simp only [\u2190 range_sigmaMk]\n  exact isOpen_biUnion fun _ _ => isOpen_range_sigmaMk\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[Finite \u03b9] [\u2200 i, DiscreteTopology (\u03c0 i)]", "{\u03b9 \u03ba : Type*} {\u03c3 : \u03b9 \u2192 Type*} {\u03c4 : \u03ba \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\ns : Set \u03b9\n\u22a2 IsOpen (Sigma.fst \u207b\u00b9' s)"}, {"line": "rw [\u2190 biUnion_of_singleton s]", "tactic_state": "\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\ns : Set \u03b9\n\u22a2 IsOpen (Sigma.fst \u207b\u00b9' \u22c3 x \u2208 s, {x})"}, {"line": "rw [preimage_iUnion\u2082]", "tactic_state": "\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\ns : Set \u03b9\n\u22a2 IsOpen (\u22c3 i \u2208 s, Sigma.fst \u207b\u00b9' {i})"}, {"line": "simp only [\u2190 range_sigmaMk]", "tactic_state": "\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\ns : Set \u03b9\n\u22a2 IsOpen (\u22c3 i \u2208 s, range (Sigma.mk i))"}, {"line": "exact isOpen_biUnion fun _ _ => isOpen_range_sigmaMk", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_sigma_iff {f : Sigma \u03c3 \u2192 X} :\n    Continuous f \u2194 \u2200 i, Continuous fun a => f \u27e8i, a\u27e9 := by\n  delta instTopologicalSpaceSigma\n  rw [continuous_iSup_dom]\n  exact forall_congr' fun _ => continuous_coinduced_dom\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[Finite \u03b9] [\u2200 i, DiscreteTopology (\u03c0 i)]", "{\u03b9 \u03ba : Type*} {\u03c3 : \u03b9 \u2192 Type*} {\u03c4 : \u03ba \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\nf : Sigma \u03c3 \u2192 X\n\u22a2 Continuous f \u2194 \u2200 (i : \u03b9), Continuous fun a => f \u27e8i, a\u27e9"}, {"line": "delta instTopologicalSpaceSigma", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\nf : Sigma \u03c3 \u2192 X\n\u22a2 Continuous f \u2194 \u2200 (i : \u03b9), Continuous fun a => f \u27e8i, a\u27e9"}, {"line": "rw [continuous_iSup_dom]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\nf : Sigma \u03c3 \u2192 X\n\u22a2 (\u2200 (i : \u03b9), Continuous f) \u2194 \u2200 (i : \u03b9), Continuous fun a => f \u27e8i, a\u27e9"}, {"line": "exact forall_congr' fun _ => continuous_coinduced_dom", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpenMap_sigma {f : Sigma \u03c3 \u2192 X} : IsOpenMap f \u2194 \u2200 i, IsOpenMap fun a => f \u27e8i, a\u27e9 := by\n  simp only [isOpenMap_iff_nhds_le]\n  simp only [Sigma.forall]\n  simp only [Sigma.nhds_eq]\n  simp only [map_map]\n  simp only [comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[Finite \u03b9] [\u2200 i, DiscreteTopology (\u03c0 i)]", "{\u03b9 \u03ba : Type*} {\u03c3 : \u03b9 \u2192 Type*} {\u03c4 : \u03ba \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\nf : Sigma \u03c3 \u2192 X\n\u22a2 IsOpenMap f \u2194 \u2200 (i : \u03b9), IsOpenMap fun a => f \u27e8i, a\u27e9"}, {"line": "simp only [isOpenMap_iff_nhds_le]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\nf : Sigma \u03c3 \u2192 X\n\u22a2 (\u2200 (x : Sigma \u03c3), nhds (f x) \u2264 map f (nhds x)) \u2194\n    \u2200 (i : \u03b9) (x : \u03c3 i), nhds (f \u27e8i, x\u27e9) \u2264 map (fun a => f \u27e8i, a\u27e9) (nhds x)"}, {"line": "simp only [Sigma.forall]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\nf : Sigma \u03c3 \u2192 X\n\u22a2 (\u2200 (a : \u03b9) (b : \u03c3 a), nhds (f \u27e8a, b\u27e9) \u2264 map f (nhds \u27e8a, b\u27e9)) \u2194\n    \u2200 (i : \u03b9) (x : \u03c3 i), nhds (f \u27e8i, x\u27e9) \u2264 map (fun a => f \u27e8i, a\u27e9) (nhds x)"}, {"line": "simp only [Sigma.nhds_eq]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\nf : Sigma \u03c3 \u2192 X\n\u22a2 (\u2200 (a : \u03b9) (b : \u03c3 a), nhds (f \u27e8a, b\u27e9) \u2264 map f (map (Sigma.mk a) (nhds b))) \u2194\n    \u2200 (i : \u03b9) (x : \u03c3 i), nhds (f \u27e8i, x\u27e9) \u2264 map (fun a => f \u27e8i, a\u27e9) (nhds x)"}, {"line": "simp only [map_map]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Type u_5\n\u03c3 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c3 i)\nf : Sigma \u03c3 \u2192 X\n\u22a2 (\u2200 (a : \u03b9) (b : \u03c3 a), nhds (f \u27e8a, b\u27e9) \u2264 map (f \u2218 Sigma.mk a) (nhds b)) \u2194\n    \u2200 (i : \u03b9) (x : \u03c3 i), nhds (f \u27e8i, x\u27e9) \u2264 map (fun a => f \u27e8i, a\u27e9) (nhds x)"}, {"line": "simp only [comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ULift.isOpen_iff [TopologicalSpace X] {s : Set (ULift.{v} X)} :\n    IsOpen s \u2194 IsOpen (ULift.up \u207b\u00b9' s) := by\n  rw [ULift.topologicalSpace]\n  rw [\u2190 Equiv.ulift_apply]\n  rw [\u2190 Equiv.ulift.coinduced_symm]\n  rw [\u2190 isOpen_coinduced]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[Finite \u03b9] [\u2200 i, DiscreteTopology (\u03c0 i)]", "{\u03b9 \u03ba : Type*} {\u03c3 : \u03b9 \u2192 Type*} {\u03c4 : \u03ba \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set (ULift.{v, u_9} X)\n\u22a2 IsOpen s \u2194 IsOpen (up \u207b\u00b9' s)"}, {"line": "rw [ULift.topologicalSpace]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set (ULift.{v, u_9} X)\n\u22a2 IsOpen s \u2194 IsOpen (up \u207b\u00b9' s)"}, {"line": "rw [\u2190 Equiv.ulift_apply]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set (ULift.{v, u_9} X)\n\u22a2 IsOpen s \u2194 IsOpen (up \u207b\u00b9' s)"}, {"line": "rw [\u2190 Equiv.ulift.coinduced_symm]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set (ULift.{v, u_9} X)\n\u22a2 IsOpen s \u2194 IsOpen (up \u207b\u00b9' s)"}, {"line": "rw [\u2190 isOpen_coinduced]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ULift.isClosed_iff [TopologicalSpace X] {s : Set (ULift.{v} X)} :\n    IsClosed s \u2194 IsClosed (ULift.up \u207b\u00b9' s) := by\n  rw [\u2190 isOpen_compl_iff]\n  rw [\u2190 isOpen_compl_iff]\n  rw [isOpen_iff]\n  rw [preimage_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[Finite \u03b9] [\u2200 i, DiscreteTopology (\u03c0 i)]", "{\u03b9 \u03ba : Type*} {\u03c3 : \u03b9 \u2192 Type*} {\u03c4 : \u03ba \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set (ULift.{v, u_9} X)\n\u22a2 IsClosed s \u2194 IsClosed (up \u207b\u00b9' s)"}, {"line": "rw [\u2190 isOpen_compl_iff]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set (ULift.{v, u_9} X)\n\u22a2 IsOpen s\u1d9c \u2194 IsClosed (up \u207b\u00b9' s)"}, {"line": "rw [\u2190 isOpen_compl_iff]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set (ULift.{v, u_9} X)\n\u22a2 IsOpen s\u1d9c \u2194 IsOpen (up \u207b\u00b9' s)\u1d9c"}, {"line": "rw [isOpen_iff]", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set (ULift.{v, u_9} X)\n\u22a2 IsOpen (up \u207b\u00b9' s\u1d9c) \u2194 IsOpen (up \u207b\u00b9' s)\u1d9c"}, {"line": "rw [preimage_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpen.trans (ht : IsOpen t) (hs : IsOpen s) : IsOpen (t : Set X) := by\n  rcases isOpen_induced_iff.mp ht with \u27e8s', hs', rfl\u27e9\n  rw [Subtype.image_preimage_coe]\n  exact hs.inter hs'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[Finite \u03b9] [\u2200 i, DiscreteTopology (\u03c0 i)]", "{\u03b9 \u03ba : Type*} {\u03c3 : \u03b9 \u2192 Type*} {\u03c4 : \u03ba \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)]", "[TopologicalSpace X] {s : Set X} {t : Set s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set X\nt : Set \u2191s\nht : IsOpen t\nhs : IsOpen s\n\u22a2 IsOpen (Subtype.val '' t)"}, {"line": "rcases isOpen_induced_iff.mp ht with \u27e8s', hs', rfl\u27e9", "tactic_state": "case intro.intro\nX : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set X\nhs : IsOpen s\ns' : Set X\nhs' : IsOpen s'\nht : IsOpen (Subtype.val \u207b\u00b9' s')\n\u22a2 IsOpen (Subtype.val '' (Subtype.val \u207b\u00b9' s'))"}, {"line": "rw [Subtype.image_preimage_coe]", "tactic_state": "case intro.intro\nX : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set X\nhs : IsOpen s\ns' : Set X\nhs' : IsOpen s'\nht : IsOpen (Subtype.val \u207b\u00b9' s')\n\u22a2 IsOpen (s \u2229 s')"}, {"line": "exact hs.inter hs'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsClosed.trans (ht : IsClosed t) (hs : IsClosed s) : IsClosed (t : Set X) := by\n  rcases isClosed_induced_iff.mp ht with \u27e8s', hs', rfl\u27e9\n  rw [Subtype.image_preimage_coe]\n  exact hs.inter hs'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "scoped Set.Notation", "Additive Multiplicative", "OrderDual", "scoped Set.Notation in", "scoped Set.Notation", "scoped Relator in"], "variables": ["{X : Type u} {Y : Type v} {Z W \u03b5 \u03b6 : Type*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "[Preorder X] {x : X}", "[TopologicalSpace X]", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] {p : X \u2192 Prop}", "{s t : Set X}", "[TopologicalSpace X] [TopologicalSpace Y]", "{r : X \u2192 X \u2192 Prop} {s : Setoid X}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} {\u03ba : Type*} [TopologicalSpace X]", "[TopologicalSpace Z]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[Finite \u03b9] [\u2200 i, DiscreteTopology (\u03c0 i)]", "{\u03b9 \u03ba : Type*} {\u03c3 : \u03b9 \u2192 Type*} {\u03c4 : \u03ba \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)]", "[TopologicalSpace X] {s : Set X} {t : Set s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set X\nt : Set \u2191s\nht : IsClosed t\nhs : IsClosed s\n\u22a2 IsClosed (Subtype.val '' t)"}, {"line": "rcases isClosed_induced_iff.mp ht with \u27e8s', hs', rfl\u27e9", "tactic_state": "case intro.intro\nX : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set X\nhs : IsClosed s\ns' : Set X\nhs' : IsClosed s'\nht : IsClosed (Subtype.val \u207b\u00b9' s')\n\u22a2 IsClosed (Subtype.val '' (Subtype.val \u207b\u00b9' s'))"}, {"line": "rw [Subtype.image_preimage_coe]", "tactic_state": "case intro.intro\nX : Type u_9\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : Preorder X\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set X\nhs : IsClosed s\ns' : Set X\nhs' : IsClosed s'\nht : IsClosed (Subtype.val \u207b\u00b9' s')\n\u22a2 IsClosed (s \u2229 s')"}, {"line": "exact hs.inter hs'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Equiv.continuous_symm_iff (e : X \u2243 Y) : Continuous e.symm \u2194 IsOpenMap e := by\n  simp_rw [continuous_def, \u2190 Set.image_equiv_eq_preimage_symm, IsOpenMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Continuous.lean", "context": {"open": ["Set Filter Topology", "TopologicalSpace"], "variables": ["{X Y Z : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{f : X \u2192 Y} {s : Set X} {x : X} {y : Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ne : X \u2243 Y\n\u22a2 Continuous \u21d1e.symm \u2194 IsOpenMap \u21d1e"}, {"line": "simp_rw [continuous_def, \u2190 Set.image_equiv_eq_preimage_symm, IsOpenMap]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Equiv.isOpenMap_symm_iff (e : X \u2243 Y) : IsOpenMap e.symm \u2194 Continuous e := by\n  simp_rw [\u2190 Equiv.continuous_symm_iff, Equiv.symm_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Continuous.lean", "context": {"open": ["Set Filter Topology", "TopologicalSpace"], "variables": ["{X Y Z : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{f : X \u2192 Y} {s : Set X} {x : X} {y : Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ne : X \u2243 Y\n\u22a2 IsOpenMap \u21d1e.symm \u2194 Continuous \u21d1e"}, {"line": "simp_rw [\u2190 Equiv.continuous_symm_iff, Equiv.symm_symm]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Set.MapsTo.closure {t : Set Y} (h : MapsTo f s t)\n    (hc : Continuous f) : MapsTo f (closure s) (closure t) := by\n  simp only [MapsTo]\n  simp only [mem_closure_iff_clusterPt]\n  exact fun x hx => hx.map hc.continuousAt (tendsto_principal_principal.2 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Continuous.lean", "context": {"open": ["Set Filter Topology", "TopologicalSpace"], "variables": ["{X Y Z : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{f : X \u2192 Y} {s : Set X} {x : X} {y : Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\ns : Set X\nt : Set Y\nh : MapsTo f s t\nhc : Continuous f\n\u22a2 MapsTo f (closure s) (closure t)"}, {"line": "simp only [MapsTo]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\ns : Set X\nt : Set Y\nh : MapsTo f s t\nhc : Continuous f\n\u22a2 \u2200 \u2983x : X\u2984, x \u2208 closure s \u2192 f x \u2208 closure t"}, {"line": "simp only [mem_closure_iff_clusterPt]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\ns : Set X\nt : Set Y\nh : MapsTo f s t\nhc : Continuous f\n\u22a2 \u2200 \u2983x : X\u2984, ClusterPt x (principal s) \u2192 ClusterPt (f x) (principal t)"}, {"line": "exact fun x hx => hx.map hc.continuousAt (tendsto_principal_principal.2 h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DenseRange.subset_closure_image_preimage_of_isOpen (hf : DenseRange f) (hs : IsOpen s) :\n    s \u2286 closure (f '' (f \u207b\u00b9' s)) := by\n  rw [image_preimage_eq_inter_range]\n  exact hf.open_subset_closure_inter hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Continuous.lean", "context": {"open": ["Set Filter Topology", "TopologicalSpace"], "variables": ["{X Y Z : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{f : X \u2192 Y} {s : Set X} {x : X} {y : Y}", "{\u03b1 \u03b9 : Type*} (f : \u03b1 \u2192 X) (g : X \u2192 Y)", "{f : \u03b1 \u2192 X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b1 : Type u_4\nf : \u03b1 \u2192 X\ns : Set X\nhf : DenseRange f\nhs : IsOpen s\n\u22a2 s \u2286 closure (f '' (f \u207b\u00b9' s))"}, {"line": "rw [image_preimage_eq_inter_range]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b1 : Type u_4\nf : \u03b1 \u2192 X\ns : Set X\nhf : DenseRange f\nhs : IsOpen s\n\u22a2 s \u2286 closure (s \u2229 range f)"}, {"line": "exact hf.open_subset_closure_inter hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DenseRange.comp {g : Y \u2192 Z} {f : \u03b1 \u2192 Y} (hg : DenseRange g) (hf : DenseRange f)\n    (cg : Continuous g) : DenseRange (g \u2218 f) := by\n  rw [DenseRange]\n  rw [range_comp]\n  exact hg.dense_image cg hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Continuous.lean", "context": {"open": ["Set Filter Topology", "TopologicalSpace"], "variables": ["{X Y Z : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{f : X \u2192 Y} {s : Set X} {x : X} {y : Y}", "{\u03b1 \u03b9 : Type*} (f : \u03b1 \u2192 X) (g : X \u2192 Y)", "{f : \u03b1 \u2192 X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Y : Type u_2\nZ : Type u_3\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\n\u03b1 : Type u_4\ng : Y \u2192 Z\nf : \u03b1 \u2192 Y\nhg : DenseRange g\nhf : DenseRange f\ncg : Continuous g\n\u22a2 DenseRange (g \u2218 f)"}, {"line": "rw [DenseRange]", "tactic_state": "Y : Type u_2\nZ : Type u_3\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\n\u03b1 : Type u_4\ng : Y \u2192 Z\nf : \u03b1 \u2192 Y\nhg : DenseRange g\nhf : DenseRange f\ncg : Continuous g\n\u22a2 Dense (range (g \u2218 f))"}, {"line": "rw [range_comp]", "tactic_state": "Y : Type u_2\nZ : Type u_3\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\n\u03b1 : Type u_4\ng : Y \u2192 Z\nf : \u03b1 \u2192 Y\nhg : DenseRange g\nhf : DenseRange f\ncg : Continuous g\n\u22a2 Dense (g '' range f)"}, {"line": "exact hg.dense_image cg hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCoveringMap_iff_isCoveringMapOn_univ : IsCoveringMap f \u2194 IsCoveringMapOn f Set.univ := by\n  simp only [IsCoveringMap]\n  simp only [IsCoveringMapOn]\n  simp only [Set.mem_univ]\n  simp only [forall_true_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Covering.lean", "context": {"open": ["Bundle Topology"], "variables": ["{E X : Type*} [TopologicalSpace E] [TopologicalSpace X] (f : E \u2192 X) (s : Set X)", "{f}", "{f} {s}", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\nX : Type u_2\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : TopologicalSpace X\nf : E \u2192 X\n\u22a2 IsCoveringMap f \u2194 IsCoveringMapOn f Set.univ"}, {"line": "simp only [IsCoveringMap]", "tactic_state": "E : Type u_1\nX : Type u_2\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : TopologicalSpace X\nf : E \u2192 X\n\u22a2 (\u2200 (x : X), IsEvenlyCovered f x \u2191(f \u207b\u00b9' {x})) \u2194 IsCoveringMapOn f Set.univ"}, {"line": "simp only [IsCoveringMapOn]", "tactic_state": "E : Type u_1\nX : Type u_2\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : TopologicalSpace X\nf : E \u2192 X\n\u22a2 (\u2200 (x : X), IsEvenlyCovered f x \u2191(f \u207b\u00b9' {x})) \u2194 \u2200 x \u2208 Set.univ, IsEvenlyCovered f x \u2191(f \u207b\u00b9' {x})"}, {"line": "simp only [Set.mem_univ]", "tactic_state": "E : Type u_1\nX : Type u_2\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : TopologicalSpace X\nf : E \u2192 X\n\u22a2 (\u2200 (x : X), IsEvenlyCovered f x \u2191(f \u207b\u00b9' {x})) \u2194 \u2200 (x : X), True \u2192 IsEvenlyCovered f x \u2191(f \u207b\u00b9' {x})"}, {"line": "simp only [forall_true_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma derivedSet_union (A B : Set X) : derivedSet (A \u222a B) = derivedSet A \u222a derivedSet B := by\n  ext x\n  simp [derivedSet, \u2190 sup_principal, accPt_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DerivedSet.lean", "context": {"open": ["Filter Topology"], "variables": ["{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nA B : Set X\n\u22a2 derivedSet (A \u222a B) = derivedSet A \u222a derivedSet B"}, {"line": "ext x", "tactic_state": "case h\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA B : Set X\nx : X\n\u22a2 x \u2208 derivedSet (A \u222a B) \u2194 x \u2208 derivedSet A \u222a derivedSet B"}, {"line": "simp [derivedSet, \u2190 sup_principal, accPt_sup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Continuous.image_derivedSet {\u03b2 : Type*} [TopologicalSpace \u03b2] {A : Set X} {f : X \u2192 \u03b2}\n    (hf1 : Continuous f) (hf2 : Function.Injective f) :\n    f '' derivedSet A \u2286 derivedSet (f '' A) := by\n  intro x hx\n  simp only [Set.mem_image] at hx\n  simp only [mem_derivedSet] at hx\n  obtain \u27e8y, hy1, rfl\u27e9 := hx\n  convert hy1.map hf1.continuousAt hf2\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DerivedSet.lean", "context": {"open": ["Filter Topology"], "variables": ["{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nA : Set X\nf : X \u2192 \u03b2\nhf1 : Continuous f\nhf2 : Function.Injective f\n\u22a2 f '' derivedSet A \u2286 derivedSet (f '' A)"}, {"line": "intro x hx", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nA : Set X\nf : X \u2192 \u03b2\nhf1 : Continuous f\nhf2 : Function.Injective f\nx : \u03b2\nhx : x \u2208 f '' derivedSet A\n\u22a2 x \u2208 derivedSet (f '' A)"}, {"line": "simp only [Set.mem_image] at hx", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nA : Set X\nf : X \u2192 \u03b2\nhf1 : Continuous f\nhf2 : Function.Injective f\nx : \u03b2\nhx : \u2203 x_1 \u2208 derivedSet A, f x_1 = x\n\u22a2 x \u2208 derivedSet (f '' A)"}, {"line": "simp only [mem_derivedSet] at hx", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nA : Set X\nf : X \u2192 \u03b2\nhf1 : Continuous f\nhf2 : Function.Injective f\nx : \u03b2\nhx : \u2203 x_1, AccPt x_1 (principal A) \u2227 f x_1 = x\n\u22a2 x \u2208 derivedSet (f '' A)"}, {"line": "obtain \u27e8y, hy1, rfl\u27e9 := hx", "tactic_state": "case intro.intro\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nA : Set X\nf : X \u2192 \u03b2\nhf1 : Continuous f\nhf2 : Function.Injective f\ny : X\nhy1 : AccPt y (principal A)\n\u22a2 f y \u2208 derivedSet (f '' A)"}, {"line": "convert hy1.map hf1.continuousAt hf2", "tactic_state": "case a\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nA : Set X\nf : X \u2192 \u03b2\nhf1 : Continuous f\nhf2 : Function.Injective f\ny : X\nhy1 : AccPt y (principal A)\n\u22a2 f y \u2208 derivedSet (f '' A) \u2194 AccPt (f y) (map f (principal A))"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isClosed_iff_derivedSet_subset (A : Set X) : IsClosed A \u2194 derivedSet A \u2286 A where\n  mp h := derivedSet_subset_closure A |>.trans h.closure_subset\n  mpr h := by\n    rw [isClosed_iff_clusterPt]\n    intro a ha\n    by_contra! nh\n    have : A = A \\ {a} := by simp [nh]\n    rw [this] at ha\n    rw [\u2190 accPt_principal_iff_clusterPt] at ha\n    exact nh (h ha)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DerivedSet.lean", "context": {"open": ["Filter Topology"], "variables": ["{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\n\u22a2 IsClosed A"}, {"line": "rw [isClosed_iff_clusterPt]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\n\u22a2 \u2200 (a : X), ClusterPt a (principal A) \u2192 a \u2208 A"}, {"line": "intro a ha", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : ClusterPt a (principal A)\n\u22a2 a \u2208 A"}, {"line": "by_contra! nh", "tactic_state": "case refine_1\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : ClusterPt a (principal A)\n\u22a2 Decidable (a \u2208 A)\n---\ncase refine_2\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : ClusterPt a (principal A)\nnh : a \u2209 A\n\u22a2 False"}, {"line": "have : A = A \\ {a} := by simp [nh]", "tactic_state": "case refine_1\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : ClusterPt a (principal A)\nthis : A = A \\ {a}\n\u22a2 Decidable (a \u2208 A)\n---\ncase refine_2\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : ClusterPt a (principal A)\nnh : a \u2209 A\n\u22a2 False"}, {"line": "rw [this] at ha", "tactic_state": "case refine_1\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : ClusterPt a (principal (A \\ {a}))\nthis : A = A \\ {a}\n\u22a2 Decidable (a \u2208 A)\n---\ncase refine_2\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : ClusterPt a (principal A)\nnh : a \u2209 A\n\u22a2 False"}, {"line": "rw [\u2190 accPt_principal_iff_clusterPt] at ha", "tactic_state": "case refine_1\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : AccPt a (principal A)\nthis : A = A \\ {a}\n\u22a2 Decidable (a \u2208 A)\n---\ncase refine_2\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : ClusterPt a (principal A)\nnh : a \u2209 A\n\u22a2 False"}, {"line": "exact nh (h ha)", "tactic_state": "case refine_2\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nh : derivedSet A \u2286 A\na : X\nha : ClusterPt a (principal A)\nnh : a \u2209 A\n\u22a2 False"}]}
{"declaration": "lemma closure_eq_self_union_derivedSet (A : Set X) : closure A = A \u222a derivedSet A := by\n  ext\n  simp [closure_eq_cluster_pts, clusterPt_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DerivedSet.lean", "context": {"open": ["Filter Topology"], "variables": ["{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\n\u22a2 closure A = A \u222a derivedSet A"}, {"line": "ext", "tactic_state": "case h\nX : Type u_1\ninst\u271d : TopologicalSpace X\nA : Set X\nx\u271d : X\n\u22a2 x\u271d \u2208 closure A \u2194 x\u271d \u2208 A \u222a derivedSet A"}, {"line": "simp [closure_eq_cluster_pts, clusterPt_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma perfect_iff_eq_derivedSet {U : Set X} : Perfect U \u2194 U = derivedSet U := by\n  rw [perfect_def]\n  rw [isClosed_iff_derivedSet_subset]\n  rw [preperfect_iff_subset_derivedSet]\n  rw [\u2190 subset_antisymm_iff]\n  rw [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DerivedSet.lean", "context": {"open": ["Filter Topology"], "variables": ["{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nU : Set X\n\u22a2 Perfect U \u2194 U = derivedSet U"}, {"line": "rw [perfect_def]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nU : Set X\n\u22a2 IsClosed U \u2227 Preperfect U \u2194 U = derivedSet U"}, {"line": "rw [isClosed_iff_derivedSet_subset]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nU : Set X\n\u22a2 derivedSet U \u2286 U \u2227 Preperfect U \u2194 U = derivedSet U"}, {"line": "rw [preperfect_iff_subset_derivedSet]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nU : Set X\n\u22a2 derivedSet U \u2286 U \u2227 U \u2286 derivedSet U \u2194 U = derivedSet U"}, {"line": "rw [\u2190 subset_antisymm_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nU : Set X\n\u22a2 derivedSet U = U \u2194 U = derivedSet U"}, {"line": "rw [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsPreconnected.inter_derivedSet_nonempty [T1Space X] {U : Set X} (hs : IsPreconnected U)\n    (a b : Set X) (h : U \u2286 a \u222a b) (ha : (U \u2229 derivedSet a).Nonempty)\n    (hb : (U \u2229 derivedSet b).Nonempty) : (U \u2229 (derivedSet a \u2229 derivedSet b)).Nonempty := by\n  by_cases hu : U.Nontrivial\n  \u00b7 apply isPreconnected_closed_iff.mp hs\n    \u00b7 simp\n    \u00b7 simp\n    \u00b7 trans derivedSet U\n      \u00b7 apply hs.preperfect_of_nontrivial hu\n      \u00b7 rw [\u2190 derivedSet_union]\n        exact derivedSet_mono _ _ h\n    \u00b7 exact ha\n    \u00b7 exact hb\n  \u00b7 obtain \u27e8x, hx\u27e9 := ha.left.exists_eq_singleton_or_nontrivial.resolve_right hu\n    simp_all", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DerivedSet.lean", "context": {"open": ["Filter Topology"], "variables": ["{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nU : Set X\nhs : IsPreconnected U\na b : Set X\nh : U \u2286 a \u222a b\nha : (U \u2229 derivedSet a).Nonempty\nhb : (U \u2229 derivedSet b).Nonempty\n\u22a2 (U \u2229 (derivedSet a \u2229 derivedSet b)).Nonempty"}, {"line": "by_cases hu : U.Nontrivial", "tactic_state": "case pos\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nU : Set X\nhs : IsPreconnected U\na b : Set X\nh : U \u2286 a \u222a b\nha : (U \u2229 derivedSet a).Nonempty\nhb : (U \u2229 derivedSet b).Nonempty\nhu : U.Nontrivial\n\u22a2 (U \u2229 (derivedSet a \u2229 derivedSet b)).Nonempty\n---\ncase neg\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nU : Set X\nhs : IsPreconnected U\na b : Set X\nh : U \u2286 a \u222a b\nha : (U \u2229 derivedSet a).Nonempty\nhb : (U \u2229 derivedSet b).Nonempty\nhu : \u00acU.Nontrivial\n\u22a2 (U \u2229 (derivedSet a \u2229 derivedSet b)).Nonempty"}, {"line": "\u00b7 apply isPreconnected_closed_iff.mp hs\n    \u00b7 simp\n    \u00b7 simp\n    \u00b7 trans derivedSet U\n      \u00b7 apply hs.preperfect_of_nontrivial hu\n      \u00b7 rw [\u2190 derivedSet_union]\n        exact derivedSet_mono _ _ h\n    \u00b7 exact ha\n    \u00b7 exact hb", "tactic_state": "case neg\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nU : Set X\nhs : IsPreconnected U\na b : Set X\nh : U \u2286 a \u222a b\nha : (U \u2229 derivedSet a).Nonempty\nhb : (U \u2229 derivedSet b).Nonempty\nhu : \u00acU.Nontrivial\n\u22a2 (U \u2229 (derivedSet a \u2229 derivedSet b)).Nonempty"}, {"line": "\u00b7 obtain \u27e8x, hx\u27e9 := ha.left.exists_eq_singleton_or_nontrivial.resolve_right hu\n    simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_mono {A B : DiscreteQuotient Y} (h : A \u2264 B) : A.comap f \u2264 B.comap f := by tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteQuotient.lean", "context": {"open": ["Set Function TopologicalSpace Topology"], "variables": ["{\u03b1 X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "(S : DiscreteQuotient X)", "(g : C(Y, Z)) (f : C(X, Y))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : C(X, Y)\nA B : DiscreteQuotient Y\nh : A \u2264 B\n\u22a2 DiscreteQuotient.comap f A \u2264 DiscreteQuotient.comap f B"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofLE_refl_apply (a : A) : ofLE (le_refl A) a = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteQuotient.lean", "context": {"open": ["Set Function TopologicalSpace Topology"], "variables": ["{\u03b1 X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "(S : DiscreteQuotient X)", "(g : C(Y, Z)) (f : C(X, Y))", "{A B C : DiscreteQuotient X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\nA : DiscreteQuotient X\nx\u271d : Sort u_5\nofLE : x\u271d\na : Quotient A.toSetoid\n\u22a2 sorry = a"}, {"line": "simp", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\nA : DiscreteQuotient X\nx\u271d : Sort u_5\nofLE : x\u271d\na : Quotient A.toSetoid\n\u22a2 sorry () = a"}]}
{"declaration": "theorem eq_of_forall_proj_eq [T2Space X] [CompactSpace X] [disc : TotallyDisconnectedSpace X]\n    {x y : X} (h : \u2200 Q : DiscreteQuotient X, Q.proj x = Q.proj y) : x = y := by\n  rw [\u2190 mem_singleton_iff]\n  rw [\u2190 connectedComponent_eq_singleton]\n  rw [connectedComponent_eq_iInter_isClopen]\n  rw [mem_iInter]\n  rintro \u27e8U, hU1, hU2\u27e9\n  exact (Quotient.exact' (h (ofIsClopen hU1))).mpr hU2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteQuotient.lean", "context": {"open": ["Set Function TopologicalSpace Topology"], "variables": ["{\u03b1 X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "(S : DiscreteQuotient X)", "(g : C(Y, Z)) (f : C(X, Y))", "{A B C : DiscreteQuotient X}", "(f : C(X, Y)) (A A' : DiscreteQuotient X) (B B' : DiscreteQuotient Y)", "{A A' B B'} {f} {g : C(Y, Z)} {C : DiscreteQuotient Z}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 x = y"}, {"line": "rw [\u2190 mem_singleton_iff]", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 x \u2208 {y}"}, {"line": "rw [\u2190 connectedComponent_eq_singleton]", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 x \u2208 connectedComponent y\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TopologicalSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TotallyDisconnectedSpace X"}, {"line": "rw [connectedComponent_eq_iInter_isClopen]", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 x \u2208 \u22c2 s, \u2191s\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TopologicalSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 T2Space X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 CompactSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TotallyDisconnectedSpace X"}, {"line": "rw [mem_iInter]", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 \u2200 (i : { s // IsClopen s \u2227 y \u2208 s }), x \u2208 \u2191i\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TopologicalSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TopologicalSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 T2Space X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 CompactSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TotallyDisconnectedSpace X"}, {"line": "rintro \u27e8U, hU1, hU2\u27e9", "tactic_state": "case mk.intro\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\nU : Set X\nhU1 : IsClopen U\nhU2 : y \u2208 U\n\u22a2 x \u2208 \u2191\u27e8U, \u22ef\u27e9\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TopologicalSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TopologicalSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 T2Space X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 CompactSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TotallyDisconnectedSpace X"}, {"line": "exact (Quotient.exact' (h (ofIsClopen hU1))).mpr hU2", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TopologicalSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TopologicalSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 T2Space X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 CompactSpace X\n---\nX : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : \u2200 (Q : DiscreteQuotient X), Q.proj x = Q.proj y\n\u22a2 TotallyDisconnectedSpace X"}]}
{"declaration": "lemma image_subset_closure_compl_image_compl_of_isOpen {\u03c1 : E \u2192 A} (\u03c1_cont : Continuous \u03c1)\n    (\u03c1_surj : \u03c1.Surjective) (zorn_subset : \u2200 E\u2080 : Set E, E\u2080 \u2260 univ \u2192 IsClosed E\u2080 \u2192 \u03c1 '' E\u2080 \u2260 univ)\n    {G : Set E} (hG : IsOpen G) : \u03c1 '' G \u2286 closure ((\u03c1 '' G\u1d9c)\u1d9c) := by\n  -- suffices to prove for nonempty $G$\n  by_cases G_empty : G = \u2205\n  \u00b7 simpa only [G_empty,image_empty] using empty_subset _\n  \u00b7 -- let $a \\in \\rho(G)$\n    intro a ha\n    rw [mem_closure_iff]\n    -- let $N$ be a neighbourhood of $a$\n    intro N N_open hN\n    -- get $x \\in A$ from nonempty open $G \\cap \\rho^{-1}(N)$\n    rcases (G.mem_image \u03c1 a).mp ha with \u27e8e, he, rfl\u27e9\n    have nonempty : (G \u2229 \u03c1\u207b\u00b9' N).Nonempty := \u27e8e, mem_inter he <| mem_preimage.mpr hN\u27e9\n    have is_open : IsOpen <| G \u2229 \u03c1\u207b\u00b9' N := hG.inter <| N_open.preimage \u03c1_cont\n    have ne_univ : \u03c1 '' (G \u2229 \u03c1\u207b\u00b9' N)\u1d9c \u2260 univ :=\n      zorn_subset _ (compl_ne_univ.mpr nonempty) is_open.isClosed_compl\n    rcases nonempty_compl.mpr ne_univ with \u27e8x, hx\u27e9\n    -- prove $x \\in N \\cap (A \\setminus \\rho(E \\setminus G))$\n    have hx' : x \u2208 (\u03c1 '' G\u1d9c)\u1d9c := fun h => hx <| image_subset \u03c1 (by simp) h\n    rcases \u03c1_surj x with \u27e8y, rfl\u27e9\n    have hy : y \u2208 G \u2229 \u03c1\u207b\u00b9' N := by simpa using mt (mem_image_of_mem \u03c1) <| mem_compl hx\n    exact \u27e8\u03c1 y, mem_inter (mem_preimage.mp <| mem_of_mem_inter_right hy) hx'\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ExtremallyDisconnected.lean", "context": {"open": ["Function Set"], "variables": ["(X : Type u) [TopologicalSpace X]", "{X}", "{A D E : Type u} [TopologicalSpace A] [TopologicalSpace D] [TopologicalSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A E : Type u\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : TopologicalSpace E\n\u03c1 : E \u2192 A\n\u03c1_cont : Continuous \u03c1\n\u03c1_surj : Surjective \u03c1\nzorn_subset : \u2200 (E\u2080 : Set E), E\u2080 \u2260 univ \u2192 IsClosed E\u2080 \u2192 \u03c1 '' E\u2080 \u2260 univ\nG : Set E\nhG : IsOpen G\n\u22a2 \u03c1 '' G \u2286 closure (\u03c1 '' G\u1d9c)\u1d9c"}, {"line": "by_cases G_empty : G = \u2205", "tactic_state": "case pos\nA E : Type u\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : TopologicalSpace E\n\u03c1 : E \u2192 A\n\u03c1_cont : Continuous \u03c1\n\u03c1_surj : Surjective \u03c1\nzorn_subset : \u2200 (E\u2080 : Set E), E\u2080 \u2260 univ \u2192 IsClosed E\u2080 \u2192 \u03c1 '' E\u2080 \u2260 univ\nG : Set E\nhG : IsOpen G\nG_empty : G = \u2205\n\u22a2 \u03c1 '' G \u2286 closure (\u03c1 '' G\u1d9c)\u1d9c\n---\ncase neg\nA E : Type u\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : TopologicalSpace E\n\u03c1 : E \u2192 A\n\u03c1_cont : Continuous \u03c1\n\u03c1_surj : Surjective \u03c1\nzorn_subset : \u2200 (E\u2080 : Set E), E\u2080 \u2260 univ \u2192 IsClosed E\u2080 \u2192 \u03c1 '' E\u2080 \u2260 univ\nG : Set E\nhG : IsOpen G\nG_empty : \u00acG = \u2205\n\u22a2 \u03c1 '' G \u2286 closure (\u03c1 '' G\u1d9c)\u1d9c"}, {"line": "\u00b7 simpa only [G_empty,image_empty] using empty_subset _", "tactic_state": "case neg\nA E : Type u\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : TopologicalSpace E\n\u03c1 : E \u2192 A\n\u03c1_cont : Continuous \u03c1\n\u03c1_surj : Surjective \u03c1\nzorn_subset : \u2200 (E\u2080 : Set E), E\u2080 \u2260 univ \u2192 IsClosed E\u2080 \u2192 \u03c1 '' E\u2080 \u2260 univ\nG : Set E\nhG : IsOpen G\nG_empty : \u00acG = \u2205\n\u22a2 \u03c1 '' G \u2286 closure (\u03c1 '' G\u1d9c)\u1d9c"}, {"line": "\u00b7 -- let $a \\in \\rho(G)$\n    intro a ha\n    rw [mem_closure_iff]\n    intro N N_open hN\n    rcases (G.mem_image \u03c1 a).mp ha with \u27e8e, he, rfl\u27e9\n    have nonempty : (G \u2229 \u03c1\u207b\u00b9' N).Nonempty := \u27e8e, mem_inter he <| mem_preimage.mpr hN\u27e9\n    have is_open : IsOpen <| G \u2229 \u03c1\u207b\u00b9' N := hG.inter <| N_open.preimage \u03c1_cont\n    have ne_univ : \u03c1 '' (G \u2229 \u03c1\u207b\u00b9' N)\u1d9c \u2260 univ :=\n      zorn_subset _ (compl_ne_univ.mpr nonempty) is_open.isClosed_compl\n    rcases nonempty_compl.mpr ne_univ with \u27e8x, hx\u27e9\n    have hx' : x \u2208 (\u03c1 '' G\u1d9c)\u1d9c := fun h => hx <| image_subset \u03c1 (by simp) h\n    rcases \u03c1_surj x with \u27e8y, rfl\u27e9\n    have hy : y \u2208 G \u2229 \u03c1\u207b\u00b9' N := by simpa using mt (mem_image_of_mem \u03c1) <| mem_compl hx\n    exact \u27e8\u03c1 y, mem_inter (mem_preimage.mp <| mem_of_mem_inter_right hy) hx'\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_setOf_mem {s : Set \u03b1} : IsOpen { l : Filter \u03b1 | s \u2208 l } := by\n  simpa only [Iic_principal] using isOpen_Iic_principal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ns : Set \u03b1\n\u22a2 IsOpen {l | s \u2208 l}"}, {"line": "simpa only [Iic_principal] using isOpen_Iic_principal", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_eq' (l : Filter \u03b1) : \ud835\udcdd l = l.lift' fun s => { l' | s \u2208 l' } := by\n  simpa only [Function.comp_def,Iic_principal] using nhds_eq l\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\n\u22a2 nhds l = l.lift' fun s => {l' | s \u2208 l'}"}, {"line": "simpa only [Function.comp_def,Iic_principal] using nhds_eq l", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem HasBasis.nhds {l : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : HasBasis l p s) :\n    HasBasis (\ud835\udcdd l) p fun i => Iic (\ud835\udcdf (s i)) := by\n  rw [nhds_eq]\n  exact h.lift' monotone_principal.Iic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 (nhds l).HasBasis p fun i => Iic (principal (s i))"}, {"line": "rw [nhds_eq]", "tactic_state": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 (l.lift' (Iic \u2218 principal)).HasBasis p fun i => Iic (principal (s i))"}, {"line": "exact h.lift' monotone_principal.Iic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.nhds' {l : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : HasBasis l p s) :\n    HasBasis (\ud835\udcdd l) p fun i => { l' | s i \u2208 l' } := by simpa only [Iic_principal] using h.nhds\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 (nhds l).HasBasis p fun i => {l' | s i \u2208 l'}"}, {"line": "simpa only [Iic_principal] using h.nhds", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_bot : \ud835\udcdd (\u22a5 : Filter \u03b1) = pure \u22a5 := by\n  simp [nhds_eq, Function.comp_def, lift'_bot monotone_principal.Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u22a2 nhds \u22a5 = pure \u22a5"}, {"line": "simp [nhds_eq, Function.comp_def, lift'_bot monotone_principal.Iic]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_top : \ud835\udcdd (\u22a4 : Filter \u03b1) = \u22a4 := by simp [nhds_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u22a2 nhds \u22a4 = \u22a4"}, {"line": "simp [nhds_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_pure (x : \u03b1) : \ud835\udcdd (pure x : Filter \u03b1) = \ud835\udcdf {\u22a5, pure x} := by\n  rw [\u2190 principal_singleton]\n  rw [nhds_principal]\n  rw [principal_singleton]\n  rw [Iic_pure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nx : \u03b1\n\u22a2 nhds (pure x) = principal {\u22a5, pure x}"}, {"line": "rw [\u2190 principal_singleton]", "tactic_state": "\u03b1 : Type u_2\nx : \u03b1\n\u22a2 nhds (principal {x}) = principal {\u22a5, principal {x}}"}, {"line": "rw [nhds_principal]", "tactic_state": "\u03b1 : Type u_2\nx : \u03b1\n\u22a2 principal (Iic (principal {x})) = principal {\u22a5, principal {x}}"}, {"line": "rw [principal_singleton]", "tactic_state": "\u03b1 : Type u_2\nx : \u03b1\n\u22a2 principal (Iic (pure x)) = principal {\u22a5, pure x}"}, {"line": "rw [Iic_pure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_nhds (l : Filter \u03b1) : \u22c2\u2080 { s | s \u2208 \ud835\udcdd l } = Iic l := by\n  simp_rw [nhds_eq, Function.comp_def, sInter_lift'_sets monotone_principal.Iic, Iic,\n    le_principal_iff, \u2190 setOf_forall, \u2190 Filter.le_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\n\u22a2 \u22c2\u2080 {s | s \u2208 nhds l} = Iic l"}, {"line": "simp_rw [nhds_eq, Function.comp_def, sInter_lift'_sets monotone_principal.Iic, Iic,\n    le_principal_iff, \u2190 setOf_forall, \u2190 Filter.le_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_mono {l\u2081 l\u2082 : Filter \u03b1} : \ud835\udcdd l\u2081 \u2264 \ud835\udcdd l\u2082 \u2194 l\u2081 \u2264 l\u2082 := by\n  refine \u27e8fun h => ?_, fun h => monotone_nhds h\u27e9\n  rw [\u2190 Iic_subset_Iic]\n  rw [\u2190 sInter_nhds]\n  rw [\u2190 sInter_nhds]\n  exact sInter_subset_sInter h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl\u2081 l\u2082 : Filter \u03b1\n\u22a2 nhds l\u2081 \u2264 nhds l\u2082 \u2194 l\u2081 \u2264 l\u2082"}, {"line": "refine \u27e8fun h => ?_, fun h => monotone_nhds h\u27e9", "tactic_state": "\u03b1 : Type u_2\nl\u2081 l\u2082 : Filter \u03b1\nh : nhds l\u2081 \u2264 nhds l\u2082\n\u22a2 l\u2081 \u2264 l\u2082"}, {"line": "rw [\u2190 Iic_subset_Iic]", "tactic_state": "\u03b1 : Type u_2\nl\u2081 l\u2082 : Filter \u03b1\nh : nhds l\u2081 \u2264 nhds l\u2082\n\u22a2 Iic l\u2081 \u2286 Iic l\u2082"}, {"line": "rw [\u2190 sInter_nhds]", "tactic_state": "\u03b1 : Type u_2\nl\u2081 l\u2082 : Filter \u03b1\nh : nhds l\u2081 \u2264 nhds l\u2082\n\u22a2 \u22c2\u2080 {s | s \u2208 nhds l\u2081} \u2286 Iic l\u2082"}, {"line": "rw [\u2190 sInter_nhds]", "tactic_state": "\u03b1 : Type u_2\nl\u2081 l\u2082 : Filter \u03b1\nh : nhds l\u2081 \u2264 nhds l\u2082\n\u22a2 \u22c2\u2080 {s | s \u2208 nhds l\u2081} \u2286 \u22c2\u2080 {s | s \u2208 nhds l\u2082}"}, {"line": "exact sInter_subset_sInter h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem specializes_iff_le {l\u2081 l\u2082 : Filter \u03b1} : l\u2081 \u2933 l\u2082 \u2194 l\u2081 \u2264 l\u2082 := by\n  simp only [specializes_iff_closure_subset]\n  simp only [Filter.closure_singleton]\n  simp only [Ici_subset_Ici]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl\u2081 l\u2082 : Filter \u03b1\n\u22a2 l\u2081 \u2933 l\u2082 \u2194 l\u2081 \u2264 l\u2082"}, {"line": "simp only [specializes_iff_closure_subset]", "tactic_state": "\u03b1 : Type u_2\nl\u2081 l\u2082 : Filter \u03b1\n\u22a2 closure {l\u2082} \u2286 closure {l\u2081} \u2194 l\u2081 \u2264 l\u2082"}, {"line": "simp only [Filter.closure_singleton]", "tactic_state": "\u03b1 : Type u_2\nl\u2081 l\u2082 : Filter \u03b1\n\u22a2 Ici l\u2082 \u2286 Ici l\u2081 \u2194 l\u2081 \u2264 l\u2082"}, {"line": "simp only [Ici_subset_Ici]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_atTop [Preorder \u03b1] : \ud835\udcdd atTop = \u2a05 x : \u03b1, \ud835\udcdf (Iic (\ud835\udcdf (Ici x))) := by\n  simp only [atTop]\n  simp only [Filter.nhds_iInf]\n  simp only [nhds_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Filter.lean", "context": {"open": ["Set Filter TopologicalSpace", "Filter Topology"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : Preorder \u03b1\n\u22a2 nhds atTop = \u2a05 x, principal (Iic (principal (Ici x)))"}, {"line": "simp only [atTop]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : Preorder \u03b1\n\u22a2 nhds (\u2a05 a, principal (Ici a)) = \u2a05 x, principal (Iic (principal (Ici x)))"}, {"line": "simp only [Filter.nhds_iInf]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : Preorder \u03b1\n\u22a2 \u2a05 i, nhds (principal (Ici i)) = \u2a05 x, principal (Iic (principal (Ici x)))"}, {"line": "simp only [nhds_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_nil : \ud835\udcdd ([] : List \u03b1) = pure [] := by\n  rw [nhds_list]\n  rw [List.traverse_nil _]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/List.lean", "context": {"open": ["TopologicalSpace Set Filter", "Topology Filter"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 nhds [] = pure []"}, {"line": "rw [nhds_list]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 traverse nhds [] = pure []"}, {"line": "rw [List.traverse_nil _]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_cons (a : \u03b1) (l : List \u03b1) : \ud835\udcdd (a::l) = List.cons <$> \ud835\udcdd a <*> \ud835\udcdd l := by\n  rw [nhds_list]\n  rw [List.traverse_cons _]\n  rw [\u2190 nhds_list]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/List.lean", "context": {"open": ["TopologicalSpace Set Filter", "Topology Filter"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\nl : List \u03b1\n\u22a2 nhds (a :: l) = List.cons <$> nhds a <*> nhds l"}, {"line": "rw [nhds_list]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\nl : List \u03b1\n\u22a2 traverse nhds (a :: l) = List.cons <$> nhds a <*> nhds l"}, {"line": "rw [List.traverse_cons _]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\nl : List \u03b1\n\u22a2 (fun x1 x2 => x1 :: x2) <$> nhds a <*> traverse nhds l = List.cons <$> nhds a <*> nhds l"}, {"line": "rw [\u2190 nhds_list]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ultrafilter_isClosed_basic (s : Set \u03b1) : IsClosed { u : Ultrafilter \u03b1 | s \u2208 u } := by\n  rw [\u2190 isOpen_compl_iff]\n  convert ultrafilter_isOpen_basic s\u1d9c using 1\n  ext u\n  exact Ultrafilter.compl_mem_iff_not_mem.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/StoneCech.lean", "context": {"open": ["Filter Set", "Topology"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\n\u22a2 IsClosed {u | s \u2208 u}"}, {"line": "rw [\u2190 isOpen_compl_iff]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\n\u22a2 IsOpen {u | s \u2208 u}\u1d9c"}, {"line": "convert ultrafilter_isOpen_basic s\u1d9c using 1", "tactic_state": "case h.e'_3\n\u03b1 : Type u\ns : Set \u03b1\n\u22a2 {u | s \u2208 u}\u1d9c = {u | s\u1d9c \u2208 u}"}, {"line": "ext u", "tactic_state": "case h.e'_3.h\n\u03b1 : Type u\ns : Set \u03b1\nu : Ultrafilter \u03b1\n\u22a2 u \u2208 {u | s \u2208 u}\u1d9c \u2194 u \u2208 {u | s\u1d9c \u2208 u}"}, {"line": "exact Ultrafilter.compl_mem_iff_not_mem.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ultrafilter_comap_pure_nhds (b : Ultrafilter \u03b1) : comap pure (\ud835\udcdd b) \u2264 b := by\n  rw [TopologicalSpace.nhds_generateFrom]\n  simp only [comap_iInf]\n  simp only [comap_principal]\n  intro s hs\n  rw [\u2190 le_principal_iff]\n  refine iInf_le_of_le { u | s \u2208 u } ?_\n  refine iInf_le_of_le \u27e8hs, \u27e8s, rfl\u27e9\u27e9 ?_\n  exact principal_mono.2 fun _ \u21a6 id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/StoneCech.lean", "context": {"open": ["Filter Set", "Topology"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nb : Ultrafilter \u03b1\n\u22a2 comap pure (nhds b) \u2264 \u2191b"}, {"line": "rw [TopologicalSpace.nhds_generateFrom]", "tactic_state": "\u03b1 : Type u\nb : Ultrafilter \u03b1\n\u22a2 comap pure (\u2a05 s \u2208 {s | b \u2208 s \u2227 s \u2208 ultrafilterBasis \u03b1}, principal s) \u2264 \u2191b"}, {"line": "simp only [comap_iInf]", "tactic_state": "\u03b1 : Type u\nb : Ultrafilter \u03b1\n\u22a2 \u2a05 i \u2208 {s | b \u2208 s \u2227 s \u2208 ultrafilterBasis \u03b1}, comap pure (principal i) \u2264 \u2191b"}, {"line": "simp only [comap_principal]", "tactic_state": "\u03b1 : Type u\nb : Ultrafilter \u03b1\n\u22a2 \u2a05 i \u2208 {s | b \u2208 s \u2227 s \u2208 ultrafilterBasis \u03b1}, principal (pure \u207b\u00b9' i) \u2264 \u2191b"}, {"line": "intro s hs", "tactic_state": "\u03b1 : Type u\nb : Ultrafilter \u03b1\ns : Set \u03b1\nhs : s \u2208 \u2191b\n\u22a2 s \u2208 \u2a05 i \u2208 {s | b \u2208 s \u2227 s \u2208 ultrafilterBasis \u03b1}, principal (pure \u207b\u00b9' i)"}, {"line": "rw [\u2190 le_principal_iff]", "tactic_state": "\u03b1 : Type u\nb : Ultrafilter \u03b1\ns : Set \u03b1\nhs : s \u2208 \u2191b\n\u22a2 \u2a05 i \u2208 {s | b \u2208 s \u2227 s \u2208 ultrafilterBasis \u03b1}, principal (pure \u207b\u00b9' i) \u2264 principal s"}, {"line": "refine iInf_le_of_le { u | s \u2208 u } ?_", "tactic_state": "\u03b1 : Type u\nb : Ultrafilter \u03b1\ns : Set \u03b1\nhs : s \u2208 \u2191b\n\u22a2 \u2a05 (_ : {u | s \u2208 u} \u2208 {s | b \u2208 s \u2227 s \u2208 ultrafilterBasis \u03b1}), principal (pure \u207b\u00b9' {u | s \u2208 u}) \u2264 principal s"}, {"line": "refine iInf_le_of_le \u27e8hs, \u27e8s, rfl\u27e9\u27e9 ?_", "tactic_state": "\u03b1 : Type u\nb : Ultrafilter \u03b1\ns : Set \u03b1\nhs : s \u2208 \u2191b\n\u22a2 principal (pure \u207b\u00b9' {u | s \u2208 u}) \u2264 principal s"}, {"line": "exact principal_mono.2 fun _ \u21a6 id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ultrafilter_pure_injective : Function.Injective (pure : \u03b1 \u2192 Ultrafilter \u03b1) := by\n  intro x y h\n  have : {x} \u2208 (pure x : Ultrafilter \u03b1) := singleton_mem_pure\n  rw [h] at this\n  exact (mem_singleton_iff.mp (mem_pure.mp this)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/StoneCech.lean", "context": {"open": ["Filter Set", "Topology"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u22a2 Function.Injective pure"}, {"line": "intro x y h", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\nh : pure x = pure y\n\u22a2 x = y"}, {"line": "have : {x} \u2208 (pure x : Ultrafilter \u03b1) := singleton_mem_pure", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\nh : pure x = pure y\nthis : {x} \u2208 pure x\n\u22a2 x = y"}, {"line": "rw [h] at this", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\nh : pure x = pure y\nthis : {x} \u2208 pure y\n\u22a2 x = y"}, {"line": "exact (mem_singleton_iff.mp (mem_pure.mp this)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem induced_topology_pure :\n    TopologicalSpace.induced (pure : \u03b1 \u2192 Ultrafilter \u03b1) Ultrafilter.topologicalSpace = \u22a5 := by\n  apply eq_bot_of_singletons_open\n  intro x\n  use { u : Ultrafilter \u03b1 | {x} \u2208 u }, ultrafilter_isOpen_basic _\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/StoneCech.lean", "context": {"open": ["Filter Set", "Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u22a2 induced pure Ultrafilter.topologicalSpace = \u22a5"}, {"line": "apply eq_bot_of_singletons_open", "tactic_state": "case h\n\u03b1 : Type u\n\u22a2 \u2200 (x : \u03b1), IsOpen {x}"}, {"line": "intro x", "tactic_state": "case h\n\u03b1 : Type u\nx : \u03b1\n\u22a2 IsOpen {x}"}, {"line": "use { u : Ultrafilter \u03b1 | {x} \u2208 u }, ultrafilter_isOpen_basic _", "tactic_state": "case right\n\u03b1 : Type u\nx : \u03b1\n\u22a2 pure \u207b\u00b9' {u | {x} \u2208 u} = {x}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ultrafilter_extend_extends (f : \u03b1 \u2192 \u03b3) : Ultrafilter.extend f \u2218 pure = f := by\n  letI : TopologicalSpace \u03b1 := \u22a5\n  haveI : DiscreteTopology \u03b1 := \u27e8rfl\u27e9\n  exact funext (isDenseInducing_pure.extend_eq continuous_of_discreteTopology)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/StoneCech.lean", "context": {"open": ["Filter Set", "Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b3 : Type*} [TopologicalSpace \u03b3]", "[T2Space \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b3 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : T2Space \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 Ultrafilter.extend f \u2218 pure = f"}, {"line": "letI : TopologicalSpace \u03b1 := \u22a5", "tactic_state": "\u03b1 : Type u\n\u03b3 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : T2Space \u03b3\nf : \u03b1 \u2192 \u03b3\nthis : TopologicalSpace \u03b1 := \u22a5\n\u22a2 Ultrafilter.extend f \u2218 pure = f"}, {"line": "haveI : DiscreteTopology \u03b1 := \u27e8rfl\u27e9", "tactic_state": "\u03b1 : Type u\n\u03b3 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : T2Space \u03b3\nf : \u03b1 \u2192 \u03b3\nthis\u271d : TopologicalSpace \u03b1 := \u22a5\nthis : DiscreteTopology \u03b1\n\u22a2 Ultrafilter.extend f \u2218 pure = f"}, {"line": "exact funext (isDenseInducing_pure.extend_eq continuous_of_discreteTopology)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stoneCechExtend_extends : stoneCechExtend hg \u2218 stoneCechUnit = g := by\n  ext x\n  rw [stoneCechExtend]\n  rw [Function.comp_apply]\n  rw [stoneCechUnit]\n  rw [t2Quotient.lift_mk]\n  apply congrFun (preStoneCechExtend_extends hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/StoneCech.lean", "context": {"open": ["Filter Set", "Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b3 : Type*} [TopologicalSpace \u03b3]", "[T2Space \u03b3]", "[CompactSpace \u03b3]", "(\u03b1 : Type u) [TopologicalSpace \u03b1]", "{\u03b1}", "{\u03b2 : Type v} [TopologicalSpace \u03b2] [T2Space \u03b2]", "[CompactSpace \u03b2]", "{g : \u03b1 \u2192 \u03b2} (hg : Continuous g)", "(\u03b1 : Type u) [TopologicalSpace \u03b1]", "{\u03b1}", "{\u03b2 : Type v} [TopologicalSpace \u03b2] [T2Space \u03b2]", "{g : \u03b1 \u2192 \u03b2} (hg : Continuous g)", "[CompactSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : T2Space \u03b2\ng : \u03b1 \u2192 \u03b2\nhg : Continuous g\ninst\u271d : CompactSpace \u03b2\n\u22a2 stoneCechExtend hg \u2218 stoneCechUnit = g"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : T2Space \u03b2\ng : \u03b1 \u2192 \u03b2\nhg : Continuous g\ninst\u271d : CompactSpace \u03b2\nx : \u03b1\n\u22a2 (stoneCechExtend hg \u2218 stoneCechUnit) x = g x"}, {"line": "rw [stoneCechExtend]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : T2Space \u03b2\ng : \u03b1 \u2192 \u03b2\nhg : Continuous g\ninst\u271d : CompactSpace \u03b2\nx : \u03b1\n\u22a2 (t2Quotient.lift \u22ef \u2218 stoneCechUnit) x = g x"}, {"line": "rw [Function.comp_apply]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : T2Space \u03b2\ng : \u03b1 \u2192 \u03b2\nhg : Continuous g\ninst\u271d : CompactSpace \u03b2\nx : \u03b1\n\u22a2 t2Quotient.lift \u22ef (stoneCechUnit x) = g x"}, {"line": "rw [stoneCechUnit]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : T2Space \u03b2\ng : \u03b1 \u2192 \u03b2\nhg : Continuous g\ninst\u271d : CompactSpace \u03b2\nx : \u03b1\n\u22a2 t2Quotient.lift \u22ef (t2Quotient.mk (preStoneCechUnit x)) = g x"}, {"line": "rw [t2Quotient.lift_mk]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : T2Space \u03b2\ng : \u03b1 \u2192 \u03b2\nhg : Continuous g\ninst\u271d : CompactSpace \u03b2\nx : \u03b1\n\u22a2 preStoneCechExtend hg (preStoneCechUnit x) = g x"}, {"line": "apply congrFun (preStoneCechExtend_extends hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.restrictPreimage_isInducing (s : Set \u03b2) (h : IsInducing f) :\n    IsInducing (s.restrictPreimage f) := by\n  simp_rw [\u2190 IsInducing.subtypeVal.of_comp_iff, isInducing_iff_nhds, restrictPreimage,\n    MapsTo.coe_restrict, restrict_eq, \u2190 @Filter.comap_comap _ _ _ _ _ f, Function.comp_apply] at h \u22a2\n  intro a\n  rw [\u2190 h]\n  rw [\u2190 IsInducing.subtypeVal.nhds_eq_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocalAtTarget.lean", "context": {"open": ["Filter Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b9 : Type*} {U : \u03b9 \u2192 Opens \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : IsInducing f\n\u22a2 IsInducing (s.restrictPreimage f)"}, {"line": "simp_rw [\u2190 IsInducing.subtypeVal.of_comp_iff, isInducing_iff_nhds, restrictPreimage,\n    MapsTo.coe_restrict, restrict_eq, \u2190 @Filter.comap_comap _ _ _ _ _ f, Function.comp_apply] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : \u2200 (x : \u03b1), nhds x = comap f (nhds (f x))\n\u22a2 \u2200 (x : \u2191(f \u207b\u00b9' s)), nhds x = comap Subtype.val (comap f (nhds (f \u2191x)))"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : \u2200 (x : \u03b1), nhds x = comap f (nhds (f x))\na : \u2191(f \u207b\u00b9' s)\n\u22a2 nhds a = comap Subtype.val (comap f (nhds (f \u2191a)))"}, {"line": "rw [\u2190 h]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : \u2200 (x : \u03b1), nhds x = comap f (nhds (f x))\na : \u2191(f \u207b\u00b9' s)\n\u22a2 nhds a = comap Subtype.val (nhds \u2191a)"}, {"line": "rw [\u2190 IsInducing.subtypeVal.nhds_eq_comap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsClosedMap.restrictPreimage (H : IsClosedMap f) (s : Set \u03b2) :\n    IsClosedMap (s.restrictPreimage f) := by\n  intro t\n  suffices \u2200 u, IsClosed u \u2192 Subtype.val \u207b\u00b9' u = t \u2192\n    \u2203 v, IsClosed v \u2227 Subtype.val \u207b\u00b9' v = s.restrictPreimage f '' t by\n      simpa [isClosed_induced_iff]\n  exact fun u hu e => \u27e8f '' u, H u hu, by simp [\u2190 e, image_restrictPreimage]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocalAtTarget.lean", "context": {"open": ["Filter Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b9 : Type*} {U : \u03b9 \u2192 Opens \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : IsClosedMap f\ns : Set \u03b2\n\u22a2 IsClosedMap (s.restrictPreimage f)"}, {"line": "intro t", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : IsClosedMap f\ns : Set \u03b2\nt : Set \u2191(f \u207b\u00b9' s)\n\u22a2 IsClosed t \u2192 IsClosed (s.restrictPreimage f '' t)"}, {"line": "suffices \u2200 u, IsClosed u \u2192 Subtype.val \u207b\u00b9' u = t \u2192\n    \u2203 v, IsClosed v \u2227 Subtype.val \u207b\u00b9' v = s.restrictPreimage f '' t by\n      simpa [isClosed_induced_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : IsClosedMap f\ns : Set \u03b2\nt : Set \u2191(f \u207b\u00b9' s)\n\u22a2 \u2200 (u : Set \u03b1), IsClosed u \u2192 Subtype.val \u207b\u00b9' u = t \u2192 \u2203 v, IsClosed v \u2227 Subtype.val \u207b\u00b9' v = s.restrictPreimage f '' t"}, {"line": "exact fun u hu e => \u27e8f '' u, H u hu, by simp [\u2190 e, image_restrictPreimage]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpenMap.restrictPreimage (H : IsOpenMap f) (s : Set \u03b2) :\n    IsOpenMap (s.restrictPreimage f) := by\n  intro t\n  suffices \u2200 u, IsOpen u \u2192 Subtype.val \u207b\u00b9' u = t \u2192\n    \u2203 v, IsOpen v \u2227 Subtype.val \u207b\u00b9' v = s.restrictPreimage f '' t by\n      simpa [isOpen_induced_iff]\n  exact fun u hu e => \u27e8f '' u, H u hu, by simp [\u2190 e, image_restrictPreimage]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocalAtTarget.lean", "context": {"open": ["Filter Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b9 : Type*} {U : \u03b9 \u2192 Opens \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : IsOpenMap f\ns : Set \u03b2\n\u22a2 IsOpenMap (s.restrictPreimage f)"}, {"line": "intro t", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : IsOpenMap f\ns : Set \u03b2\nt : Set \u2191(f \u207b\u00b9' s)\n\u22a2 IsOpen t \u2192 IsOpen (s.restrictPreimage f '' t)"}, {"line": "suffices \u2200 u, IsOpen u \u2192 Subtype.val \u207b\u00b9' u = t \u2192\n    \u2203 v, IsOpen v \u2227 Subtype.val \u207b\u00b9' v = s.restrictPreimage f '' t by\n      simpa [isOpen_induced_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : IsOpenMap f\ns : Set \u03b2\nt : Set \u2191(f \u207b\u00b9' s)\n\u22a2 \u2200 (u : Set \u03b1), IsOpen u \u2192 Subtype.val \u207b\u00b9' u = t \u2192 \u2203 v, IsOpen v \u2227 Subtype.val \u207b\u00b9' v = s.restrictPreimage f '' t"}, {"line": "exact fun u hu e => \u27e8f '' u, H u hu, by simp [\u2190 e, image_restrictPreimage]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma GeneralizingMap.restrictPreimage (H : GeneralizingMap f) (s : Set \u03b2) :\n    GeneralizingMap (s.restrictPreimage f) := by\n  intro x y h\n  obtain \u27e8a, ha, hy\u27e9 := H (h.map <| continuous_subtype_val (p := s))\n  use \u27e8a, by simp [hy]\u27e9\n  simp [hy, subtype_specializes_iff, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocalAtTarget.lean", "context": {"open": ["Filter Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b9 : Type*} {U : \u03b9 \u2192 Opens \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : GeneralizingMap f\ns : Set \u03b2\n\u22a2 GeneralizingMap (s.restrictPreimage f)"}, {"line": "intro x y h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : GeneralizingMap f\ns : Set \u03b2\nx : \u2191(f \u207b\u00b9' s)\ny : \u2191s\nh : y \u2933 s.restrictPreimage f x\n\u22a2 \u2203 a', (fun x1 x2 => x1 \u2933 x2) a' x \u2227 s.restrictPreimage f a' = y"}, {"line": "obtain \u27e8a, ha, hy\u27e9 := H (h.map <| continuous_subtype_val (p := s))", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : GeneralizingMap f\ns : Set \u03b2\nx : \u2191(f \u207b\u00b9' s)\ny : \u2191s\nh : y \u2933 s.restrictPreimage f x\na : \u03b1\nha : a \u2933 \u2191x\nhy : f a = \u2191y\n\u22a2 \u2203 a', (fun x1 x2 => x1 \u2933 x2) a' x \u2227 s.restrictPreimage f a' = y"}, {"line": "use \u27e8a, by simp [hy]\u27e9", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nH : GeneralizingMap f\ns : Set \u03b2\nx : \u2191(f \u207b\u00b9' s)\ny : \u2191s\nh : y \u2933 s.restrictPreimage f x\na : \u03b1\nha : a \u2933 \u2191x\nhy : f a = \u2191y\n\u22a2 (fun x1 x2 => x1 \u2933 x2) \u27e8a, \u22ef\u27e9 x \u2227 s.restrictPreimage f \u27e8a, \u22ef\u27e9 = y"}, {"line": "simp [hy, subtype_specializes_iff, ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_iff_coe_preimage {s : Set \u03b2} :\n    IsClosed s \u2194 \u2200 i, IsClosed ((\u2191) \u207b\u00b9' s : Set (U i)) := by\n  simpa using hU.isOpen_iff_coe_preimage (s := s\u1d9c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocalAtTarget.lean", "context": {"open": ["Filter Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b9 : Type*} {U : \u03b9 \u2192 Opens \u03b2}", "{U : \u03b9 \u2192 Opens \u03b2} {s : Set \u03b2} (hU : IsOpenCover U)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\n\u03b9 : Type u_3\nU : \u03b9 \u2192 Opens \u03b2\ns : Set \u03b2\n\u22a2 IsClosed s \u2194 \u2200 (i : \u03b9), IsClosed (Subtype.val \u207b\u00b9' s)"}, {"line": "simpa using hU.isOpen_iff_coe_preimage (s := s\u1d9c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmbedding_iff_restrictPreimage (h : Continuous f) :\n    IsEmbedding f \u2194 \u2200 i, IsEmbedding ((U i).1.restrictPreimage f) := by\n  simpa [isEmbedding_iff, forall_and] using and_congr (hU.isInducing_iff_restrictPreimage h)\n    (injective_iff_injective_of_iUnion_eq_univ hU.iSup_set_eq_univ)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocalAtTarget.lean", "context": {"open": ["Filter Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b9 : Type*} {U : \u03b9 \u2192 Opens \u03b2}", "{U : \u03b9 \u2192 Opens \u03b2} {s : Set \u03b2} (hU : IsOpenCover U)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Type u_3\nU : \u03b9 \u2192 Opens \u03b2\nh : Continuous f\n\u22a2 IsEmbedding f \u2194 \u2200 (i : \u03b9), IsEmbedding ((U i).carrier.restrictPreimage f)"}, {"line": "simpa [isEmbedding_iff, forall_and] using and_congr (hU.isInducing_iff_restrictPreimage h)\n    (injective_iff_injective_of_iUnion_eq_univ hU.iSup_set_eq_univ)", "tactic_state": "No Goals!"}]}
{"declaration": "example : CompactSpace I := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UnitInterval.lean", "context": {"open": ["Topology Filter Set Int Set.Icc"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u_1\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_minus_nonneg (x : I) : 0 \u2264 1 - (x : \u211d) := by simpa using x.2.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UnitInterval.lean", "context": {"open": ["Topology Filter Set Int Set.Icc"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Sort u_1\nx : I\n\u22a2 0 \u2264 1 - sorry"}, {"line": "simpa using x.2.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_minus_le_one (x : I) : 1 - (x : \u211d) \u2264 1 := by simpa using x.2.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UnitInterval.lean", "context": {"open": ["Topology Filter Set Int Set.Icc"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Sort u_1\nx : I\n\u22a2 1 - sorry \u2264 1"}, {"line": "simpa using x.2.1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_monotone_Icc_subset_open_cover_unitInterval {\u03b9} {c : \u03b9 \u2192 Set I}\n    (hc\u2081 : \u2200 i, IsOpen (c i)) (hc\u2082 : univ \u2286 \u22c3 i, c i) : \u2203 t : \u2115 \u2192 I, t 0 = 0 \u2227\n      Monotone t \u2227 (\u2203 n, \u2200 m \u2265 n, t m = 1) \u2227 \u2200 n, \u2203 i, Icc (t n) (t (n + 1)) \u2286 c i := by\n  simp_rw [\u2190 Subtype.coe_inj]\n  exact exists_monotone_Icc_subset_open_cover_Icc zero_le_one hc\u2081 hc\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UnitInterval.lean", "context": {"open": ["Topology Filter Set Int Set.Icc", "scoped unitInterval"], "variables": ["{\u03b1} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nc : \u03b9 \u2192 Set \u2191unitInterval\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : univ \u2286 \u22c3 i, c i\n\u22a2 \u2203 t, t 0 = 0 \u2227 Monotone t \u2227 (\u2203 n, \u2200 m \u2265 n, t m = 1) \u2227 \u2200 (n : \u2115), \u2203 i, Icc (t n) (t (n + 1)) \u2286 c i"}, {"line": "simp_rw [\u2190 Subtype.coe_inj]", "tactic_state": "\u03b9 : Sort u_1\nc : \u03b9 \u2192 Set \u2191unitInterval\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : univ \u2286 \u22c3 i, c i\n\u22a2 \u2203 t, \u2191(t 0) = \u21910 \u2227 Monotone t \u2227 (\u2203 n, \u2200 m \u2265 n, \u2191(t m) = \u21911) \u2227 \u2200 (n : \u2115), \u2203 i, Icc (t n) (t (n + 1)) \u2286 c i"}, {"line": "exact exists_monotone_Icc_subset_open_cover_Icc zero_le_one hc\u2081 hc\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_monotone_Icc_subset_open_cover_unitInterval_prod_self {\u03b9} {c : \u03b9 \u2192 Set (I \u00d7 I)}\n    (hc\u2081 : \u2200 i, IsOpen (c i)) (hc\u2082 : univ \u2286 \u22c3 i, c i) :\n    \u2203 t : \u2115 \u2192 I, t 0 = 0 \u2227 Monotone t \u2227 (\u2203 n, \u2200 m \u2265 n, t m = 1) \u2227\n      \u2200 n m, \u2203 i, Icc (t n) (t (n + 1)) \u00d7\u02e2 Icc (t m) (t (m + 1)) \u2286 c i := by\n  obtain \u27e8\u03b4, \u03b4_pos, ball_subset\u27e9 := lebesgue_number_lemma_of_metric isCompact_univ hc\u2081 hc\u2082\n  have h\u03b4 := half_pos \u03b4_pos\n  simp_rw [Subtype.ext_iff]\n  have h : (0 : \u211d) \u2264 1 := zero_le_one\n  refine \u27e8addNSMul h (\u03b4/2), addNSMul_zero h,\n    monotone_addNSMul h h\u03b4.le, addNSMul_eq_right h h\u03b4, fun n m \u21a6 ?_\u27e9\n  obtain \u27e8i, hsub\u27e9 := ball_subset (addNSMul h (\u03b4/2) n, addNSMul h (\u03b4/2) m) trivial\n  exact \u27e8i, fun t ht \u21a6 hsub (Metric.mem_ball.mpr <| (max_le (abs_sub_addNSMul_le h h\u03b4.le n ht.1) <|\n    abs_sub_addNSMul_le h h\u03b4.le m ht.2).trans_lt <| half_lt_self \u03b4_pos)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UnitInterval.lean", "context": {"open": ["Topology Filter Set Int Set.Icc", "scoped unitInterval"], "variables": ["{\u03b1} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nc : \u03b9 \u2192 Set (\u2191unitInterval \u00d7 \u2191unitInterval)\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : univ \u2286 \u22c3 i, c i\n\u22a2 \u2203 t,\n    t 0 = 0 \u2227\n      Monotone t \u2227 (\u2203 n, \u2200 m \u2265 n, t m = 1) \u2227 \u2200 (n m : \u2115), \u2203 i, Icc (t n) (t (n + 1)) \u00d7\u02e2 Icc (t m) (t (m + 1)) \u2286 c i"}, {"line": "obtain \u27e8\u03b4, \u03b4_pos, ball_subset\u27e9 := lebesgue_number_lemma_of_metric isCompact_univ hc\u2081 hc\u2082", "tactic_state": "case intro.intro\n\u03b9 : Sort u_1\nc : \u03b9 \u2192 Set (\u2191unitInterval \u00d7 \u2191unitInterval)\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : univ \u2286 \u22c3 i, c i\n\u03b4 : \u211d\n\u03b4_pos : \u03b4 > 0\nball_subset : \u2200 x \u2208 univ, \u2203 i, Metric.ball x \u03b4 \u2286 c i\n\u22a2 \u2203 t,\n    t 0 = 0 \u2227\n      Monotone t \u2227 (\u2203 n, \u2200 m \u2265 n, t m = 1) \u2227 \u2200 (n m : \u2115), \u2203 i, Icc (t n) (t (n + 1)) \u00d7\u02e2 Icc (t m) (t (m + 1)) \u2286 c i"}, {"line": "have h\u03b4 := half_pos \u03b4_pos", "tactic_state": "case intro.intro\n\u03b9 : Sort u_1\nc : \u03b9 \u2192 Set (\u2191unitInterval \u00d7 \u2191unitInterval)\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : univ \u2286 \u22c3 i, c i\n\u03b4 : \u211d\n\u03b4_pos : \u03b4 > 0\nball_subset : \u2200 x \u2208 univ, \u2203 i, Metric.ball x \u03b4 \u2286 c i\nh\u03b4 : 0 < \u03b4 / 2\n\u22a2 \u2203 t,\n    t 0 = 0 \u2227\n      Monotone t \u2227 (\u2203 n, \u2200 m \u2265 n, t m = 1) \u2227 \u2200 (n m : \u2115), \u2203 i, Icc (t n) (t (n + 1)) \u00d7\u02e2 Icc (t m) (t (m + 1)) \u2286 c i"}, {"line": "simp_rw [Subtype.ext_iff]", "tactic_state": "case intro.intro\n\u03b9 : Sort u_1\nc : \u03b9 \u2192 Set (\u2191unitInterval \u00d7 \u2191unitInterval)\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : univ \u2286 \u22c3 i, c i\n\u03b4 : \u211d\n\u03b4_pos : \u03b4 > 0\nball_subset : \u2200 x \u2208 univ, \u2203 i, Metric.ball x \u03b4 \u2286 c i\nh\u03b4 : 0 < \u03b4 / 2\n\u22a2 \u2203 t,\n    \u2191(t 0) = \u21910 \u2227\n      Monotone t \u2227 (\u2203 n, \u2200 m \u2265 n, \u2191(t m) = \u21911) \u2227 \u2200 (n m : \u2115), \u2203 i, Icc (t n) (t (n + 1)) \u00d7\u02e2 Icc (t m) (t (m + 1)) \u2286 c i"}, {"line": "have h : (0 : \u211d) \u2264 1 := zero_le_one", "tactic_state": "case intro.intro\n\u03b9 : Sort u_1\nc : \u03b9 \u2192 Set (\u2191unitInterval \u00d7 \u2191unitInterval)\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : univ \u2286 \u22c3 i, c i\n\u03b4 : \u211d\n\u03b4_pos : \u03b4 > 0\nball_subset : \u2200 x \u2208 univ, \u2203 i, Metric.ball x \u03b4 \u2286 c i\nh\u03b4 : 0 < \u03b4 / 2\nh : 0 \u2264 1\n\u22a2 \u2203 t,\n    \u2191(t 0) = \u21910 \u2227\n      Monotone t \u2227 (\u2203 n, \u2200 m \u2265 n, \u2191(t m) = \u21911) \u2227 \u2200 (n m : \u2115), \u2203 i, Icc (t n) (t (n + 1)) \u00d7\u02e2 Icc (t m) (t (m + 1)) \u2286 c i"}, {"line": "refine \u27e8addNSMul h (\u03b4/2), addNSMul_zero h,\n    monotone_addNSMul h h\u03b4.le, addNSMul_eq_right h h\u03b4, fun n m \u21a6 ?_\u27e9", "tactic_state": "case intro.intro\n\u03b9 : Sort u_1\nc : \u03b9 \u2192 Set (\u2191unitInterval \u00d7 \u2191unitInterval)\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : univ \u2286 \u22c3 i, c i\n\u03b4 : \u211d\n\u03b4_pos : \u03b4 > 0\nball_subset : \u2200 x \u2208 univ, \u2203 i, Metric.ball x \u03b4 \u2286 c i\nh\u03b4 : 0 < \u03b4 / 2\nh : 0 \u2264 1\nn m : \u2115\n\u22a2 \u2203 i,\n    Icc (addNSMul h (\u03b4 / 2) n) (addNSMul h (\u03b4 / 2) (n + 1)) \u00d7\u02e2 Icc (addNSMul h (\u03b4 / 2) m) (addNSMul h (\u03b4 / 2) (m + 1)) \u2286\n      c i"}, {"line": "obtain \u27e8i, hsub\u27e9 := ball_subset (addNSMul h (\u03b4/2) n, addNSMul h (\u03b4/2) m) trivial", "tactic_state": "case intro.intro.intro\n\u03b9 : Sort u_1\nc : \u03b9 \u2192 Set (\u2191unitInterval \u00d7 \u2191unitInterval)\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : univ \u2286 \u22c3 i, c i\n\u03b4 : \u211d\n\u03b4_pos : \u03b4 > 0\nball_subset : \u2200 x \u2208 univ, \u2203 i, Metric.ball x \u03b4 \u2286 c i\nh\u03b4 : 0 < \u03b4 / 2\nh : 0 \u2264 1\nn m : \u2115\ni : \u03b9\nhsub : Metric.ball (addNSMul h (\u03b4 / 2) n, addNSMul h (\u03b4 / 2) m) \u03b4 \u2286 c i\n\u22a2 \u2203 i,\n    Icc (addNSMul h (\u03b4 / 2) n) (addNSMul h (\u03b4 / 2) (n + 1)) \u00d7\u02e2 Icc (addNSMul h (\u03b4 / 2) m) (addNSMul h (\u03b4 / 2) (m + 1)) \u2286\n      c i"}, {"line": "exact \u27e8i, fun t ht \u21a6 hsub (Metric.mem_ball.mpr <| (max_le (abs_sub_addNSMul_le h h\u03b4.le n ht.1) <|\n    abs_sub_addNSMul_le h h\u03b4.le m ht.2).trans_lt <| half_lt_self \u03b4_pos)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : unitInterval) : 0 \u2264 (x : \u211d) := by unit_interval\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UnitInterval.lean", "context": {"open": ["Topology Filter Set Int Set.Icc", "scoped unitInterval"], "variables": ["{\u03b1} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.859\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nx : \u2191unitInterval\n\u22a2 0 \u2264 \u2191x"}, {"line": "unit_interval", "tactic_state": "No Goals!"}]}
{"declaration": "theorem affineHomeomorph_image_I (a b : \ud835\udd5c) (h : 0 < a) :\n    affineHomeomorph a b h.ne.symm '' Set.Icc 0 1 = Set.Icc b (a + b) := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UnitInterval.lean", "context": {"open": ["Topology Filter Set Int Set.Icc", "scoped unitInterval"], "variables": ["{\u03b1} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1]", "{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\na b : \ud835\udd5c\nh : 0 < a\n\u22a2 sorry '' Icc 0 1 = Icc b (a + b)"}, {"line": "simp [h]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\na b : \ud835\udd5c\nh : 0 < a\n\u22a2 (fun a => sorry () a) '' Icc 0 1 = Icc b (a + b)"}]}
{"declaration": "lemma unitInterval.toNNReal_continuous : Continuous toNNReal := by\n  delta toNNReal\n  fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UnitInterval.lean", "context": {"open": ["Topology Filter Set Int Set.Icc", "scoped unitInterval", "unitInterval NNReal"], "variables": ["{\u03b1} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1]", "{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Continuous toNNReal"}, {"line": "delta toNNReal", "tactic_state": "\u22a2 Continuous fun i => \u27e8\u2191i, \u22ef\u27e9"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lift_openEmbedding_trans_apply\n    (e e' : PartialHomeomorph X Z) (hf : IsOpenEmbedding f) (z : Z) :\n    (e.lift_openEmbedding hf).symm.trans (e'.lift_openEmbedding hf) z = (e.symm.trans e') z := by\n  simp [hf.injective.extend_apply e']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/PartialHomeomorph.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace"], "variables": ["{X X' : Type*} {Y Y' : Type*} {Z Z' : Type*}", "(e : PartialHomeomorph X Y)", "{e} {s : Set X} {t : Set Y} {x : X} {y : Y}", "{a : X} {b : Y}", "{s : Set X} (hs : IsOpen s)", "(e' : PartialHomeomorph Y Z)", "{\u03b9 : Type*} [Finite \u03b9] {X Y : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (X i)]", "(e : X \u2243\u209c Y) (e' : Y \u2243\u209c Z)", "(f : X \u2192 Y) (h : IsOpenEmbedding f)", "[Nonempty X]", "(s : Opens X) (hs : Nonempty s)", "(e : PartialHomeomorph X Y)", "{s : Opens X} (hs : Nonempty s)", "{X X' Z : Type*} [TopologicalSpace X] [TopologicalSpace X'] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "inst\u271d\u00b2 : Nonempty sorry\nX : Type u_10\nZ : Type u_12\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Z\nY\u271d : Type u_13\nf : X \u2192 Y\u271d\ne e' : PartialHomeomorph X Z\nhf : IsOpenEmbedding f\nz : Z\n\u22a2 sorry = \u2191(e.symm.trans e') z"}, {"line": "simp [hf.injective.extend_apply e']", "tactic_state": "inst\u271d\u00b2 : Nonempty sorry\nX : Type u_10\nZ : Type u_12\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Z\nY\u271d : Type u_13\nf : X \u2192 Y\u271d\ne e' : PartialHomeomorph X Z\nhf : IsOpenEmbedding f\nz : Z\n\u22a2 sorry () = \u2191e' (\u2191e.symm z)"}]}
{"declaration": "lemma subset_coborder :\n    s \u2286 coborder s := by\n  rw [coborder]\n  rw [subset_compl_iff_disjoint_right]\n  exact disjoint_sdiff_self_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2286 coborder s"}, {"line": "rw [coborder]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2286 (closure s \\ s)\u1d9c"}, {"line": "rw [subset_compl_iff_disjoint_right]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 Disjoint s (closure s \\ s)"}, {"line": "exact disjoint_sdiff_self_right", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coborder_inter_closure :\n    coborder s \u2229 closure s = s := by\n  rw [coborder]\n  rw [\u2190 diff_eq_compl_inter]\n  rw [diff_diff_right_self]\n  rw [inter_eq_right]\n  exact subset_closure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 coborder s \u2229 closure s = s"}, {"line": "rw [coborder]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (closure s \\ s)\u1d9c \u2229 closure s = s"}, {"line": "rw [\u2190 diff_eq_compl_inter]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \\ (closure s \\ s) = s"}, {"line": "rw [diff_diff_right_self]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \u2229 s = s"}, {"line": "rw [inter_eq_right]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2286 closure s"}, {"line": "exact subset_closure", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closure_inter_coborder :\n    closure s \u2229 coborder s = s := by\n  rw [inter_comm]\n  rw [coborder_inter_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \u2229 coborder s = s"}, {"line": "rw [inter_comm]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 coborder s \u2229 closure s = s"}, {"line": "rw [coborder_inter_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coborder_eq_union_frontier_compl :\n    coborder s = s \u222a (frontier s)\u1d9c := by\n  rw [coborder]\n  rw [compl_eq_comm]\n  rw [compl_union]\n  rw [compl_compl]\n  rw [\u2190 diff_eq_compl_inter]\n  rw [\u2190 union_diff_right]\n  rw [union_comm]\n  rw [\u2190 closure_eq_self_union_frontier]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 coborder s = s \u222a (frontier s)\u1d9c"}, {"line": "rw [coborder]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (closure s \\ s)\u1d9c = s \u222a (frontier s)\u1d9c"}, {"line": "rw [compl_eq_comm]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (s \u222a (frontier s)\u1d9c)\u1d9c = closure s \\ s"}, {"line": "rw [compl_union]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s\u1d9c \u2229 (frontier s)\u1d9c\u1d9c = closure s \\ s"}, {"line": "rw [compl_compl]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s\u1d9c \u2229 frontier s = closure s \\ s"}, {"line": "rw [\u2190 diff_eq_compl_inter]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 frontier s \\ s = closure s \\ s"}, {"line": "rw [\u2190 union_diff_right]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (frontier s \u222a s) \\ s = closure s \\ s"}, {"line": "rw [union_comm]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (s \u222a frontier s) \\ s = closure s \\ s"}, {"line": "rw [\u2190 closure_eq_self_union_frontier]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coborder_eq_univ_iff :\n    coborder s = univ \u2194 IsClosed s := by\n  simp [coborder, diff_eq_empty, closure_subset_iff_isClosed]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 coborder s = univ \u2194 IsClosed s"}, {"line": "simp [coborder, diff_eq_empty, closure_subset_iff_isClosed]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coborder_eq_compl_frontier_iff :\n    coborder s = (frontier s)\u1d9c \u2194 IsOpen s := by\n  simp_rw [coborder_eq_union_frontier_compl, union_eq_right, subset_compl_iff_disjoint_left,\n    disjoint_frontier_iff_isOpen]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 coborder s = (frontier s)\u1d9c \u2194 IsOpen s"}, {"line": "simp_rw [coborder_eq_union_frontier_compl, union_eq_right, subset_compl_iff_disjoint_left,\n    disjoint_frontier_iff_isOpen]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coborder_eq_union_closure_compl {s : Set X} : coborder s = s \u222a (closure s)\u1d9c := by\n  rw [coborder]\n  rw [compl_eq_comm]\n  rw [compl_union]\n  rw [compl_compl]\n  rw [inter_comm]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 coborder s = s \u222a (closure s)\u1d9c"}, {"line": "rw [coborder]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (closure s \\ s)\u1d9c = s \u222a (closure s)\u1d9c"}, {"line": "rw [compl_eq_comm]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (s \u222a (closure s)\u1d9c)\u1d9c = closure s \\ s"}, {"line": "rw [compl_union]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s\u1d9c \u2229 (closure s)\u1d9c\u1d9c = closure s \\ s"}, {"line": "rw [compl_compl]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s\u1d9c \u2229 closure s = closure s \\ s"}, {"line": "rw [inter_comm]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \u2229 s\u1d9c = closure s \\ s"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dense_coborder {s : Set X} :\n    Dense (coborder s) := by\n  rw [dense_iff_closure_eq]\n  rw [coborder_eq_union_closure_compl]\n  rw [closure_union]\n  rw [\u2190 univ_subset_iff]\n  refine _root_.subset_trans ?_ (union_subset_union_right _ (subset_closure))\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 Dense (coborder s)"}, {"line": "rw [dense_iff_closure_eq]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure (coborder s) = univ"}, {"line": "rw [coborder_eq_union_closure_compl]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure (s \u222a (closure s)\u1d9c) = univ"}, {"line": "rw [closure_union]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \u222a closure (closure s)\u1d9c = univ"}, {"line": "rw [\u2190 univ_subset_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 univ \u2286 closure s \u222a closure (closure s)\u1d9c"}, {"line": "refine _root_.subset_trans ?_ (union_subset_union_right _ (subset_closure))", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 univ \u2286 closure s \u222a (closure s)\u1d9c"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsOpenMap.coborder_preimage_subset (hf : IsOpenMap f) (s : Set Y) :\n    coborder (f \u207b\u00b9' s) \u2286 f \u207b\u00b9' (coborder s) := by\n  rw [coborder]\n  rw [coborder]\n  rw [preimage_compl]\n  rw [preimage_diff]\n  rw [compl_subset_compl]\n  apply diff_subset_diff_left\n  exact hf.preimage_closure_subset_closure_preimage\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsOpenMap f\ns : Set Y\n\u22a2 coborder (f \u207b\u00b9' s) \u2286 f \u207b\u00b9' coborder s"}, {"line": "rw [coborder]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsOpenMap f\ns : Set Y\n\u22a2 (closure (f \u207b\u00b9' s) \\ f \u207b\u00b9' s)\u1d9c \u2286 f \u207b\u00b9' coborder s"}, {"line": "rw [coborder]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsOpenMap f\ns : Set Y\n\u22a2 (closure (f \u207b\u00b9' s) \\ f \u207b\u00b9' s)\u1d9c \u2286 f \u207b\u00b9' (closure s \\ s)\u1d9c"}, {"line": "rw [preimage_compl]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsOpenMap f\ns : Set Y\n\u22a2 (closure (f \u207b\u00b9' s) \\ f \u207b\u00b9' s)\u1d9c \u2286 (f \u207b\u00b9' (closure s \\ s))\u1d9c"}, {"line": "rw [preimage_diff]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsOpenMap f\ns : Set Y\n\u22a2 (closure (f \u207b\u00b9' s) \\ f \u207b\u00b9' s)\u1d9c \u2286 (f \u207b\u00b9' closure s \\ f \u207b\u00b9' s)\u1d9c"}, {"line": "rw [compl_subset_compl]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsOpenMap f\ns : Set Y\n\u22a2 f \u207b\u00b9' closure s \\ f \u207b\u00b9' s \u2286 closure (f \u207b\u00b9' s) \\ f \u207b\u00b9' s"}, {"line": "apply diff_subset_diff_left", "tactic_state": "case h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : IsOpenMap f\ns : Set Y\n\u22a2 f \u207b\u00b9' closure s \u2286 closure (f \u207b\u00b9' s)"}, {"line": "exact hf.preimage_closure_subset_closure_preimage", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Continuous.preimage_coborder_subset (hf : Continuous f) (s : Set Y) :\n    f \u207b\u00b9' (coborder s) \u2286 coborder (f \u207b\u00b9' s) := by\n  rw [coborder]\n  rw [coborder]\n  rw [preimage_compl]\n  rw [preimage_diff]\n  rw [compl_subset_compl]\n  apply diff_subset_diff_left\n  exact hf.closure_preimage_subset s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Continuous f\ns : Set Y\n\u22a2 f \u207b\u00b9' coborder s \u2286 coborder (f \u207b\u00b9' s)"}, {"line": "rw [coborder]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Continuous f\ns : Set Y\n\u22a2 f \u207b\u00b9' (closure s \\ s)\u1d9c \u2286 coborder (f \u207b\u00b9' s)"}, {"line": "rw [coborder]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Continuous f\ns : Set Y\n\u22a2 f \u207b\u00b9' (closure s \\ s)\u1d9c \u2286 (closure (f \u207b\u00b9' s) \\ f \u207b\u00b9' s)\u1d9c"}, {"line": "rw [preimage_compl]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Continuous f\ns : Set Y\n\u22a2 (f \u207b\u00b9' (closure s \\ s))\u1d9c \u2286 (closure (f \u207b\u00b9' s) \\ f \u207b\u00b9' s)\u1d9c"}, {"line": "rw [preimage_diff]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Continuous f\ns : Set Y\n\u22a2 (f \u207b\u00b9' closure s \\ f \u207b\u00b9' s)\u1d9c \u2286 (closure (f \u207b\u00b9' s) \\ f \u207b\u00b9' s)\u1d9c"}, {"line": "rw [compl_subset_compl]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Continuous f\ns : Set Y\n\u22a2 closure (f \u207b\u00b9' s) \\ f \u207b\u00b9' s \u2286 f \u207b\u00b9' closure s \\ f \u207b\u00b9' s"}, {"line": "apply diff_subset_diff_left", "tactic_state": "case h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Continuous f\ns : Set Y\n\u22a2 closure (f \u207b\u00b9' s) \u2286 f \u207b\u00b9' closure s"}, {"line": "exact hf.closure_preimage_subset s", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isClosed_preimage_val_coborder :\n    IsClosed (coborder s \u2193\u2229 s) := by\n  rw [isClosed_preimage_val]\n  rw [inter_eq_right.mpr subset_coborder]\n  rw [coborder_inter_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsClosed (Subtype.val \u207b\u00b9' s)"}, {"line": "rw [isClosed_preimage_val]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 coborder s \u2229 closure (coborder s \u2229 s) \u2286 s"}, {"line": "rw [inter_eq_right.mpr subset_coborder]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 coborder s \u2229 closure s \u2286 s"}, {"line": "rw [coborder_inter_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLocallyClosed.inter (hs : IsLocallyClosed s) (ht : IsLocallyClosed t) :\n    IsLocallyClosed (s \u2229 t) := by\n  obtain \u27e8U\u2081, Z\u2081, hU\u2081, hZ\u2081, rfl\u27e9 := hs\n  obtain \u27e8U\u2082, Z\u2082, hU\u2082, hZ\u2082, rfl\u27e9 := ht\n  refine \u27e8_, _, hU\u2081.inter hU\u2082, hZ\u2081.inter hZ\u2082, inter_inter_inter_comm U\u2081 Z\u2081 U\u2082 Z\u2082\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhs : IsLocallyClosed s\nht : IsLocallyClosed t\n\u22a2 IsLocallyClosed (s \u2229 t)"}, {"line": "obtain \u27e8U\u2081, Z\u2081, hU\u2081, hZ\u2081, rfl\u27e9 := hs", "tactic_state": "case intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\nt : Set X\nht : IsLocallyClosed t\nU\u2081 Z\u2081 : Set X\nhU\u2081 : IsOpen U\u2081\nhZ\u2081 : IsClosed Z\u2081\n\u22a2 IsLocallyClosed (U\u2081 \u2229 Z\u2081 \u2229 t)"}, {"line": "obtain \u27e8U\u2082, Z\u2082, hU\u2082, hZ\u2082, rfl\u27e9 := ht", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\nU\u2081 Z\u2081 : Set X\nhU\u2081 : IsOpen U\u2081\nhZ\u2081 : IsClosed Z\u2081\nU\u2082 Z\u2082 : Set X\nhU\u2082 : IsOpen U\u2082\nhZ\u2082 : IsClosed Z\u2082\n\u22a2 IsLocallyClosed (U\u2081 \u2229 Z\u2081 \u2229 (U\u2082 \u2229 Z\u2082))"}, {"line": "refine \u27e8_, _, hU\u2081.inter hU\u2082, hZ\u2081.inter hZ\u2082, inter_inter_inter_comm U\u2081 Z\u2081 U\u2082 Z\u2082\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLocallyClosed.preimage {s : Set Y} (hs : IsLocallyClosed s)\n    {f : X \u2192 Y} (hf : Continuous f) :\n    IsLocallyClosed (f \u207b\u00b9' s) := by\n  obtain \u27e8U, Z, hU, hZ, rfl\u27e9 := hs\n  exact \u27e8_, _, hU.preimage hf, hZ.preimage hf, preimage_inter\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyClosed.lean", "context": {"open": ["Set Topology", "scoped Set.Notation"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set Y\nhs : IsLocallyClosed s\nf : X \u2192 Y\nhf : Continuous f\n\u22a2 IsLocallyClosed (f \u207b\u00b9' s)"}, {"line": "obtain \u27e8U, Z, hU, hZ, rfl\u27e9 := hs", "tactic_state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Continuous f\nU Z : Set Y\nhU : IsOpen U\nhZ : IsClosed Z\n\u22a2 IsLocallyClosed (f \u207b\u00b9' (U \u2229 Z))"}, {"line": "exact \u27e8_, _, hU.preimage hf, hZ.preimage hf, preimage_inter\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_forall_eventually_eq_prod {\u03c0 : X \u2192 Sort*} {f : \u2115 \u2192 \u2200 x : X, \u03c0 x}\n    (hf : LocallyFinite fun n => { x | f (n + 1) x \u2260 f n x }) :\n    \u2203 F : \u2200 x : X, \u03c0 x, \u2200 x, \u2200\u1da0 p : \u2115 \u00d7 X in atTop \u00d7\u02e2 \ud835\udcdd x, f p.1 p.2 = F p.2 := by\n  choose U hUx hU using hf\n  choose N hN using fun x => (hU x).bddAbove\n  replace hN : \u2200 (x), \u2200 n > N x, \u2200 y \u2208 U x, f (n + 1) y = f n y :=\n    fun x n hn y hy => by_contra fun hne => hn.lt.not_le <| hN x \u27e8y, hne, hy\u27e9\n  replace hN : \u2200 (x), \u2200 n \u2265 N x + 1, \u2200 y \u2208 U x, f n y = f (N x + 1) y :=\n    fun x n hn y hy => Nat.le_induction rfl (fun k hle => (hN x _ hle _ hy).trans) n hn\n  refine \u27e8fun x => f (N x + 1) x, fun x => ?_\u27e9\n  filter_upwards [Filter.prod_mem_prod (eventually_gt_atTop (N x)) (hUx x)]\n  rintro \u27e8n, y\u27e9 \u27e8hn : N x < n, hy : y \u2208 U x\u27e9\n  calc\n    f n y = f (N x + 1) y := hN _ _ hn _ hy\n    _ = f (max (N x + 1) (N y + 1)) y := (hN _ _ (le_max_left _ _) _ hy).symm\n    _ = f (N y + 1) y := hN _ _ (le_max_right _ _) _ (mem_of_mem_nhds <| hUx y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyFinite.lean", "context": {"open": ["Set Function Filter Topology"], "variables": ["{\u03b9 \u03b9' \u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f g : \u03b9 \u2192 Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\n\u03c0 : X \u2192 Sort u_6\nf : \u2115 \u2192 (x : X) \u2192 \u03c0 x\nhf : LocallyFinite fun n => {x | f (n + 1) x \u2260 f n x}\n\u22a2 \u2203 F, \u2200 (x : X), \u2200\u1da0 (p : \u2115 \u00d7 X) in atTop \u00d7\u02e2 nhds x, f p.1 p.2 = F p.2"}, {"line": "choose U hUx hU using hf", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\n\u03c0 : X \u2192 Sort u_6\nf : \u2115 \u2192 (x : X) \u2192 \u03c0 x\nU : X \u2192 Set X\nhUx : \u2200 (x : X), U x \u2208 nhds x\nhU : \u2200 (x : X), {i | ((fun n => {x | f (n + 1) x \u2260 f n x}) i \u2229 U x).Nonempty}.Finite\n\u22a2 \u2203 F, \u2200 (x : X), \u2200\u1da0 (p : \u2115 \u00d7 X) in atTop \u00d7\u02e2 nhds x, f p.1 p.2 = F p.2"}, {"line": "choose N hN using fun x => (hU x).bddAbove", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\n\u03c0 : X \u2192 Sort u_6\nf : \u2115 \u2192 (x : X) \u2192 \u03c0 x\nU : X \u2192 Set X\nhUx : \u2200 (x : X), U x \u2208 nhds x\nhU : \u2200 (x : X), {i | ((fun n => {x | f (n + 1) x \u2260 f n x}) i \u2229 U x).Nonempty}.Finite\nN : X \u2192 \u2115\nhN : \u2200 (x : X), N x \u2208 upperBounds {i | ((fun n => {x | f (n + 1) x \u2260 f n x}) i \u2229 U x).Nonempty}\n\u22a2 \u2203 F, \u2200 (x : X), \u2200\u1da0 (p : \u2115 \u00d7 X) in atTop \u00d7\u02e2 nhds x, f p.1 p.2 = F p.2"}, {"line": "replace hN : \u2200 (x), \u2200 n > N x, \u2200 y \u2208 U x, f (n + 1) y = f n y :=\n    fun x n hn y hy => by_contra fun hne => hn.lt.not_le <| hN x \u27e8y, hne, hy\u27e9", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\n\u03c0 : X \u2192 Sort u_6\nf : \u2115 \u2192 (x : X) \u2192 \u03c0 x\nU : X \u2192 Set X\nhUx : \u2200 (x : X), U x \u2208 nhds x\nhU : \u2200 (x : X), {i | ((fun n => {x | f (n + 1) x \u2260 f n x}) i \u2229 U x).Nonempty}.Finite\nN : X \u2192 \u2115\nhN : \u2200 (x : X), \u2200 n > N x, \u2200 y \u2208 U x, f (n + 1) y = f n y\n\u22a2 \u2203 F, \u2200 (x : X), \u2200\u1da0 (p : \u2115 \u00d7 X) in atTop \u00d7\u02e2 nhds x, f p.1 p.2 = F p.2"}, {"line": "replace hN : \u2200 (x), \u2200 n \u2265 N x + 1, \u2200 y \u2208 U x, f n y = f (N x + 1) y :=\n    fun x n hn y hy => Nat.le_induction rfl (fun k hle => (hN x _ hle _ hy).trans) n hn", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\n\u03c0 : X \u2192 Sort u_6\nf : \u2115 \u2192 (x : X) \u2192 \u03c0 x\nU : X \u2192 Set X\nhUx : \u2200 (x : X), U x \u2208 nhds x\nhU : \u2200 (x : X), {i | ((fun n => {x | f (n + 1) x \u2260 f n x}) i \u2229 U x).Nonempty}.Finite\nN : X \u2192 \u2115\nhN : \u2200 (x : X), \u2200 n \u2265 N x + 1, \u2200 y \u2208 U x, f n y = f (N x + 1) y\n\u22a2 \u2203 F, \u2200 (x : X), \u2200\u1da0 (p : \u2115 \u00d7 X) in atTop \u00d7\u02e2 nhds x, f p.1 p.2 = F p.2"}, {"line": "refine \u27e8fun x => f (N x + 1) x, fun x => ?_\u27e9", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\n\u03c0 : X \u2192 Sort u_6\nf : \u2115 \u2192 (x : X) \u2192 \u03c0 x\nU : X \u2192 Set X\nhUx : \u2200 (x : X), U x \u2208 nhds x\nhU : \u2200 (x : X), {i | ((fun n => {x | f (n + 1) x \u2260 f n x}) i \u2229 U x).Nonempty}.Finite\nN : X \u2192 \u2115\nhN : \u2200 (x : X), \u2200 n \u2265 N x + 1, \u2200 y \u2208 U x, f n y = f (N x + 1) y\nx : X\n\u22a2 \u2200\u1da0 (p : \u2115 \u00d7 X) in atTop \u00d7\u02e2 nhds x, f p.1 p.2 = (fun x => f (N x + 1) x) p.2"}, {"line": "filter_upwards [Filter.prod_mem_prod (eventually_gt_atTop (N x)) (hUx x)]", "tactic_state": "case h\nX : Type u_4\ninst\u271d : TopologicalSpace X\n\u03c0 : X \u2192 Sort u_6\nf : \u2115 \u2192 (x : X) \u2192 \u03c0 x\nU : X \u2192 Set X\nhUx : \u2200 (x : X), U x \u2208 nhds x\nhU : \u2200 (x : X), {i | ((fun n => {x | f (n + 1) x \u2260 f n x}) i \u2229 U x).Nonempty}.Finite\nN : X \u2192 \u2115\nhN : \u2200 (x : X), \u2200 n \u2265 N x + 1, \u2200 y \u2208 U x, f n y = f (N x + 1) y\nx : X\n\u22a2 \u2200 a \u2208 {x_1 | N x < x_1} \u00d7\u02e2 U x, f a.1 a.2 = f (N a.2 + 1) a.2"}, {"line": "rintro \u27e8n, y\u27e9 \u27e8hn : N x < n, hy : y \u2208 U x\u27e9", "tactic_state": "case h.mk.intro\nX : Type u_4\ninst\u271d : TopologicalSpace X\n\u03c0 : X \u2192 Sort u_6\nf : \u2115 \u2192 (x : X) \u2192 \u03c0 x\nU : X \u2192 Set X\nhUx : \u2200 (x : X), U x \u2208 nhds x\nhU : \u2200 (x : X), {i | ((fun n => {x | f (n + 1) x \u2260 f n x}) i \u2229 U x).Nonempty}.Finite\nN : X \u2192 \u2115\nhN : \u2200 (x : X), \u2200 n \u2265 N x + 1, \u2200 y \u2208 U x, f n y = f (N x + 1) y\nx : X\nn : \u2115\ny : X\nhn : N x < n\nhy : y \u2208 U x\n\u22a2 f (n, y).1 (n, y).2 = f (N (n, y).2 + 1) (n, y).2"}, {"line": "calc\n    f n y = f (N x + 1) y := hN _ _ hn _ hy\n    _ = f (max (N x + 1) (N y + 1)) y := (hN _ _ (le_max_left _ _) _ hy).symm\n    _ = f (N y + 1) y := hN _ _ (le_max_right _ _) _ (mem_of_mem_nhds <| hUx y)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem locallyFinite_sum {f : \u03b9 \u2295 \u03b9' \u2192 Set X} :\n    LocallyFinite f \u2194 LocallyFinite (f \u2218 Sum.inl) \u2227 LocallyFinite (f \u2218 Sum.inr) := by\n  simp only [locallyFinite_iff_smallSets]\n  simp only [\u2190 forall_and]\n  simp only [\u2190 finite_preimage_inl_and_inr]\n  simp only [preimage_setOf_eq]\n  simp only [(\u00b7 \u2218 \u00b7)]\n  simp only [eventually_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyFinite.lean", "context": {"open": ["Set Function Filter Topology"], "variables": ["{\u03b9 \u03b9' \u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f g : \u03b9 \u2192 Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nX : Type u_4\ninst\u271d : TopologicalSpace X\nf : \u03b9 \u2295 \u03b9' \u2192 Set X\n\u22a2 LocallyFinite f \u2194 LocallyFinite (f \u2218 Sum.inl) \u2227 LocallyFinite (f \u2218 Sum.inr)"}, {"line": "simp only [locallyFinite_iff_smallSets]", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nX : Type u_4\ninst\u271d : TopologicalSpace X\nf : \u03b9 \u2295 \u03b9' \u2192 Set X\n\u22a2 (\u2200 (x : X), \u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | (f i \u2229 s).Nonempty}.Finite) \u2194\n    (\u2200 (x : X), \u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | ((f \u2218 Sum.inl) i \u2229 s).Nonempty}.Finite) \u2227\n      \u2200 (x : X), \u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | ((f \u2218 Sum.inr) i \u2229 s).Nonempty}.Finite"}, {"line": "simp only [\u2190 forall_and]", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nX : Type u_4\ninst\u271d : TopologicalSpace X\nf : \u03b9 \u2295 \u03b9' \u2192 Set X\n\u22a2 (\u2200 (x : X), \u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | (f i \u2229 s).Nonempty}.Finite) \u2194\n    \u2200 (x : X),\n      (\u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | ((f \u2218 Sum.inl) i \u2229 s).Nonempty}.Finite) \u2227\n        \u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | ((f \u2218 Sum.inr) i \u2229 s).Nonempty}.Finite"}, {"line": "simp only [\u2190 finite_preimage_inl_and_inr]", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nX : Type u_4\ninst\u271d : TopologicalSpace X\nf : \u03b9 \u2295 \u03b9' \u2192 Set X\n\u22a2 (\u2200 (x : X),\n      \u2200\u1da0 (s : Set X) in (nhds x).smallSets,\n        (Sum.inl \u207b\u00b9' {i | (f i \u2229 s).Nonempty}).Finite \u2227 (Sum.inr \u207b\u00b9' {i | (f i \u2229 s).Nonempty}).Finite) \u2194\n    \u2200 (x : X),\n      (\u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | ((f \u2218 Sum.inl) i \u2229 s).Nonempty}.Finite) \u2227\n        \u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | ((f \u2218 Sum.inr) i \u2229 s).Nonempty}.Finite"}, {"line": "simp only [preimage_setOf_eq]", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nX : Type u_4\ninst\u271d : TopologicalSpace X\nf : \u03b9 \u2295 \u03b9' \u2192 Set X\n\u22a2 (\u2200 (x : X),\n      \u2200\u1da0 (s : Set X) in (nhds x).smallSets,\n        {a | (f (Sum.inl a) \u2229 s).Nonempty}.Finite \u2227 {a | (f (Sum.inr a) \u2229 s).Nonempty}.Finite) \u2194\n    \u2200 (x : X),\n      (\u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | ((f \u2218 Sum.inl) i \u2229 s).Nonempty}.Finite) \u2227\n        \u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | ((f \u2218 Sum.inr) i \u2229 s).Nonempty}.Finite"}, {"line": "simp only [(\u00b7 \u2218 \u00b7)]", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nX : Type u_4\ninst\u271d : TopologicalSpace X\nf : \u03b9 \u2295 \u03b9' \u2192 Set X\n\u22a2 (\u2200 (x : X),\n      \u2200\u1da0 (s : Set X) in (nhds x).smallSets,\n        {a | (f (Sum.inl a) \u2229 s).Nonempty}.Finite \u2227 {a | (f (Sum.inr a) \u2229 s).Nonempty}.Finite) \u2194\n    \u2200 (x : X),\n      (\u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | (f (Sum.inl i) \u2229 s).Nonempty}.Finite) \u2227\n        \u2200\u1da0 (s : Set X) in (nhds x).smallSets, {i | (f (Sum.inr i) \u2229 s).Nonempty}.Finite"}, {"line": "simp only [eventually_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LocallyFinite.eventually_subset {s : \u03b9 \u2192 Set X}\n    (hs : LocallyFinite s) (hs' : \u2200 i, IsClosed (s i)) (x : X) :\n    \u2200\u1da0 y in \ud835\udcdd x, {i | y \u2208 s i} \u2286 {i | x \u2208 s i} := by\n  filter_upwards [hs.iInter_compl_mem_nhds hs' x] with y hy i hi\n  simp only [mem_iInter] at hy\n  simp only [mem_compl_iff] at hy\n  exact not_imp_not.mp (hy i) hi", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/LocallyFinite.lean", "context": {"open": ["Set Function Filter Topology"], "variables": ["{\u03b9 \u03b9' \u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f g : \u03b9 \u2192 Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : Type u_4\ninst\u271d : TopologicalSpace X\ns : \u03b9 \u2192 Set X\nhs : LocallyFinite s\nhs' : \u2200 (i : \u03b9), IsClosed (s i)\nx : X\n\u22a2 \u2200\u1da0 (y : X) in nhds x, {i | y \u2208 s i} \u2286 {i | x \u2208 s i}"}, {"line": "filter_upwards [hs.iInter_compl_mem_nhds hs' x] with y hy i hi", "tactic_state": "case h\n\u03b9 : Type u_1\nX : Type u_4\ninst\u271d : TopologicalSpace X\ns : \u03b9 \u2192 Set X\nhs : LocallyFinite s\nhs' : \u2200 (i : \u03b9), IsClosed (s i)\nx y : X\nhy : y \u2208 \u22c2 i, \u22c2 (_ : x \u2209 s i), (s i)\u1d9c\ni : \u03b9\nhi : i \u2208 {i | y \u2208 s i}\n\u22a2 i \u2208 {i | x \u2208 s i}"}, {"line": "simp only [mem_iInter] at hy", "tactic_state": "case h\n\u03b9 : Type u_1\nX : Type u_4\ninst\u271d : TopologicalSpace X\ns : \u03b9 \u2192 Set X\nhs : LocallyFinite s\nhs' : \u2200 (i : \u03b9), IsClosed (s i)\nx y : X\ni : \u03b9\nhi : i \u2208 {i | y \u2208 s i}\nhy : \u2200 (i : \u03b9), x \u2209 s i \u2192 y \u2208 (s i)\u1d9c\n\u22a2 i \u2208 {i | x \u2208 s i}"}, {"line": "simp only [mem_compl_iff] at hy", "tactic_state": "case h\n\u03b9 : Type u_1\nX : Type u_4\ninst\u271d : TopologicalSpace X\ns : \u03b9 \u2192 Set X\nhs : LocallyFinite s\nhs' : \u2200 (i : \u03b9), IsClosed (s i)\nx y : X\ni : \u03b9\nhi : i \u2208 {i | y \u2208 s i}\nhy : \u2200 (i : \u03b9), x \u2209 s i \u2192 y \u2209 s i\n\u22a2 i \u2208 {i | x \u2208 s i}"}, {"line": "exact not_imp_not.mp (hy i) hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_def' (x : X) : \ud835\udcdd x = \u2a05 (s : Set X) (_ : IsOpen s) (_ : x \u2208 s), \ud835\udcdf s := by\n  simp only [nhds_def]\n  simp only [mem_setOf_eq]\n  simp only [@and_comm (x \u2208 _)]\n  simp only [iInf_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 nhds x = \u2a05 s, \u2a05 (_ : IsOpen s), \u2a05 (_ : x \u2208 s), principal s"}, {"line": "simp only [nhds_def]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 \u2a05 s \u2208 {s | x \u2208 s \u2227 IsOpen s}, principal s = \u2a05 s, \u2a05 (_ : IsOpen s), \u2a05 (_ : x \u2208 s), principal s"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 \u2a05 s, \u2a05 (_ : x \u2208 s \u2227 IsOpen s), principal s = \u2a05 s, \u2a05 (_ : IsOpen s), \u2a05 (_ : x \u2208 s), principal s"}, {"line": "simp only [@and_comm (x \u2208 _)]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 \u2a05 s, \u2a05 (_ : IsOpen s \u2227 x \u2208 s), principal s = \u2a05 s, \u2a05 (_ : IsOpen s), \u2a05 (_ : x \u2208 s), principal s"}, {"line": "simp only [iInf_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_basis_opens (x : X) :\n    (\ud835\udcdd x).HasBasis (fun s : Set X => x \u2208 s \u2227 IsOpen s) fun s => s := by\n  rw [nhds_def]\n  exact hasBasis_biInf_principal\n    (fun s \u27e8has, hs\u27e9 t \u27e8hat, ht\u27e9 =>\n      \u27e8s \u2229 t, \u27e8\u27e8has, hat\u27e9, IsOpen.inter hs ht\u27e9, \u27e8inter_subset_left, inter_subset_right\u27e9\u27e9)\n    \u27e8univ, \u27e8mem_univ x, isOpen_univ\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 (nhds x).HasBasis (fun s => x \u2208 s \u2227 IsOpen s) fun s => s"}, {"line": "rw [nhds_def]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 (\u2a05 s \u2208 {s | x \u2208 s \u2227 IsOpen s}, principal s).HasBasis (fun s => x \u2208 s \u2227 IsOpen s) fun s => s"}, {"line": "exact hasBasis_biInf_principal\n    (fun s \u27e8has, hs\u27e9 t \u27e8hat, ht\u27e9 =>\n      \u27e8s \u2229 t, \u27e8\u27e8has, hat\u27e9, IsOpen.inter hs ht\u27e9, \u27e8inter_subset_left, inter_subset_right\u27e9\u27e9)\n    \u27e8univ, \u27e8mem_univ x, isOpen_univ\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_nhds_iff {f} : f \u2264 \ud835\udcdd x \u2194 \u2200 s : Set X, x \u2208 s \u2192 IsOpen s \u2192 s \u2208 f := by simp [nhds_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nf : Filter X\n\u22a2 f \u2264 nhds x \u2194 \u2200 (s : Set X), x \u2208 s \u2192 IsOpen s \u2192 s \u2208 f"}, {"line": "simp [nhds_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_basis_opens' (x : X) :\n    (\ud835\udcdd x).HasBasis (fun s : Set X => s \u2208 \ud835\udcdd x \u2227 IsOpen s) fun x => x := by\n  convert nhds_basis_opens x using 2\n  exact and_congr_left_iff.2 IsOpen.mem_nhds_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 (nhds x).HasBasis (fun s => s \u2208 nhds x \u2227 IsOpen s) fun x => x"}, {"line": "convert nhds_basis_opens x using 2", "tactic_state": "case h.e'_4.h.a\nX : Type u\ninst\u271d : TopologicalSpace X\nx : X\nx\u271d : Set X\n\u22a2 x\u271d \u2208 nhds x \u2227 IsOpen x\u271d \u2194 x \u2208 x\u271d \u2227 IsOpen x\u271d"}, {"line": "exact and_congr_left_iff.2 IsOpen.mem_nhds_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_frequently_nhds {p : X \u2192 Prop} :\n    (\u2203\u1da0 x' in \ud835\udcdd x, \u2203\u1da0 x'' in \ud835\udcdd x', p x'') \u2194 \u2203\u1da0 x in \ud835\udcdd x, p x := by\n  rw [\u2190 not_iff_not]\n  simp only [not_frequently]\n  simp only [eventually_eventually_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\np : X \u2192 Prop\n\u22a2 (\u2203\u1da0 (x' : X) in nhds x, \u2203\u1da0 (x'' : X) in nhds x', p x'') \u2194 \u2203\u1da0 (x : X) in nhds x, p x"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\np : X \u2192 Prop\n\u22a2 (\u00ac\u2203\u1da0 (x' : X) in nhds x, \u2203\u1da0 (x'' : X) in nhds x', p x'') \u2194 \u00ac\u2203\u1da0 (x : X) in nhds x, p x"}, {"line": "simp only [not_frequently]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\np : X \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : X) in nhds x, \u2200\u1da0 (x : X) in nhds x, \u00acp x) \u2194 \u2200\u1da0 (x : X) in nhds x, \u00acp x"}, {"line": "simp only [eventually_eventually_nhds]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_interior_iff_nhds {V : Set X} : s \u2286 interior V \u2194 \u2200 x \u2208 s, V \u2208 \ud835\udcdd x := by\n  simp_rw [subset_def, mem_interior_iff_mem_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns V : Set X\n\u22a2 s \u2286 interior V \u2194 \u2200 x \u2208 s, V \u2208 nhds x"}, {"line": "simp_rw [subset_def, mem_interior_iff_mem_nhds]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_iff_nhds : IsOpen s \u2194 \u2200 x \u2208 s, \ud835\udcdd x \u2264 \ud835\udcdf s :=\n  calc\n    IsOpen s \u2194 s \u2286 interior s := subset_interior_iff_isOpen.symm\n    _ \u2194 \u2200 x \u2208 s, \ud835\udcdd x \u2264 \ud835\udcdf s := by simp_rw [interior_eq_nhds, subset_def, mem_setOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2286 interior s \u2194 \u2200 x \u2208 s, nhds x \u2264 principal s"}, {"line": "simp_rw [interior_eq_nhds, subset_def, mem_setOf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_singleton_iff_nhds_eq_pure (x : X) : IsOpen ({x} : Set X) \u2194 \ud835\udcdd x = pure x := by\n  simp [\u2190 (pure_le_nhds _).le_iff_eq, isOpen_iff_mem_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 IsOpen {x} \u2194 nhds x = pure x"}, {"line": "simp [\u2190 (pure_le_nhds _).le_iff_eq, isOpen_iff_mem_nhds]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_singleton_iff_punctured_nhds (x : X) : IsOpen ({x} : Set X) \u2194 \ud835\udcdd[\u2260] x = \u22a5 := by\n  rw [isOpen_singleton_iff_nhds_eq_pure]\n  rw [nhdsWithin]\n  rw [\u2190 mem_iff_inf_principal_compl]\n  rw [le_antisymm_iff]\n  simp [pure_le_nhds x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 IsOpen {x} \u2194 nhdsWithin x {x}\u1d9c = \u22a5"}, {"line": "rw [isOpen_singleton_iff_nhds_eq_pure]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 nhds x = pure x \u2194 nhdsWithin x {x}\u1d9c = \u22a5"}, {"line": "rw [nhdsWithin]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 nhds x = pure x \u2194 nhds x \u2293 principal {x}\u1d9c = \u22a5"}, {"line": "rw [\u2190 mem_iff_inf_principal_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 nhds x = pure x \u2194 {x} \u2208 nhds x"}, {"line": "rw [le_antisymm_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 nhds x \u2264 pure x \u2227 pure x \u2264 nhds x \u2194 {x} \u2208 nhds x"}, {"line": "simp [pure_le_nhds x]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 {x} \u2208 nhds x \u2192 pure x \u2264 nhds x"}]}
{"declaration": "theorem mem_closure_iff_frequently : x \u2208 closure s \u2194 \u2203\u1da0 x in \ud835\udcdd x, x \u2208 s := by\n  rw [Filter.Frequently]\n  rw [Filter.Eventually]\n  rw [\u2190 mem_interior_iff_mem_nhds]\n  rw [closure_eq_compl_interior_compl]\n  rw [mem_compl_iff]\n  rw [compl_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2208 closure s \u2194 \u2203\u1da0 (x : X) in nhds x, x \u2208 s"}, {"line": "rw [Filter.Frequently]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2208 closure s \u2194 \u00ac\u2200\u1da0 (x : X) in nhds x, x \u2209 s"}, {"line": "rw [Filter.Eventually]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2208 closure s \u2194 {x | x \u2209 s} \u2209 nhds x"}, {"line": "rw [\u2190 mem_interior_iff_mem_nhds]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2208 closure s \u2194 x \u2209 interior {x | x \u2209 s}"}, {"line": "rw [closure_eq_compl_interior_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2208 (interior s\u1d9c)\u1d9c \u2194 x \u2209 interior {x | x \u2209 s}"}, {"line": "rw [mem_compl_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2209 interior s\u1d9c \u2194 x \u2209 interior {x | x \u2209 s}"}, {"line": "rw [compl_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_iff_frequently : IsClosed s \u2194 \u2200 x, (\u2203\u1da0 y in \ud835\udcdd x, y \u2208 s) \u2192 x \u2208 s := by\n  rw [\u2190 closure_subset_iff_isClosed]\n  refine forall_congr' fun x => ?_\n  rw [mem_closure_iff_frequently]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsClosed s \u2194 \u2200 (x : X), (\u2203\u1da0 (y : X) in nhds x, y \u2208 s) \u2192 x \u2208 s"}, {"line": "rw [\u2190 closure_subset_iff_isClosed]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \u2286 s \u2194 \u2200 (x : X), (\u2203\u1da0 (y : X) in nhds x, y \u2208 s) \u2192 x \u2208 s"}, {"line": "refine forall_congr' fun x => ?_", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nx : X\n\u22a2 x \u2208 closure s \u2192 x \u2208 s \u2194 (\u2203\u1da0 (y : X) in nhds x, y \u2208 s) \u2192 x \u2208 s"}, {"line": "rw [mem_closure_iff_frequently]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nhdsWithin_neBot : (\ud835\udcdd[s] x).NeBot \u2194 \u2200 \u2983t\u2984, t \u2208 \ud835\udcdd x \u2192 (t \u2229 s).Nonempty := by\n  rw [nhdsWithin]\n  rw [inf_neBot_iff]\n  exact forall\u2082_congr fun U _ \u21a6\n    \u27e8fun h \u21a6 h (mem_principal_self _), fun h u hsu \u21a6 h.mono <| inter_subset_inter_right _ hsu\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (nhdsWithin x s).NeBot \u2194 \u2200 \u2983t : Set X\u2984, t \u2208 nhds x \u2192 (t \u2229 s).Nonempty"}, {"line": "rw [nhdsWithin]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (nhds x \u2293 principal s).NeBot \u2194 \u2200 \u2983t : Set X\u2984, t \u2208 nhds x \u2192 (t \u2229 s).Nonempty"}, {"line": "rw [inf_neBot_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (\u2200 \u2983s_1 : Set X\u2984, s_1 \u2208 nhds x \u2192 \u2200 \u2983s' : Set X\u2984, s' \u2208 principal s \u2192 (s_1 \u2229 s').Nonempty) \u2194\n    \u2200 \u2983t : Set X\u2984, t \u2208 nhds x \u2192 (t \u2229 s).Nonempty"}, {"line": "exact forall\u2082_congr fun U _ \u21a6\n    \u27e8fun h \u21a6 h (mem_principal_self _), fun h u hsu \u21a6 h.mono <| inter_subset_inter_right _ hsu\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsClosed.interior_union_right (h : IsClosed t) :\n    interior (s \u222a t) \u2286 interior s \u222a t := by\n  simpa only [union_comm _ t] using h.interior_union_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns t : Set X\nh : IsClosed t\n\u22a2 interior (s \u222a t) \u2286 interior s \u222a t"}, {"line": "simpa only [union_comm _ t] using h.interior_union_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpen.closure_inter (h : IsOpen t) : closure s \u2229 t \u2286 closure (s \u2229 t) := by\n  simpa only [inter_comm t] using h.inter_closure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Neighborhoods.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns t : Set X\nh : IsOpen t\n\u22a2 closure s \u2229 t \u2286 closure (s \u2229 t)"}, {"line": "simpa only [inter_comm t] using h.inter_closure", "tactic_state": "No Goals!"}]}
{"declaration": "theorem is\u03c9Sup_iff_isLUB {\u03b1 : Type u} [Preorder \u03b1] {c : Chain \u03b1} {x : \u03b1} :\n    Is\u03c9Sup c x \u2194 IsLUB (range c) x := by\n  simp [Is\u03c9Sup, IsLUB, IsLeast, upperBounds, lowerBounds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/OmegaCompletePartialOrder.lean", "context": {"open": ["Set OmegaCompletePartialOrder", "Topology.IsScott in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIs\u03c9Sup : x\u271d\n\u03b1 : Type u\ninst\u271d : Preorder \u03b1\nc : Chain \u03b1\nx : \u03b1\n\u22a2 sorry \u2194 IsLUB (range \u21d1c) x"}, {"line": "simp [Is\u03c9Sup, IsLUB, IsLeast, upperBounds, lowerBounds]", "tactic_state": "x\u271d : Sort u_1\nIs\u03c9Sup : x\u271d\n\u03b1 : Type u\ninst\u271d : Preorder \u03b1\nc : Chain \u03b1\nx : \u03b1\n\u22a2 sorry () \u2194 (\u2200 (a : \u2115), c a \u2264 x) \u2227 \u2200 \u2983a : \u03b1\u2984, (\u2200 (a_1 : \u2115), c a_1 \u2264 a) \u2192 x \u2264 a"}]}
{"declaration": "lemma isOpen_iff_\u03c9ScottContinuous_mem {\u03b1} [OmegaCompletePartialOrder \u03b1] {s : Set (Scott \u03b1)} :\n    IsOpen s \u2194 \u03c9ScottContinuous fun x \u21a6 x \u2208 s := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/OmegaCompletePartialOrder.lean", "context": {"open": ["Set OmegaCompletePartialOrder", "Topology.IsScott in"], "variables": ["(\u03b1 : Type u) [OmegaCompletePartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : OmegaCompletePartialOrder \u03b1\ns : Set (Scott \u03b1)\n\u22a2 IsOpen s \u2194 \u03c9ScottContinuous fun x => x \u2208 s"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_of_scottContinuous {\u03b1 \u03b2} [OmegaCompletePartialOrder \u03b1]\n    [OmegaCompletePartialOrder \u03b2] (f : Scott \u03b1 \u2192 Scott \u03b2)\n    (hf : \u03c9ScottContinuous f) : Continuous f := by\n  rw [continuous_def]\n  intro s hs\n  dsimp only [IsOpen, TopologicalSpace.IsOpen, Scott.IsOpen]\n  simp_rw [mem_preimage, mem_def, \u2190 Function.comp_def]\n  apply \u03c9ScottContinuous.comp hs hf", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/OmegaCompletePartialOrder.lean", "context": {"open": ["Set OmegaCompletePartialOrder", "Topology.IsScott in", "Scott hiding IsOpen IsOpen.isUpperSet", "OmegaCompletePartialOrder"], "variables": ["(\u03b1 : Type u) [OmegaCompletePartialOrder \u03b1]", "{\u03b1 : Type*} [OmegaCompletePartialOrder \u03b1] (y : Scott \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : OmegaCompletePartialOrder \u03b2\nf : Scott \u03b1 \u2192 Scott \u03b2\nhf : \u03c9ScottContinuous f\n\u22a2 Continuous f"}, {"line": "rw [continuous_def]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : OmegaCompletePartialOrder \u03b2\nf : Scott \u03b1 \u2192 Scott \u03b2\nhf : \u03c9ScottContinuous f\n\u22a2 \u2200 (s : Set (Scott \u03b2)), IsOpen s \u2192 IsOpen (f \u207b\u00b9' s)"}, {"line": "intro s hs", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : OmegaCompletePartialOrder \u03b2\nf : Scott \u03b1 \u2192 Scott \u03b2\nhf : \u03c9ScottContinuous f\ns : Set (Scott \u03b2)\nhs : IsOpen s\n\u22a2 IsOpen (f \u207b\u00b9' s)"}, {"line": "dsimp only [IsOpen, TopologicalSpace.IsOpen, Scott.IsOpen]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : OmegaCompletePartialOrder \u03b2\nf : Scott \u03b1 \u2192 Scott \u03b2\nhf : \u03c9ScottContinuous f\ns : Set (Scott \u03b2)\nhs : IsOpen s\n\u22a2 \u03c9ScottContinuous fun x => x \u2208 f \u207b\u00b9' s"}, {"line": "simp_rw [mem_preimage, mem_def, \u2190 Function.comp_def]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : OmegaCompletePartialOrder \u03b2\nf : Scott \u03b1 \u2192 Scott \u03b2\nhf : \u03c9ScottContinuous f\ns : Set (Scott \u03b2)\nhs : IsOpen s\n\u22a2 \u03c9ScottContinuous (s \u2218 f)"}, {"line": "apply \u03c9ScottContinuous.comp hs hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerSemicontinuousWithinAt_univ_iff :\n    LowerSemicontinuousWithinAt f univ x \u2194 LowerSemicontinuousAt f x := by\n  simp [LowerSemicontinuousWithinAt, LowerSemicontinuousAt, nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 LowerSemicontinuousWithinAt f univ x \u2194 LowerSemicontinuousAt f x"}, {"line": "simp [LowerSemicontinuousWithinAt, LowerSemicontinuousAt, nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerSemicontinuousOn_univ_iff : LowerSemicontinuousOn f univ \u2194 LowerSemicontinuous f := by\n  simp [LowerSemicontinuousOn, LowerSemicontinuous, lowerSemicontinuousWithinAt_univ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 LowerSemicontinuousOn f univ \u2194 LowerSemicontinuous f"}, {"line": "simp [LowerSemicontinuousOn, LowerSemicontinuous, lowerSemicontinuousWithinAt_univ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerSemicontinuous_iff_isClosed_preimage {f : \u03b1 \u2192 \u03b3} :\n    LowerSemicontinuous f \u2194 \u2200 y, IsClosed (f \u207b\u00b9' Iic y) := by\n  rw [lowerSemicontinuous_iff_isOpen_preimage]\n  simp only [\u2190 isOpen_compl_iff]\n  simp only [\u2190 preimage_compl]\n  simp only [compl_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b3 : Type u_3\ninst\u271d : LinearOrder \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 LowerSemicontinuous f \u2194 \u2200 (y : \u03b3), IsClosed (f \u207b\u00b9' Iic y)"}, {"line": "rw [lowerSemicontinuous_iff_isOpen_preimage]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b3 : Type u_3\ninst\u271d : LinearOrder \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 (\u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' Ioi y)) \u2194 \u2200 (y : \u03b3), IsClosed (f \u207b\u00b9' Iic y)"}, {"line": "simp only [\u2190 isOpen_compl_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b3 : Type u_3\ninst\u271d : LinearOrder \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 (\u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' Ioi y)) \u2194 \u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' Iic y)\u1d9c"}, {"line": "simp only [\u2190 preimage_compl]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b3 : Type u_3\ninst\u271d : LinearOrder \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 (\u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' Ioi y)) \u2194 \u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' (Iic y)\u1d9c)"}, {"line": "simp only [compl_Iic]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerSemicontinuousAt_iff_le_liminf {f : \u03b1 \u2192 \u03b3} :\n    LowerSemicontinuousAt f x \u2194 f x \u2264 liminf f (\ud835\udcdd x) := by\n  rw [\u2190 lowerSemicontinuousWithinAt_univ_iff]\n  rw [lowerSemicontinuousWithinAt_iff_le_liminf]\n  rw [\u2190 nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_4\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 LowerSemicontinuousAt f x \u2194 f x \u2264 liminf f (nhds x)"}, {"line": "rw [\u2190 lowerSemicontinuousWithinAt_univ_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_4\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 LowerSemicontinuousWithinAt f univ x \u2194 f x \u2264 liminf f (nhds x)"}, {"line": "rw [lowerSemicontinuousWithinAt_iff_le_liminf]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_4\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 f x \u2264 liminf f (nhdsWithin x univ) \u2194 f x \u2264 liminf f (nhds x)\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_4\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 DenselyOrdered \u03b3"}, {"line": "rw [\u2190 nhdsWithin_univ]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_4\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 DenselyOrdered \u03b3"}]}
{"declaration": "theorem ContinuousAt.comp_lowerSemicontinuousAt {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : ContinuousAt g (f x))\n    (hf : LowerSemicontinuousAt f x) (gmon : Monotone g) : LowerSemicontinuousAt (g \u2218 f) x := by\n  simp only [\u2190 lowerSemicontinuousWithinAt_univ_iff] at hf \u22a2\n  exact hg.comp_lowerSemicontinuousWithinAt hf gmon\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_5\ninst\u271d\u2075 : LinearOrder \u03b3\ninst\u271d\u2074 : TopologicalSpace \u03b3\ninst\u271d\u00b3 : OrderTopology \u03b3\n\u03b4 : Type u_6\ninst\u271d\u00b2 : LinearOrder \u03b4\ninst\u271d\u00b9 : TopologicalSpace \u03b4\ninst\u271d : OrderTopology \u03b4\ng : \u03b3 \u2192 \u03b4\nf : \u03b1 \u2192 \u03b3\nhg : ContinuousAt g (f x)\nhf : LowerSemicontinuousAt f x\ngmon : Monotone g\n\u22a2 LowerSemicontinuousAt (g \u2218 f) x"}, {"line": "simp only [\u2190 lowerSemicontinuousWithinAt_univ_iff] at hf \u22a2", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_5\ninst\u271d\u2075 : LinearOrder \u03b3\ninst\u271d\u2074 : TopologicalSpace \u03b3\ninst\u271d\u00b3 : OrderTopology \u03b3\n\u03b4 : Type u_6\ninst\u271d\u00b2 : LinearOrder \u03b4\ninst\u271d\u00b9 : TopologicalSpace \u03b4\ninst\u271d : OrderTopology \u03b4\ng : \u03b3 \u2192 \u03b4\nf : \u03b1 \u2192 \u03b3\nhg : ContinuousAt g (f x)\ngmon : Monotone g\nhf : LowerSemicontinuousWithinAt f univ x\n\u22a2 LowerSemicontinuousWithinAt (g \u2218 f) univ x"}, {"line": "exact hg.comp_lowerSemicontinuousWithinAt hf gmon", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LowerSemicontinuousAt.comp_continuousAt_of_eq {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1} {y : \u03b1} {x : \u03b9}\n    (hf : LowerSemicontinuousAt f y) (hg : ContinuousAt g x) (hy : g x = y) :\n    LowerSemicontinuousAt (fun x \u21a6 f (g x)) x := by\n  rw [\u2190 hy] at hf\n  exact comp_continuousAt hf hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Zero \u03b2\n\u03b9 : Type u_7\ninst\u271d : TopologicalSpace \u03b9\nf : \u03b1 \u2192 \u03b2\ng : \u03b9 \u2192 \u03b1\ny : \u03b1\nx : \u03b9\nhf : LowerSemicontinuousAt f y\nhg : ContinuousAt g x\nhy : g x = y\n\u22a2 LowerSemicontinuousAt (fun x => f (g x)) x"}, {"line": "rw [\u2190 hy] at hf", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Zero \u03b2\n\u03b9 : Type u_7\ninst\u271d : TopologicalSpace \u03b9\nf : \u03b1 \u2192 \u03b2\ng : \u03b9 \u2192 \u03b1\ny : \u03b1\nx : \u03b9\nhf : LowerSemicontinuousAt f (g x)\nhg : ContinuousAt g x\nhy : g x = y\n\u22a2 LowerSemicontinuousAt (fun x => f (g x)) x"}, {"line": "exact comp_continuousAt hf hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LowerSemicontinuousAt.add' {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuousAt f x)\n    (hg : LowerSemicontinuousAt g x)\n    (hcont : ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    LowerSemicontinuousAt (fun z => f z + g z) x := by\n  simp_rw [\u2190 lowerSemicontinuousWithinAt_univ_iff] at *\n  exact hf.add' hg hcont\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_9\ninst\u271d\u00b2 : AddCommMonoid \u03b3\ninst\u271d\u00b9 : LinearOrder \u03b3\ninst\u271d : IsOrderedAddMonoid \u03b3\nf g : \u03b1 \u2192 \u03b3\nhf : LowerSemicontinuousAt f x\nhg : LowerSemicontinuousAt g x\nhcont : sorry\n\u22a2 LowerSemicontinuousAt (fun z => f z + g z) x"}, {"line": "simp_rw [\u2190 lowerSemicontinuousWithinAt_univ_iff] at *", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_9\ninst\u271d\u00b2 : AddCommMonoid \u03b3\ninst\u271d\u00b9 : LinearOrder \u03b3\ninst\u271d : IsOrderedAddMonoid \u03b3\nf g : \u03b1 \u2192 \u03b3\nhcont : sorry\nhf : LowerSemicontinuousWithinAt f univ x\nhg : LowerSemicontinuousWithinAt g univ x\n\u22a2 LowerSemicontinuousWithinAt (fun z => f z + g z) univ x"}, {"line": "exact hf.add' hg hcont", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerSemicontinuousWithinAt_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, LowerSemicontinuousWithinAt (f i) s x) :\n    LowerSemicontinuousWithinAt (fun z => \u2211 i \u2208 a, f i z) s x := by\n  classical\n    induction a using Finset.induction_on with\n    | empty => exact lowerSemicontinuousWithinAt_const\n    | insert _ _ ia IH =>\n      simp only [ia]\n      simp only [Finset.sum_insert]\n      simp only [not_false_iff]\n      exact\n        LowerSemicontinuousWithinAt.add (ha _ (Finset.mem_insert_self ..))\n          (IH fun j ja => ha j (Finset.mem_insert_of_mem ja))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b9 : Type u_8\n\u03b3 : Type u_9\ninst\u271d\u00b2 : AddCommMonoid \u03b3\ninst\u271d\u00b9 : LinearOrder \u03b3\ninst\u271d : IsOrderedAddMonoid \u03b3\ns : Set \u03b1\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b3\na : Finset \u03b9\nha : \u2200 i \u2208 a, LowerSemicontinuousWithinAt (f i) s x\n\u22a2 LowerSemicontinuousWithinAt (fun z => \u2211 i \u2208 a, f i z) s x"}, {"line": "classical\n    induction a using Finset.induction_on with\n    | empty => exact lowerSemicontinuousWithinAt_const\n    | insert _ _ ia IH =>\n      simp only [ia]\n      simp only [Finset.sum_insert]\n      simp only [not_false_iff]\n      exact\n        LowerSemicontinuousWithinAt.add (ha _ (Finset.mem_insert_self ..))\n          (IH fun j ja => ha j (Finset.mem_insert_of_mem ja))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerSemicontinuousAt_ciSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'}\n    (bdd : \u2200\u1da0 y in \ud835\udcdd x, BddAbove (range fun i => f i y)) (h : \u2200 i, LowerSemicontinuousAt (f i) x) :\n    LowerSemicontinuousAt (fun x' => \u2a06 i, f i x') x := by\n  simp_rw [\u2190 lowerSemicontinuousWithinAt_univ_iff] at *\n  rw [\u2190 nhdsWithin_univ] at bdd\n  exact lowerSemicontinuousWithinAt_ciSup bdd h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]", "{\u03b9 : Sort*} {\u03b4 \u03b4' : Type*} [CompleteLinearOrder \u03b4] [ConditionallyCompleteLinearOrder \u03b4']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b9 : Sort u_10\n\u03b4' : Type u_12\ninst\u271d : ConditionallyCompleteLinearOrder \u03b4'\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b4'\nbdd : \u2200\u1da0 (y : \u03b1) in nhds x, BddAbove (range fun i => f i y)\nh : \u2200 (i : \u03b9), LowerSemicontinuousAt (f i) x\n\u22a2 LowerSemicontinuousAt (fun x' => \u2a06 i, f i x') x"}, {"line": "simp_rw [\u2190 lowerSemicontinuousWithinAt_univ_iff] at *", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b9 : Sort u_10\n\u03b4' : Type u_12\ninst\u271d : ConditionallyCompleteLinearOrder \u03b4'\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b4'\nbdd : \u2200\u1da0 (y : \u03b1) in nhds x, BddAbove (range fun i => f i y)\nh : \u2200 (i : \u03b9), LowerSemicontinuousWithinAt (f i) univ x\n\u22a2 LowerSemicontinuousWithinAt (fun x' => \u2a06 i, f i x') univ x"}, {"line": "rw [\u2190 nhdsWithin_univ] at bdd", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b9 : Sort u_10\n\u03b4' : Type u_12\ninst\u271d : ConditionallyCompleteLinearOrder \u03b4'\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b4'\nbdd : \u2200\u1da0 (y : \u03b1) in nhdsWithin x univ, BddAbove (range fun i => f i y)\nh : \u2200 (i : \u03b9), LowerSemicontinuousWithinAt (f i) univ x\n\u22a2 LowerSemicontinuousWithinAt (fun x' => \u2a06 i, f i x') univ x"}, {"line": "exact lowerSemicontinuousWithinAt_ciSup bdd h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerSemicontinuousAt_tsum {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 i, LowerSemicontinuousAt (f i) x) :\n    LowerSemicontinuousAt (fun x' => \u2211' i, f i x') x := by\n  simp_rw [\u2190 lowerSemicontinuousWithinAt_univ_iff] at *\n  exact lowerSemicontinuousWithinAt_tsum h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]", "{\u03b9 : Sort*} {\u03b4 \u03b4' : Type*} [CompleteLinearOrder \u03b4] [ConditionallyCompleteLinearOrder \u03b4']", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\n\u03b9 : Type u_13\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\nh : \u2200 (i : \u03b9), LowerSemicontinuousAt (f i) x\n\u22a2 LowerSemicontinuousAt (fun x' => \u2211' (i : \u03b9), f i x') x"}, {"line": "simp_rw [\u2190 lowerSemicontinuousWithinAt_univ_iff] at *", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\n\u03b9 : Type u_13\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\nh : \u2200 (i : \u03b9), LowerSemicontinuousWithinAt (f i) univ x\n\u22a2 LowerSemicontinuousWithinAt (fun x' => \u2211' (i : \u03b9), f i x') univ x"}, {"line": "exact lowerSemicontinuousWithinAt_tsum h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upperSemicontinuousWithinAt_univ_iff :\n    UpperSemicontinuousWithinAt f univ x \u2194 UpperSemicontinuousAt f x := by\n  simp [UpperSemicontinuousWithinAt, UpperSemicontinuousAt, nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]", "{\u03b9 : Sort*} {\u03b4 \u03b4' : Type*} [CompleteLinearOrder \u03b4] [ConditionallyCompleteLinearOrder \u03b4']", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\ninst\u271d : Zero \u03b2\n\u22a2 UpperSemicontinuousWithinAt f univ x \u2194 UpperSemicontinuousAt f x"}, {"line": "simp [UpperSemicontinuousWithinAt, UpperSemicontinuousAt, nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upperSemicontinuousOn_univ_iff : UpperSemicontinuousOn f univ \u2194 UpperSemicontinuous f := by\n  simp [UpperSemicontinuousOn, UpperSemicontinuous, upperSemicontinuousWithinAt_univ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]", "{\u03b9 : Sort*} {\u03b4 \u03b4' : Type*} [CompleteLinearOrder \u03b4] [ConditionallyCompleteLinearOrder \u03b4']", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\n\u22a2 UpperSemicontinuousOn f univ \u2194 UpperSemicontinuous f"}, {"line": "simp [UpperSemicontinuousOn, UpperSemicontinuous, upperSemicontinuousWithinAt_univ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upperSemicontinuous_iff_isClosed_preimage {f : \u03b1 \u2192 \u03b3} :\n    UpperSemicontinuous f \u2194 \u2200 y, IsClosed (f \u207b\u00b9' Ici y) := by\n  rw [upperSemicontinuous_iff_isOpen_preimage]\n  simp only [\u2190 isOpen_compl_iff]\n  simp only [\u2190 preimage_compl]\n  simp only [compl_Ici]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]", "{\u03b9 : Sort*} {\u03b4 \u03b4' : Type*} [CompleteLinearOrder \u03b4] [ConditionallyCompleteLinearOrder \u03b4']", "{\u03b9 : Type*}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b3 : Type u_14\ninst\u271d : LinearOrder \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 UpperSemicontinuous f \u2194 \u2200 (y : \u03b3), IsClosed (f \u207b\u00b9' Ici y)"}, {"line": "rw [upperSemicontinuous_iff_isOpen_preimage]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b3 : Type u_14\ninst\u271d : LinearOrder \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 (\u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' Iio y)) \u2194 \u2200 (y : \u03b3), IsClosed (f \u207b\u00b9' Ici y)"}, {"line": "simp only [\u2190 isOpen_compl_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b3 : Type u_14\ninst\u271d : LinearOrder \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 (\u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' Iio y)) \u2194 \u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' Ici y)\u1d9c"}, {"line": "simp only [\u2190 preimage_compl]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\n\u03b3 : Type u_14\ninst\u271d : LinearOrder \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 (\u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' Iio y)) \u2194 \u2200 (y : \u03b3), IsOpen (f \u207b\u00b9' (Ici y)\u1d9c)"}, {"line": "simp only [compl_Ici]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UpperSemicontinuousAt.comp_continuousAt_of_eq {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1} {y : \u03b1} {x : \u03b9}\n    (hf : UpperSemicontinuousAt f y) (hg : ContinuousAt g x) (hy : g x = y) :\n    UpperSemicontinuousAt (fun x \u21a6 f (g x)) x := by\n  rw [\u2190 hy] at hf\n  exact comp_continuousAt hf hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]", "{\u03b9 : Sort*} {\u03b4 \u03b4' : Type*} [CompleteLinearOrder \u03b4] [ConditionallyCompleteLinearOrder \u03b4']", "{\u03b9 : Type*}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 inst\u271d\u00b9 : Zero \u03b2\n\u03b9 : Type u_18\ninst\u271d : TopologicalSpace \u03b9\nf : \u03b1 \u2192 \u03b2\ng : \u03b9 \u2192 \u03b1\ny : \u03b1\nx : \u03b9\nhf : UpperSemicontinuousAt f y\nhg : ContinuousAt g x\nhy : g x = y\n\u22a2 UpperSemicontinuousAt (fun x => f (g x)) x"}, {"line": "rw [\u2190 hy] at hf", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 inst\u271d\u00b9 : Zero \u03b2\n\u03b9 : Type u_18\ninst\u271d : TopologicalSpace \u03b9\nf : \u03b1 \u2192 \u03b2\ng : \u03b9 \u2192 \u03b1\ny : \u03b1\nx : \u03b9\nhf : UpperSemicontinuousAt f (g x)\nhg : ContinuousAt g x\nhy : g x = y\n\u22a2 UpperSemicontinuousAt (fun x => f (g x)) x"}, {"line": "exact comp_continuousAt hf hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UpperSemicontinuousAt.add' {f g : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuousAt f x)\n    (hg : UpperSemicontinuousAt g x)\n    (hcont : ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    UpperSemicontinuousAt (fun z => f z + g z) x := by\n  simp_rw [\u2190 upperSemicontinuousWithinAt_univ_iff] at *\n  exact hf.add' hg hcont\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]", "{\u03b9 : Sort*} {\u03b4 \u03b4' : Type*} [CompleteLinearOrder \u03b4] [ConditionallyCompleteLinearOrder \u03b4']", "{\u03b9 : Type*}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_20\ninst\u271d\u00b2 : AddCommMonoid \u03b3\ninst\u271d\u00b9 : LinearOrder \u03b3\ninst\u271d : IsOrderedAddMonoid \u03b3\nf g : \u03b1 \u2192 \u03b3\nhf : UpperSemicontinuousAt f x\nhg : UpperSemicontinuousAt g x\nhcont : sorry\n\u22a2 UpperSemicontinuousAt (fun z => f z + g z) x"}, {"line": "simp_rw [\u2190 upperSemicontinuousWithinAt_univ_iff] at *", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b3 : Type u_20\ninst\u271d\u00b2 : AddCommMonoid \u03b3\ninst\u271d\u00b9 : LinearOrder \u03b3\ninst\u271d : IsOrderedAddMonoid \u03b3\nf g : \u03b1 \u2192 \u03b3\nhcont : sorry\nhf : UpperSemicontinuousWithinAt f univ x\nhg : UpperSemicontinuousWithinAt g univ x\n\u22a2 UpperSemicontinuousWithinAt (fun z => f z + g z) univ x"}, {"line": "exact hf.add' hg hcont", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upperSemicontinuousAt_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, UpperSemicontinuousAt (f i) x) :\n    UpperSemicontinuousAt (fun z => \u2211 i \u2208 a, f i z) x := by\n  simp_rw [\u2190 upperSemicontinuousWithinAt_univ_iff] at *\n  exact upperSemicontinuousWithinAt_sum ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Semicontinuous.lean", "context": {"open": ["Topology ENNReal", "Set Function Filter"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]", "{\u03b9 : Sort*} {\u03b4 \u03b4' : Type*} [CompleteLinearOrder \u03b4] [ConditionallyCompleteLinearOrder \u03b4']", "{\u03b9 : Type*}", "[Zero \u03b2]", "{\u03b3 : Type*} [LinearOrder \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [CompleteLinearOrder \u03b3] [DenselyOrdered \u03b3]", "[TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b3 : Type*} [LinearOrder \u03b3] [TopologicalSpace \u03b3] [OrderTopology \u03b3]", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderTopology \u03b4]", "{\u03b9 : Type*} [TopologicalSpace \u03b9]", "{\u03b9 : Type*} {\u03b3 : Type*} [AddCommMonoid \u03b3] [LinearOrder \u03b3] [IsOrderedAddMonoid \u03b3]", "[ContinuousAdd \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b9 : Type u_19\n\u03b3 : Type u_20\ninst\u271d\u00b2 : AddCommMonoid \u03b3\ninst\u271d\u00b9 : LinearOrder \u03b3\ninst\u271d : IsOrderedAddMonoid \u03b3\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b3\na : Finset \u03b9\nha : \u2200 i \u2208 a, UpperSemicontinuousAt (f i) x\n\u22a2 UpperSemicontinuousAt (fun z => \u2211 i \u2208 a, f i z) x"}, {"line": "simp_rw [\u2190 upperSemicontinuousWithinAt_univ_iff] at *", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nx : \u03b1\n\u03b9 : Type u_19\n\u03b3 : Type u_20\ninst\u271d\u00b2 : AddCommMonoid \u03b3\ninst\u271d\u00b9 : LinearOrder \u03b3\ninst\u271d : IsOrderedAddMonoid \u03b3\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b3\na : Finset \u03b9\nha : \u2200 i \u2208 a, UpperSemicontinuousWithinAt (f i) univ x\n\u22a2 UpperSemicontinuousWithinAt (fun z => \u2211 i \u2208 a, f i z) univ x"}, {"line": "exact upperSemicontinuousWithinAt_sum ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem discreteTopology_iff_singleton_mem_nhds [TopologicalSpace \u03b1] :\n    DiscreteTopology \u03b1 \u2194 \u2200 x : \u03b1, {x} \u2208 \ud835\udcdd x := by\n  simp only [\u2190 singletons_open_iff_discrete]\n  simp only [isOpen_iff_mem_nhds]\n  simp only [mem_singleton_iff]\n  simp only [forall_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 DiscreteTopology \u03b1 \u2194 \u2200 (x : \u03b1), {x} \u2208 nhds x"}, {"line": "simp only [\u2190 singletons_open_iff_discrete]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (a : \u03b1), IsOpen {a}) \u2194 \u2200 (x : \u03b1), {x} \u2208 nhds x"}, {"line": "simp only [isOpen_iff_mem_nhds]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (a x : \u03b1), x \u2208 {a} \u2192 {a} \u2208 nhds x) \u2194 \u2200 (x : \u03b1), {x} \u2208 nhds x"}, {"line": "simp only [mem_singleton_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (a x : \u03b1), x = a \u2192 {a} \u2208 nhds x) \u2194 \u2200 (x : \u03b1), {x} \u2208 nhds x"}, {"line": "simp only [forall_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem discreteTopology_iff_nhds [TopologicalSpace \u03b1] :\n    DiscreteTopology \u03b1 \u2194 \u2200 x : \u03b1, \ud835\udcdd x = pure x := by\n  simp [discreteTopology_iff_singleton_mem_nhds, le_pure_iff]\n  apply forall_congr' (fun x \u21a6 ?_)\n  simp [le_antisymm_iff, pure_le_nhds x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 DiscreteTopology \u03b1 \u2194 \u2200 (x : \u03b1), nhds x = pure x"}, {"line": "simp [discreteTopology_iff_singleton_mem_nhds, le_pure_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (x : \u03b1), {x} \u2208 nhds x) \u2194 \u2200 (x : \u03b1), nhds x = pure x"}, {"line": "apply forall_congr' (fun x \u21a6 ?_)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\n\u22a2 {x} \u2208 nhds x \u2194 nhds x = pure x"}, {"line": "simp [le_antisymm_iff, pure_le_nhds x]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\n\u22a2 {x} \u2208 nhds x \u2192 pure x \u2264 nhds x"}]}
{"declaration": "theorem discreteTopology_iff_nhds_ne [TopologicalSpace \u03b1] :\n    DiscreteTopology \u03b1 \u2194 \u2200 x : \u03b1, \ud835\udcdd[\u2260] x = \u22a5 := by\n  simp only [discreteTopology_iff_singleton_mem_nhds]\n  simp only [nhdsWithin]\n  simp only [inf_principal_eq_bot]\n  simp only [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 DiscreteTopology \u03b1 \u2194 \u2200 (x : \u03b1), nhdsWithin x {x}\u1d9c = \u22a5"}, {"line": "simp only [discreteTopology_iff_singleton_mem_nhds]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (x : \u03b1), {x} \u2208 nhds x) \u2194 \u2200 (x : \u03b1), nhdsWithin x {x}\u1d9c = \u22a5"}, {"line": "simp only [nhdsWithin]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (x : \u03b1), {x} \u2208 nhds x) \u2194 \u2200 (x : \u03b1), nhds x \u2293 principal {x}\u1d9c = \u22a5"}, {"line": "simp only [inf_principal_eq_bot]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : DiscreteTopology \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (x : \u03b1), {x} \u2208 nhds x) \u2194 \u2200 (x : \u03b1), {x}\u1d9c\u1d9c \u2208 nhds x"}, {"line": "simp only [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_induced_iff [t : TopologicalSpace \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    IsClosed[t.induced f] s \u2194 \u2203 t, IsClosed t \u2227 f \u207b\u00b9' t = s := by\n  letI := t.induced f\n  simp only [\u2190 isOpen_compl_iff]\n  simp only [isOpen_induced_iff]\n  exact compl_surjective.exists.trans (by simp only [preimage_compl, compl_inj_iff])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nt : TopologicalSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsClosed s \u2194 \u2203 t_1, IsClosed t_1 \u2227 f \u207b\u00b9' t_1 = s"}, {"line": "letI := t.induced f", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nt : TopologicalSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nthis : TopologicalSpace \u03b1 := TopologicalSpace.induced f t\n\u22a2 IsClosed s \u2194 \u2203 t_1, IsClosed t_1 \u2227 f \u207b\u00b9' t_1 = s"}, {"line": "simp only [\u2190 isOpen_compl_iff]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nt : TopologicalSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nthis : TopologicalSpace \u03b1 := TopologicalSpace.induced f t\n\u22a2 IsOpen s\u1d9c \u2194 \u2203 t_1, IsOpen t_1\u1d9c \u2227 f \u207b\u00b9' t_1 = s"}, {"line": "simp only [isOpen_induced_iff]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nt : TopologicalSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nthis : TopologicalSpace \u03b1 := TopologicalSpace.induced f t\n\u22a2 (\u2203 t_1, IsOpen t_1 \u2227 f \u207b\u00b9' t_1 = s\u1d9c) \u2194 \u2203 t_1, IsOpen t_1\u1d9c \u2227 f \u207b\u00b9' t_1 = s"}, {"line": "exact compl_surjective.exists.trans (by simp only [preimage_compl, compl_inj_iff])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_coinduced {t : TopologicalSpace \u03b1} {s : Set \u03b2} {f : \u03b1 \u2192 \u03b2} :\n    IsClosed[t.coinduced f] s \u2194 IsClosed (f \u207b\u00b9' s) := by\n  simp only [\u2190 isOpen_compl_iff]\n  simp only [isOpen_coinduced (f := f)]\n  simp only [preimage_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nt : TopologicalSpace \u03b1\ns : Set \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsClosed s \u2194 IsClosed (f \u207b\u00b9' s)"}, {"line": "simp only [\u2190 isOpen_compl_iff]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nt : TopologicalSpace \u03b1\ns : Set \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsOpen s\u1d9c \u2194 IsOpen (f \u207b\u00b9' s)\u1d9c"}, {"line": "simp only [isOpen_coinduced (f := f)]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nt : TopologicalSpace \u03b1\ns : Set \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsOpen (f \u207b\u00b9' s\u1d9c) \u2194 IsOpen (f \u207b\u00b9' s)\u1d9c"}, {"line": "simp only [preimage_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_nhds_coinduced [TopologicalSpace \u03b1] {\u03c0 : \u03b1 \u2192 \u03b2} {s : Set \u03b2} {a : \u03b1}\n    (hs : s \u2208 @nhds \u03b2 (TopologicalSpace.coinduced \u03c0 \u2039_\u203a) (\u03c0 a)) : \u03c0 \u207b\u00b9' s \u2208 \ud835\udcdd a := by\n  letI := TopologicalSpace.coinduced \u03c0 \u2039_\u203a\n  rcases mem_nhds_iff.mp hs with \u27e8V, hVs, V_op, mem_V\u27e9\n  exact mem_nhds_iff.mpr \u27e8\u03c0 \u207b\u00b9' V, Set.preimage_mono hVs, V_op, mem_V\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\n\u03c0 : \u03b1 \u2192 \u03b2\ns : Set \u03b2\na : \u03b1\nhs : s \u2208 nhds (\u03c0 a)\n\u22a2 \u03c0 \u207b\u00b9' s \u2208 nhds a"}, {"line": "letI := TopologicalSpace.coinduced \u03c0 \u2039_\u203a", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\n\u03c0 : \u03b1 \u2192 \u03b2\ns : Set \u03b2\na : \u03b1\nhs : s \u2208 nhds (\u03c0 a)\nthis : TopologicalSpace \u03b2 := TopologicalSpace.coinduced \u03c0 inst\u271d\n\u22a2 \u03c0 \u207b\u00b9' s \u2208 nhds a"}, {"line": "rcases mem_nhds_iff.mp hs with \u27e8V, hVs, V_op, mem_V\u27e9", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\n\u03c0 : \u03b1 \u2192 \u03b2\ns : Set \u03b2\na : \u03b1\nhs : s \u2208 nhds (\u03c0 a)\nthis : TopologicalSpace \u03b2 := TopologicalSpace.coinduced \u03c0 inst\u271d\nV : Set \u03b2\nhVs : V \u2286 s\nV_op : IsOpen V\nmem_V : \u03c0 a \u2208 V\n\u22a2 \u03c0 \u207b\u00b9' s \u2208 nhds a"}, {"line": "exact mem_nhds_iff.mpr \u27e8\u03c0 \u207b\u00b9' V, Set.preimage_mono hVs, V_op, mem_V\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem induced_sInf {s : Set (TopologicalSpace \u03b1)} :\n    TopologicalSpace.induced g (sInf s) = sInf (TopologicalSpace.induced g '' s) := by\n  rw [sInf_eq_iInf']\n  rw [sInf_image']\n  rw [induced_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ng : \u03b2 \u2192 \u03b1\ns : Set (TopologicalSpace \u03b1)\n\u22a2 TopologicalSpace.induced g (sInf s) = sInf (TopologicalSpace.induced g '' s)"}, {"line": "rw [sInf_eq_iInf']", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ng : \u03b2 \u2192 \u03b1\ns : Set (TopologicalSpace \u03b1)\n\u22a2 TopologicalSpace.induced g (\u2a05 a, \u2191a) = sInf (TopologicalSpace.induced g '' s)"}, {"line": "rw [sInf_image']", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ng : \u03b2 \u2192 \u03b1\ns : Set (TopologicalSpace \u03b1)\n\u22a2 TopologicalSpace.induced g (\u2a05 a, \u2191a) = \u2a05 a, TopologicalSpace.induced g \u2191a"}, {"line": "rw [induced_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coinduced_sSup {s : Set (TopologicalSpace \u03b1)} :\n    TopologicalSpace.coinduced f (sSup s) = sSup ((TopologicalSpace.coinduced f) '' s) := by\n  rw [sSup_eq_iSup']\n  rw [sSup_image']\n  rw [coinduced_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2\ns : Set (TopologicalSpace \u03b1)\n\u22a2 TopologicalSpace.coinduced f (sSup s) = sSup (TopologicalSpace.coinduced f '' s)"}, {"line": "rw [sSup_eq_iSup']", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2\ns : Set (TopologicalSpace \u03b1)\n\u22a2 TopologicalSpace.coinduced f (\u2a06 a, \u2191a) = sSup (TopologicalSpace.coinduced f '' s)"}, {"line": "rw [sSup_image']", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2\ns : Set (TopologicalSpace \u03b1)\n\u22a2 TopologicalSpace.coinduced f (\u2a06 a, \u2191a) = \u2a06 a, TopologicalSpace.coinduced f \u2191a"}, {"line": "rw [coinduced_iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.induced_symm {\u03b1 \u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) :\n    TopologicalSpace.induced e.symm = TopologicalSpace.coinduced e := by\n  ext t U\n  rw [isOpen_induced_iff]\n  rw [isOpen_coinduced]\n  simp only [e.symm.preimage_eq_iff_eq_image]\n  simp only [exists_eq_right]\n  simp only [\u2190 preimage_equiv_eq_image_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ne : \u03b1 \u2243 \u03b2\n\u22a2 TopologicalSpace.induced \u21d1e.symm = TopologicalSpace.coinduced \u21d1e"}, {"line": "ext t U", "tactic_state": "case h.a.h.a\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ne : \u03b1 \u2243 \u03b2\nt : TopologicalSpace \u03b1\nU : Set \u03b2\n\u22a2 IsOpen U \u2194 IsOpen U"}, {"line": "rw [isOpen_induced_iff]", "tactic_state": "case h.a.h.a\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ne : \u03b1 \u2243 \u03b2\nt : TopologicalSpace \u03b1\nU : Set \u03b2\n\u22a2 (\u2203 t_1, IsOpen t_1 \u2227 \u21d1e.symm \u207b\u00b9' t_1 = U) \u2194 IsOpen U"}, {"line": "rw [isOpen_coinduced]", "tactic_state": "case h.a.h.a\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ne : \u03b1 \u2243 \u03b2\nt : TopologicalSpace \u03b1\nU : Set \u03b2\n\u22a2 (\u2203 t_1, IsOpen t_1 \u2227 \u21d1e.symm \u207b\u00b9' t_1 = U) \u2194 IsOpen (\u21d1e \u207b\u00b9' U)"}, {"line": "simp only [e.symm.preimage_eq_iff_eq_image]", "tactic_state": "case h.a.h.a\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ne : \u03b1 \u2243 \u03b2\nt : TopologicalSpace \u03b1\nU : Set \u03b2\n\u22a2 (\u2203 t_1, IsOpen t_1 \u2227 t_1 = \u21d1e.symm '' U) \u2194 IsOpen (\u21d1e \u207b\u00b9' U)"}, {"line": "simp only [exists_eq_right]", "tactic_state": "case h.a.h.a\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ne : \u03b1 \u2243 \u03b2\nt : TopologicalSpace \u03b1\nU : Set \u03b2\n\u22a2 IsOpen (\u21d1e.symm '' U) \u2194 IsOpen (\u21d1e \u207b\u00b9' U)"}, {"line": "simp only [\u2190 preimage_equiv_eq_image_symm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma generateFrom_insert_of_generateOpen {\u03b1 : Type*} {s : Set (Set \u03b1)} {t : Set \u03b1}\n    (ht : GenerateOpen s t) : generateFrom (insert t s) = generateFrom s := by\n  refine le_antisymm (generateFrom_anti <| subset_insert t s) (le_generateFrom ?_)\n  rintro t (rfl | h)\n  \u00b7 exact ht\n  \u00b7 exact isOpen_generateFrom_of_mem h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ns : Set (Set \u03b1)\nt : Set \u03b1\nht : GenerateOpen s t\n\u22a2 generateFrom (insert t s) = generateFrom s"}, {"line": "refine le_antisymm (generateFrom_anti <| subset_insert t s) (le_generateFrom ?_)", "tactic_state": "\u03b1 : Type u_6\ns : Set (Set \u03b1)\nt : Set \u03b1\nht : GenerateOpen s t\n\u22a2 \u2200 s_1 \u2208 insert t s, IsOpen s_1"}, {"line": "rintro t (rfl | h)", "tactic_state": "case inl\n\u03b1 : Type u_6\ns : Set (Set \u03b1)\nt : Set \u03b1\nht : GenerateOpen s t\n\u22a2 IsOpen t\n---\ncase inr\n\u03b1 : Type u_6\ns : Set (Set \u03b1)\nt\u271d : Set \u03b1\nht : GenerateOpen s t\u271d\nt : Set \u03b1\nh : t \u2208 s\n\u22a2 IsOpen t"}, {"line": "\u00b7 exact ht", "tactic_state": "case inr\n\u03b1 : Type u_6\ns : Set (Set \u03b1)\nt\u271d : Set \u03b1\nht : GenerateOpen s t\u271d\nt : Set \u03b1\nh : t \u2208 s\n\u22a2 IsOpen t"}, {"line": "\u00b7 exact isOpen_generateFrom_of_mem h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma generateFrom_insert_empty {\u03b1 : Type*} {s : Set (Set \u03b1)} :\n    generateFrom (insert \u2205 s) = generateFrom s := by\n  rw [\u2190 sUnion_empty]\n  exact generateFrom_insert_of_generateOpen (.sUnion \u2205 (fun s_1 a \u21a6 False.elim a))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ns : Set (Set \u03b1)\n\u22a2 generateFrom (insert \u2205 s) = generateFrom s"}, {"line": "rw [\u2190 sUnion_empty]", "tactic_state": "\u03b1 : Type u_6\ns : Set (Set \u03b1)\n\u22a2 generateFrom (insert (\u22c3\u2080 \u2205) s) = generateFrom s"}, {"line": "exact generateFrom_insert_of_generateOpen (.sUnion \u2205 (fun s_1 a \u21a6 False.elim a))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_nhdsAdjoint_iff {\u03b1 : Type*} (a : \u03b1) (f : Filter \u03b1) (t : TopologicalSpace \u03b1) :\n    t \u2264 nhdsAdjoint a f \u2194 @nhds \u03b1 t a \u2264 pure a \u2294 f \u2227 \u2200 b \u2260 a, IsOpen[t] {b} := by\n  simp only [le_nhdsAdjoint_iff']\n  simp only [@isOpen_singleton_iff_nhds_eq_pure \u03b1 t]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\na : \u03b1\nf : Filter \u03b1\nt : TopologicalSpace \u03b1\n\u22a2 t \u2264 nhdsAdjoint a f \u2194 nhds a \u2264 pure a \u2294 f \u2227 \u2200 (b : \u03b1), b \u2260 a \u2192 IsOpen {b}"}, {"line": "simp only [le_nhdsAdjoint_iff']", "tactic_state": "\u03b1 : Type u_6\na : \u03b1\nf : Filter \u03b1\nt : TopologicalSpace \u03b1\n\u22a2 (nhds a \u2264 pure a \u2294 f \u2227 \u2200 (b : \u03b1), b \u2260 a \u2192 nhds b = pure b) \u2194 nhds a \u2264 pure a \u2294 f \u2227 \u2200 (b : \u03b1), b \u2260 a \u2192 IsOpen {b}"}, {"line": "simp only [@isOpen_singleton_iff_nhds_eq_pure \u03b1 t]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_induced_rng {g : \u03b3 \u2192 \u03b1} {t\u2082 : TopologicalSpace \u03b2} {t\u2081 : TopologicalSpace \u03b3} :\n    Continuous[t\u2081, induced f t\u2082] g \u2194 Continuous[t\u2081, t\u2082] (f \u2218 g) := by\n  simp only [continuous_iff_le_induced]\n  simp only [induced_compose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_6\nf : \u03b1 \u2192 \u03b2\ng : \u03b3 \u2192 \u03b1\nt\u2082 : TopologicalSpace \u03b2\nt\u2081 : TopologicalSpace \u03b3\n\u22a2 Continuous g \u2194 Continuous (f \u2218 g)"}, {"line": "simp only [continuous_iff_le_induced]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_6\nf : \u03b1 \u2192 \u03b2\ng : \u03b3 \u2192 \u03b1\nt\u2082 : TopologicalSpace \u03b2\nt\u2081 : TopologicalSpace \u03b3\n\u22a2 t\u2081 \u2264 induced g (induced f t\u2082) \u2194 t\u2081 \u2264 induced (f \u2218 g) t\u2082"}, {"line": "simp only [induced_compose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_coinduced_dom {g : \u03b2 \u2192 \u03b3} {t\u2081 : TopologicalSpace \u03b1} {t\u2082 : TopologicalSpace \u03b3} :\n    Continuous[coinduced f t\u2081, t\u2082] g \u2194 Continuous[t\u2081, t\u2082] (g \u2218 f) := by\n  simp only [continuous_iff_coinduced_le]\n  simp only [coinduced_compose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_6\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nt\u2081 : TopologicalSpace \u03b1\nt\u2082 : TopologicalSpace \u03b3\n\u22a2 Continuous g \u2194 Continuous (g \u2218 f)"}, {"line": "simp only [continuous_iff_coinduced_le]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_6\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nt\u2081 : TopologicalSpace \u03b1\nt\u2082 : TopologicalSpace \u03b3\n\u22a2 coinduced g (coinduced f t\u2081) \u2264 t\u2082 \u2194 coinduced (g \u2218 f) t\u2081 \u2264 t\u2082"}, {"line": "simp only [coinduced_compose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_le_dom {t\u2081 t\u2082 : TopologicalSpace \u03b1} {t\u2083 : TopologicalSpace \u03b2} (h\u2081 : t\u2082 \u2264 t\u2081)\n    (h\u2082 : Continuous[t\u2081, t\u2083] f) : Continuous[t\u2082, t\u2083] f := by\n  rw [continuous_iff_le_induced] at h\u2082 \u22a2\n  exact le_trans h\u2081 h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 t\u2082 : TopologicalSpace \u03b1\nt\u2083 : TopologicalSpace \u03b2\nh\u2081 : t\u2082 \u2264 t\u2081\nh\u2082 : Continuous f\n\u22a2 Continuous f"}, {"line": "rw [continuous_iff_le_induced] at h\u2082 \u22a2", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 t\u2082 : TopologicalSpace \u03b1\nt\u2083 : TopologicalSpace \u03b2\nh\u2081 : t\u2082 \u2264 t\u2081\nh\u2082 : t\u2081 \u2264 induced f t\u2083\n\u22a2 t\u2082 \u2264 induced f t\u2083"}, {"line": "exact le_trans h\u2081 h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_le_rng {t\u2081 : TopologicalSpace \u03b1} {t\u2082 t\u2083 : TopologicalSpace \u03b2} (h\u2081 : t\u2082 \u2264 t\u2083)\n    (h\u2082 : Continuous[t\u2081, t\u2082] f) : Continuous[t\u2081, t\u2083] f := by\n  rw [continuous_iff_coinduced_le] at h\u2082 \u22a2\n  exact le_trans h\u2082 h\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 : TopologicalSpace \u03b1\nt\u2082 t\u2083 : TopologicalSpace \u03b2\nh\u2081 : t\u2082 \u2264 t\u2083\nh\u2082 : Continuous f\n\u22a2 Continuous f"}, {"line": "rw [continuous_iff_coinduced_le] at h\u2082 \u22a2", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 : TopologicalSpace \u03b1\nt\u2082 t\u2083 : TopologicalSpace \u03b2\nh\u2081 : t\u2082 \u2264 t\u2083\nh\u2082 : coinduced f t\u2081 \u2264 t\u2082\n\u22a2 coinduced f t\u2081 \u2264 t\u2083"}, {"line": "exact le_trans h\u2082 h\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_sup_dom {t\u2081 t\u2082 : TopologicalSpace \u03b1} {t\u2083 : TopologicalSpace \u03b2} :\n    Continuous[t\u2081 \u2294 t\u2082, t\u2083] f \u2194 Continuous[t\u2081, t\u2083] f \u2227 Continuous[t\u2082, t\u2083] f := by\n  simp only [continuous_iff_le_induced]\n  simp only [sup_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 t\u2082 : TopologicalSpace \u03b1\nt\u2083 : TopologicalSpace \u03b2\n\u22a2 Continuous f \u2194 Continuous f \u2227 Continuous f"}, {"line": "simp only [continuous_iff_le_induced]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 t\u2082 : TopologicalSpace \u03b1\nt\u2083 : TopologicalSpace \u03b2\n\u22a2 t\u2081 \u2294 t\u2082 \u2264 induced f t\u2083 \u2194 t\u2081 \u2264 induced f t\u2083 \u2227 t\u2082 \u2264 induced f t\u2083"}, {"line": "simp only [sup_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_sSup_dom {T : Set (TopologicalSpace \u03b1)} {t\u2082 : TopologicalSpace \u03b2} :\n    Continuous[sSup T, t\u2082] f \u2194 \u2200 t \u2208 T, Continuous[t, t\u2082] f := by\n  simp only [continuous_iff_le_induced]\n  simp only [sSup_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nT : Set (TopologicalSpace \u03b1)\nt\u2082 : TopologicalSpace \u03b2\n\u22a2 Continuous f \u2194 \u2200 t \u2208 T, Continuous f"}, {"line": "simp only [continuous_iff_le_induced]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nT : Set (TopologicalSpace \u03b1)\nt\u2082 : TopologicalSpace \u03b2\n\u22a2 sSup T \u2264 induced f t\u2082 \u2194 \u2200 t \u2208 T, t \u2264 induced f t\u2082"}, {"line": "simp only [sSup_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_iSup_dom {t\u2081 : \u03b9 \u2192 TopologicalSpace \u03b1} {t\u2082 : TopologicalSpace \u03b2} :\n    Continuous[iSup t\u2081, t\u2082] f \u2194 \u2200 i, Continuous[t\u2081 i, t\u2082] f := by\n  simp only [continuous_iff_le_induced]\n  simp only [iSup_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_7\nt\u2081 : \u03b9 \u2192 TopologicalSpace \u03b1\nt\u2082 : TopologicalSpace \u03b2\n\u22a2 Continuous f \u2194 \u2200 (i : \u03b9), Continuous f"}, {"line": "simp only [continuous_iff_le_induced]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_7\nt\u2081 : \u03b9 \u2192 TopologicalSpace \u03b1\nt\u2082 : TopologicalSpace \u03b2\n\u22a2 iSup t\u2081 \u2264 induced f t\u2082 \u2194 \u2200 (i : \u03b9), t\u2081 i \u2264 induced f t\u2082"}, {"line": "simp only [iSup_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_inf_rng {t\u2081 : TopologicalSpace \u03b1} {t\u2082 t\u2083 : TopologicalSpace \u03b2} :\n    Continuous[t\u2081, t\u2082 \u2293 t\u2083] f \u2194 Continuous[t\u2081, t\u2082] f \u2227 Continuous[t\u2081, t\u2083] f := by\n  simp only [continuous_iff_coinduced_le]\n  simp only [le_inf_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 : TopologicalSpace \u03b1\nt\u2082 t\u2083 : TopologicalSpace \u03b2\n\u22a2 Continuous f \u2194 Continuous f \u2227 Continuous f"}, {"line": "simp only [continuous_iff_coinduced_le]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 : TopologicalSpace \u03b1\nt\u2082 t\u2083 : TopologicalSpace \u03b2\n\u22a2 coinduced f t\u2081 \u2264 t\u2082 \u2293 t\u2083 \u2194 coinduced f t\u2081 \u2264 t\u2082 \u2227 coinduced f t\u2081 \u2264 t\u2083"}, {"line": "simp only [le_inf_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_sInf_rng {t\u2081 : TopologicalSpace \u03b1} {T : Set (TopologicalSpace \u03b2)} :\n    Continuous[t\u2081, sInf T] f \u2194 \u2200 t \u2208 T, Continuous[t\u2081, t] f := by\n  simp only [continuous_iff_coinduced_le]\n  simp only [le_sInf_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 : TopologicalSpace \u03b1\nT : Set (TopologicalSpace \u03b2)\n\u22a2 Continuous f \u2194 \u2200 t \u2208 T, Continuous f"}, {"line": "simp only [continuous_iff_coinduced_le]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt\u2081 : TopologicalSpace \u03b1\nT : Set (TopologicalSpace \u03b2)\n\u22a2 coinduced f t\u2081 \u2264 sInf T \u2194 \u2200 t \u2208 T, coinduced f t\u2081 \u2264 t"}, {"line": "simp only [le_sInf_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_induced [T : TopologicalSpace \u03b1] (f : \u03b2 \u2192 \u03b1) (a : \u03b2) :\n    @nhds \u03b2 (TopologicalSpace.induced f T) a = comap f (\ud835\udcdd (f a)) := by\n  ext s\n  rw [mem_nhds_induced]\n  rw [mem_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nT : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b2\n\u22a2 nhds a = comap f (nhds (f a))"}, {"line": "ext s", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\nT : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b2\ns : Set \u03b2\n\u22a2 s \u2208 nhds a \u2194 s \u2208 comap f (nhds (f a))"}, {"line": "rw [mem_nhds_induced]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\nT : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b2\ns : Set \u03b2\n\u22a2 (\u2203 u \u2208 nhds (f a), f \u207b\u00b9' u \u2286 s) \u2194 s \u2208 comap f (nhds (f a))"}, {"line": "rw [mem_comap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem induced_iff_nhds_eq [t\u03b1 : TopologicalSpace \u03b1] [t\u03b2 : TopologicalSpace \u03b2] (f : \u03b2 \u2192 \u03b1) :\n    t\u03b2 = t\u03b1.induced f \u2194 \u2200 b, \ud835\udcdd b = comap f (\ud835\udcdd <| f b) := by\n  simp only [ext_iff_nhds]\n  simp only [nhds_induced]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nt\u03b1 : TopologicalSpace \u03b1\nt\u03b2 : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 t\u03b2 = induced f t\u03b1 \u2194 \u2200 (b : \u03b2), nhds b = comap f (nhds (f b))"}, {"line": "simp only [ext_iff_nhds]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nt\u03b1 : TopologicalSpace \u03b1\nt\u03b2 : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 (\u2200 (x : \u03b2), nhds x = nhds x) \u2194 \u2200 (b : \u03b2), nhds b = comap f (nhds (f b))"}, {"line": "simp only [nhds_induced]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_nhds_induced_of_surjective [T : TopologicalSpace \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Surjective f)\n    (a : \u03b2) : map f (@nhds \u03b2 (TopologicalSpace.induced f T) a) = \ud835\udcdd (f a) := by\n  rw [nhds_induced]\n  rw [map_comap_of_surjective hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nT : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nhf : Surjective f\na : \u03b2\n\u22a2 map f (nhds a) = nhds (f a)"}, {"line": "rw [nhds_induced]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nT : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nhf : Surjective f\na : \u03b2\n\u22a2 map f (comap f (nhds (f a))) = nhds (f a)"}, {"line": "rw [map_comap_of_surjective hf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_nhdsAdjoint_dom [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : Filter \u03b1} :\n    Continuous[nhdsAdjoint a l, _] f \u2194 Tendsto f l (\ud835\udcdd (f a)) := by\n  simp_rw [continuous_iff_le_induced, gc_nhds _ _, nhds_induced, tendsto_iff_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nl : Filter \u03b1\n\u22a2 Continuous f \u2194 Tendsto f l (nhds (f a))"}, {"line": "simp_rw [continuous_iff_le_induced, gc_nhds _ _, nhds_induced, tendsto_iff_comap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_nhds_induced_eq (a : \u03b1) : map f (@nhds \u03b1 (induced f t) a) = \ud835\udcdd[range f] f a := by\n  rw [nhds_induced]\n  rw [Filter.map_comap]\n  rw [nhdsWithin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}", "{\u03b1 : Type*} {\u03b2 : Type*}", "[t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 map f (nhds a) = nhdsWithin (f a) (range f)"}, {"line": "rw [nhds_induced]", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 map f (comap f (nhds (f a))) = nhdsWithin (f a) (range f)"}, {"line": "rw [Filter.map_comap]", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 nhds (f a) \u2293 principal (range f) = nhdsWithin (f a) (range f)"}, {"line": "rw [nhdsWithin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_nhds_induced_of_mem {a : \u03b1} (h : range f \u2208 \ud835\udcdd (f a)) :\n    map f (@nhds \u03b1 (induced f t) a) = \ud835\udcdd (f a) := by rw [nhds_induced, Filter.map_comap_of_mem h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}", "{\u03b1 : Type*} {\u03b2 : Type*}", "[t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nh : range f \u2208 nhds (f a)\n\u22a2 map f (nhds a) = nhds (f a)"}, {"line": "rw [nhds_induced, Filter.map_comap_of_mem h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_induced {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1} :\n    a \u2208 @closure \u03b1 (t.induced f) s \u2194 f a \u2208 closure (f '' s) := by\n  letI := t.induced f\n  simp only [mem_closure_iff_frequently]\n  simp only [nhds_induced]\n  simp only [frequently_comap]\n  simp only [mem_image]\n  simp only [and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}", "{\u03b1 : Type*} {\u03b2 : Type*}", "[t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\n\u22a2 a \u2208 closure s \u2194 f a \u2208 closure (f '' s)"}, {"line": "letI := t.induced f", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nthis : TopologicalSpace \u03b1 := induced f t\n\u22a2 a \u2208 closure s \u2194 f a \u2208 closure (f '' s)"}, {"line": "simp only [mem_closure_iff_frequently]", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nthis : TopologicalSpace \u03b1 := induced f t\n\u22a2 (\u2203\u1da0 (x : \u03b1) in nhds a, x \u2208 s) \u2194 \u2203\u1da0 (x : \u03b2) in nhds (f a), x \u2208 f '' s"}, {"line": "simp only [nhds_induced]", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nthis : TopologicalSpace \u03b1 := induced f t\n\u22a2 (\u2203\u1da0 (x : \u03b1) in comap f (nhds (f a)), x \u2208 s) \u2194 \u2203\u1da0 (x : \u03b2) in nhds (f a), x \u2208 f '' s"}, {"line": "simp only [frequently_comap]", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nthis : TopologicalSpace \u03b1 := induced f t\n\u22a2 (\u2203\u1da0 (b : \u03b2) in nhds (f a), \u2203 a, f a = b \u2227 a \u2208 s) \u2194 \u2203\u1da0 (x : \u03b2) in nhds (f a), x \u2208 f '' s"}, {"line": "simp only [mem_image]", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nthis : TopologicalSpace \u03b1 := induced f t\n\u22a2 (\u2203\u1da0 (b : \u03b2) in nhds (f a), \u2203 a, f a = b \u2227 a \u2208 s) \u2194 \u2203\u1da0 (x : \u03b2) in nhds (f a), \u2203 x_1 \u2208 s, f x_1 = x"}, {"line": "simp only [and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_induced_iff' {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    IsClosed[t.induced f] s \u2194 \u2200 a, f a \u2208 closure (f '' s) \u2192 a \u2208 s := by\n  letI := t.induced f\n  simp only [\u2190 closure_subset_iff_isClosed]\n  simp only [subset_def]\n  simp only [closure_induced]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}", "{\u03b1 : Type*} {\u03b2 : Type*}", "[t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 IsClosed s \u2194 \u2200 (a : \u03b1), f a \u2208 closure (f '' s) \u2192 a \u2208 s"}, {"line": "letI := t.induced f", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nthis : TopologicalSpace \u03b1 := induced f t\n\u22a2 IsClosed s \u2194 \u2200 (a : \u03b1), f a \u2208 closure (f '' s) \u2192 a \u2208 s"}, {"line": "simp only [\u2190 closure_subset_iff_isClosed]", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nthis : TopologicalSpace \u03b1 := induced f t\n\u22a2 closure s \u2286 s \u2194 \u2200 (a : \u03b1), f a \u2208 closure (f '' s) \u2192 a \u2208 s"}, {"line": "simp only [subset_def]", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\nt : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nthis : TopologicalSpace \u03b1 := induced f t\n\u22a2 (\u2200 x \u2208 closure s, x \u2208 s) \u2194 \u2200 (a : \u03b1), f a \u2208 closure (f '' s) \u2192 a \u2208 s"}, {"line": "simp only [closure_induced]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_nhds_true {l : Filter \u03b1} {p : \u03b1 \u2192 Prop} :\n    Tendsto p l (\ud835\udcdd True) \u2194 \u2200\u1da0 x in l, p x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}", "{\u03b1 : Type*} {\u03b2 : Type*}", "[t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_10\nl : Filter \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 Tendsto p l (nhds True) \u2194 \u2200\u1da0 (x : \u03b1) in l, p x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_nhds_Prop {l : Filter \u03b1} {p : \u03b1 \u2192 Prop} {q : Prop} :\n    Tendsto p l (\ud835\udcdd q) \u2194 (q \u2192 \u2200\u1da0 x in l, p x) := by\n  by_cases q <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}", "{\u03b1 : Type*} {\u03b2 : Type*}", "[t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_10\nl : Filter \u03b1\np : \u03b1 \u2192 Prop\nq : Prop\n\u22a2 Tendsto p l (nhds q) \u2194 q \u2192 \u2200\u1da0 (x : \u03b1) in l, p x"}, {"line": "by_cases q <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_sSup_iff {s : Set \u03b1} {T : Set (TopologicalSpace \u03b1)} :\n    IsOpen[sSup T] s \u2194 \u2200 t \u2208 T, IsOpen[t] s := by\n  simp only [sSup_eq_iSup]\n  simp only [isOpen_iSup_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}", "{\u03b1 : Type*} {\u03b2 : Type*}", "[t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b1 : Type u} {\u03b9 : Sort v}", "{t : \u03b9 \u2192 TopologicalSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nT : Set (TopologicalSpace \u03b1)\n\u22a2 IsOpen s \u2194 \u2200 t \u2208 T, IsOpen s"}, {"line": "simp only [sSup_eq_iSup]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nT : Set (TopologicalSpace \u03b1)\n\u22a2 IsOpen s \u2194 \u2200 t \u2208 T, IsOpen s"}, {"line": "simp only [isOpen_iSup_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_sSup_iff {s : Set \u03b1} {T : Set (TopologicalSpace \u03b1)} :\n    IsClosed[sSup T] s \u2194 \u2200 t \u2208 T, IsClosed[t] s := by\n  simp only [sSup_eq_iSup]\n  simp only [isClosed_iSup_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order.lean", "context": {"open": ["Function Set Filter Topology", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b1 : Type*} {t t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1}", "[TopologicalSpace \u03b1] [DiscreteTopology \u03b1] {\u03b2 : Type*}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{t t\u2081 t\u2082 : TopologicalSpace \u03b1} {t' : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {\u03b9 : Sort*}", "{\u03b1 : Type*} {\u03b2 : Type*}", "[t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b1 : Type u} {\u03b9 : Sort v}", "{t : \u03b9 \u2192 TopologicalSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nT : Set (TopologicalSpace \u03b1)\n\u22a2 IsClosed s \u2194 \u2200 t \u2208 T, IsClosed s"}, {"line": "simp only [sSup_eq_iSup]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nT : Set (TopologicalSpace \u03b1)\n\u22a2 IsClosed s \u2194 \u2200 t \u2208 T, IsClosed s"}, {"line": "simp only [isClosed_iSup_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_single (i : \u03b9) (s : Set X) : \u21d1(BumpCovering.single i s) = Pi.single i 1 := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/PartitionOfUnity.lean", "context": {"open": ["Function Set Filter Topology", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type u} {X : Type v} [TopologicalSpace X]", "{E : Type*} [AddCommMonoid E] [SMulWithZero \u211d E] [TopologicalSpace E] [ContinuousSMul \u211d E]", "{s : Set X} (\u03c1 : PartitionOfUnity \u03b9 X s) (x\u2080 : X)", "{x\u2080 : X}", "{s : Set X} (\u03c1 : PartitionOfUnity \u03b9 X s) (x\u2080 : X)", "{f}", "{s : Set X} (f : BumpCovering \u03b9 X s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\n\u03b9 : Type u_4\ni : \u03b9\ns : Set X\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
