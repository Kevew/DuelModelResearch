{"declaration": "theorem sinh_nonpos_iff : sinh x \u2264 0 \u2194 x \u2264 0 := by simpa only [sinh_zero] using @sinh_le_sinh x 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_2\nsinh : x\u271d\n\u22a2 sorry \u2264 0 \u2194 x \u2264 0"}, {"line": "simpa only [sinh_zero] using @sinh_le_sinh x 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_neg_iff : sinh x < 0 \u2194 x < 0 := by simpa only [sinh_zero] using @sinh_lt_sinh x 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_2\nsinh : x\u271d\n\u22a2 sorry < 0 \u2194 x < 0"}, {"line": "simpa only [sinh_zero] using @sinh_lt_sinh x 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_nonneg_iff : 0 \u2264 sinh x \u2194 0 \u2264 x := by simpa only [sinh_zero] using @sinh_le_sinh 0 x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_2\nsinh : x\u271d\n\u22a2 0 \u2264 sorry \u2194 0 \u2264 x"}, {"line": "simpa only [sinh_zero] using @sinh_le_sinh 0 x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.logDeriv_sin : logDeriv (Complex.sin) = Complex.cot := by\n  ext\n  rw [logDeriv]\n  rw [Complex.deriv_sin]\n  rw [Pi.div_apply]\n  rw [Complex.cot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 logDeriv sin = cot"}, {"line": "ext", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 logDeriv sin x\u271d = x\u271d.cot"}, {"line": "rw [logDeriv]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 (deriv sin / sin) x\u271d = x\u271d.cot"}, {"line": "rw [Complex.deriv_sin]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 (cos / sin) x\u271d = x\u271d.cot"}, {"line": "rw [Pi.div_apply]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 cos x\u271d / sin x\u271d = x\u271d.cot"}, {"line": "rw [Complex.cot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.logDeriv_sin : logDeriv (Real.sin) = Real.cot := by\n  ext\n  rw [logDeriv]\n  rw [Real.deriv_sin]\n  rw [Pi.div_apply]\n  rw [Real.cot_eq_cos_div_sin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 logDeriv sin = cot"}, {"line": "ext", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 logDeriv sin x\u271d = x\u271d.cot"}, {"line": "rw [logDeriv]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 (deriv sin / sin) x\u271d = x\u271d.cot"}, {"line": "rw [Real.deriv_sin]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 (cos / sin) x\u271d = x\u271d.cot"}, {"line": "rw [Pi.div_apply]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 cos x\u271d / sin x\u271d = x\u271d.cot"}, {"line": "rw [Real.cot_eq_cos_div_sin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.logDeriv_cos : logDeriv (Complex.cos) = -Complex.tan := by\n  ext\n  rw [logDeriv]\n  rw [Complex.deriv_cos']\n  rw [Pi.div_apply]\n  rw [Pi.neg_apply]\n  rw [Complex.tan]\n  rw [neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 logDeriv cos = -tan"}, {"line": "ext", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 logDeriv cos x\u271d = (-tan) x\u271d"}, {"line": "rw [logDeriv]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 (deriv cos / cos) x\u271d = (-tan) x\u271d"}, {"line": "rw [Complex.deriv_cos']", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 ((fun x => -sin x) / cos) x\u271d = (-tan) x\u271d"}, {"line": "rw [Pi.div_apply]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 -sin x\u271d / cos x\u271d = (-tan) x\u271d"}, {"line": "rw [Pi.neg_apply]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 -sin x\u271d / cos x\u271d = -tan x\u271d"}, {"line": "rw [Complex.tan]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 -sin x\u271d / cos x\u271d = -(sin x\u271d / cos x\u271d)"}, {"line": "rw [neg_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.logDeriv_cos : logDeriv (Real.cos) = -Real.tan := by\n  ext\n  rw [logDeriv]\n  rw [Real.deriv_cos']\n  rw [Pi.div_apply]\n  rw [Pi.neg_apply]\n  rw [neg_div]\n  rw [Real.tan_eq_sin_div_cos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 logDeriv cos = -tan"}, {"line": "ext", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 logDeriv cos x\u271d = (-tan) x\u271d"}, {"line": "rw [logDeriv]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 (deriv cos / cos) x\u271d = (-tan) x\u271d"}, {"line": "rw [Real.deriv_cos']", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 ((fun x => -sin x) / cos) x\u271d = (-tan) x\u271d"}, {"line": "rw [Pi.div_apply]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 -sin x\u271d / cos x\u271d = (-tan) x\u271d"}, {"line": "rw [Pi.neg_apply]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 -sin x\u271d / cos x\u271d = -tan x\u271d"}, {"line": "rw [neg_div]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 -(sin x\u271d / cos x\u271d) = -tan x\u271d"}, {"line": "rw [Real.tan_eq_sin_div_cos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.logDeriv_cosh : logDeriv (Complex.cosh) = Complex.tanh := by\n  ext\n  rw [logDeriv]\n  rw [Complex.deriv_cosh]\n  rw [Pi.div_apply]\n  rw [Complex.tanh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 logDeriv cosh = tanh"}, {"line": "ext", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 logDeriv cosh x\u271d = tanh x\u271d"}, {"line": "rw [logDeriv]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 (deriv cosh / cosh) x\u271d = tanh x\u271d"}, {"line": "rw [Complex.deriv_cosh]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 (sinh / cosh) x\u271d = tanh x\u271d"}, {"line": "rw [Pi.div_apply]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 sinh x\u271d / cosh x\u271d = tanh x\u271d"}, {"line": "rw [Complex.tanh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.logDeriv_cosh : logDeriv (Real.cosh) = Real.tanh := by\n  ext\n  rw [logDeriv]\n  rw [Real.deriv_cosh]\n  rw [Pi.div_apply]\n  rw [Real.tanh_eq_sinh_div_cosh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 logDeriv cosh = tanh"}, {"line": "ext", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 logDeriv cosh x\u271d = tanh x\u271d"}, {"line": "rw [logDeriv]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 (deriv cosh / cosh) x\u271d = tanh x\u271d"}, {"line": "rw [Real.deriv_cosh]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 (sinh / cosh) x\u271d = tanh x\u271d"}, {"line": "rw [Pi.div_apply]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 sinh x\u271d / cosh x\u271d = tanh x\u271d"}, {"line": "rw [Real.tanh_eq_sinh_div_cosh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.LogDeriv_exp : logDeriv (Complex.exp) = 1 := by\n  ext\n  rw [logDeriv]\n  rw [Complex.deriv_exp]\n  rw [Pi.div_apply]\n  rw [\u2190 exp_sub]\n  rw [sub_self]\n  rw [exp_zero]\n  rw [Pi.one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 logDeriv exp = 1"}, {"line": "ext", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 logDeriv exp x\u271d = 1 x\u271d"}, {"line": "rw [logDeriv]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 (deriv exp / exp) x\u271d = 1 x\u271d"}, {"line": "rw [Complex.deriv_exp]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 (exp / exp) x\u271d = 1 x\u271d"}, {"line": "rw [Pi.div_apply]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 exp x\u271d / exp x\u271d = 1 x\u271d"}, {"line": "rw [\u2190 exp_sub]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 exp (x\u271d - x\u271d) = 1 x\u271d"}, {"line": "rw [sub_self]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 exp 0 = 1 x\u271d"}, {"line": "rw [exp_zero]", "tactic_state": "case h\nx\u271d : \u2102\n\u22a2 1 = 1 x\u271d"}, {"line": "rw [Pi.one_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.LogDeriv_exp : logDeriv (Real.exp) = 1 := by\n  ext\n  rw [logDeriv]\n  rw [Real.deriv_exp]\n  rw [Pi.div_apply]\n  rw [\u2190 exp_sub]\n  rw [sub_self]\n  rw [exp_zero]\n  rw [Pi.one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 logDeriv exp = 1"}, {"line": "ext", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 logDeriv exp x\u271d = 1 x\u271d"}, {"line": "rw [logDeriv]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 (deriv exp / exp) x\u271d = 1 x\u271d"}, {"line": "rw [Real.deriv_exp]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 (exp / exp) x\u271d = 1 x\u271d"}, {"line": "rw [Pi.div_apply]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 exp x\u271d / exp x\u271d = 1 x\u271d"}, {"line": "rw [\u2190 exp_sub]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 exp (x\u271d - x\u271d) = 1 x\u271d"}, {"line": "rw [sub_self]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 exp 0 = 1 x\u271d"}, {"line": "rw [exp_zero]", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 1 = 1 x\u271d"}, {"line": "rw [Pi.one_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211d) (hx : 0 < x) : 0 < x.sinh := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set", "Lean Meta Qq"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f\u271d\u00b2 : \u2102 \u2192 \u2102\nf'\u271d\u00b2 x\u271d\u2074 : \u2102\ns\u271d : Set \u2102\nE\u271d : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\u271d\ninst\u271d\u00b2 : NormedSpace \u2102 E\u271d\nf\u271d\u00b9 : E\u271d \u2192 \u2102\nf'\u271d\u00b9 : E\u271d \u2192L[\u2102] \u2102\nx\u271d\u00b3 : E\u271d\nx\u271d\u00b2 y z : \u211d\nf\u271d : \u211d \u2192 \u211d\nf'\u271d x\u271d\u00b9 : \u211d\ns : Set \u211d\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\nx\u271d : E\nx : \u211d\nhx : 0 < x\n\u22a2 0 < Real.sinh x"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211d) (hx : 0 \u2264 x) : 0 \u2264 x.sinh := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set", "Lean Meta Qq"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f\u271d\u00b2 : \u2102 \u2192 \u2102\nf'\u271d\u00b2 x\u271d\u2074 : \u2102\ns\u271d : Set \u2102\nE\u271d : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\u271d\ninst\u271d\u00b2 : NormedSpace \u2102 E\u271d\nf\u271d\u00b9 : E\u271d \u2192 \u2102\nf'\u271d\u00b9 : E\u271d \u2192L[\u2102] \u2102\nx\u271d\u00b3 : E\u271d\nx\u271d\u00b2 y z : \u211d\nf\u271d : \u211d \u2192 \u211d\nf'\u271d x\u271d\u00b9 : \u211d\ns : Set \u211d\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\nx\u271d : E\nx : \u211d\nhx : 0 \u2264 x\n\u22a2 0 \u2264 Real.sinh x"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211d) (hx : x \u2260 0) : x.sinh \u2260 0 := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "context": {"open": ["scoped Topology Filter", "Set", "Lean Meta Qq"], "variables": ["{f : \u2102 \u2192 \u2102} {f' x : \u2102} {s : Set \u2102}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : E \u2192 \u2102} {f' : E \u2192L[\u2102] \u2102} {x : E}", "{x y z : \u211d}", "{f : \u211d \u2192 \u211d} {f' x : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f\u271d\u00b2 : \u2102 \u2192 \u2102\nf'\u271d\u00b2 x\u271d\u2074 : \u2102\ns\u271d : Set \u2102\nE\u271d : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\u271d\ninst\u271d\u00b2 : NormedSpace \u2102 E\u271d\nf\u271d\u00b9 : E\u271d \u2192 \u2102\nf'\u271d\u00b9 : E\u271d \u2192L[\u2102] \u2102\nx\u271d\u00b3 : E\u271d\nx\u271d\u00b2 y z : \u211d\nf\u271d : \u211d \u2192 \u211d\nf'\u271d x\u271d\u00b9 : \u211d\ns : Set \u211d\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\nx\u271d : E\nx : \u211d\nhx : x \u2260 0\n\u22a2 Real.sinh x \u2260 0"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_sin_mul_sin_mul_cos_pow_eq (hn : 2 \u2264 n) (hz : z \u2260 0) :\n    (\u222b x in (0 : \u211d)..\u03c0 / 2, Complex.sin (2 * z * x) * sin x * (cos x : \u2102) ^ (n - 1)) =\n      (n / (2 * z) * \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ n) -\n        (n - 1) / (2 * z) *\n          \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ (n - 2) := by\n  have der1 :\n    \u2200 x : \u211d,\n      x \u2208 uIcc 0 (\u03c0 / 2) \u2192\n        HasDerivAt (fun y : \u211d => sin y * (cos y : \u2102) ^ (n - 1))\n          ((cos x : \u2102) ^ n - (n - 1) * (sin x : \u2102) ^ 2 * (cos x : \u2102) ^ (n - 2)) x := by\n    intro x _\n    have c := HasDerivAt.comp (x : \u2102) (hasDerivAt_pow (n - 1) _) (Complex.hasDerivAt_cos x)\n    convert ((Complex.hasDerivAt_sin x).mul c).comp_ofReal using 1\n    \u00b7 ext1 y; simp only [Complex.ofReal_sin, Complex.ofReal_cos, Function.comp]\n    \u00b7 simp only [Complex.ofReal_cos, Complex.ofReal_sin]\n      rw [mul_neg]\n      rw [mul_neg]\n      rw [\u2190 sub_eq_add_neg]\n      rw [Function.comp_apply]\n      congr 1\n      \u00b7 rw [\u2190 pow_succ', Nat.sub_add_cancel (by omega : 1 \u2264 n)]\n      \u00b7 have : ((n - 1 : \u2115) : \u2102) = (n : \u2102) - 1 := by\n          rw [Nat.cast_sub (one_le_two.trans hn)]\n          rw [Nat.cast_one]\n        rw [Nat.sub_sub]\n        rw [this]\n        ring\n  convert\n    integral_mul_deriv_eq_deriv_mul der1 (fun x _ => antideriv_sin_comp_const_mul hz x) _ _ using 1\n  \u00b7 refine integral_congr fun x _ => ?_\n    ring_nf\n  \u00b7 -- now a tedious rearrangement of terms\n    -- gather into a single integral, and deal with continuity subgoals:\n    rw [sin_zero]\n    rw [cos_pi_div_two]\n    rw [Complex.ofReal_zero]\n    rw [zero_pow]\n    rw [zero_mul]\n    rw [mul_zero]\n    rw [zero_mul]\n    rw [zero_mul]\n    rw [sub_zero]\n    rw [zero_sub]\n    rw [\u2190       integral_neg]\n    rw [\u2190 integral_const_mul]\n    rw [\u2190 integral_const_mul]\n    rw [\u2190 integral_sub]\n    rotate_left\n    \u00b7 apply Continuous.intervalIntegrable\n      exact\n        continuous_const.mul\n          ((Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).mul\n            ((Complex.continuous_ofReal.comp continuous_cos).pow n))\n    \u00b7 apply Continuous.intervalIntegrable\n      exact\n        continuous_const.mul\n          ((Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).mul\n            ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 2)))\n    \u00b7 exact Nat.sub_ne_zero_of_lt hn\n    refine integral_congr fun x _ => ?_\n    dsimp only\n    -- get rid of real trig functions and divisions by 2 * z:\n    rw [Complex.ofReal_cos]\n    rw [Complex.ofReal_sin]\n    rw [Complex.sin_sq]\n    rw [\u2190 mul_div_right_comm]\n    rw [\u2190       mul_div_right_comm]\n    rw [\u2190 sub_div]\n    rw [mul_div]\n    rw [\u2190 neg_div]\n    congr 1\n    have : Complex.cos x ^ n = Complex.cos x ^ (n - 2) * Complex.cos x ^ 2 := by\n      conv_lhs => rw [\u2190 Nat.sub_add_cancel hn, pow_add]\n    rw [this]\n    ring\n  \u00b7 apply Continuous.intervalIntegrable\n    exact\n      ((Complex.continuous_ofReal.comp continuous_cos).pow n).sub\n        ((continuous_const.mul ((Complex.continuous_ofReal.comp continuous_sin).pow 2)).mul\n          ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 2)))\n  \u00b7 apply Continuous.intervalIntegrable\n    exact Complex.continuous_sin.comp (continuous_const.mul Complex.continuous_ofReal)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/EulerSineProd.lean", "context": {"open": ["scoped Real Topology", "Real Set Filter intervalIntegral MeasureTheory.MeasureSpace"], "variables": ["{z : \u2102} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\n\u22a2 \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.sin (2 * z * \u2191x) * \u2191(sin x) * \u2191(cos x) ^ (n - 1) =\n    (\u2191n / (2 * z) * \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.cos (2 * z * \u2191x) * \u2191(cos x) ^ n) -\n      (\u2191n - 1) / (2 * z) * \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.cos (2 * z * \u2191x) * \u2191(cos x) ^ (n - 2)"}, {"line": "have der1 :\n    \u2200 x : \u211d,\n      x \u2208 uIcc 0 (\u03c0 / 2) \u2192\n        HasDerivAt (fun y : \u211d => sin y * (cos y : \u2102) ^ (n - 1))\n          ((cos x : \u2102) ^ n - (n - 1) * (sin x : \u2102) ^ 2 * (cos x : \u2102) ^ (n - 2)) x := by\n    intro x _\n    have c := HasDerivAt.comp (x : \u2102) (hasDerivAt_pow (n - 1) _) (Complex.hasDerivAt_cos x)\n    convert ((Complex.hasDerivAt_sin x).mul c).comp_ofReal using 1\n    \u00b7 ext1 y; simp only [Complex.ofReal_sin, Complex.ofReal_cos, Function.comp]\n    \u00b7 simp only [Complex.ofReal_cos, Complex.ofReal_sin]\n      rw [mul_neg]\n      rw [mul_neg]\n      rw [\u2190 sub_eq_add_neg]\n      rw [Function.comp_apply]\n      congr 1\n      \u00b7 rw [\u2190 pow_succ', Nat.sub_add_cancel (by omega : 1 \u2264 n)]\n      \u00b7 have : ((n - 1 : \u2115) : \u2102) = (n : \u2102) - 1 := by\n          rw [Nat.cast_sub (one_le_two.trans hn)]\n          rw [Nat.cast_one]\n        rw [Nat.sub_sub]\n        rw [this]\n        ring", "tactic_state": "z : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.sin (2 * z * \u2191x) * \u2191(sin x) * \u2191(cos x) ^ (n - 1) =\n    (\u2191n / (2 * z) * \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.cos (2 * z * \u2191x) * \u2191(cos x) ^ n) -\n      (\u2191n - 1) / (2 * z) * \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.cos (2 * z * \u2191x) * \u2191(cos x) ^ (n - 2)"}, {"line": "convert\n    integral_mul_deriv_eq_deriv_mul der1 (fun x _ => antideriv_sin_comp_const_mul hz x) _ _ using 1", "tactic_state": "case h.e'_2\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.sin (2 * z * \u2191x) * \u2191(sin x) * \u2191(cos x) ^ (n - 1) =\n    \u222b (x : \u211d) in 0 ..sorry / 2, \u2191(sin x) * \u2191(cos x) ^ (n - 1) * ?convert_2 x\n---\ncase h.e'_3\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 (\u2191n / (2 * z) * \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.cos (2 * z * \u2191x) * \u2191(cos x) ^ n) -\n      (\u2191n - 1) / (2 * z) * \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.cos (2 * z * \u2191x) * \u2191(cos x) ^ (n - 2) =\n    \u2191(sin (sorry / 2)) * \u2191(cos (sorry / 2)) ^ (n - 1) * ?convert_1 (sorry / 2) -\n        \u2191(sin 0) * \u2191(cos 0) ^ (n - 1) * ?convert_1 0 -\n      \u222b (x : \u211d) in 0 ..sorry / 2, (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) * ?convert_1 x\n---\ncase convert_1\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 \u211d \u2192 \u2102\n---\ncase convert_2\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 \u211d \u2192 \u2102\n---\ncase convert_3\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable (fun x => \u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) volume 0 (sorry / 2)\n---\ncase convert_4\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable ?convert_2 volume 0 (sorry / 2)"}, {"line": "\u00b7 refine integral_congr fun x _ => ?_\n    ring_nf", "tactic_state": "case h.e'_3\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 (\u2191n / (2 * z) * \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.cos (2 * z * \u2191x) * \u2191(cos x) ^ n) -\n      (\u2191n - 1) / (2 * z) * \u222b (x : \u211d) in 0 ..Real.pi / 2, Complex.cos (2 * z * \u2191x) * \u2191(cos x) ^ (n - 2) =\n    \u2191(sin (sorry / 2)) * \u2191(cos (sorry / 2)) ^ (n - 1) * ?convert_1 (sorry / 2) -\n        \u2191(sin 0) * \u2191(cos 0) ^ (n - 1) * ?convert_1 0 -\n      \u222b (x : \u211d) in 0 ..sorry / 2, (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) * ?convert_1 x\n---\ncase convert_1\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 \u211d \u2192 \u2102\n---\ncase convert_2\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 \u211d \u2192 \u2102\n---\ncase convert_3\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable (fun x => \u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) volume 0 (sorry / 2)\n---\ncase convert_4\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable ?convert_2 volume 0 (sorry / 2)"}, {"line": "\u00b7 -- now a tedious rearrangement of terms\n    rw [sin_zero]\n    rw [cos_pi_div_two]\n    rw [Complex.ofReal_zero]\n    rw [zero_pow]\n    rw [zero_mul]\n    rw [mul_zero]\n    rw [zero_mul]\n    rw [zero_mul]\n    rw [sub_zero]\n    rw [zero_sub]\n    rw [\u2190       integral_neg]\n    rw [\u2190 integral_const_mul]\n    rw [\u2190 integral_const_mul]\n    rw [\u2190 integral_sub]\n    rotate_left\n    \u00b7 apply Continuous.intervalIntegrable\n      exact\n        continuous_const.mul\n          ((Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).mul\n            ((Complex.continuous_ofReal.comp continuous_cos).pow n))\n    \u00b7 apply Continuous.intervalIntegrable\n      exact\n        continuous_const.mul\n          ((Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).mul\n            ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 2)))\n    \u00b7 exact Nat.sub_ne_zero_of_lt hn\n    refine integral_congr fun x _ => ?_\n    dsimp only\n    rw [Complex.ofReal_cos]\n    rw [Complex.ofReal_sin]\n    rw [Complex.sin_sq]\n    rw [\u2190 mul_div_right_comm]\n    rw [\u2190       mul_div_right_comm]\n    rw [\u2190 sub_div]\n    rw [mul_div]\n    rw [\u2190 neg_div]\n    congr 1\n    have : Complex.cos x ^ n = Complex.cos x ^ (n - 2) * Complex.cos x ^ 2 := by\n      conv_lhs => rw [\u2190 Nat.sub_add_cancel hn, pow_add]\n    rw [this]\n    ring", "tactic_state": "case convert_1\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 \u211d \u2192 \u2102\n---\ncase convert_2\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 \u211d \u2192 \u2102\n---\ncase convert_3\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable (fun x => \u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) volume 0 (sorry / 2)\n---\ncase convert_4\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable ?convert_2 volume 0 (sorry / 2)"}, {"line": "\u00b7 apply Continuous.intervalIntegrable\n    exact\n      ((Complex.continuous_ofReal.comp continuous_cos).pow n).sub\n        ((continuous_const.mul ((Complex.continuous_ofReal.comp continuous_sin).pow 2)).mul\n          ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 2)))", "tactic_state": "case convert_2\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 \u211d \u2192 \u2102\n---\ncase convert_3\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable (fun x => \u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) volume 0 (sorry / 2)\n---\ncase convert_4\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable ?convert_2 volume 0 (sorry / 2)"}, {"line": "\u00b7 apply Continuous.intervalIntegrable\n    exact Complex.continuous_sin.comp (continuous_const.mul Complex.continuous_ofReal)", "tactic_state": "case convert_3\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable (fun x => \u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) volume 0 (sorry / 2)\n---\ncase convert_4\nz : \u2102\nn : \u2115\nhn : 2 \u2264 n\nhz : z \u2260 0\nder1 :\n  \u2200 x \u2208 uIcc 0 (sorry / 2),\n    HasDerivAt (fun y => \u2191(sin y) * \u2191(cos y) ^ (n - 1)) (\u2191(cos x) ^ n - (\u2191n - 1) * \u2191(sin x) ^ 2 * \u2191(cos x) ^ (n - 2)) x\n\u22a2 IntervalIntegrable sorry volume 0 (sorry / 2)"}]}
{"declaration": "theorem tendsto_integral_cos_pow_mul_div {f : \u211d \u2192 \u2102} (hf : ContinuousOn f (Icc 0 (\u03c0 / 2))) :\n    Tendsto\n      (fun n : \u2115 => (\u222b x in (0 : \u211d)..\u03c0 / 2, (cos x : \u2102) ^ n * f x) /\n        (\u222b x in (0 : \u211d)..\u03c0 / 2, cos x ^ n : \u211d))\n      atTop (\ud835\udcdd <| f 0) := by\n  simp_rw [div_eq_inv_mul (\u03b1 := \u2102), \u2190 Complex.ofReal_inv, integral_of_le pi_div_two_pos.le,\n    \u2190 MeasureTheory.integral_Icc_eq_integral_Ioc, \u2190 Complex.ofReal_pow, \u2190 Complex.real_smul]\n  have c_lt : \u2200 y : \u211d, y \u2208 Icc 0 (\u03c0 / 2) \u2192 y \u2260 0 \u2192 cos y < cos 0 := fun y hy hy' =>\n    cos_lt_cos_of_nonneg_of_le_pi_div_two (le_refl 0) hy.2 (lt_of_le_of_ne hy.1 hy'.symm)\n  have c_nonneg : \u2200 x : \u211d, x \u2208 Icc 0 (\u03c0 / 2) \u2192 0 \u2264 cos x := fun x hx =>\n    cos_nonneg_of_mem_Icc ((Icc_subset_Icc_left (neg_nonpos_of_nonneg pi_div_two_pos.le)) hx)\n  have c_zero_pos : 0 < cos 0 := by rw [cos_zero]; exact zero_lt_one\n  have zero_mem : (0 : \u211d) \u2208 closure (interior (Icc 0 (\u03c0 / 2))) := by\n    rw [interior_Icc]\n    rw [closure_Ioo pi_div_two_pos.ne]\n    rw [left_mem_Icc]\n    exact pi_div_two_pos.le\n  exact\n    tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn isCompact_Icc\n      continuousOn_cos c_lt c_nonneg c_zero_pos zero_mem hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/EulerSineProd.lean", "context": {"open": ["scoped Real Topology", "Real Set Filter intervalIntegral MeasureTheory.MeasureSpace"], "variables": ["{z : \u2102} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u2102\nhf : ContinuousOn f (Icc 0 (Real.pi / 2))\n\u22a2 Tendsto (fun n => (\u222b (x : \u211d) in 0 ..Real.pi / 2, \u2191(cos x) ^ n * f x) / \u2191(\u222b (x : \u211d) in 0 ..Real.pi / 2, cos x ^ n))\n    atTop (nhds (f 0))"}, {"line": "simp_rw [div_eq_inv_mul (\u03b1 := \u2102), \u2190 Complex.ofReal_inv, integral_of_le pi_div_two_pos.le,\n    \u2190 MeasureTheory.integral_Icc_eq_integral_Ioc, \u2190 Complex.ofReal_pow, \u2190 Complex.real_smul]", "tactic_state": "f : \u211d \u2192 \u2102\nhf : ContinuousOn f (Icc 0 (Real.pi / 2))\n\u22a2 Tendsto\n    (fun n =>\n      (\u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2202volume)\u207b\u00b9 \u2022\n        \u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2022 f x \u2202volume)\n    atTop (nhds (f 0))"}, {"line": "have c_lt : \u2200 y : \u211d, y \u2208 Icc 0 (\u03c0 / 2) \u2192 y \u2260 0 \u2192 cos y < cos 0 := fun y hy hy' =>\n    cos_lt_cos_of_nonneg_of_le_pi_div_two (le_refl 0) hy.2 (lt_of_le_of_ne hy.1 hy'.symm)", "tactic_state": "f : \u211d \u2192 \u2102\nhf : ContinuousOn f (Icc 0 (Real.pi / 2))\nc_lt : \u2200 y \u2208 Icc 0 (sorry / 2), y \u2260 0 \u2192 cos y < cos 0\n\u22a2 Tendsto\n    (fun n =>\n      (\u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2202volume)\u207b\u00b9 \u2022\n        \u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2022 f x \u2202volume)\n    atTop (nhds (f 0))"}, {"line": "have c_nonneg : \u2200 x : \u211d, x \u2208 Icc 0 (\u03c0 / 2) \u2192 0 \u2264 cos x := fun x hx =>\n    cos_nonneg_of_mem_Icc ((Icc_subset_Icc_left (neg_nonpos_of_nonneg pi_div_two_pos.le)) hx)", "tactic_state": "f : \u211d \u2192 \u2102\nhf : ContinuousOn f (Icc 0 (Real.pi / 2))\nc_lt : \u2200 y \u2208 Icc 0 (sorry / 2), y \u2260 0 \u2192 cos y < cos 0\nc_nonneg : \u2200 x \u2208 Icc 0 (sorry / 2), 0 \u2264 cos x\n\u22a2 Tendsto\n    (fun n =>\n      (\u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2202volume)\u207b\u00b9 \u2022\n        \u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2022 f x \u2202volume)\n    atTop (nhds (f 0))"}, {"line": "have c_zero_pos : 0 < cos 0 := sorry", "tactic_state": "f : \u211d \u2192 \u2102\nhf : ContinuousOn f (Icc 0 (Real.pi / 2))\nc_lt : \u2200 y \u2208 Icc 0 (sorry / 2), y \u2260 0 \u2192 cos y < cos 0\nc_nonneg : \u2200 x \u2208 Icc 0 (sorry / 2), 0 \u2264 cos x\nc_zero_pos : 0 < cos 0\n\u22a2 Tendsto\n    (fun n =>\n      (\u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2202volume)\u207b\u00b9 \u2022\n        \u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2022 f x \u2202volume)\n    atTop (nhds (f 0))"}, {"line": "have zero_mem : (0 : \u211d) \u2208 closure (interior (Icc 0 (\u03c0 / 2))) := sorry", "tactic_state": "f : \u211d \u2192 \u2102\nhf : ContinuousOn f (Icc 0 (Real.pi / 2))\nc_lt : \u2200 y \u2208 Icc 0 (sorry / 2), y \u2260 0 \u2192 cos y < cos 0\nc_nonneg : \u2200 x \u2208 Icc 0 (sorry / 2), 0 \u2264 cos x\nc_zero_pos : 0 < cos 0\nzero_mem : 0 \u2208 closure (interior (Icc 0 (sorry / 2)))\n\u22a2 Tendsto\n    (fun n =>\n      (\u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2202volume)\u207b\u00b9 \u2022\n        \u222b (x : \u211d) in Icc 0 (Real.pi / 2), cos x ^ n \u2022 f x \u2202volume)\n    atTop (nhds (f 0))"}, {"line": "exact\n    tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn isCompact_Icc\n      continuousOn_cos c_lt c_nonneg c_zero_pos zero_mem hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_arcsin : range arcsin = Icc (-(\u03c0 / 2)) (\u03c0 / 2) := by\n  rw [arcsin]\n  rw [range_comp Subtype.val]\n  simp [Icc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 range arcsin = Icc (-(Real.pi / 2)) (Real.pi / 2)"}, {"line": "rw [arcsin]", "tactic_state": "\u22a2 range (Subtype.val \u2218 IccExtend arcsin._proof_2 \u21d1sinOrderIso.symm) = Icc (-(Real.pi / 2)) (Real.pi / 2)"}, {"line": "rw [range_comp Subtype.val]", "tactic_state": "\u22a2 Subtype.val '' range (IccExtend arcsin._proof_2 \u21d1sinOrderIso.symm) = Icc (-(Real.pi / 2)) (Real.pi / 2)"}, {"line": "simp [Icc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_projIcc (x : \u211d) :\n    arcsin (projIcc (-1) 1 (neg_le_self zero_le_one) x) = arcsin x := by\n  rw [arcsin]\n  rw [Function.comp_apply]\n  rw [IccExtend_val]\n  rw [Function.comp_apply]\n  rw [IccExtend]\n  rw [Function.comp_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arcsin \u2191(projIcc (-1) 1 \u22ef x) = arcsin x"}, {"line": "rw [arcsin]", "tactic_state": "x : \u211d\n\u22a2 (Subtype.val \u2218 IccExtend arcsin._proof_2 \u21d1sinOrderIso.symm) \u2191(projIcc (-1) 1 \u22ef x) =\n    (Subtype.val \u2218 IccExtend arcsin._proof_2 \u21d1sinOrderIso.symm) x"}, {"line": "rw [Function.comp_apply]", "tactic_state": "x : \u211d\n\u22a2 \u2191(IccExtend arcsin._proof_2 \u21d1sinOrderIso.symm \u2191(projIcc (-1) 1 \u22ef x)) =\n    (Subtype.val \u2218 IccExtend arcsin._proof_2 \u21d1sinOrderIso.symm) x"}, {"line": "rw [IccExtend_val]", "tactic_state": "x : \u211d\n\u22a2 \u2191(sinOrderIso.symm (projIcc (-1) 1 \u22ef x)) = (Subtype.val \u2218 IccExtend arcsin._proof_2 \u21d1sinOrderIso.symm) x"}, {"line": "rw [Function.comp_apply]", "tactic_state": "x : \u211d\n\u22a2 \u2191(sinOrderIso.symm (projIcc (-1) 1 \u22ef x)) = \u2191(IccExtend arcsin._proof_2 (\u21d1sinOrderIso.symm) x)"}, {"line": "rw [IccExtend]", "tactic_state": "x : \u211d\n\u22a2 \u2191(sinOrderIso.symm (projIcc (-1) 1 \u22ef x)) = \u2191((\u21d1sinOrderIso.symm \u2218 projIcc (-1) 1 arcsin._proof_2) x)"}, {"line": "rw [Function.comp_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_arcsin' {x : \u211d} (hx : x \u2208 Icc (-1 : \u211d) 1) : sin (arcsin x) = x := by\n  simpa [arcsin, IccExtend_of_mem _ _ hx, -OrderIso.apply_symm_apply] using\n    Subtype.ext_iff.1 (sinOrderIso.apply_symm_apply \u27e8x, hx\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2208 Icc (-1) 1\n\u22a2 sin (arcsin x) = x"}, {"line": "simpa [arcsin, IccExtend_of_mem _ _ hx, -OrderIso.apply_symm_apply] using\n    Subtype.ext_iff.1 (sinOrderIso.apply_symm_apply \u27e8x, hx\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_eq_of_sin_eq {x y : \u211d} (h\u2081 : sin x = y) (h\u2082 : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin y = x := by\n  subst y\n  exact injOn_sin (arcsin_mem_Icc _) h\u2082 (sin_arcsin' (sin_mem_Icc x))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh\u2081 : sin x = y\nh\u2082 : x \u2208 Icc (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 arcsin y = x"}, {"line": "subst y", "tactic_state": "x : \u211d\nh\u2082 : x \u2208 Icc (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 arcsin (sin x) = x"}, {"line": "exact injOn_sin (arcsin_mem_Icc _) h\u2082 (sin_arcsin' (sin_mem_Icc x))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_of_one_le {x : \u211d} (hx : 1 \u2264 x) : arcsin x = \u03c0 / 2 := by\n  rw [\u2190 arcsin_projIcc]\n  rw [projIcc_of_right_le _ hx]\n  rw [Subtype.coe_mk]\n  rw [arcsin_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 1 \u2264 x\n\u22a2 arcsin x = Real.pi / 2"}, {"line": "rw [\u2190 arcsin_projIcc]", "tactic_state": "x : \u211d\nhx : 1 \u2264 x\n\u22a2 arcsin \u2191(projIcc (-1) 1 \u22ef x) = Real.pi / 2"}, {"line": "rw [projIcc_of_right_le _ hx]", "tactic_state": "x : \u211d\nhx : 1 \u2264 x\n\u22a2 arcsin \u2191\u27e81, \u22ef\u27e9 = Real.pi / 2"}, {"line": "rw [Subtype.coe_mk]", "tactic_state": "x : \u211d\nhx : 1 \u2264 x\n\u22a2 arcsin 1 = Real.pi / 2"}, {"line": "rw [arcsin_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_of_le_neg_one {x : \u211d} (hx : x \u2264 -1) : arcsin x = -(\u03c0 / 2) := by\n  rw [\u2190 arcsin_projIcc]\n  rw [projIcc_of_le_left _ hx]\n  rw [Subtype.coe_mk]\n  rw [arcsin_neg_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2264 -1\n\u22a2 arcsin x = -(Real.pi / 2)"}, {"line": "rw [\u2190 arcsin_projIcc]", "tactic_state": "x : \u211d\nhx : x \u2264 -1\n\u22a2 arcsin \u2191(projIcc (-1) 1 \u22ef x) = -(Real.pi / 2)"}, {"line": "rw [projIcc_of_le_left _ hx]", "tactic_state": "x : \u211d\nhx : x \u2264 -1\n\u22a2 arcsin \u2191\u27e8-1, \u22ef\u27e9 = -(Real.pi / 2)"}, {"line": "rw [Subtype.coe_mk]", "tactic_state": "x : \u211d\nhx : x \u2264 -1\n\u22a2 arcsin (-1) = -(Real.pi / 2)"}, {"line": "rw [arcsin_neg_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_neg (x : \u211d) : arcsin (-x) = -arcsin x := by\n  rcases le_total x (-1) with hx\u2081 | hx\u2081\n  \u00b7 rw [arcsin_of_le_neg_one hx\u2081, neg_neg, arcsin_of_one_le (le_neg.2 hx\u2081)]\n  rcases le_total 1 x with hx\u2082 | hx\u2082\n  \u00b7 rw [arcsin_of_one_le hx\u2082, arcsin_of_le_neg_one (neg_le_neg hx\u2082)]\n  refine arcsin_eq_of_sin_eq ?_ ?_\n  \u00b7 rw [sin_neg, sin_arcsin hx\u2081 hx\u2082]\n  \u00b7 exact \u27e8neg_le_neg (arcsin_le_pi_div_two _), neg_le.2 (neg_pi_div_two_le_arcsin _)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arcsin (-x) = -arcsin x"}, {"line": "rcases le_total x (-1) with hx\u2081 | hx\u2081", "tactic_state": "case inl\nx : \u211d\nhx\u2081 : x \u2264 -1\n\u22a2 arcsin (-x) = -arcsin x\n---\ncase inr\nx : \u211d\nhx\u2081 : -1 \u2264 x\n\u22a2 arcsin (-x) = -arcsin x"}, {"line": "\u00b7 rw [arcsin_of_le_neg_one hx\u2081, neg_neg, arcsin_of_one_le (le_neg.2 hx\u2081)]", "tactic_state": "case inr\nx : \u211d\nhx\u2081 : -1 \u2264 x\n\u22a2 arcsin (-x) = -arcsin x"}, {"line": "rcases le_total 1 x with hx\u2082 | hx\u2082", "tactic_state": "case inr.inl\nx : \u211d\nhx\u2081 : -1 \u2264 x\nhx\u2082 : 1 \u2264 x\n\u22a2 arcsin (-x) = -arcsin x\n---\ncase inr.inr\nx : \u211d\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 arcsin (-x) = -arcsin x"}, {"line": "\u00b7 rw [arcsin_of_one_le hx\u2082, arcsin_of_le_neg_one (neg_le_neg hx\u2082)]", "tactic_state": "case inr.inr\nx : \u211d\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 arcsin (-x) = -arcsin x"}, {"line": "refine arcsin_eq_of_sin_eq ?_ ?_", "tactic_state": "case inr.inr.refine_1\nx : \u211d\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 sin (-arcsin x) = -x\n---\ncase inr.inr.refine_2\nx : \u211d\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 -arcsin x \u2208 Icc (-(Real.pi / 2)) (Real.pi / 2)"}, {"line": "\u00b7 rw [sin_neg, sin_arcsin hx\u2081 hx\u2082]", "tactic_state": "case inr.inr.refine_2\nx : \u211d\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 -arcsin x \u2208 Icc (-(Real.pi / 2)) (Real.pi / 2)"}, {"line": "\u00b7 exact \u27e8neg_le_neg (arcsin_le_pi_div_two _), neg_le.2 (neg_pi_div_two_le_arcsin _)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_le_iff_le_sin {x y : \u211d} (hx : x \u2208 Icc (-1 : \u211d) 1) (hy : y \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin x \u2264 y \u2194 x \u2264 sin y := by\n  rw [\u2190 arcsin_sin' hy]\n  rw [strictMonoOn_arcsin.le_iff_le hx (sin_mem_Icc _)]\n  rw [arcsin_sin' hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : x \u2208 Icc (-1) 1\nhy : y \u2208 Icc (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 arcsin x \u2264 y \u2194 x \u2264 sin y"}, {"line": "rw [\u2190 arcsin_sin' hy]", "tactic_state": "x y : \u211d\nhx : x \u2208 Icc (-1) 1\nhy : y \u2208 Icc (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 arcsin x \u2264 arcsin (sin y) \u2194 x \u2264 sin (arcsin (sin y))"}, {"line": "rw [strictMonoOn_arcsin.le_iff_le hx (sin_mem_Icc _)]", "tactic_state": "x y : \u211d\nhx : x \u2208 Icc (-1) 1\nhy : y \u2208 Icc (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 x \u2264 sin y \u2194 x \u2264 sin (arcsin (sin y))"}, {"line": "rw [arcsin_sin' hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_le_iff_le_sin' {x y : \u211d} (hy : y \u2208 Ico (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin x \u2264 y \u2194 x \u2264 sin y := by\n  rcases le_total x (-1) with hx\u2081 | hx\u2081\n  \u00b7 simp [arcsin_of_le_neg_one hx\u2081, hy.1, hx\u2081.trans (neg_one_le_sin _)]\n  rcases lt_or_le 1 x with hx\u2082 | hx\u2082\n  \u00b7 simp [arcsin_of_one_le hx\u2082.le, hy.2.not_le, (sin_le_one y).trans_lt hx\u2082]\n  exact arcsin_le_iff_le_sin \u27e8hx\u2081, hx\u2082\u27e9 (mem_Icc_of_Ico hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhy : y \u2208 Ico (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 arcsin x \u2264 y \u2194 x \u2264 sin y"}, {"line": "rcases le_total x (-1) with hx\u2081 | hx\u2081", "tactic_state": "case inl\nx y : \u211d\nhy : y \u2208 Ico (-(Real.pi / 2)) (Real.pi / 2)\nhx\u2081 : x \u2264 -1\n\u22a2 arcsin x \u2264 y \u2194 x \u2264 sin y\n---\ncase inr\nx y : \u211d\nhy : y \u2208 Ico (-(Real.pi / 2)) (Real.pi / 2)\nhx\u2081 : -1 \u2264 x\n\u22a2 arcsin x \u2264 y \u2194 x \u2264 sin y"}, {"line": "\u00b7 simp [arcsin_of_le_neg_one hx\u2081, hy.1, hx\u2081.trans (neg_one_le_sin _)]", "tactic_state": "case inr\nx y : \u211d\nhy : y \u2208 Ico (-(Real.pi / 2)) (Real.pi / 2)\nhx\u2081 : -1 \u2264 x\n\u22a2 arcsin x \u2264 y \u2194 x \u2264 sin y"}, {"line": "rcases lt_or_le 1 x with hx\u2082 | hx\u2082", "tactic_state": "case inr.inl\nx y : \u211d\nhy : y \u2208 Ico (-(Real.pi / 2)) (Real.pi / 2)\nhx\u2081 : -1 \u2264 x\nhx\u2082 : 1 < x\n\u22a2 arcsin x \u2264 y \u2194 x \u2264 sin y\n---\ncase inr.inr\nx y : \u211d\nhy : y \u2208 Ico (-(Real.pi / 2)) (Real.pi / 2)\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 arcsin x \u2264 y \u2194 x \u2264 sin y"}, {"line": "\u00b7 simp [arcsin_of_one_le hx\u2082.le, hy.2.not_le, (sin_le_one y).trans_lt hx\u2082]", "tactic_state": "case inr.inr\nx y : \u211d\nhy : y \u2208 Ico (-(Real.pi / 2)) (Real.pi / 2)\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 arcsin x \u2264 y \u2194 x \u2264 sin y"}, {"line": "exact arcsin_le_iff_le_sin \u27e8hx\u2081, hx\u2082\u27e9 (mem_Icc_of_Ico hy)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_eq_iff_eq_sin {x y : \u211d} (hy : y \u2208 Ioo (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin x = y \u2194 x = sin y := by\n  simp only [le_antisymm_iff]\n  simp only [arcsin_le_iff_le_sin' (mem_Ico_of_Ioo hy)]\n  simp only [le_arcsin_iff_sin_le' (mem_Ioc_of_Ioo hy)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 arcsin x = y \u2194 x = sin y"}, {"line": "simp only [le_antisymm_iff]", "tactic_state": "x y : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 arcsin x \u2264 y \u2227 y \u2264 arcsin x \u2194 x \u2264 sin y \u2227 sin y \u2264 x"}, {"line": "simp only [arcsin_le_iff_le_sin' (mem_Ico_of_Ioo hy)]", "tactic_state": "x y : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 x \u2264 sin y \u2227 y \u2264 arcsin x \u2194 x \u2264 sin y \u2227 sin y \u2264 x"}, {"line": "simp only [le_arcsin_iff_sin_le' (mem_Ioc_of_Ioo hy)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_eq_zero_iff {x : \u211d} : arcsin x = 0 \u2194 x = 0 := by simp [le_antisymm_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arcsin x = 0 \u2194 x = 0"}, {"line": "simp [le_antisymm_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_div_four_le_arcsin {x} : \u03c0 / 4 \u2264 arcsin x \u2194 \u221a2 / 2 \u2264 x := by\n  rw [\u2190 sin_pi_div_four]\n  rw [le_arcsin_iff_sin_le']\n  have := pi_pos\n  constructor <;> linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 Real.pi / 4 \u2264 arcsin x \u2194 \u221a2 / 2 \u2264 x"}, {"line": "rw [\u2190 sin_pi_div_four]", "tactic_state": "x : \u211d\n\u22a2 Real.pi / 4 \u2264 arcsin x \u2194 sin (Real.pi / 4) \u2264 x"}, {"line": "rw [le_arcsin_iff_sin_le']", "tactic_state": "x : \u211d\n\u22a2 Real.pi / 4 \u2208 Ioc (-(Real.pi / 2)) (Real.pi / 2)"}, {"line": "have := pi_pos", "tactic_state": "x : \u211d\nthis : 0 < Real.pi\n\u22a2 Real.pi / 4 \u2208 Ioc (-(Real.pi / 2)) (Real.pi / 2)"}, {"line": "constructor <;> linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arcsin_eq_pi_div_two_sub_arccos (x : \u211d) : arcsin x = \u03c0 / 2 - arccos x := by simp [arccos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arcsin x = Real.pi / 2 - arccos x"}, {"line": "simp [arccos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_pos {x : \u211d} : 0 < arccos x \u2194 x < 1 := by simp [arccos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 0 < arccos x \u2194 x < 1"}, {"line": "simp [arccos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_arccos {x : \u211d} (hx\u2081 : -1 \u2264 x) (hx\u2082 : x \u2264 1) : cos (arccos x) = x := by\n  rw [arccos]\n  rw [cos_pi_div_two_sub]\n  rw [sin_arcsin hx\u2081 hx\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 cos (arccos x) = x"}, {"line": "rw [arccos]", "tactic_state": "x : \u211d\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 cos (Real.pi / 2 - arcsin x) = x"}, {"line": "rw [cos_pi_div_two_sub]", "tactic_state": "x : \u211d\nhx\u2081 : -1 \u2264 x\nhx\u2082 : x \u2264 1\n\u22a2 sin (arcsin x) = x"}, {"line": "rw [sin_arcsin hx\u2081 hx\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma arccos_eq_of_eq_cos (hy\u2080 : 0 \u2264 y) (hy\u2081 : y \u2264 \u03c0) (hxy : x = cos y) : arccos x = y := by\n  rw [hxy]\n  rw [arccos_cos hy\u2080 hy\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhy\u2080 : 0 \u2264 y\nhy\u2081 : y \u2264 Real.pi\nhxy : x = cos y\n\u22a2 arccos x = y"}, {"line": "rw [hxy]", "tactic_state": "x y : \u211d\nhy\u2080 : 0 \u2264 y\nhy\u2081 : y \u2264 Real.pi\nhxy : x = cos y\n\u22a2 arccos (cos y) = y"}, {"line": "rw [arccos_cos hy\u2080 hy\u2081]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_zero : arccos 0 = \u03c0 / 2 := by simp [arccos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 arccos 0 = Real.pi / 2"}, {"line": "simp [arccos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_one : arccos 1 = 0 := by simp [arccos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 arccos 1 = 0"}, {"line": "simp [arccos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_neg_one : arccos (-1) = \u03c0 := by simp [arccos, add_halves]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 arccos (-1) = Real.pi"}, {"line": "simp [arccos, add_halves]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_eq_zero {x} : arccos x = 0 \u2194 1 \u2264 x := by simp [arccos, sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arccos x = 0 \u2194 1 \u2264 x"}, {"line": "simp [arccos, sub_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_eq_pi_div_two {x} : arccos x = \u03c0 / 2 \u2194 x = 0 := by simp [arccos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arccos x = Real.pi / 2 \u2194 x = 0"}, {"line": "simp [arccos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_eq_pi {x} : arccos x = \u03c0 \u2194 x \u2264 -1 := by\n  rw [arccos]\n  rw [sub_eq_iff_eq_add]\n  rw [\u2190 sub_eq_iff_eq_add']\n  rw [div_two_sub_self]\n  rw [neg_pi_div_two_eq_arcsin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arccos x = Real.pi \u2194 x \u2264 -1"}, {"line": "rw [arccos]", "tactic_state": "x : \u211d\n\u22a2 Real.pi / 2 - arcsin x = Real.pi \u2194 x \u2264 -1"}, {"line": "rw [sub_eq_iff_eq_add]", "tactic_state": "x : \u211d\n\u22a2 Real.pi / 2 = Real.pi + arcsin x \u2194 x \u2264 -1"}, {"line": "rw [\u2190 sub_eq_iff_eq_add']", "tactic_state": "x : \u211d\n\u22a2 Real.pi / 2 - Real.pi = arcsin x \u2194 x \u2264 -1"}, {"line": "rw [div_two_sub_self]", "tactic_state": "x : \u211d\n\u22a2 -(Real.pi / 2) = arcsin x \u2194 x \u2264 -1"}, {"line": "rw [neg_pi_div_two_eq_arcsin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_of_one_le {x : \u211d} (hx : 1 \u2264 x) : arccos x = 0 := by\n  rw [arccos]\n  rw [arcsin_of_one_le hx]\n  rw [sub_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 1 \u2264 x\n\u22a2 arccos x = 0"}, {"line": "rw [arccos]", "tactic_state": "x : \u211d\nhx : 1 \u2264 x\n\u22a2 Real.pi / 2 - arcsin x = 0"}, {"line": "rw [arcsin_of_one_le hx]", "tactic_state": "x : \u211d\nhx : 1 \u2264 x\n\u22a2 Real.pi / 2 - Real.pi / 2 = 0"}, {"line": "rw [sub_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_of_le_neg_one {x : \u211d} (hx : x \u2264 -1) : arccos x = \u03c0 := by\n  rw [arccos]\n  rw [arcsin_of_le_neg_one hx]\n  rw [sub_neg_eq_add]\n  rw [add_halves]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2264 -1\n\u22a2 arccos x = Real.pi"}, {"line": "rw [arccos]", "tactic_state": "x : \u211d\nhx : x \u2264 -1\n\u22a2 Real.pi / 2 - arcsin x = Real.pi"}, {"line": "rw [arcsin_of_le_neg_one hx]", "tactic_state": "x : \u211d\nhx : x \u2264 -1\n\u22a2 Real.pi / 2 - -(Real.pi / 2) = Real.pi"}, {"line": "rw [sub_neg_eq_add]", "tactic_state": "x : \u211d\nhx : x \u2264 -1\n\u22a2 Real.pi / 2 + Real.pi / 2 = Real.pi"}, {"line": "rw [add_halves]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_le_pi_div_two {x} : arccos x \u2264 \u03c0 / 2 \u2194 0 \u2264 x := by simp [arccos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arccos x \u2264 Real.pi / 2 \u2194 0 \u2264 x"}, {"line": "simp [arccos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_lt_pi_div_two {x : \u211d} : arccos x < \u03c0 / 2 \u2194 0 < x := by simp [arccos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arccos x < Real.pi / 2 \u2194 0 < x"}, {"line": "simp [arccos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_le_pi_div_four {x} : arccos x \u2264 \u03c0 / 4 \u2194 \u221a2 / 2 \u2264 x := by\n  rw [arccos]\n  rw [\u2190 pi_div_four_le_arcsin]\n  constructor <;>\n    \u00b7 intro\n      linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 arccos x \u2264 Real.pi / 4 \u2194 \u221a2 / 2 \u2264 x"}, {"line": "rw [arccos]", "tactic_state": "x : \u211d\n\u22a2 Real.pi / 2 - arcsin x \u2264 Real.pi / 4 \u2194 \u221a2 / 2 \u2264 x"}, {"line": "rw [\u2190 pi_div_four_le_arcsin]", "tactic_state": "x : \u211d\n\u22a2 Real.pi / 2 - arcsin x \u2264 Real.pi / 4 \u2194 Real.pi / 4 \u2264 arcsin x"}, {"line": "constructor <;>\n    \u00b7 intro\n      linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_arccos (x : \u211d) : tan (arccos x) = \u221a(1 - x ^ 2) / x := by\n  rw [arccos]\n  rw [tan_pi_div_two_sub]\n  rw [tan_arcsin]\n  rw [inv_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 tan (arccos x) = \u221a(1 - x ^ 2) / x"}, {"line": "rw [arccos]", "tactic_state": "x : \u211d\n\u22a2 tan (Real.pi / 2 - arcsin x) = \u221a(1 - x ^ 2) / x"}, {"line": "rw [tan_pi_div_two_sub]", "tactic_state": "x : \u211d\n\u22a2 (tan (arcsin x))\u207b\u00b9 = \u221a(1 - x ^ 2) / x"}, {"line": "rw [tan_arcsin]", "tactic_state": "x : \u211d\n\u22a2 (x / \u221a(1 - x ^ 2))\u207b\u00b9 = \u221a(1 - x ^ 2) / x"}, {"line": "rw [inv_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arccos_nhdsGE (h : Tendsto f l (\ud835\udcdd[\u2265] x)) :\n    Tendsto (arccos <| f \u00b7) l (\ud835\udcdd[\u2264] (arccos x)) := by\n  refine ((continuous_arccos.tendsto _).inf <| MapsTo.tendsto fun y hy \u21a6 ?_).comp h\n  simp only [mem_Ici] at hy \u22a2\n  simp only [mem_Iic] at hy \u22a2\n  exact antitone_arccos hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "context": {"open": ["Topology Filter Set Filter Real", "Real"], "variables": ["{x y : \u211d}", "{\u03b1 : Type*} {l : Filter \u03b1} {x : \u211d} {f : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nx : \u211d\nf : \u03b1 \u2192 \u211d\nh : Tendsto f l (nhdsWithin x (Ici x))\n\u22a2 Tendsto (fun x => arccos (f x)) l (nhdsWithin (arccos x) (Iic (arccos x)))"}, {"line": "refine ((continuous_arccos.tendsto _).inf <| MapsTo.tendsto fun y hy \u21a6 ?_).comp h", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nx : \u211d\nf : \u03b1 \u2192 \u211d\nh : Tendsto f l (nhdsWithin x (Ici x))\ny : \u211d\nhy : y \u2208 Ici x\n\u22a2 arccos y \u2208 Iic (arccos x)"}, {"line": "simp only [mem_Ici] at hy \u22a2", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nx : \u211d\nf : \u03b1 \u2192 \u211d\nh : Tendsto f l (nhdsWithin x (Ici x))\ny : \u211d\nhy : x \u2264 y\n\u22a2 arccos y \u2208 Iic (arccos x)"}, {"line": "simp only [mem_Iic] at hy \u22a2", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nx : \u211d\nf : \u03b1 \u2192 \u211d\nh : Tendsto f l (nhdsWithin x (Ici x))\ny : \u211d\nhy : x \u2264 y\n\u22a2 arccos y \u2264 arccos x"}, {"line": "exact antitone_arccos hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivWithinAt_arcsin_Ici {x : \u211d} (h : x \u2260 -1) :\n    HasDerivWithinAt arcsin (1 / \u221a(1 - x ^ 2)) (Ici x) x := by\n  rcases eq_or_ne x 1 with (rfl | h')\n  \u00b7 convert (hasDerivWithinAt_const (1 : \u211d) _ (\u03c0 / 2)).congr _ _ <;>\n      simp +contextual [arcsin_of_one_le]\n  \u00b7 exact (hasDerivAt_arcsin h h').hasDerivWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/InverseDeriv.lean", "context": {"open": ["scoped Topology Filter Real ContDiff", "Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "arcsin : \u211d \u2192 \u211d\nx : \u211d\nh : x \u2260 -1\n\u22a2 HasDerivWithinAt arcsin (1 / \u221a(1 - x ^ 2)) (Ici x) x"}, {"line": "rcases eq_or_ne x 1 with (rfl | h')", "tactic_state": "case inl\narcsin : \u211d \u2192 \u211d\nh : 1 \u2260 -1\n\u22a2 HasDerivWithinAt arcsin (1 / \u221a(1 - 1 ^ 2)) (Ici 1) 1\n---\ncase inr\narcsin : \u211d \u2192 \u211d\nx : \u211d\nh : x \u2260 -1\nh' : x \u2260 1\n\u22a2 HasDerivWithinAt arcsin (1 / \u221a(1 - x ^ 2)) (Ici x) x"}, {"line": "\u00b7 convert (hasDerivWithinAt_const (1 : \u211d) _ (\u03c0 / 2)).congr _ _ <;>\n      simp +contextual [arcsin_of_one_le]", "tactic_state": "case inr\narcsin : \u211d \u2192 \u211d\nx : \u211d\nh : x \u2260 -1\nh' : x \u2260 1\n\u22a2 HasDerivWithinAt arcsin (1 / \u221a(1 - x ^ 2)) (Ici x) x"}, {"line": "\u00b7 exact (hasDerivAt_arcsin h h').hasDerivWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivWithinAt_arcsin_Iic {x : \u211d} (h : x \u2260 1) :\n    HasDerivWithinAt arcsin (1 / \u221a(1 - x ^ 2)) (Iic x) x := by\n  rcases em (x = -1) with (rfl | h')\n  \u00b7 convert (hasDerivWithinAt_const (-1 : \u211d) _ (-(\u03c0 / 2))).congr _ _ <;>\n      simp +contextual [arcsin_of_le_neg_one]\n  \u00b7 exact (hasDerivAt_arcsin h' h).hasDerivWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/InverseDeriv.lean", "context": {"open": ["scoped Topology Filter Real ContDiff", "Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "arcsin : \u211d \u2192 \u211d\nx : \u211d\nh : x \u2260 1\n\u22a2 HasDerivWithinAt arcsin (1 / \u221a(1 - x ^ 2)) (Iic x) x"}, {"line": "rcases em (x = -1) with (rfl | h')", "tactic_state": "case inl\narcsin : \u211d \u2192 \u211d\nh : -1 \u2260 1\n\u22a2 HasDerivWithinAt arcsin (1 / \u221a(1 - (-1) ^ 2)) (Iic (-1)) (-1)\n---\ncase inr\narcsin : \u211d \u2192 \u211d\nx : \u211d\nh : x \u2260 1\nh' : \u00acx = -1\n\u22a2 HasDerivWithinAt arcsin (1 / \u221a(1 - x ^ 2)) (Iic x) x"}, {"line": "\u00b7 convert (hasDerivWithinAt_const (-1 : \u211d) _ (-(\u03c0 / 2))).congr _ _ <;>\n      simp +contextual [arcsin_of_le_neg_one]", "tactic_state": "case inr\narcsin : \u211d \u2192 \u211d\nx : \u211d\nh : x \u2260 1\nh' : \u00acx = -1\n\u22a2 HasDerivWithinAt arcsin (1 / \u221a(1 - x ^ 2)) (Iic x) x"}, {"line": "\u00b7 exact (hasDerivAt_arcsin h' h).hasDerivWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NNReal.tendsto_inverse_atTop_nhds_zero_nat :\n    Tendsto (fun n : \u2115 \u21a6 (n : \u211d\u22650)\u207b\u00b9) atTop (\ud835\udcdd 0) := by\n  rw [\u2190 NNReal.tendsto_coe]\n  exact _root_.tendsto_inverse_atTop_nhds_zero_nat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto (fun n => (\u2191n)\u207b\u00b9) atTop (nhds 0)"}, {"line": "rw [\u2190 NNReal.tendsto_coe]", "tactic_state": "\u22a2 Tendsto (fun a => \u2191(\u2191a)\u207b\u00b9) atTop (nhds \u21910)"}, {"line": "exact _root_.tendsto_inverse_atTop_nhds_zero_nat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NNReal.tendsto_const_div_atTop_nhds_zero_nat (C : \u211d\u22650) :\n    Tendsto (fun n : \u2115 \u21a6 C / n) atTop (\ud835\udcdd 0) := by\n  simpa using tendsto_const_nhds.mul NNReal.tendsto_inverse_atTop_nhds_zero_nat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : NNReal\n\u22a2 Tendsto (fun n => C / \u2191n) atTop (nhds 0)"}, {"line": "simpa using tendsto_const_nhds.mul NNReal.tendsto_inverse_atTop_nhds_zero_nat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EReal.tendsto_const_div_atTop_nhds_zero_nat {C : EReal} (h : C \u2260 \u22a5) (h' : C \u2260 \u22a4) :\n    Tendsto (fun n : \u2115 \u21a6 C / n) atTop (\ud835\udcdd 0) := by\n  have : (fun n : \u2115 \u21a6 C / n) = fun n : \u2115 \u21a6 ((C.toReal / n : \u211d) : EReal) := by\n    ext n\n    nth_rw 1 [\u2190 coe_toReal h' h, \u2190 coe_coe_eq_natCast n, \u2190 coe_div C.toReal n]\n  rw [this]\n  rw [\u2190 coe_zero]\n  rw [tendsto_coe]\n  exact _root_.tendsto_const_div_atTop_nhds_zero_nat C.toReal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : EReal\nh : C \u2260 \u22a5\nh' : C \u2260 \u22a4\n\u22a2 Tendsto (fun n => C / \u2191n) atTop (nhds 0)"}, {"line": "have : (fun n : \u2115 \u21a6 C / n) = fun n : \u2115 \u21a6 ((C.toReal / n : \u211d) : EReal) := by\n    ext n\n    nth_rw 1 [\u2190 coe_toReal h' h, \u2190 coe_coe_eq_natCast n, \u2190 coe_div C.toReal n]", "tactic_state": "C : EReal\nh : C \u2260 \u22a5\nh' : C \u2260 \u22a4\nthis : (fun n => C / \u2191n) = fun n => \u2191(C.toReal / \u2191n)\n\u22a2 Tendsto (fun n => C / \u2191n) atTop (nhds 0)"}, {"line": "rw [this]", "tactic_state": "C : EReal\nh : C \u2260 \u22a5\nh' : C \u2260 \u22a4\nthis : (fun n => C / \u2191n) = fun n => \u2191(C.toReal / \u2191n)\n\u22a2 Tendsto (fun n => \u2191(C.toReal / \u2191n)) atTop (nhds 0)"}, {"line": "rw [\u2190 coe_zero]", "tactic_state": "C : EReal\nh : C \u2260 \u22a5\nh' : C \u2260 \u22a4\nthis : (fun n => C / \u2191n) = fun n => \u2191(C.toReal / \u2191n)\n\u22a2 Tendsto (fun n => \u2191(C.toReal / \u2191n)) atTop (nhds \u21910)"}, {"line": "rw [tendsto_coe]", "tactic_state": "C : EReal\nh : C \u2260 \u22a5\nh' : C \u2260 \u22a4\nthis : (fun n => C / \u2191n) = fun n => \u2191(C.toReal / \u2191n)\n\u22a2 Tendsto (fun n => C.toReal / \u2191n) atTop (nhds 0)"}, {"line": "exact _root_.tendsto_const_div_atTop_nhds_zero_nat C.toReal", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_mod_div_atTop_nhds_zero_nat {m : \u2115} (hm : 0 < m) :\n    Tendsto (fun n : \u2115 => ((n % m : \u2115) : \u211d) / (n : \u211d)) atTop (\ud835\udcdd 0) := by\n  have h0 : \u2200\u1da0 n : \u2115 in atTop, 0 \u2264 (fun n : \u2115 => ((n % m : \u2115) : \u211d)) n := by aesop\n  exact tendsto_bdd_div_atTop_nhds_zero h0\n    (.of_forall (fun n \u21a6  cast_le.mpr (mod_lt n hm).le)) tendsto_natCast_atTop_atTop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\nhm : 0 < m\n\u22a2 Tendsto (fun n => \u2191(n % m) / \u2191n) atTop (nhds 0)"}, {"line": "have h0 : \u2200\u1da0 n : \u2115 in atTop, 0 \u2264 (fun n : \u2115 => ((n % m : \u2115) : \u211d)) n := by aesop", "tactic_state": "m : \u2115\nhm : 0 < m\nh0 : \u2200\u1da0 (n : \u2115) in atTop, 0 \u2264 (fun n => \u2191(n % m)) n\n\u22a2 Tendsto (fun n => \u2191(n % m) / \u2191n) atTop (nhds 0)"}, {"line": "exact tendsto_bdd_div_atTop_nhds_zero h0\n    (.of_forall (fun n \u21a6  cast_le.mpr (mod_lt n hm).le)) tendsto_natCast_atTop_atTop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.EventuallyEq.div_mul_cancel {\u03b1 G : Type*} [GroupWithZero G] {f g : \u03b1 \u2192 G}\n    {l : Filter \u03b1} (hg : Tendsto g l (\ud835\udcdf {0}\u1d9c)) : (fun x \u21a6 f x / g x * g x) =\u1da0[l] fun x \u21a6 f x := by\n  filter_upwards [hg.le_comap <| preimage_mem_comap (m := g) (mem_principal_self {0}\u1d9c)] with x hx\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\nG : Type u_5\ninst\u271d : GroupWithZero G\nf g : \u03b1 \u2192 G\nl : Filter \u03b1\nhg : Tendsto g l (principal {0}\u1d9c)\n\u22a2 (fun x => f x / g x * g x) =\u1da0[l] fun x => f x"}, {"line": "filter_upwards [hg.le_comap <| preimage_mem_comap (m := g) (mem_principal_self {0}\u1d9c)] with x hx", "tactic_state": "case h\n\u03b1 : Type u_4\nG : Type u_5\ninst\u271d : GroupWithZero G\nf g : \u03b1 \u2192 G\nl : Filter \u03b1\nhg : Tendsto g l (principal {0}\u1d9c)\nx : \u03b1\nhx : x \u2208 g \u207b\u00b9' {0}\u1d9c\n\u22a2 f x / g x * g x = f x"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_lt {u : \u2115 \u2192 \u211d} {c : \u211d} (hc : 0 \u2264 c) {n : \u2115} (hn : 0 < n)\n    (h : \u2200 k < n, c * u k < u (k + 1)) : c ^ n * u 0 < u n := by\n  apply (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_le_of_lt hn _ _ h\n  \u00b7 simp\n  \u00b7 simp [_root_.pow_succ', mul_assoc, le_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nhn : 0 < n\nh : \u2200 k < n, c * u k < u (k + 1)\n\u22a2 c ^ n * u 0 < u n"}, {"line": "apply (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_le_of_lt hn _ _ h", "tactic_state": "u : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nhn : 0 < n\nh : \u2200 k < n, c * u k < u (k + 1)\n\u22a2 c ^ 0 * u 0 \u2264 u 0\n---\nu : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nhn : 0 < n\nh : \u2200 k < n, c * u k < u (k + 1)\n\u22a2 \u2200 k < n, c ^ (k + 1) * u 0 \u2264 c * (c ^ k * u 0)"}, {"line": "\u00b7 simp", "tactic_state": "u : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nhn : 0 < n\nh : \u2200 k < n, c * u k < u (k + 1)\n\u22a2 \u2200 k < n, c ^ (k + 1) * u 0 \u2264 c * (c ^ k * u 0)"}, {"line": "\u00b7 simp [_root_.pow_succ', mul_assoc, le_refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_le {u : \u2115 \u2192 \u211d} {c : \u211d} (hc : 0 \u2264 c) (n : \u2115) (h : \u2200 k < n, c * u k \u2264 u (k + 1)) :\n    c ^ n * u 0 \u2264 u n := by\n  apply (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h <;>\n    simp [_root_.pow_succ', mul_assoc, le_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nh : \u2200 k < n, c * u k \u2264 u (k + 1)\n\u22a2 c ^ n * u 0 \u2264 u n"}, {"line": "apply (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h <;>\n    simp [_root_.pow_succ', mul_assoc, le_refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_geom {u : \u2115 \u2192 \u211d} {c : \u211d} (hc : 0 \u2264 c) {n : \u2115} (hn : 0 < n)\n    (h : \u2200 k < n, u (k + 1) < c * u k) : u n < c ^ n * u 0 := by\n  apply (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_lt_of_le hn _ h _\n  \u00b7 simp\n  \u00b7 simp [_root_.pow_succ', mul_assoc, le_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nhn : 0 < n\nh : \u2200 k < n, u (k + 1) < c * u k\n\u22a2 u n < c ^ n * u 0"}, {"line": "apply (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_lt_of_le hn _ h _", "tactic_state": "u : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nhn : 0 < n\nh : \u2200 k < n, u (k + 1) < c * u k\n\u22a2 u 0 \u2264 c ^ 0 * u 0\n---\nu : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nhn : 0 < n\nh : \u2200 k < n, u (k + 1) < c * u k\n\u22a2 \u2200 k < n, c * (c ^ k * u 0) \u2264 c ^ (k + 1) * u 0"}, {"line": "\u00b7 simp", "tactic_state": "u : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nhn : 0 < n\nh : \u2200 k < n, u (k + 1) < c * u k\n\u22a2 \u2200 k < n, c * (c ^ k * u 0) \u2264 c ^ (k + 1) * u 0"}, {"line": "\u00b7 simp [_root_.pow_succ', mul_assoc, le_refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_geom {u : \u2115 \u2192 \u211d} {c : \u211d} (hc : 0 \u2264 c) (n : \u2115) (h : \u2200 k < n, u (k + 1) \u2264 c * u k) :\n    u n \u2264 c ^ n * u 0 := by\n  apply (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _ <;>\n    simp [_root_.pow_succ', mul_assoc, le_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : \u2115 \u2192 \u211d\nc : \u211d\nhc : 0 \u2264 c\nn : \u2115\nh : \u2200 k < n, u (k + 1) \u2264 c * u k\n\u22a2 u n \u2264 c ^ n * u 0"}, {"line": "apply (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _ <;>\n    simp [_root_.pow_succ', mul_assoc, le_refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one {r : \u211d\u22650\u221e} (hr : r < 1) :\n    Tendsto (fun n : \u2115 \u21a6 r ^ n) atTop (\ud835\udcdd 0) := by\n  rcases ENNReal.lt_iff_exists_coe.1 hr with \u27e8r, rfl, hr'\u27e9\n  rw [\u2190 ENNReal.coe_zero]\n  norm_cast at *\n  apply NNReal.tendsto_pow_atTop_nhds_zero_of_lt_one hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : ENNReal\nhr : r < 1\n\u22a2 Tendsto (fun n => r ^ n) atTop (nhds 0)"}, {"line": "rcases ENNReal.lt_iff_exists_coe.1 hr with \u27e8r, rfl, hr'\u27e9", "tactic_state": "case intro.intro\nr : NNReal\nhr' hr : \u2191r < 1\n\u22a2 Tendsto (fun n => \u2191r ^ n) atTop (nhds 0)"}, {"line": "rw [\u2190 ENNReal.coe_zero]", "tactic_state": "case intro.intro\nr : NNReal\nhr' hr : \u2191r < 1\n\u22a2 Tendsto (fun n => \u2191r ^ n) atTop (nhds \u21910)"}, {"line": "norm_cast at *", "tactic_state": "case intro.intro\nr : NNReal\nhr' hr : r < 1\n\u22a2 Tendsto (HPow.hPow r) atTop (nhds 0)"}, {"line": "apply NNReal.tendsto_pow_atTop_nhds_zero_of_lt_one hr", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem ENNReal.tendsto_pow_atTop_nhds_zero_iff {r : \u211d\u22650\u221e} :\n    Tendsto (fun n : \u2115 => r ^ n) atTop (\ud835\udcdd 0) \u2194 r < 1 := by\n  refine \u27e8fun h \u21a6 ?_, tendsto_pow_atTop_nhds_zero_of_lt_one\u27e9\n  lift r to NNReal\n  \u00b7 refine fun hr \u21a6 top_ne_zero (tendsto_nhds_unique (EventuallyEq.tendsto ?_) (hr \u25b8 h))\n    exact eventually_atTop.mpr \u27e81, fun _ hn \u21a6 pow_eq_top_iff.mpr \u27e8rfl, Nat.pos_iff_ne_zero.mp hn\u27e9\u27e9\n  rw [\u2190 coe_zero] at h\n  norm_cast at h \u22a2\n  exact NNReal.tendsto_pow_atTop_nhds_zero_iff.mp h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : ENNReal\n\u22a2 Tendsto (fun n => r ^ n) atTop (nhds 0) \u2194 r < 1"}, {"line": "refine \u27e8fun h \u21a6 ?_, tendsto_pow_atTop_nhds_zero_of_lt_one\u27e9", "tactic_state": "r : ENNReal\nh : Tendsto (fun n => r ^ n) atTop (nhds 0)\n\u22a2 r < 1"}, {"line": "lift r to NNReal", "tactic_state": "r : ENNReal\nh : Tendsto (fun n => r ^ n) atTop (nhds 0)\n\u22a2 r \u2260 \u22a4\n---\ncase intro\nr : NNReal\nh : Tendsto (fun n => \u2191r ^ n) atTop (nhds 0)\n\u22a2 \u2191r < 1"}, {"line": "\u00b7 refine fun hr \u21a6 top_ne_zero (tendsto_nhds_unique (EventuallyEq.tendsto ?_) (hr \u25b8 h))\n    exact eventually_atTop.mpr \u27e81, fun _ hn \u21a6 pow_eq_top_iff.mpr \u27e8rfl, Nat.pos_iff_ne_zero.mp hn\u27e9\u27e9", "tactic_state": "case intro\nr : NNReal\nh : Tendsto (fun n => \u2191r ^ n) atTop (nhds 0)\n\u22a2 \u2191r < 1"}, {"line": "rw [\u2190 coe_zero] at h", "tactic_state": "case intro\nr : NNReal\nh : Tendsto (fun n => \u2191r ^ n) atTop (nhds \u21910)\n\u22a2 \u2191r < 1"}, {"line": "norm_cast at h \u22a2", "tactic_state": "case intro\nr : NNReal\nh : Tendsto (HPow.hPow r) atTop (nhds 0)\n\u22a2 r < 1"}, {"line": "exact NNReal.tendsto_pow_atTop_nhds_zero_iff.mp h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasSum_geometric_two : HasSum (fun n : \u2115 \u21a6 ((1 : \u211d) / 2) ^ n) 2 := by\n  convert hasSum_geometric_of_lt_one _ _ <;> norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 HasSum (fun n => (1 / 2) ^ n) 2"}, {"line": "convert hasSum_geometric_of_lt_one _ _ <;> norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasSum_geometric_two' (a : \u211d) : HasSum (fun n : \u2115 \u21a6 a / 2 / 2 ^ n) a := by\n  convert HasSum.mul_left (a / 2)\n      (hasSum_geometric_of_lt_one (le_of_lt one_half_pos) one_half_lt_one) using 1\n  \u00b7 funext n\n    simp only [one_div]\n    simp only [inv_pow]\n    rfl\n  \u00b7 norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 HasSum (fun n => a / 2 / 2 ^ n) a"}, {"line": "convert HasSum.mul_left (a / 2)\n      (hasSum_geometric_of_lt_one (le_of_lt one_half_pos) one_half_lt_one) using 1", "tactic_state": "case h.e'_5\na : \u211d\n\u22a2 (fun n => a / 2 / 2 ^ n) = fun i => a / 2 * (1 / 2) ^ i\n---\ncase h.e'_6\na : \u211d\n\u22a2 a = a / 2 * (1 - 1 / 2)\u207b\u00b9"}, {"line": "\u00b7 funext n\n    simp only [one_div]\n    simp only [inv_pow]\n    rfl", "tactic_state": "case h.e'_6\na : \u211d\n\u22a2 a = a / 2 * (1 - 1 / 2)\u207b\u00b9"}, {"line": "\u00b7 norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NNReal.hasSum_geometric {r : \u211d\u22650} (hr : r < 1) : HasSum (fun n : \u2115 \u21a6 r ^ n) (1 - r)\u207b\u00b9 := by\n  apply NNReal.hasSum_coe.1\n  push_cast\n  rw [NNReal.coe_sub (le_of_lt hr)]\n  exact hasSum_geometric_of_lt_one r.coe_nonneg hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : NNReal\nhr : r < 1\n\u22a2 HasSum (fun n => r ^ n) (1 - r)\u207b\u00b9"}, {"line": "apply NNReal.hasSum_coe.1", "tactic_state": "r : NNReal\nhr : r < 1\n\u22a2 HasSum (fun a => \u2191(r ^ a)) \u2191(1 - r)\u207b\u00b9"}, {"line": "push_cast", "tactic_state": "r : NNReal\nhr : r < 1\n\u22a2 HasSum (fun a => \u2191r ^ a) (\u2191(1 - r))\u207b\u00b9"}, {"line": "rw [NNReal.coe_sub (le_of_lt hr)]", "tactic_state": "r : NNReal\nhr : r < 1\n\u22a2 HasSum (fun a => \u2191r ^ a) (\u21911 - \u2191r)\u207b\u00b9"}, {"line": "exact hasSum_geometric_of_lt_one r.coe_nonneg hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ENNReal.tsum_geometric_add_one (r : \u211d\u22650\u221e) : \u2211' n : \u2115, r ^ (n + 1) = r * (1 - r)\u207b\u00b9 := by\n  simp only [_root_.pow_succ']\n  simp only [ENNReal.tsum_mul_left]\n  simp only [ENNReal.tsum_geometric]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : ENNReal\n\u22a2 \u2211' (n : \u2115), r ^ (n + 1) = r * (1 - r)\u207b\u00b9"}, {"line": "simp only [_root_.pow_succ']", "tactic_state": "r : ENNReal\n\u22a2 \u2211' (n : \u2115), r * r ^ n = r * (1 - r)\u207b\u00b9"}, {"line": "simp only [ENNReal.tsum_mul_left]", "tactic_state": "r : ENNReal\n\u22a2 r * \u2211' (i : \u2115), r ^ i = r * (1 - r)\u207b\u00b9"}, {"line": "simp only [ENNReal.tsum_geometric]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_le_of_edist_le_geometric_of_tendsto\u2080 {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) :\n    edist (f 0) a \u2264 C / (1 - r) := by\n  simpa only [_root_.pow_zero,mul_one] using edist_le_of_edist_le_geometric_of_tendsto r C hu ha 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[PseudoEMetricSpace \u03b1] (r C : \u211d\u22650\u221e) (hr : r < 1) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nr C : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\nha : Tendsto f atTop (nhds a)\n\u22a2 edist (f 0) a \u2264 C / (1 - r)"}, {"line": "simpa only [_root_.pow_zero,mul_one] using edist_le_of_edist_le_geometric_of_tendsto r C hu ha 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_le_of_edist_le_geometric_two_of_tendsto (n : \u2115) : edist (f n) a \u2264 2 * C / 2 ^ n := by\n  simp only [div_eq_mul_inv] at *\n  simp only [ENNReal.inv_pow] at *\n  rw [mul_assoc]\n  rw [mul_comm]\n  convert edist_le_of_edist_le_geometric_of_tendsto 2\u207b\u00b9 C hu ha n using 1\n  rw [ENNReal.one_sub_inv_two]\n  rw [div_eq_mul_inv]\n  rw [inv_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[PseudoEMetricSpace \u03b1] (r C : \u211d\u22650\u221e) (hr : r < 1) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}", "[PseudoEMetricSpace \u03b1] (C : \u211d\u22650\u221e) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nC : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 edist (f n) a \u2264 2 * C / 2 ^ n"}, {"line": "simp only [div_eq_mul_inv] at *", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nC : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 edist (f n) a \u2264 2 * C * (2 ^ n)\u207b\u00b9"}, {"line": "simp only [ENNReal.inv_pow] at *", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nC : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 edist (f n) a \u2264 2 * C * 2\u207b\u00b9 ^ n"}, {"line": "rw [mul_assoc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nC : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 edist (f n) a \u2264 2 * (C * 2\u207b\u00b9 ^ n)"}, {"line": "rw [mul_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nC : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 edist (f n) a \u2264 C * 2\u207b\u00b9 ^ n * 2"}, {"line": "convert edist_le_of_edist_le_geometric_of_tendsto 2\u207b\u00b9 C hu ha n using 1", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nC : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 C * 2\u207b\u00b9 ^ n * 2 = C * 2\u207b\u00b9 ^ n / (1 - 2\u207b\u00b9)"}, {"line": "rw [ENNReal.one_sub_inv_two]", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nC : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 C * 2\u207b\u00b9 ^ n * 2 = C * 2\u207b\u00b9 ^ n / 2\u207b\u00b9"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nC : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 C * 2\u207b\u00b9 ^ n * 2 = C * 2\u207b\u00b9 ^ n * 2\u207b\u00b9\u207b\u00b9"}, {"line": "rw [inv_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_le_of_edist_le_geometric_two_of_tendsto\u2080 : edist (f 0) a \u2264 2 * C := by\n  simpa only [_root_.pow_zero,div_eq_mul_inv,inv_one,mul_one] using\n    edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[PseudoEMetricSpace \u03b1] (r C : \u211d\u22650\u221e) (hr : r < 1) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}", "[PseudoEMetricSpace \u03b1] (C : \u211d\u22650\u221e) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nC : ENNReal\nf : \u2115 \u2192 \u03b1\na : \u03b1\n\u22a2 edist (f 0) a \u2264 2 * C"}, {"line": "simpa only [_root_.pow_zero,div_eq_mul_inv,inv_one,mul_one] using\n    edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_le_of_le_geometric_two_of_tendsto {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) (n : \u2115) :\n    dist (f n) a \u2264 C / 2 ^ n := by\n  convert dist_le_tsum_of_dist_le_of_tendsto _ hu\u2082 (summable_geometric_two' C) ha n\n  simp only [add_comm n]\n  simp only [pow_add]\n  simp only [\u2190 div_div]\n  symm\n  exact ((hasSum_geometric_two' C).div_const _).tsum_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[PseudoEMetricSpace \u03b1] (r C : \u211d\u22650\u221e) (hr : r < 1) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}", "[PseudoEMetricSpace \u03b1] (C : \u211d\u22650\u221e) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}", "[PseudoMetricSpace \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "(hr : r < 1) (hu : \u2200 n, dist (f n) (f (n + 1)) \u2264 C * r ^ n)", "(r C)", "(hu\u2082 : \u2200 n, dist (f n) (f (n + 1)) \u2264 C / 2 / 2 ^ n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\nC : \u211d\nf : \u2115 \u2192 \u03b1\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn : \u2115\n\u22a2 Dist.dist (f n) a \u2264 C / 2 ^ n"}, {"line": "convert dist_le_tsum_of_dist_le_of_tendsto _ hu\u2082 (summable_geometric_two' C) ha n", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\nC : \u211d\nf : \u2115 \u2192 \u03b1\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn : \u2115\n\u22a2 C / 2 ^ n = \u2211' (m : \u2115), C / 2 / 2 ^ (n + m)"}, {"line": "simp only [add_comm n]", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\nC : \u211d\nf : \u2115 \u2192 \u03b1\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn : \u2115\n\u22a2 C / 2 ^ n = \u2211' (m : \u2115), C / 2 / 2 ^ (m + n)"}, {"line": "simp only [pow_add]", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\nC : \u211d\nf : \u2115 \u2192 \u03b1\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn : \u2115\n\u22a2 C / 2 ^ n = \u2211' (m : \u2115), C / 2 / (2 ^ m * 2 ^ n)"}, {"line": "simp only [\u2190 div_div]", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\nC : \u211d\nf : \u2115 \u2192 \u03b1\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn : \u2115\n\u22a2 C / 2 ^ n = \u2211' (m : \u2115), C / 2 / 2 ^ m / 2 ^ n"}, {"line": "symm", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\nC : \u211d\nf : \u2115 \u2192 \u03b1\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn : \u2115\n\u22a2 \u2211' (m : \u2115), C / 2 / 2 ^ m / 2 ^ n = C / 2 ^ n"}, {"line": "exact ((hasSum_geometric_two' C).div_const _).tsum_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_one_div_pow_of_le {m : \u211d} {f : \u2115 \u2192 \u2115} (hm : 1 < m) (fi : \u2200 i, i \u2264 f i) :\n    Summable fun i \u21a6 1 / m ^ f i := by\n  refine .of_nonneg_of_le (fun a \u21a6 by positivity) (fun a \u21a6 ?_)\n      (summable_geometric_of_lt_one (one_div_nonneg.mpr (zero_le_one.trans hm.le))\n        ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))\n  rw [div_pow]\n  rw [one_pow]\n  refine (one_div_le_one_div ?_ ?_).mpr (pow_right_mono\u2080 hm.le (fi a)) <;>\n    exact pow_pos (zero_lt_one.trans hm) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[PseudoEMetricSpace \u03b1] (r C : \u211d\u22650\u221e) (hr : r < 1) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}", "[PseudoEMetricSpace \u03b1] (C : \u211d\u22650\u221e) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}", "[PseudoMetricSpace \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "(hr : r < 1) (hu : \u2200 n, dist (f n) (f (n + 1)) \u2264 C * r ^ n)", "(r C)", "(hu\u2082 : \u2200 n, dist (f n) (f (n + 1)) \u2264 C / 2 / 2 ^ n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u211d\nf : \u2115 \u2192 \u2115\nhm : 1 < m\nfi : \u2200 (i : \u2115), i \u2264 f i\n\u22a2 Summable fun i => 1 / m ^ f i"}, {"line": "refine .of_nonneg_of_le (fun a \u21a6 by positivity) (fun a \u21a6 ?_)\n      (summable_geometric_of_lt_one (one_div_nonneg.mpr (zero_le_one.trans hm.le))\n        ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))", "tactic_state": "m : \u211d\nf : \u2115 \u2192 \u2115\nhm : 1 < m\nfi : \u2200 (i : \u2115), i \u2264 f i\na : \u2115\n\u22a2 1 / m ^ f a \u2264 (1 / m) ^ a"}, {"line": "rw [div_pow]", "tactic_state": "m : \u211d\nf : \u2115 \u2192 \u2115\nhm : 1 < m\nfi : \u2200 (i : \u2115), i \u2264 f i\na : \u2115\n\u22a2 1 / m ^ f a \u2264 1 ^ a / m ^ a"}, {"line": "rw [one_pow]", "tactic_state": "m : \u211d\nf : \u2115 \u2192 \u2115\nhm : 1 < m\nfi : \u2200 (i : \u2115), i \u2264 f i\na : \u2115\n\u22a2 1 / m ^ f a \u2264 1 / m ^ a"}, {"line": "refine (one_div_le_one_div ?_ ?_).mpr (pow_right_mono\u2080 hm.le (fi a)) <;>\n    exact pow_pos (zero_lt_one.trans hm) _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nat.tendsto_div_const_atTop {n : \u2115} (hn : n \u2260 0) : Tendsto (\u00b7 / n) atTop atTop := by\n  rw [Tendsto]\n  rw [map_div_atTop_eq_nat n hn.bot_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Basic.lean", "context": {"open": ["Set Function Filter Finset Metric Topology Nat uniformity NNReal ENNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[PseudoEMetricSpace \u03b1] (r C : \u211d\u22650\u221e) (hr : r < 1) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}", "[PseudoEMetricSpace \u03b1] (C : \u211d\u22650\u221e) (hC : C \u2260 \u22a4) {f : \u2115 \u2192 \u03b1}", "[PseudoMetricSpace \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "(hr : r < 1) (hu : \u2200 n, dist (f n) (f (n + 1)) \u2264 C * r ^ n)", "(r C)", "(hu\u2082 : \u2200 n, dist (f n) (f (n + 1)) \u2264 C / 2 / 2 ^ n)", "{R : Type*} [TopologicalSpace R] [Field R] [LinearOrder R] [IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 Tendsto (fun x => x / n) atTop atTop"}, {"line": "rw [Tendsto]", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 Filter.map (fun x => x / n) atTop \u2264 atTop"}, {"line": "rw [map_div_atTop_eq_nat n hn.bot_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_div_pow_sq_le_div_sq (N : \u2115) {j : \u211d} (hj : 0 < j) {c : \u211d} (hc : 1 < c) :\n    (\u2211 i \u2208 range N with j < c ^ i, (1 : \u211d) / (c ^ i) ^ 2) \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2 := by\n  have cpos : 0 < c := zero_lt_one.trans hc\n  have A : (0 : \u211d) < c\u207b\u00b9 ^ 2 := sq_pos_of_pos (inv_pos.2 cpos)\n  have B : c ^ 2 * ((1 : \u211d) - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 := by\n    rw [\u2190 div_eq_mul_inv]\n    rw [\u2190 div_eq_mul_inv]\n    rw [div_le_div_iff\u2080 _ (sub_pos.2 hc)]\n    swap\n    \u00b7 exact sub_pos.2 (pow_lt_one\u2080 (inv_nonneg.2 cpos.le) (inv_lt_one_of_one_lt\u2080 hc) two_ne_zero)\n    have : c ^ 3 = c ^ 2 * c := by ring\n    simp only [mul_sub]\n    simp only [this]\n    simp only [mul_one]\n    simp only [inv_pow]\n    simp only [sub_le_sub_iff_left]\n    rw [mul_assoc]\n    rw [mul_comm c]\n    rw [\u2190 mul_assoc]\n    rw [mul_inv_cancel\u2080 (sq_pos_of_pos cpos).ne']\n    rw [one_mul]\n    simpa using pow_right_mono\u2080 hc.le one_le_two\n  have C : c\u207b\u00b9 ^ 2 < 1 := pow_lt_one\u2080 (inv_nonneg.2 cpos.le) (inv_lt_one_of_one_lt\u2080 hc) two_ne_zero\n  calc\n    (\u2211 i \u2208 range N with j < c ^ i, (1 : \u211d) / (c ^ i) ^ 2) \u2264\n        \u2211 i \u2208 Ico \u230aReal.log j / Real.log c\u230b\u208a N, (1 : \u211d) / (c ^ i) ^ 2 := by\n      refine sum_le_sum_of_subset_of_nonneg (fun i hi \u21a6 ?_) (by intros; positivity)\n      simp only [mem_filter] at hi\n      simp only [mem_range] at hi\n      simp only [hi.1]\n      simp only [mem_Ico]\n      simp only [and_true]\n      apply Nat.floor_le_of_le\n      apply le_of_lt\n      rw [div_lt_iff\u2080 (Real.log_pos hc)]\n      rw [\u2190 Real.log_pow]\n      exact Real.log_lt_log hj hi.2\n    _ = \u2211 i \u2208 Ico \u230aReal.log j / Real.log c\u230b\u208a N, (c\u207b\u00b9 ^ 2) ^ i := by\n      congr 1 with i\n      simp [\u2190 pow_mul, mul_comm]\n    _ \u2264 (c\u207b\u00b9 ^ 2) ^ \u230aReal.log j / Real.log c\u230b\u208a / ((1 : \u211d) - c\u207b\u00b9 ^ 2) :=\n      geom_sum_Ico_le_of_lt_one (sq_nonneg _) C\n    _ \u2264 (c\u207b\u00b9 ^ 2) ^ (Real.log j / Real.log c - 1) / ((1 : \u211d) - c\u207b\u00b9 ^ 2) := by\n      gcongr\n      \u00b7 exact sub_nonneg.2 C.le\n      \u00b7 rw [\u2190 Real.rpow_natCast]\n        exact Real.rpow_le_rpow_of_exponent_ge A C.le (Nat.sub_one_lt_floor _).le\n    _ = c ^ 2 * ((1 : \u211d) - c\u207b\u00b9 ^ 2)\u207b\u00b9 / j ^ 2 := by\n      have I : (c\u207b\u00b9 ^ 2) ^ (Real.log j / Real.log c) = (1 : \u211d) / j ^ 2 := by\n        apply Real.log_injOn_pos (Real.rpow_pos_of_pos A _)\n        \u00b7 rw [Set.mem_Ioi]; positivity\n        rw [Real.log_rpow A]\n        simp only [one_div]\n        simp only [Real.log_inv]\n        simp only [Real.log_pow]\n        simp only [Nat.cast_one]\n        simp only [mul_neg]\n        simp only [neg_inj]\n        field_simp [(Real.log_pos hc).ne']\n        ring\n      rw [Real.rpow_sub A]\n      rw [I]\n      have : c ^ 2 - 1 \u2260 0 := (sub_pos.2 (one_lt_pow\u2080 hc two_ne_zero)).ne'\n      field_simp [hj.ne', (zero_lt_one.trans hc).ne']\n      ring\n    _ \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2 := by gcongr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/FloorPow.lean", "context": {"open": ["Filter Finset", "Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\n\u22a2 \u2211 i \u2208 {i \u2208 range N | j < c ^ i}, 1 / (c ^ i) ^ 2 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2"}, {"line": "have cpos : 0 < c := zero_lt_one.trans hc", "tactic_state": "N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\n\u22a2 \u2211 i \u2208 {i \u2208 range N | j < c ^ i}, 1 / (c ^ i) ^ 2 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2"}, {"line": "have A : (0 : \u211d) < c\u207b\u00b9 ^ 2 := sq_pos_of_pos (inv_pos.2 cpos)", "tactic_state": "N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < c\u207b\u00b9 ^ 2\n\u22a2 \u2211 i \u2208 {i \u2208 range N | j < c ^ i}, 1 / (c ^ i) ^ 2 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2"}, {"line": "have B : c ^ 2 * ((1 : \u211d) - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 := sorry", "tactic_state": "N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < c\u207b\u00b9 ^ 2\nB : c ^ 2 * (1 - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9\n\u22a2 \u2211 i \u2208 {i \u2208 range N | j < c ^ i}, 1 / (c ^ i) ^ 2 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2"}, {"line": "have C : c\u207b\u00b9 ^ 2 < 1 := pow_lt_one\u2080 (inv_nonneg.2 cpos.le) (inv_lt_one_of_one_lt\u2080 hc) two_ne_zero", "tactic_state": "N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < c\u207b\u00b9 ^ 2\nB : c ^ 2 * (1 - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9\nC : c\u207b\u00b9 ^ 2 < 1\n\u22a2 \u2211 i \u2208 {i \u2208 range N | j < c ^ i}, 1 / (c ^ i) ^ 2 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2"}, {"line": "calc\n    (\u2211 i \u2208 range N with j < c ^ i, (1 : \u211d) / (c ^ i) ^ 2) \u2264\n        \u2211 i \u2208 Ico \u230aReal.log j / Real.log c\u230b\u208a N, (1 : \u211d) / (c ^ i) ^ 2 := by\n      refine sum_le_sum_of_subset_of_nonneg (fun i hi \u21a6 ?_) (by intros; positivity)\n      simp only [mem_filter] at hi\n      simp only [mem_range] at hi\n      simp only [hi.1]\n      simp only [mem_Ico]\n      simp only [and_true]\n      apply Nat.floor_le_of_le\n      apply le_of_lt\n      rw [div_lt_iff\u2080 (Real.log_pos hc)]\n      rw [\u2190 Real.log_pow]\n      exact Real.log_lt_log hj hi.2\n    _ = \u2211 i \u2208 Ico \u230aReal.log j / Real.log c\u230b\u208a N, (c\u207b\u00b9 ^ 2) ^ i := by\n      congr 1 with i\n      simp [\u2190 pow_mul, mul_comm]\n    _ \u2264 (c\u207b\u00b9 ^ 2) ^ \u230aReal.log j / Real.log c\u230b\u208a / ((1 : \u211d) - c\u207b\u00b9 ^ 2) :=\n      geom_sum_Ico_le_of_lt_one (sq_nonneg _) C\n    _ \u2264 (c\u207b\u00b9 ^ 2) ^ (Real.log j / Real.log c - 1) / ((1 : \u211d) - c\u207b\u00b9 ^ 2) := by\n      gcongr\n      \u00b7 exact sub_nonneg.2 C.le\n      \u00b7 rw [\u2190 Real.rpow_natCast]\n        exact Real.rpow_le_rpow_of_exponent_ge A C.le (Nat.sub_one_lt_floor _).le\n    _ = c ^ 2 * ((1 : \u211d) - c\u207b\u00b9 ^ 2)\u207b\u00b9 / j ^ 2 := by\n      have I : (c\u207b\u00b9 ^ 2) ^ (Real.log j / Real.log c) = (1 : \u211d) / j ^ 2 := by\n        apply Real.log_injOn_pos (Real.rpow_pos_of_pos A _)\n        \u00b7 rw [Set.mem_Ioi]; positivity\n        rw [Real.log_rpow A]\n        simp only [one_div]\n        simp only [Real.log_inv]\n        simp only [Real.log_pow]\n        simp only [Nat.cast_one]\n        simp only [mul_neg]\n        simp only [neg_inj]\n        field_simp [(Real.log_pos hc).ne']\n        ring\n      rw [Real.rpow_sub A]\n      rw [I]\n      have : c ^ 2 - 1 \u2260 0 := (sub_pos.2 (one_lt_pow\u2080 hc two_ne_zero)).ne'\n      field_simp [hj.ne', (zero_lt_one.trans hc).ne']\n      ring\n    _ \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2 := by gcongr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_pow_le_nat_floor_pow {c : \u211d} (hc : 1 < c) (i : \u2115) : (1 - c\u207b\u00b9) * c ^ i \u2264 \u230ac ^ i\u230b\u208a := by\n  have cpos : 0 < c := zero_lt_one.trans hc\n  rcases eq_or_ne i 0 with (rfl | hi)\n  \u00b7 simp only [pow_zero, Nat.floor_one, Nat.cast_one, mul_one, sub_le_self_iff, inv_nonneg, cpos.le]\n  calc\n    (1 - c\u207b\u00b9) * c ^ i = c ^ i - c ^ i * c\u207b\u00b9 := by ring\n    _ \u2264 c ^ i - 1 := by\n      gcongr\n      simpa only [\u2190 div_eq_mul_inv,one_le_div cpos,pow_one] using le_self_pow\u2080 hc.le hi\n    _ \u2264 \u230ac ^ i\u230b\u208a := (Nat.sub_one_lt_floor _).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/FloorPow.lean", "context": {"open": ["Filter Finset", "Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nhc : 1 < c\ni : \u2115\n\u22a2 (1 - c\u207b\u00b9) * c ^ i \u2264 \u2191\u230ac ^ i\u230b\u208a"}, {"line": "have cpos : 0 < c := zero_lt_one.trans hc", "tactic_state": "c : \u211d\nhc : 1 < c\ni : \u2115\ncpos : 0 < c\n\u22a2 (1 - c\u207b\u00b9) * c ^ i \u2264 \u2191\u230ac ^ i\u230b\u208a"}, {"line": "rcases eq_or_ne i 0 with (rfl | hi)", "tactic_state": "case inl\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\n\u22a2 (1 - c\u207b\u00b9) * c ^ 0 \u2264 \u2191\u230ac ^ 0\u230b\u208a\n---\ncase inr\nc : \u211d\nhc : 1 < c\ni : \u2115\ncpos : 0 < c\nhi : i \u2260 0\n\u22a2 (1 - c\u207b\u00b9) * c ^ i \u2264 \u2191\u230ac ^ i\u230b\u208a"}, {"line": "\u00b7 simp only [pow_zero, Nat.floor_one, Nat.cast_one, mul_one, sub_le_self_iff, inv_nonneg, cpos.le]", "tactic_state": "case inr\nc : \u211d\nhc : 1 < c\ni : \u2115\ncpos : 0 < c\nhi : i \u2260 0\n\u22a2 (1 - c\u207b\u00b9) * c ^ i \u2264 \u2191\u230ac ^ i\u230b\u208a"}, {"line": "calc\n    (1 - c\u207b\u00b9) * c ^ i = c ^ i - c ^ i * c\u207b\u00b9 := by ring\n    _ \u2264 c ^ i - 1 := by\n      gcongr\n      simpa only [\u2190 div_eq_mul_inv,one_le_div cpos,pow_one] using le_self_pow\u2080 hc.le hi\n    _ \u2264 \u230ac ^ i\u230b\u208a := (Nat.sub_one_lt_floor _).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_div_nat_floor_pow_sq_le_div_sq (N : \u2115) {j : \u211d} (hj : 0 < j) {c : \u211d} (hc : 1 < c) :\n    (\u2211 i \u2208 range N with j < \u230ac ^ i\u230b\u208a, (1 : \u211d) / (\u230ac ^ i\u230b\u208a : \u211d) ^ 2) \u2264\n      c ^ 5 * (c - 1)\u207b\u00b9 ^ 3 / j ^ 2 := by\n  have cpos : 0 < c := zero_lt_one.trans hc\n  have A : 0 < 1 - c\u207b\u00b9 := sub_pos.2 (inv_lt_one_of_one_lt\u2080 hc)\n  calc\n    (\u2211 i \u2208 range N with j < \u230ac ^ i\u230b\u208a, (1 : \u211d) / (\u230ac ^ i\u230b\u208a : \u211d) ^ 2) \u2264\n        \u2211 i \u2208 range N with j < c ^ i, (1 : \u211d) / (\u230ac ^ i\u230b\u208a : \u211d) ^ 2 := by\n      gcongr\n      exact fun k hk \u21a6 hk.trans_le <| Nat.floor_le (by positivity)\n    _ \u2264 \u2211 i \u2208 range N with j < c ^ i, (1 - c\u207b\u00b9)\u207b\u00b9 ^ 2 * ((1 : \u211d) / (c ^ i) ^ 2) := by\n      refine sum_le_sum fun i _hi => ?_\n      rw [mul_div_assoc']; rotate_left\n      rw [mul_one]; rotate_left\n      rw [div_le_div_iff\u2080]; rotate_left\n      \u00b7 apply sq_pos_of_pos\n        refine zero_lt_one.trans_le ?_\n        simp only [Nat.le_floor]\n        simp only [one_le_pow\u2080]\n        simp only [hc.le]\n        simp only [Nat.one_le_cast]\n        simp only [Nat.cast_one]\n      \u00b7 exact sq_pos_of_pos (pow_pos cpos _)\n      rw [one_mul]\n      rw [\u2190 mul_pow]\n      gcongr\n      rw [\u2190 div_eq_inv_mul]\n      rw [le_div_iff\u2080 A]\n      rw [mul_comm]\n      exact mul_pow_le_nat_floor_pow hc i\n    _ \u2264 (1 - c\u207b\u00b9)\u207b\u00b9 ^ 2 * (c ^ 3 * (c - 1)\u207b\u00b9) / j ^ 2 := by\n      rw [\u2190 mul_sum]\n      rw [\u2190 mul_div_assoc']\n      gcongr\n      exact sum_div_pow_sq_le_div_sq N hj hc\n    _ = c ^ 5 * (c - 1)\u207b\u00b9 ^ 3 / j ^ 2 := by\n      congr 1\n      field_simp [(sub_pos.2 hc).ne']\n      ring!", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/FloorPow.lean", "context": {"open": ["Filter Finset", "Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\n\u22a2 \u2211 i \u2208 {i \u2208 range N | j < \u2191\u230ac ^ i\u230b\u208a}, 1 / \u2191\u230ac ^ i\u230b\u208a ^ 2 \u2264 c ^ 5 * (c - 1)\u207b\u00b9 ^ 3 / j ^ 2"}, {"line": "have cpos : 0 < c := zero_lt_one.trans hc", "tactic_state": "N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\n\u22a2 \u2211 i \u2208 {i \u2208 range N | j < \u2191\u230ac ^ i\u230b\u208a}, 1 / \u2191\u230ac ^ i\u230b\u208a ^ 2 \u2264 c ^ 5 * (c - 1)\u207b\u00b9 ^ 3 / j ^ 2"}, {"line": "have A : 0 < 1 - c\u207b\u00b9 := sub_pos.2 (inv_lt_one_of_one_lt\u2080 hc)", "tactic_state": "N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < 1 - c\u207b\u00b9\n\u22a2 \u2211 i \u2208 {i \u2208 range N | j < \u2191\u230ac ^ i\u230b\u208a}, 1 / \u2191\u230ac ^ i\u230b\u208a ^ 2 \u2264 c ^ 5 * (c - 1)\u207b\u00b9 ^ 3 / j ^ 2"}, {"line": "calc\n    (\u2211 i \u2208 range N with j < \u230ac ^ i\u230b\u208a, (1 : \u211d) / (\u230ac ^ i\u230b\u208a : \u211d) ^ 2) \u2264\n        \u2211 i \u2208 range N with j < c ^ i, (1 : \u211d) / (\u230ac ^ i\u230b\u208a : \u211d) ^ 2 := by\n      gcongr\n      exact fun k hk \u21a6 hk.trans_le <| Nat.floor_le (by positivity)\n    _ \u2264 \u2211 i \u2208 range N with j < c ^ i, (1 - c\u207b\u00b9)\u207b\u00b9 ^ 2 * ((1 : \u211d) / (c ^ i) ^ 2) := by\n      refine sum_le_sum fun i _hi => ?_\n      rw [mul_div_assoc']; rotate_left\n      rw [mul_one]; rotate_left\n      rw [div_le_div_iff\u2080]; rotate_left\n      \u00b7 apply sq_pos_of_pos\n        refine zero_lt_one.trans_le ?_\n        simp only [Nat.le_floor]\n        simp only [one_le_pow\u2080]\n        simp only [hc.le]\n        simp only [Nat.one_le_cast]\n        simp only [Nat.cast_one]\n      \u00b7 exact sq_pos_of_pos (pow_pos cpos _)\n      rw [one_mul]\n      rw [\u2190 mul_pow]\n      gcongr\n      rw [\u2190 div_eq_inv_mul]\n      rw [le_div_iff\u2080 A]\n      rw [mul_comm]\n      exact mul_pow_le_nat_floor_pow hc i\n    _ \u2264 (1 - c\u207b\u00b9)\u207b\u00b9 ^ 2 * (c ^ 3 * (c - 1)\u207b\u00b9) / j ^ 2 := by\n      rw [\u2190 mul_sum]\n      rw [\u2190 mul_div_assoc']\n      gcongr\n      exact sum_div_pow_sq_le_div_sq N hj hc\n    _ = c ^ 5 * (c - 1)\u207b\u00b9 ^ 3 / j ^ 2 := by\n      congr 1\n      field_simp [(sub_pos.2 hc).ne']\n      ring!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_pow_pow_of_abs_lt_left {r\u2081 r\u2082 : \u211d} (h : |r\u2081| < |r\u2082|) :\n    (fun n : \u2115 \u21a6 r\u2081 ^ n) =o[atTop] fun n \u21a6 r\u2082 ^ n := by\n  refine (IsLittleO.of_norm_left ?_).of_norm_right\n  exact (isLittleO_pow_pow_of_lt_left (abs_nonneg r\u2081) h).congr (pow_abs r\u2081) (pow_abs r\u2082)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r\u2081 r\u2082 : \u211d\nh : |r\u2081| < |r\u2082|\n\u22a2 (fun n => r\u2081 ^ n) =o[atTop] fun n => r\u2082 ^ n"}, {"line": "refine (IsLittleO.of_norm_left ?_).of_norm_right", "tactic_state": "r\u2081 r\u2082 : \u211d\nh : |r\u2081| < |r\u2082|\n\u22a2 (fun x => \u2016r\u2081 ^ x\u2016) =o[atTop] fun x => \u2016r\u2082 ^ x\u2016"}, {"line": "exact (isLittleO_pow_pow_of_lt_left (abs_nonneg r\u2081) h).congr (pow_abs r\u2081) (pow_abs r\u2082)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_coe_const_pow_of_one_lt {R : Type*} [NormedRing R] {r : \u211d} (hr : 1 < r) :\n    ((\u2191) : \u2115 \u2192 R) =o[atTop] fun n \u21a6 r ^ n := by\n  simpa only [pow_one] using @isLittleO_pow_const_const_pow_of_one_lt R _ 1 _ hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NormedRing R\nr : \u211d\nhr : 1 < r\n\u22a2 Nat.cast =o[atTop] fun n => r ^ n"}, {"line": "simpa only [pow_one] using @isLittleO_pow_const_const_pow_of_one_lt R _ 1 _ hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : \u2115) {r : \u211d} (hr : |r| < 1) :\n    Tendsto (fun n \u21a6 (n : \u211d) ^ k * r ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0) := by\n  by_cases h0 : r = 0\n  \u00b7 exact tendsto_const_nhds.congr'\n      (mem_atTop_sets.2 \u27e81, fun n hn \u21a6 by simp [zero_lt_one.trans_le hn |>.ne', h0]\u27e9)\n  have hr' : 1 < |r|\u207b\u00b9 := (one_lt_inv\u2080 (abs_pos.2 h0)).2 hr\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\nr : \u211d\nhr : |r| < 1\n\u22a2 Tendsto (fun n => \u2191n ^ k * r ^ n) atTop (nhds 0)"}, {"line": "by_cases h0 : r = 0", "tactic_state": "case pos\nk : \u2115\nr : \u211d\nhr : |r| < 1\nh0 : r = 0\n\u22a2 Tendsto (fun n => \u2191n ^ k * r ^ n) atTop (nhds 0)\n---\ncase neg\nk : \u2115\nr : \u211d\nhr : |r| < 1\nh0 : \u00acr = 0\n\u22a2 Tendsto (fun n => \u2191n ^ k * r ^ n) atTop (nhds 0)"}, {"line": "\u00b7 exact tendsto_const_nhds.congr'\n      (mem_atTop_sets.2 \u27e81, fun n hn \u21a6 by simp [zero_lt_one.trans_le hn |>.ne', h0]\u27e9)", "tactic_state": "case neg\nk : \u2115\nr : \u211d\nhr : |r| < 1\nh0 : \u00acr = 0\n\u22a2 Tendsto (fun n => \u2191n ^ k * r ^ n) atTop (nhds 0)"}, {"line": "have hr' : 1 < |r|\u207b\u00b9 := (one_lt_inv\u2080 (abs_pos.2 h0)).2 hr", "tactic_state": "case neg\nk : \u2115\nr : \u211d\nhr : |r| < 1\nh0 : \u00acr = 0\nhr' : 1 < |r|\u207b\u00b9\n\u22a2 Tendsto (fun n => \u2191n ^ k * r ^ n) atTop (nhds 0)"}, {"line": "rw [tendsto_zero_iff_norm_tendsto_zero]", "tactic_state": "case neg\nk : \u2115\nr : \u211d\nhr : |r| < 1\nh0 : \u00acr = 0\nhr' : 1 < |r|\u207b\u00b9\n\u22a2 Tendsto (fun x => \u2016\u2191x ^ k * r ^ x\u2016) atTop (nhds 0)"}, {"line": "simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_const_div_pow (r : \u211d) (k : \u2115) (hk : k \u2260 0) :\n    Tendsto (fun n : \u2115 => r / n ^ k) atTop (\ud835\udcdd 0) := by\n  simpa using Filter.Tendsto.const_div_atTop (tendsto_natCast_atTop_atTop (R := \u211d).comp\n    (tendsto_pow_atTop hk) ) r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nk : \u2115\nhk : k \u2260 0\n\u22a2 Tendsto (fun n => r / \u2191n ^ k) atTop (nhds 0)"}, {"line": "simpa using Filter.Tendsto.const_div_atTop (tendsto_natCast_atTop_atTop (R := \u211d).comp\n    (tendsto_pow_atTop hk) ) r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_self_mul_const_pow_of_abs_lt_one {r : \u211d} (hr : |r| < 1) :\n    Tendsto (fun n \u21a6 n * r ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0) := by\n  simpa only [pow_one] using tendsto_pow_const_mul_const_pow_of_abs_lt_one 1 hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nhr : |r| < 1\n\u22a2 Tendsto (fun n => \u2191n * r ^ n) atTop (nhds 0)"}, {"line": "simpa only [pow_one] using tendsto_pow_const_mul_const_pow_of_abs_lt_one 1 hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_self_mul_const_pow_of_lt_one {r : \u211d} (hr : 0 \u2264 r) (h'r : r < 1) :\n    Tendsto (fun n \u21a6 n * r ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0) := by\n  simpa only [pow_one] using tendsto_pow_const_mul_const_pow_of_lt_one 1 hr h'r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nhr : 0 \u2264 r\nh'r : r < 1\n\u22a2 Tendsto (fun n => \u2191n * r ^ n) atTop (nhds 0)"}, {"line": "simpa only [pow_one] using tendsto_pow_const_mul_const_pow_of_lt_one 1 hr h'r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasSum_geom_series_inverse (x : R) (h : \u2016x\u2016 < 1) :\n    HasSum (fun i \u21a6 x ^ i) (Ring.inverse (1 - x)) := by\n  convert (summable_geometric_of_norm_lt_one h).hasSum\n  exact (geom_series_eq_inverse x h).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nx : R\nh : \u2016x\u2016 < 1\n\u22a2 HasSum (fun i => x ^ i) (Ring.inverse (1 - x))"}, {"line": "convert (summable_geometric_of_norm_lt_one h).hasSum", "tactic_state": "case h.e'_6\nR : Type u_2\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nx : R\nh : \u2016x\u2016 < 1\n\u22a2 Ring.inverse (1 - x) = \u2211' (b : \u2115), x ^ b\n---\nR : Type u_2\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nx : R\nh : \u2016x\u2016 < 1\n\u22a2 HasSummableGeomSeries R"}, {"line": "exact (geom_series_eq_inverse x h).symm", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nx : R\nh : \u2016x\u2016 < 1\n\u22a2 HasSummableGeomSeries R"}]}
{"declaration": "theorem summable_norm_pow_mul_geometric_of_norm_lt_one (k : \u2115) {r : R}\n    (hr : \u2016r\u2016 < 1) : Summable fun n : \u2115 \u21a6 \u2016((n : R) ^ k * r ^ n : R)\u2016 := by\n  simp only [\u2190 cast_pow]\n  exact summable_norm_mul_geometric_of_norm_lt_one (k := k) (u := fun n \u21a6 n ^ k) hr\n    (isBigO_refl _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d : NormedRing R\nk : \u2115\nr : R\nhr : \u2016r\u2016 < 1\n\u22a2 Summable fun n => \u2016\u2191n ^ k * r ^ n\u2016"}, {"line": "simp only [\u2190 cast_pow]", "tactic_state": "R : Type u_4\ninst\u271d : NormedRing R\nk : \u2115\nr : R\nhr : \u2016r\u2016 < 1\n\u22a2 Summable fun n => \u2016\u2191(n ^ k) * r ^ n\u2016"}, {"line": "exact summable_norm_mul_geometric_of_norm_lt_one (k := k) (u := fun n \u21a6 n ^ k) hr\n    (isBigO_refl _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_norm_geometric_of_norm_lt_one {r : R}\n    (hr : \u2016r\u2016 < 1) : Summable fun n : \u2115 \u21a6 \u2016(r ^ n : R)\u2016 := by\n  simpa using summable_norm_pow_mul_geometric_of_norm_lt_one 0 hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d : NormedRing R\nr : R\nhr : \u2016r\u2016 < 1\n\u22a2 Summable fun n => \u2016r ^ n\u2016"}, {"line": "simpa using summable_norm_pow_mul_geometric_of_norm_lt_one 0 hr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma summable_descFactorial_mul_geometric_of_norm_lt_one (k : \u2115) {r : R} (hr : \u2016r\u2016 < 1) :\n    Summable (fun n \u21a6 (n + k).descFactorial k * r ^ n) := by\n  convert (summable_choose_mul_geometric_of_norm_lt_one k hr).mul_left (k.factorial : R)\n    using 2 with n\n  simp [\u2190 mul_assoc, descFactorial_eq_factorial_mul_choose (n + k) k]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nk : \u2115\nr : R\nhr : \u2016r\u2016 < 1\n\u22a2 Summable fun n => \u2191((n + k).descFactorial k) * r ^ n"}, {"line": "convert (summable_choose_mul_geometric_of_norm_lt_one k hr).mul_left (k.factorial : R)\n    using 2 with n", "tactic_state": "case h.e'_5.h\nR : Type u_4\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nk : \u2115\nr : R\nhr : \u2016r\u2016 < 1\nn : \u2115\n\u22a2 \u2191((n + k).descFactorial k) * r ^ n = sorry * (\u2191((n + k).choose k) * r ^ n)\n---\ncase convert_1\nR : Type u_4\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nk : \u2115\nr : R\nhr : \u2016r\u2016 < 1\n\u22a2 HasSummableGeomSeries R\n---\ncase convert_2\nR : Type u_4\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nk : \u2115\nr : R\nhr : \u2016r\u2016 < 1\n\u22a2 IsTopologicalSemiring R"}, {"line": "simp [\u2190 mul_assoc, descFactorial_eq_factorial_mul_choose (n + k) k]", "tactic_state": "case h.e'_5.h\nR : Type u_4\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nk : \u2115\nr : R\nhr : \u2016r\u2016 < 1\nn : \u2115\n\u22a2 \u2191(k.factorial * (n + k).choose k) * r ^ n = sorry () * (\u2191((n + k).choose k) * r ^ n)\n---\ncase convert_1\nR : Type u_4\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nk : \u2115\nr : R\nhr : \u2016r\u2016 < 1\n\u22a2 HasSummableGeomSeries R\n---\ncase convert_2\nR : Type u_4\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nk : \u2115\nr : R\nhr : \u2016r\u2016 < 1\n\u22a2 IsTopologicalSemiring R"}]}
{"declaration": "theorem dist_partial_sum (u : \u2115 \u2192 \u03b1) (n : \u2115) :\n    dist (\u2211 k \u2208 range (n + 1), u k) (\u2211 k \u2208 range n, u k) = \u2016u n\u2016 := by\n  simp [dist_eq_norm, sum_range_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : SeminormedAddCommGroup \u03b1\nu : \u2115 \u2192 \u03b1\nn : \u2115\n\u22a2 Dist.dist (\u2211 k \u2208 Finset.range (n + 1), u k) (\u2211 k \u2208 Finset.range n, u k) = \u2016u n\u2016"}, {"line": "simp [dist_eq_norm, sum_range_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_partial_sum' (u : \u2115 \u2192 \u03b1) (n : \u2115) :\n    dist (\u2211 k \u2208 range n, u k) (\u2211 k \u2208 range (n + 1), u k) = \u2016u n\u2016 := by\n  simp [dist_eq_norm', sum_range_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : SeminormedAddCommGroup \u03b1\nu : \u2115 \u2192 \u03b1\nn : \u2115\n\u22a2 Dist.dist (\u2211 k \u2208 Finset.range n, u k) (\u2211 k \u2208 Finset.range (n + 1), u k) = \u2016u n\u2016"}, {"line": "simp [dist_eq_norm', sum_range_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_norm_le_of_cauchySeq (h : CauchySeq fun n \u21a6 \u2211 k \u2208 range n, f k) :\n    \u2203 C, \u2200 n, \u2016f n\u2016 \u2264 C := by\n  obtain \u27e8b, \u27e8_, key, _\u27e9\u27e9 := cauchySeq_iff_le_tendsto_0.mp h\n  refine \u27e8b 0, fun n \u21a6 ?_\u27e9\n  simpa only [dist_partial_sum'] using key n (n + 1) 0 (_root_.zero_le _) (_root_.zero_le _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : SeminormedAddCommGroup \u03b1\nf : \u2115 \u2192 \u03b1\nh : CauchySeq fun n => \u2211 k \u2208 Finset.range n, f k\n\u22a2 \u2203 C, \u2200 (n : \u2115), \u2016f n\u2016 \u2264 C"}, {"line": "obtain \u27e8b, \u27e8_, key, _\u27e9\u27e9 := cauchySeq_iff_le_tendsto_0.mp h", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_5\ninst\u271d : SeminormedAddCommGroup \u03b1\nf : \u2115 \u2192 \u03b1\nh : CauchySeq fun n => \u2211 k \u2208 Finset.range n, f k\nb : \u2115 \u2192 \u211d\nleft\u271d : \u2200 (n : \u2115), 0 \u2264 b n\nkey : \u2200 (n m N : \u2115), N \u2264 n \u2192 N \u2264 m \u2192 Dist.dist (\u2211 k \u2208 Finset.range n, f k) (\u2211 k \u2208 Finset.range m, f k) \u2264 b N\nright\u271d : Tendsto b atTop (nhds 0)\n\u22a2 \u2203 C, \u2200 (n : \u2115), \u2016f n\u2016 \u2264 C"}, {"line": "refine \u27e8b 0, fun n \u21a6 ?_\u27e9", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_5\ninst\u271d : SeminormedAddCommGroup \u03b1\nf : \u2115 \u2192 \u03b1\nh : CauchySeq fun n => \u2211 k \u2208 Finset.range n, f k\nb : \u2115 \u2192 \u211d\nleft\u271d : \u2200 (n : \u2115), 0 \u2264 b n\nkey : \u2200 (n m N : \u2115), N \u2264 n \u2192 N \u2264 m \u2192 Dist.dist (\u2211 k \u2208 Finset.range n, f k) (\u2211 k \u2208 Finset.range m, f k) \u2264 b N\nright\u271d : Tendsto b atTop (nhds 0)\nn : \u2115\n\u22a2 \u2016f n\u2016 \u2264 b 0"}, {"line": "simpa only [dist_partial_sum'] using key n (n + 1) 0 (_root_.zero_le _) (_root_.zero_le _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_sum_neg_one_pow_le (n : \u2115) : \u2016\u2211 i \u2208 range n, (-1 : \u211d) ^ i\u2016 \u2264 1 := by\n  rw [neg_one_geom_sum]\n  split_ifs <;> norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2016\u2211 i \u2208 Finset.range n, (-1) ^ i\u2016 \u2264 1"}, {"line": "rw [neg_one_geom_sum]", "tactic_state": "n : \u2115\n\u22a2 \u2016if Even n then 0 else 1\u2016 \u2264 1"}, {"line": "split_ifs <;> norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monotone.cauchySeq_alternating_series_of_tendsto_zero (hfa : Monotone f)\n    (hf0 : Tendsto f atTop (\ud835\udcdd 0)) : CauchySeq fun n \u21a6 \u2211 i \u2208 range n, (-1) ^ i * f i := by\n  simp_rw [mul_comm]\n  exact hfa.cauchySeq_series_mul_of_tendsto_zero_of_bounded hf0 norm_sum_neg_one_pow_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nhfa : Monotone f\nhf0 : Tendsto f atTop (nhds 0)\n\u22a2 CauchySeq fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i"}, {"line": "simp_rw [mul_comm]", "tactic_state": "f : \u2115 \u2192 \u211d\nhfa : Monotone f\nhf0 : Tendsto f atTop (nhds 0)\n\u22a2 CauchySeq fun n => \u2211 x \u2208 Finset.range n, f x * (-1) ^ x"}, {"line": "exact hfa.cauchySeq_series_mul_of_tendsto_zero_of_bounded hf0 norm_sum_neg_one_pow_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antitone.cauchySeq_alternating_series_of_tendsto_zero (hfa : Antitone f)\n    (hf0 : Tendsto f atTop (\ud835\udcdd 0)) : CauchySeq fun n \u21a6 \u2211 i \u2208 range n, (-1) ^ i * f i := by\n  simp_rw [mul_comm]\n  exact hfa.cauchySeq_series_mul_of_tendsto_zero_of_bounded hf0 norm_sum_neg_one_pow_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nhfa : Antitone f\nhf0 : Tendsto f atTop (nhds 0)\n\u22a2 CauchySeq fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i"}, {"line": "simp_rw [mul_comm]", "tactic_state": "f : \u2115 \u2192 \u211d\nhfa : Antitone f\nhf0 : Tendsto f atTop (nhds 0)\n\u22a2 CauchySeq fun n => \u2211 x \u2208 Finset.range n, f x * (-1) ^ x"}, {"line": "exact hfa.cauchySeq_series_mul_of_tendsto_zero_of_bounded hf0 norm_sum_neg_one_pow_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monotone.tendsto_le_alternating_series\n    (hfl : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, (-1) ^ i * f i) atTop (\ud835\udcdd l))\n    (hfm : Monotone f) (k : \u2115) : l \u2264 \u2211 i \u2208 range (2 * k), (-1) ^ i * f i := by\n  have ha : Antitone (fun n \u21a6 \u2211 i \u2208 range (2 * n), (-1) ^ i * f i) := by\n    refine antitone_nat_of_succ_le (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ]\n    rw [sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, one_mul,\n      \u2190 sub_eq_add_neg, sub_le_iff_le_add]\n    gcongr\n    exact hfm (by omega)\n  exact ha.le_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n \u21a6 by dsimp; omega) tendsto_id)) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nl : \u211d\nhfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)\nhfm : Monotone f\nk : \u2115\n\u22a2 l \u2264 \u2211 i \u2208 Finset.range (2 * k), (-1) ^ i * f i"}, {"line": "have ha : Antitone (fun n \u21a6 \u2211 i \u2208 range (2 * n), (-1) ^ i * f i) := sorry", "tactic_state": "f : \u2115 \u2192 \u211d\nl : \u211d\nhfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)\nhfm : Monotone f\nk : \u2115\nha : Antitone fun n => \u2211 i \u2208 Finset.range (2 * n), (-1) ^ i * f i\n\u22a2 l \u2264 \u2211 i \u2208 Finset.range (2 * k), (-1) ^ i * f i"}, {"line": "exact ha.le_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n \u21a6 by dsimp; omega) tendsto_id)) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monotone.alternating_series_le_tendsto\n    (hfl : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, (-1) ^ i * f i) atTop (\ud835\udcdd l))\n    (hfm : Monotone f) (k : \u2115) : \u2211 i \u2208 range (2 * k + 1), (-1) ^ i * f i \u2264 l := by\n  have hm : Monotone (fun n \u21a6 \u2211 i \u2208 range (2 * n + 1), (-1) ^ i * f i) := by\n    refine monotone_nat_of_le_succ (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ _ (2 * n + 1 + 1)]\n    rw [sum_range_succ _ (2 * n + 1)]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, neg_neg, one_mul,\n      \u2190 sub_eq_add_neg, sub_add_eq_add_sub, le_sub_iff_add_le]\n    gcongr\n    exact hfm (by omega)\n  exact hm.ge_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n \u21a6 by dsimp; omega) tendsto_id)) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nl : \u211d\nhfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)\nhfm : Monotone f\nk : \u2115\n\u22a2 \u2211 i \u2208 Finset.range (2 * k + 1), (-1) ^ i * f i \u2264 l"}, {"line": "have hm : Monotone (fun n \u21a6 \u2211 i \u2208 range (2 * n + 1), (-1) ^ i * f i) := sorry", "tactic_state": "f : \u2115 \u2192 \u211d\nl : \u211d\nhfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)\nhfm : Monotone f\nk : \u2115\nhm : Monotone fun n => \u2211 i \u2208 Finset.range (2 * n + 1), (-1) ^ i * f i\n\u22a2 \u2211 i \u2208 Finset.range (2 * k + 1), (-1) ^ i * f i \u2264 l"}, {"line": "exact hm.ge_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n \u21a6 by dsimp; omega) tendsto_id)) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antitone.alternating_series_le_tendsto\n    (hfl : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, (-1) ^ i * f i) atTop (\ud835\udcdd l))\n    (hfa : Antitone f) (k : \u2115) : \u2211 i \u2208 range (2 * k), (-1) ^ i * f i \u2264 l := by\n  have hm : Monotone (fun n \u21a6 \u2211 i \u2208 range (2 * n), (-1) ^ i * f i) := by\n    refine monotone_nat_of_le_succ (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ]\n    rw [sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, one_mul,\n      \u2190 sub_eq_add_neg, le_sub_iff_add_le]\n    gcongr\n    exact hfa (by omega)\n  exact hm.ge_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n \u21a6 by dsimp; omega) tendsto_id)) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nl : \u211d\nhfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)\nhfa : Antitone f\nk : \u2115\n\u22a2 \u2211 i \u2208 Finset.range (2 * k), (-1) ^ i * f i \u2264 l"}, {"line": "have hm : Monotone (fun n \u21a6 \u2211 i \u2208 range (2 * n), (-1) ^ i * f i) := sorry", "tactic_state": "f : \u2115 \u2192 \u211d\nl : \u211d\nhfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)\nhfa : Antitone f\nk : \u2115\nhm : Monotone fun n => \u2211 i \u2208 Finset.range (2 * n), (-1) ^ i * f i\n\u22a2 \u2211 i \u2208 Finset.range (2 * k), (-1) ^ i * f i \u2264 l"}, {"line": "exact hm.ge_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n \u21a6 by dsimp; omega) tendsto_id)) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antitone.tendsto_le_alternating_series\n    (hfl : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, (-1) ^ i * f i) atTop (\ud835\udcdd l))\n    (hfa : Antitone f) (k : \u2115) : l \u2264 \u2211 i \u2208 range (2 * k + 1), (-1) ^ i * f i := by\n  have ha : Antitone (fun n \u21a6 \u2211 i \u2208 range (2 * n + 1), (-1) ^ i * f i) := by\n    refine antitone_nat_of_succ_le (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ]\n    rw [sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, neg_neg, one_mul,\n      \u2190 sub_eq_add_neg, sub_add_eq_add_sub, sub_le_iff_le_add]\n    gcongr\n    exact hfa (by omega)\n  exact ha.le_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n \u21a6 by dsimp; omega) tendsto_id)) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/Normed.lean", "context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nl : \u211d\nhfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)\nhfa : Antitone f\nk : \u2115\n\u22a2 l \u2264 \u2211 i \u2208 Finset.range (2 * k + 1), (-1) ^ i * f i"}, {"line": "have ha : Antitone (fun n \u21a6 \u2211 i \u2208 range (2 * n + 1), (-1) ^ i * f i) := sorry", "tactic_state": "f : \u2115 \u2192 \u211d\nl : \u211d\nhfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)\nhfa : Antitone f\nk : \u2115\nha : Antitone fun n => \u2211 i \u2208 Finset.range (2 * n + 1), (-1) ^ i * f i\n\u22a2 l \u2264 \u2211 i \u2208 Finset.range (2 * k + 1), (-1) ^ i * f i"}, {"line": "exact ha.le_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n \u21a6 by dsimp; omega) tendsto_id)) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem RCLike.tendsto_inverse_atTop_nhds_zero_nat :\n    Tendsto (fun n : \u2115 => (n : \ud835\udd5c)\u207b\u00b9) atTop (\ud835\udcdd 0) := by\n  convert tendsto_algebraMap_inverse_atTop_nhds_zero_nat \ud835\udd5c\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/RCLike.lean", "context": {"open": ["Set Algebra Filter", "scoped Topology"], "variables": ["(\ud835\udd5c : Type*) [RCLike \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\n\u22a2 Tendsto (fun n => (\u2191n)\u207b\u00b9) atTop (nhds 0)"}, {"line": "convert tendsto_algebraMap_inverse_atTop_nhds_zero_nat \ud835\udd5c", "tactic_state": "case h.e'_3.h\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\nx\u271d : \u2115\n\u22a2 (\u2191x\u271d)\u207b\u00b9 = (\u21d1(algebraMap \u211d \ud835\udd5c) \u2218 fun n => (\u2191n)\u207b\u00b9) x\u271d\n---\ncase convert_2\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\n\u22a2 Algebra \u211d \ud835\udd5c\n---\ncase convert_4\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\n\u22a2 ContinuousSMul \u211d \ud835\udd5c"}, {"line": "simp", "tactic_state": "case h.e'_3.h\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\nx\u271d : \u2115\n\u22a2 (\u2191x\u271d)\u207b\u00b9 = (algebraMap \u211d \ud835\udd5c) (\u2191x\u271d)\u207b\u00b9\n---\ncase convert_2\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\n\u22a2 Algebra \u211d \ud835\udd5c\n---\ncase convert_4\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\n\u22a2 ContinuousSMul \u211d \ud835\udd5c"}]}
{"declaration": "theorem RCLike.tendsto_add_mul_div_add_mul_atTop_nhds (a b c : \ud835\udd5c) {d : \ud835\udd5c} (hd : d \u2260 0) :\n    Tendsto (fun k : \u2115 \u21a6 (a + c * k) / (b + d * k)) atTop (\ud835\udcdd (c / d)) := by\n  apply Filter.Tendsto.congr'\n  case f\u2081 => exact fun k \u21a6 (a * (\u2191k)\u207b\u00b9 + c) / (b * (\u2191k)\u207b\u00b9 + d)\n  \u00b7 refine (eventually_ne_atTop 0).mp (Eventually.of_forall ?_)\n    intro h hx\n    field_simp [hx]\n  \u00b7 apply Filter.Tendsto.div _ _ hd\n    all_goals\n      apply zero_add (_ : \ud835\udd5c) \u25b8 Filter.Tendsto.add_const _ _\n      apply mul_zero (_ : \ud835\udd5c) \u25b8 Filter.Tendsto.const_mul _ _\n      exact RCLike.tendsto_inverse_atTop_nhds_zero_nat \ud835\udd5c", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecificLimits/RCLike.lean", "context": {"open": ["Set Algebra Filter", "scoped Topology"], "variables": ["(\ud835\udd5c : Type*) [RCLike \ud835\udd5c]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\na b c d : \ud835\udd5c\nhd : d \u2260 0\n\u22a2 Tendsto (fun k => (a + c * \u2191k) / (b + d * \u2191k)) atTop (nhds (c / d))"}, {"line": "apply Filter.Tendsto.congr'", "tactic_state": "case hl\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\na b c d : \ud835\udd5c\nhd : d \u2260 0\n\u22a2 ?f\u2081 =\u1da0[atTop] fun k => (a + c * \u2191k) / (b + d * \u2191k)\n---\ncase h\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\na b c d : \ud835\udd5c\nhd : d \u2260 0\n\u22a2 Tendsto ?f\u2081 atTop (nhds (c / d))\n---\ncase f\u2081\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\na b c d : \ud835\udd5c\nhd : d \u2260 0\n\u22a2 \u2115 \u2192 \ud835\udd5c"}, {"line": "case f\u2081 => exact fun k \u21a6 (a * (\u2191k)\u207b\u00b9 + c) / (b * (\u2191k)\u207b\u00b9 + d)", "tactic_state": "case hl\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\na b c d : \ud835\udd5c\nhd : d \u2260 0\n\u22a2 sorry =\u1da0[atTop] fun k => (a + c * \u2191k) / (b + d * \u2191k)\n---\ncase h\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\na b c d : \ud835\udd5c\nhd : d \u2260 0\n\u22a2 Tendsto sorry atTop (nhds (c / d))"}, {"line": "\u00b7 refine (eventually_ne_atTop 0).mp (Eventually.of_forall ?_)\n    intro h hx\n    field_simp [hx]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\na b c d : \ud835\udd5c\nhd : d \u2260 0\n\u22a2 Tendsto sorry atTop (nhds (c / d))"}, {"line": "\u00b7 apply Filter.Tendsto.div _ _ hd\n    all_goals\n      apply zero_add (_ : \ud835\udd5c) \u25b8 Filter.Tendsto.add_const _ _\n      apply mul_zero (_ : \ud835\udd5c) \u25b8 Filter.Tendsto.const_mul _ _\n      exact RCLike.tendsto_inverse_atTop_nhds_zero_nat \ud835\udd5c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_commutant (S : VonNeumannAlgebra H) :\n    \u2191S.commutant = Set.centralizer (S : Set (H \u2192L[\u2102] H)) := by\n  simp [commutant]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/VonNeumannAlgebra/Basic.lean", "context": {"open": [], "variables": ["{H : Type u} [NormedAddCommGroup H] [InnerProductSpace \u2102 H] [CompleteSpace H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u\ninst\u271d\u00b2 : NormedAddCommGroup H\ninst\u271d\u00b9 : InnerProductSpace \u2102 H\ninst\u271d : CompleteSpace H\nS : VonNeumannAlgebra H\n\u22a2 \u2191S.commutant = (\u2191S).centralizer"}, {"line": "simp [commutant]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem id_hom (X : C) : Iso.hom (coreCategory.id X) = @CategoryStruct.id C _ X := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Core.lean", "context": {"open": [], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_1\nX : C\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_sections_of_finite_inverse_system {J : Type u} [Preorder J] [IsDirected J (\u00b7 \u2264 \u00b7)]\n    (F : J\u1d52\u1d56 \u2964 Type v) [\u2200 j : J\u1d52\u1d56, Finite (F.obj j)] [\u2200 j : J\u1d52\u1d56, Nonempty (F.obj j)] :\n    F.sections.Nonempty := by\n  cases isEmpty_or_nonempty J\n  \u00b7 haveI : IsEmpty J\u1d52\u1d56 := \u27e8fun j => isEmptyElim j.unop\u27e9 -- TODO: this should be a global instance\n    exact \u27e8isEmptyElim, by apply isEmptyElim\u27e9\n  \u00b7 exact nonempty_sections_of_finite_cofiltered_system _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/CofilteredSystem.lean", "context": {"open": ["CategoryTheory CategoryTheory.IsCofiltered Set CategoryTheory.FunctorToTypes"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u\ninst\u271d\u00b3 : Preorder J\ninst\u271d\u00b2 : IsDirected J fun x1 x2 => x1 \u2264 x2\nF : CategoryTheory.Functor J\u1d52\u1d56 (Type v)\ninst\u271d\u00b9 : \u2200 (j : J\u1d52\u1d56), Finite (F.obj j)\ninst\u271d : \u2200 (j : J\u1d52\u1d56), Nonempty (F.obj j)\n\u22a2 F.sections.Nonempty"}, {"line": "cases isEmpty_or_nonempty J", "tactic_state": "case inl\nJ : Type u\ninst\u271d\u00b3 : Preorder J\ninst\u271d\u00b2 : IsDirected J fun x1 x2 => x1 \u2264 x2\nF : CategoryTheory.Functor J\u1d52\u1d56 (Type v)\ninst\u271d\u00b9 : \u2200 (j : J\u1d52\u1d56), Finite (F.obj j)\ninst\u271d : \u2200 (j : J\u1d52\u1d56), Nonempty (F.obj j)\nh\u271d : IsEmpty J\n\u22a2 F.sections.Nonempty\n---\ncase inr\nJ : Type u\ninst\u271d\u00b3 : Preorder J\ninst\u271d\u00b2 : IsDirected J fun x1 x2 => x1 \u2264 x2\nF : CategoryTheory.Functor J\u1d52\u1d56 (Type v)\ninst\u271d\u00b9 : \u2200 (j : J\u1d52\u1d56), Finite (F.obj j)\ninst\u271d : \u2200 (j : J\u1d52\u1d56), Nonempty (F.obj j)\nh\u271d : Nonempty J\n\u22a2 F.sections.Nonempty"}, {"line": "\u00b7 haveI : IsEmpty J\u1d52\u1d56 := \u27e8fun j => isEmptyElim j.unop\u27e9 -- TODO: this should be a global instance\n    exact \u27e8isEmptyElim, by apply isEmptyElim\u27e9", "tactic_state": "case inr\nJ : Type u\ninst\u271d\u00b3 : Preorder J\ninst\u271d\u00b2 : IsDirected J fun x1 x2 => x1 \u2264 x2\nF : CategoryTheory.Functor J\u1d52\u1d56 (Type v)\ninst\u271d\u00b9 : \u2200 (j : J\u1d52\u1d56), Finite (F.obj j)\ninst\u271d : \u2200 (j : J\u1d52\u1d56), Nonempty (F.obj j)\nh\u271d : Nonempty J\n\u22a2 F.sections.Nonempty"}, {"line": "\u00b7 exact nonempty_sections_of_finite_cofiltered_system _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iff : HasLift sq \u2194 Nonempty sq.LiftStruct := by\n  constructor\n  exacts [fun h => h.exists_lift, fun h => mk h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/CommSq.lean", "context": {"open": [], "variables": ["{C : Type*} [Category C]", "{W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "{W X Y : C}", "{D : Type*} [Category D]", "(F : C \u2964 D) {W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "{A B X Y : C} {f : A \u27f6 X} {i : A \u27f6 B} {p : X \u27f6 Y} {g : B \u27f6 Y}", "(sq : CommSq f i p g)", "{sq} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type ?u.18757\nCommSq : ?m.18746\nW\u271d X\u271d\u00b9 Y\u271d\u00b9 Z : C\nf\u271d : sorry\ng\u271d : sorry\nh : sorry\ni\u271d : sorry\nW X\u271d Y\u271d F A B X Y : C\nf : sorry\ni : sorry\np : sorry\ng : sorry\nsq : sorry\nx\u271d : Sort u_1\nHasLift : x\u271d\n\u22a2 sorry \u2194 Nonempty sorry"}, {"line": "constructor", "tactic_state": "case mp\nC : Type ?u.18757\nCommSq : ?m.18746\nW\u271d X\u271d\u00b9 Y\u271d\u00b9 Z : C\nf\u271d : sorry\ng\u271d : sorry\nh : sorry\ni\u271d : sorry\nW X\u271d Y\u271d F A B X Y : C\nf : sorry\ni : sorry\np : sorry\ng : sorry\nsq : sorry\nx\u271d : Sort u_1\nHasLift : x\u271d\n\u22a2 sorry \u2192 Nonempty sorry\n---\ncase mpr\nC : Type ?u.18757\nCommSq : ?m.18746\nW\u271d X\u271d\u00b9 Y\u271d\u00b9 Z : C\nf\u271d : sorry\ng\u271d : sorry\nh : sorry\ni\u271d : sorry\nW X\u271d Y\u271d F A B X Y : C\nf : sorry\ni : sorry\np : sorry\ng : sorry\nsq : sorry\nx\u271d : Sort u_1\nHasLift : x\u271d\n\u22a2 Nonempty sorry \u2192 sorry"}, {"line": "exacts [fun h => h.exists_lift, fun h => mk h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqToHom_op {X Y : C} (h : X = Y) : (eqToHom h).op = eqToHom (congr_arg op h.symm) := by\n  cases h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/EqToHom.lean", "context": {"open": ["Opposite"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{\u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_2\nx\u271d : Sort u_3\neqToHom : x\u271d\nX Y : C\nh : X = Y\n\u22a2 sorry = sorry"}, {"line": "cases h", "tactic_state": "case refl\nC : Sort u_2\nx\u271d : Sort u_3\neqToHom : x\u271d\nX : C\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqToHom_unop {X Y : C\u1d52\u1d56} (h : X = Y) :\n    (eqToHom h).unop = eqToHom (congr_arg unop h.symm) := by\n  cases h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/EqToHom.lean", "context": {"open": ["Opposite"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{\u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_2\nx\u271d : Sort u_3\neqToHom : x\u271d\nX Y : C\u1d52\u1d56\nh : X = Y\n\u22a2 sorry = sorry"}, {"line": "cases h", "tactic_state": "case refl\nC : Sort u_2\nx\u271d : Sort u_3\neqToHom : x\u271d\nX : C\u1d52\u1d56\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem counit_app_functor (e : C \u224c D) (X : C) :\n    e.counit.app (e.functor.obj X) = e.functor.map (e.unitInv.app X) := by\n  simpa using Iso.hom_comp_eq_id (e.functor.mapIso (e.unitIso.app X)) (f := e.counit.app _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Equivalence.lean", "context": {"open": ["CategoryTheory.Functor NatIso Category"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nD : Type u_2\ne : sorry\nX : C\n\u22a2 sorry = sorry"}, {"line": "simpa using Iso.hom_comp_eq_id (e.functor.mapIso (e.unitIso.app X)) (f := e.counit.app _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unit_app_inverse (e : C \u224c D) (Y : D) :\n    e.unit.app (e.inverse.obj Y) = e.inverse.map (e.counitInv.app Y) := by\n  simpa using Iso.comp_hom_eq_id (e.inverse.mapIso (e.counitIso.app Y)) (f := e.unit.app _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Equivalence.lean", "context": {"open": ["CategoryTheory.Functor NatIso Category"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nD : Type u_2\ne : sorry\nY : D\n\u22a2 sorry = sorry"}, {"line": "simpa using Iso.comp_hom_eq_id (e.inverse.mapIso (e.counitIso.app Y)) (f := e.unit.app _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem changeFunctor_refl (e : C \u224c D) : e.changeFunctor (Iso.refl _) = e := by aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Equivalence.lean", "context": {"open": ["CategoryTheory.Functor NatIso Category"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]", "{F : C \u2964 D} {G : D \u2964 C} (\u03b7 : \ud835\udfed C \u2245 F \u22d9 G) (\u03b5 : G \u22d9 F \u2245 \ud835\udfed D)", "{E : Type u\u2083} [Category.{v\u2083} E]", "(e : C \u224c D)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "e : sorry\n\u22a2 sorry = e"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem essentiallySmall_congr {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D]\n    (e : C \u224c D) : EssentiallySmall.{w} C \u2194 EssentiallySmall.{w} D := by\n  fconstructor\n  \u00b7 rintro \u27e8S, \ud835\udcae, \u27e8f\u27e9\u27e9\n    exact EssentiallySmall.mk' (e.symm.trans f)\n  \u00b7 rintro \u27e8S, \ud835\udcae, \u27e8f\u27e9\u27e9\n    exact EssentiallySmall.mk' (e.trans f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/EssentiallySmall.lean", "context": {"open": ["CategoryTheory"], "variables": ["(C : Type u) [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\ne : C \u224c D\n\u22a2 EssentiallySmall.{w, v, u} C \u2194 EssentiallySmall.{w, v', u'} D"}, {"line": "fconstructor", "tactic_state": "case mp\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\ne : C \u224c D\n\u22a2 EssentiallySmall.{w, v, u} C \u2192 EssentiallySmall.{w, v', u'} D\n---\ncase mpr\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\ne : C \u224c D\n\u22a2 EssentiallySmall.{w, v', u'} D \u2192 EssentiallySmall.{w, v, u} C"}, {"line": "\u00b7 rintro \u27e8S, \ud835\udcae, \u27e8f\u27e9\u27e9\n    exact EssentiallySmall.mk' (e.symm.trans f)", "tactic_state": "case mpr\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\ne : C \u224c D\n\u22a2 EssentiallySmall.{w, v', u'} D \u2192 EssentiallySmall.{w, v, u} C"}, {"line": "\u00b7 rintro \u27e8S, \ud835\udcae, \u27e8f\u27e9\u27e9\n    exact EssentiallySmall.mk' (e.trans f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem essentiallySmall_iff_of_thin {C : Type u} [Category.{v} C] [Quiver.IsThin C] :\n    EssentiallySmall.{w} C \u2194 Small.{w} (Skeleton C) := by\n  simp [essentiallySmall_iff, CategoryTheory.locallySmall_of_thin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/EssentiallySmall.lean", "context": {"open": ["CategoryTheory"], "variables": ["(C : Type u) [Category.{v} C]", "{C' : Type*}", "[LocallySmall.{w} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Quiver.IsThin C\n\u22a2 EssentiallySmall.{w, v, u} C \u2194 Small.{w, u} (Skeleton C)"}, {"line": "simp [essentiallySmall_iff, CategoryTheory.locallySmall_of_thin]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Quiver.IsThin C\n\u22a2 Small.{w, u} (Skeleton C) \u2192 LocallySmall.{w, v, u} C"}]}
{"declaration": "lemma eqToHom_eq {X Y : Grothendieck F} (hF : X = Y) :\n    eqToHom hF = { base := eqToHom (by subst hF; rfl), fiber := eqToHom (by subst hF; simp) } := by\n  subst hF\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Grothendieck.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2081} [Category.{v\u2081} D]", "(F : C \u2964 Cat.{v\u2082, u\u2082})", "{F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nGrothendieck : x\u271d\u00b9\nx\u271d : Sort u_2\neqToHom : x\u271d\nX : sorry\nY : sorry\nhF : X = Y\n\u22a2 sorry = sorry"}, {"line": "subst hF", "tactic_state": "x\u271d\u00b9 : Sort u_1\nGrothendieck : x\u271d\u00b9\nx\u271d : Sort u_2\neqToHom : x\u271d\nX : sorry\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cancel_natIso_hom_left {X : C} {Z : D} (g g' : G.obj X \u27f6 Z) :\n    \u03b1.hom.app X \u226b g = \u03b1.hom.app X \u226b g' \u2194 g = g' := by simp only [cancel_epi, refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/NatIso.lean", "context": {"open": ["CategoryTheory", "NatTrans", "CategoryTheory.Category CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] {E : Type u\u2083}", "{F G : C \u2964 D}", "(\u03b1 : F \u2245 G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\n\u03b1 : F \u2245 G\nX : C\nZ : D\ng g' : G.obj X \u27f6 Z\n\u22a2 CategoryStruct.comp (\u03b1.hom.app X) g = CategoryStruct.comp (\u03b1.hom.app X) g' \u2194 g = g'"}, {"line": "simp only [cancel_epi, refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cancel_natIso_inv_left {X : C} {Z : D} (g g' : F.obj X \u27f6 Z) :\n    \u03b1.inv.app X \u226b g = \u03b1.inv.app X \u226b g' \u2194 g = g' := by simp only [cancel_epi, refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/NatIso.lean", "context": {"open": ["CategoryTheory", "NatTrans", "CategoryTheory.Category CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] {E : Type u\u2083}", "{F G : C \u2964 D}", "(\u03b1 : F \u2245 G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\n\u03b1 : F \u2245 G\nX : C\nZ : D\ng g' : F.obj X \u27f6 Z\n\u22a2 CategoryStruct.comp (\u03b1.inv.app X) g = CategoryStruct.comp (\u03b1.inv.app X) g' \u2194 g = g'"}, {"line": "simp only [cancel_epi, refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cancel_natIso_hom_right {X : D} {Y : C} (f f' : X \u27f6 F.obj Y) :\n    f \u226b \u03b1.hom.app Y = f' \u226b \u03b1.hom.app Y \u2194 f = f' := by simp only [cancel_mono, refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/NatIso.lean", "context": {"open": ["CategoryTheory", "NatTrans", "CategoryTheory.Category CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] {E : Type u\u2083}", "{F G : C \u2964 D}", "(\u03b1 : F \u2245 G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\n\u03b1 : F \u2245 G\nX : D\nY : C\nf f' : X \u27f6 F.obj Y\n\u22a2 CategoryStruct.comp f (\u03b1.hom.app Y) = CategoryStruct.comp f' (\u03b1.hom.app Y) \u2194 f = f'"}, {"line": "simp only [cancel_mono, refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cancel_natIso_inv_right {X : D} {Y : C} (f f' : X \u27f6 G.obj Y) :\n    f \u226b \u03b1.inv.app Y = f' \u226b \u03b1.inv.app Y \u2194 f = f' := by simp only [cancel_mono, refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/NatIso.lean", "context": {"open": ["CategoryTheory", "NatTrans", "CategoryTheory.Category CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] {E : Type u\u2083}", "{F G : C \u2964 D}", "(\u03b1 : F \u2245 G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\n\u03b1 : F \u2245 G\nX : D\nY : C\nf f' : X \u27f6 G.obj Y\n\u22a2 CategoryStruct.comp f (\u03b1.inv.app Y) = CategoryStruct.comp f' (\u03b1.inv.app Y) \u2194 f = f'"}, {"line": "simp only [cancel_mono, refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_inv_app {F G : C \u2964 D} (e : F \u2245 G) (X : C) : inv (e.inv.app X) = e.hom.app X := by\n  aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/NatIso.lean", "context": {"open": ["CategoryTheory", "NatTrans", "CategoryTheory.Category CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] {E : Type u\u2083}", "{F G : C \u2964 D}", "(\u03b1 : F \u2245 G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\ne : F \u2245 G\nX : C\n\u22a2 CategoryTheory.inv (e.inv.app X) = e.hom.app X"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem naturality_1 (\u03b1 : F \u2245 G) (f : X \u27f6 Y) : \u03b1.inv.app X \u226b F.map f \u226b \u03b1.hom.app Y = G.map f := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/NatIso.lean", "context": {"open": ["CategoryTheory", "NatTrans", "CategoryTheory.Category CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] {E : Type u\u2083}", "{F G : C \u2964 D}", "(\u03b1 : F \u2245 G)", "{X Y : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\nX Y : C\n\u03b1 : F \u2245 G\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (\u03b1.inv.app X) (CategoryStruct.comp (F.map f) (\u03b1.hom.app Y)) = G.map f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem naturality_2 (\u03b1 : F \u2245 G) (f : X \u27f6 Y) : \u03b1.hom.app X \u226b G.map f \u226b \u03b1.inv.app Y = F.map f := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/NatIso.lean", "context": {"open": ["CategoryTheory", "NatTrans", "CategoryTheory.Category CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] {E : Type u\u2083}", "{F G : C \u2964 D}", "(\u03b1 : F \u2245 G)", "{X Y : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\nX Y : C\n\u03b1 : F \u2245 G\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (\u03b1.hom.app X) (CategoryStruct.comp (G.map f) (\u03b1.inv.app Y)) = F.map f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem naturality_1' (\u03b1 : F \u27f6 G) (f : X \u27f6 Y) {_ : IsIso (\u03b1.app X)} :\n    inv (\u03b1.app X) \u226b F.map f \u226b \u03b1.app Y = G.map f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/NatIso.lean", "context": {"open": ["CategoryTheory", "NatTrans", "CategoryTheory.Category CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] {E : Type u\u2083}", "{F G : C \u2964 D}", "(\u03b1 : F \u2245 G)", "{X Y : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\nX Y : C\n\u03b1 : F \u27f6 G\nf : X \u27f6 Y\nx\u271d : IsIso (\u03b1.app X)\n\u22a2 CategoryStruct.comp (CategoryTheory.inv (\u03b1.app X)) (CategoryStruct.comp (F.map f) (\u03b1.app Y)) = G.map f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem naturality_2' (\u03b1 : F \u27f6 G) (f : X \u27f6 Y) {_ : IsIso (\u03b1.app Y)} :\n    \u03b1.app X \u226b G.map f \u226b inv (\u03b1.app Y) = F.map f := by\n  rw [\u2190 Category.assoc]\n  rw [\u2190 naturality]\n  rw [Category.assoc]\n  rw [IsIso.hom_inv_id]\n  rw [Category.comp_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/NatIso.lean", "context": {"open": ["CategoryTheory", "NatTrans", "CategoryTheory.Category CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] {E : Type u\u2083}", "{F G : C \u2964 D}", "(\u03b1 : F \u2245 G)", "{X Y : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\nX Y : C\n\u03b1 : F \u27f6 G\nf : X \u27f6 Y\nx\u271d : IsIso (\u03b1.app Y)\n\u22a2 CategoryStruct.comp (\u03b1.app X) (CategoryStruct.comp (G.map f) (CategoryTheory.inv (\u03b1.app Y))) = F.map f"}, {"line": "rw [\u2190 Category.assoc]", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\nX Y : C\n\u03b1 : F \u27f6 G\nf : X \u27f6 Y\nx\u271d : IsIso (\u03b1.app Y)\n\u22a2 CategoryStruct.comp (CategoryStruct.comp (\u03b1.app X) (G.map f)) (CategoryTheory.inv (\u03b1.app Y)) = F.map f"}, {"line": "rw [\u2190 naturality]", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\nX Y : C\n\u03b1 : F \u27f6 G\nf : X \u27f6 Y\nx\u271d : IsIso (\u03b1.app Y)\n\u22a2 CategoryStruct.comp (CategoryStruct.comp (F.map f) (\u03b1.app Y)) (CategoryTheory.inv (\u03b1.app Y)) = F.map f"}, {"line": "rw [Category.assoc]", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\nX Y : C\n\u03b1 : F \u27f6 G\nf : X \u27f6 Y\nx\u271d : IsIso (\u03b1.app Y)\n\u22a2 CategoryStruct.comp (F.map f) (CategoryStruct.comp (\u03b1.app Y) (CategoryTheory.inv (\u03b1.app Y))) = F.map f"}, {"line": "rw [IsIso.hom_inv_id]", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : CategoryTheory.Functor C D\nX Y : C\n\u03b1 : F \u27f6 G\nf : X \u27f6 Y\nx\u271d : IsIso (\u03b1.app Y)\n\u22a2 CategoryStruct.comp (F.map f) (CategoryStruct.id (F.obj Y)) = F.map f"}, {"line": "rw [Category.comp_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqToHom_proj {I : Type*} {x x' : GradedObject I C} (h : x = x') (i : I) :\n    (eqToHom h : x \u27f6 x') i = eqToHom (funext_iff.mp h i) := by\n  subst h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/GradedObject.lean", "context": {"open": ["Category Limits"], "variables": ["{C : Type u} [Category.{v} C]", "{\u03b2 : Type*} (X Y : GradedObject \u03b2 C)", "{X Y}", "{C D E J : Type*} [Category C] [Category D] [Category E]", "{C : Type u} [Category.{v} C]", "(C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "GradedObject : ?m.4209\n\u03b2 : Type u_1\nX : sorry\nY : sorry\nC : ?m.5033\nx\u271d : Sort u_3\neqToHom : x\u271d\nI : Type u_2\nx : sorry\nx' : sorry\nh : x = x'\ni : I\n\u22a2 sorry = sorry"}, {"line": "subst h", "tactic_state": "GradedObject : ?m.4209\n\u03b2 : Type u_1\nX : sorry\nY : sorry\nC : ?m.5033\nx\u271d : Sort u_3\neqToHom : x\u271d\nI : Type u_2\nx : sorry\ni : I\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comapEq_symm {\u03b2 \u03b3 : Type w} {f g : \u03b2 \u2192 \u03b3} (h : f = g) :\n    comapEq C h.symm = (comapEq C h).symm := by aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/GradedObject.lean", "context": {"open": ["Category Limits"], "variables": ["{C : Type u} [Category.{v} C]", "{\u03b2 : Type*} (X Y : GradedObject \u03b2 C)", "{X Y}", "{C D E J : Type*} [Category C] [Category D] [Category E]", "{C : Type u} [Category.{v} C]", "(C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "GradedObject : ?m.4209\n\u03b2\u271d : Type u_1\nX : sorry\nY : sorry\nC : ?m.5033\nx\u271d : Sort u_2\ncomapEq : x\u271d\n\u03b2 \u03b3 : Type w\nf g : \u03b2 \u2192 \u03b3\nh : f = g\n\u22a2 sorry = sorry"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqToHom_apply {\u03b2 : Type w} {X Y : \u03b2 \u2192 C} (h : X = Y) (b : \u03b2) :\n    (eqToHom h : X \u27f6 Y) b = eqToHom (by rw [h]) := by\n  subst h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/GradedObject.lean", "context": {"open": ["Category Limits"], "variables": ["{C : Type u} [Category.{v} C]", "{\u03b2 : Type*} (X Y : GradedObject \u03b2 C)", "{X Y}", "{C D E J : Type*} [Category C] [Category D] [Category E]", "{C : Type u} [Category.{v} C]", "(C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "GradedObject : ?m.4209\n\u03b2\u271d : Type u_1\nX\u271d : sorry\nY\u271d : sorry\nC : ?m.5033\nx\u271d : Sort u_2\neqToHom : x\u271d\n\u03b2 : Type w\nX : sorry\nY : sorry\nh : X = Y\nb : \u03b2\n\u22a2 sorry = sorry"}, {"line": "subst h", "tactic_state": "GradedObject : ?m.4209\n\u03b2\u271d : Type u_1\nX\u271d : sorry\nY : sorry\nC : ?m.5033\nx\u271d : Sort u_2\neqToHom : x\u271d\n\u03b2 : Type w\nX : sorry\nb : \u03b2\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem homCongr_refl {X Y : C} (f : X \u27f6 Y) : (Iso.refl X).homCongr (Iso.refl Y) f = f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/HomCongr.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nX Y : C\nf : sorry\n\u22a2 sorry = f"}, {"line": "simp", "tactic_state": "C : Type u_1\nX Y : C\nf : sorry\n\u22a2 sorry () = f"}]}
{"declaration": "theorem map_homCongr {X Y X\u2081 Y\u2081 : C} (\u03b1 : X \u2245 X\u2081) (\u03b2 : Y \u2245 Y\u2081) (f : X \u27f6 Y) :\n    F.map (Iso.homCongr \u03b1 \u03b2 f) = Iso.homCongr (F.mapIso \u03b1) (F.mapIso \u03b2) (F.map f) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/HomCongr.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C]", "{C : Type u} [Category.{v} C] {D : Type u\u2081} [Category.{v\u2081} D] (F : C \u2964 D)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nX Y X\u2081 Y\u2081 : C\n\u03b1 : sorry\n\u03b2 : sorry\nf : sorry\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UnivLE.ofEssSurj (w : (uliftFunctor.{u, v} : Type v \u2964 Type max u v).EssSurj) :\n    UnivLE.{max u v, v} where\n  small \u03b1 := by\n    obtain \u27e8a', \u27e8m\u27e9\u27e9 := w.mem_essImage \u03b1\n    exact \u27e8a', \u27e8(Iso.toEquiv m).symm.trans Equiv.ulift\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/UnivLE.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "w : uliftFunctor.{u, v}.EssSurj\n\u03b1 : Type (max u v)\n\u22a2 Small.{v, max u v} \u03b1"}, {"line": "obtain \u27e8a', \u27e8m\u27e9\u27e9 := w.mem_essImage \u03b1", "tactic_state": "case intro.intro\nw : uliftFunctor.{u, v}.EssSurj\n\u03b1 : Type (max u v)\na' : Type v\nm : uliftFunctor.{u, v}.obj a' \u2245 \u03b1\n\u22a2 Small.{v, max u v} \u03b1"}, {"line": "exact \u27e8a', \u27e8(Iso.toEquiv m).symm.trans Equiv.ulift\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "example : map' (mk\u2082 f g) 0 1 = f := by dsimp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/ComposableArrows.lean", "context": {"open": ["Category"], "variables": ["(C : Type*) [Category C]", "{C} {n m : \u2115}", "(F G : ComposableArrows C n)", "{F G}", "(X\u2080 X\u2081 : C)", "{X\u2080 X\u2081}", "(f : X\u2080 \u27f6 X\u2081)", "(F)", "(X : C)", "{X} (f : X \u27f6 F.left)", "{X\u2080 X\u2081 X\u2082 X\u2083 X\u2084 : C} (f : X\u2080 \u27f6 X\u2081) (g : X\u2081 \u27f6 X\u2082) (h : X\u2082 \u27f6 X\u2083) (i : X\u2083 \u27f6 X\u2084)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\nf : \u03b1\u271d\n\u22a2 sorry = f"}, {"line": "dsimp", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\nf : \u03b1\u271d\n\u22a2 sorry () = f"}]}
{"declaration": "example : map' (mk\u2082 f g) 1 2 = g := by dsimp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/ComposableArrows.lean", "context": {"open": ["Category"], "variables": ["(C : Type*) [Category C]", "{C} {n m : \u2115}", "(F G : ComposableArrows C n)", "{F G}", "(X\u2080 X\u2081 : C)", "{X\u2080 X\u2081}", "(f : X\u2080 \u27f6 X\u2081)", "(F)", "(X : C)", "{X} (f : X \u27f6 F.left)", "{X\u2080 X\u2081 X\u2082 X\u2083 X\u2084 : C} (f : X\u2080 \u27f6 X\u2081) (g : X\u2081 \u27f6 X\u2082) (h : X\u2082 \u27f6 X\u2083) (i : X\u2083 \u27f6 X\u2084)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\ng : \u03b1\u271d\n\u22a2 sorry = g"}, {"line": "dsimp", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\ng : \u03b1\u271d\n\u22a2 sorry () = g"}]}
{"declaration": "example : map' (mk\u2083 f g h) 0 1 = f := by dsimp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/ComposableArrows.lean", "context": {"open": ["Category"], "variables": ["(C : Type*) [Category C]", "{C} {n m : \u2115}", "(F G : ComposableArrows C n)", "{F G}", "(X\u2080 X\u2081 : C)", "{X\u2080 X\u2081}", "(f : X\u2080 \u27f6 X\u2081)", "(F)", "(X : C)", "{X} (f : X \u27f6 F.left)", "{X\u2080 X\u2081 X\u2082 X\u2083 X\u2084 : C} (f : X\u2080 \u27f6 X\u2081) (g : X\u2081 \u27f6 X\u2082) (h : X\u2082 \u27f6 X\u2083) (i : X\u2083 \u27f6 X\u2084)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\nf : \u03b1\u271d\n\u22a2 sorry = f"}, {"line": "dsimp", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\nf : \u03b1\u271d\n\u22a2 sorry () = f"}]}
{"declaration": "example : map' (mk\u2083 f g h) 1 2 = g := by dsimp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/ComposableArrows.lean", "context": {"open": ["Category"], "variables": ["(C : Type*) [Category C]", "{C} {n m : \u2115}", "(F G : ComposableArrows C n)", "{F G}", "(X\u2080 X\u2081 : C)", "{X\u2080 X\u2081}", "(f : X\u2080 \u27f6 X\u2081)", "(F)", "(X : C)", "{X} (f : X \u27f6 F.left)", "{X\u2080 X\u2081 X\u2082 X\u2083 X\u2084 : C} (f : X\u2080 \u27f6 X\u2081) (g : X\u2081 \u27f6 X\u2082) (h : X\u2082 \u27f6 X\u2083) (i : X\u2083 \u27f6 X\u2084)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\ng : \u03b1\u271d\n\u22a2 sorry = g"}, {"line": "dsimp", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\ng : \u03b1\u271d\n\u22a2 sorry () = g"}]}
{"declaration": "example : map' (mk\u2083 f g h) 2 3 = h := by dsimp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/ComposableArrows.lean", "context": {"open": ["Category"], "variables": ["(C : Type*) [Category C]", "{C} {n m : \u2115}", "(F G : ComposableArrows C n)", "{F G}", "(X\u2080 X\u2081 : C)", "{X\u2080 X\u2081}", "(f : X\u2080 \u27f6 X\u2081)", "(F)", "(X : C)", "{X} (f : X \u27f6 F.left)", "{X\u2080 X\u2081 X\u2082 X\u2083 X\u2084 : C} (f : X\u2080 \u27f6 X\u2081) (g : X\u2081 \u27f6 X\u2082) (h : X\u2082 \u27f6 X\u2083) (i : X\u2083 \u27f6 X\u2084)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\nh : \u03b1\u271d\n\u22a2 sorry = h"}, {"line": "dsimp", "tactic_state": "ComposableArrows\u271d : ?m.8919\nC\u271d : ?m.9750\nn\u271d m\u271d : \u2115\nF\u271d : sorry\nG\u271d : sorry\nX\u2080\u271d : ?m.9751 F\u271d\nX\u2081\u271d : ?m.9752 F\u271d\nx\u271d\u00b9 : Sort ?u.8918\nComposableArrows : x\u271d\u00b9\nC : ?m.9750\nn m : \u2115\nF : sorry\nG : sorry\nX\u2080 : ?m.9751 F\nX\u2081 : ?m.9752 F\nx\u271d : Sort u_1\nmap' : x\u271d\n\u03b1\u271d : Sort u_2\nh : \u03b1\u271d\n\u22a2 sorry () = h"}]}
{"declaration": "theorem lift_map {X Y : C} (f : X \u27f6 Y) :\n    prod.lift (\ud835\udfd9 X) 0 \u226b Limits.prod.map f f = f \u226b prod.lift (\ud835\udfd9 Y) 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/NonPreadditive.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "CategoryTheory"], "variables": ["(C : Type u) [Category.{v} C]", "{C : Type u} [Category.{v} C] [NonPreadditiveAbelian C]", "{P Q : C} (f : P \u27f6 Q)", "{X Y : C} {f : X \u27f6 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (prod.lift (CategoryStruct.id X) 0) (prod.map f f) =\n    CategoryStruct.comp f (prod.lift (CategoryStruct.id Y) 0)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem apply_zero {P Q : C} (f : P \u27f6 Q) : f 0 = 0 := by\n  rw [pseudoZero_def]\n  rw [pseudoApply_mk']\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "CategoryTheory.Abelian", "CategoryTheory.Preadditive", "Pseudoelement"], "variables": ["{C : Type u} [Category.{v} C]", "[Abelian.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP Q : C\nf : P \u27f6 Q\n\u22a2 pseudoApply f 0 = 0"}, {"line": "rw [pseudoZero_def]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP Q : C\nf : P \u27f6 Q\n\u22a2 pseudoApply f \u27e6Over.mk 0\u27e7 = 0"}, {"line": "rw [pseudoApply_mk']", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP Q : C\nf : P \u27f6 Q\n\u22a2 \u27e6Over.mk (CategoryStruct.comp (Over.mk 0).hom f)\u27e7 = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example : HasImages C := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C]", "(C)", "{C : Type u} [Category.{v} C] [Preadditive C]", "[Limits.HasKernels C] [Limits.HasCokernels C]", "[\u2200 {X Y : C} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)]", "[Limits.HasFiniteProducts C]", "[\u2200 {X Y : C} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)]", "{C : Type u} [Category.{v} C] [Abelian C]", "{P Q : C} (f : P \u27f6 Q)", "{P Q : C} (f : P \u27f6 Q)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u271d\u00b9 : Type u\ninst\u271d\u2079 : Category.{v, u} C\u271d\u00b9\nC\u271d : Type u\ninst\u271d\u2078 : Category.{v, u} C\u271d\ninst\u271d\u2077 : Preadditive C\u271d\ninst\u271d\u2076 : HasKernels C\u271d\ninst\u271d\u2075 : HasCokernels C\u271d\ninst\u271d\u2074 : \u2200 {X Y : C\u271d} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)\ninst\u271d\u00b3 : HasFiniteProducts C\u271d\ninst\u271d\u00b2 : \u2200 {X Y : C\u271d} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP\u271d Q\u271d : C\nf\u271d : P\u271d \u27f6 Q\u271d\nP Q : C\nf : P \u27f6 Q\n\u22a2 HasImages C"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : HasImageMaps C := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C]", "(C)", "{C : Type u} [Category.{v} C] [Preadditive C]", "[Limits.HasKernels C] [Limits.HasCokernels C]", "[\u2200 {X Y : C} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)]", "[Limits.HasFiniteProducts C]", "[\u2200 {X Y : C} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)]", "{C : Type u} [Category.{v} C] [Abelian C]", "{P Q : C} (f : P \u27f6 Q)", "{P Q : C} (f : P \u27f6 Q)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u271d\u00b9 : Type u\ninst\u271d\u2079 : Category.{v, u} C\u271d\u00b9\nC\u271d : Type u\ninst\u271d\u2078 : Category.{v, u} C\u271d\ninst\u271d\u2077 : Preadditive C\u271d\ninst\u271d\u2076 : HasKernels C\u271d\ninst\u271d\u2075 : HasCokernels C\u271d\ninst\u271d\u2074 : \u2200 {X Y : C\u271d} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)\ninst\u271d\u00b3 : HasFiniteProducts C\u271d\ninst\u271d\u00b2 : \u2200 {X Y : C\u271d} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP\u271d Q\u271d : C\nf\u271d : P\u271d \u27f6 Q\u271d\nP Q : C\nf : P \u27f6 Q\n\u22a2 HasImageMaps C"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem epi_fst_of_factor_thru_epi_mono_factorization (g\u2081 : Y \u27f6 W) [Epi g\u2081] (g\u2082 : W \u27f6 Z) [Mono g\u2082]\n    (hg : g\u2081 \u226b g\u2082 = g) (f' : X \u27f6 W) (hf : f' \u226b g\u2082 = f) (t : PullbackCone f g) (ht : IsLimit t) :\n    Epi t.fst := by\n  apply epi_fst_of_isLimit _ _ (PullbackCone.isLimitOfFactors f g g\u2082 f' g\u2081 hf hg t ht)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C]", "(C)", "{C : Type u} [Category.{v} C] [Preadditive C]", "[Limits.HasKernels C] [Limits.HasCokernels C]", "[\u2200 {X Y : C} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)]", "[Limits.HasFiniteProducts C]", "[\u2200 {X Y : C} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)]", "{C : Type u} [Category.{v} C] [Abelian C]", "{P Q : C} (f : P \u27f6 Q)", "{P Q : C} (f : P \u27f6 Q)", "{f}", "{X Y : C} (f : X \u27f6 Y)", "{X Y : C} {f : X \u27f6 Y}", "(f)", "{D : Type*} [Category D] [HasZeroMorphisms D]", "[Limits.HasPullbacks C] {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "[Limits.HasPushouts C] {W X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "[Limits.HasPullbacks C] {W X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u2076 : Category.{v, u} C\ninst\u271d\u2075 : Abelian C\ninst\u271d\u2074 : HasPullbacks C\ninst\u271d\u00b3 : HasPushouts C\ninst\u271d\u00b2 : HasPullbacks C\nW X Y Z : C\nf : X \u27f6 Z\ng : Y \u27f6 Z\ng\u2081 : Y \u27f6 W\ninst\u271d\u00b9 : Epi g\u2081\ng\u2082 : W \u27f6 Z\ninst\u271d : Mono g\u2082\nhg : CategoryStruct.comp g\u2081 g\u2082 = g\nf' : X \u27f6 W\nhf : CategoryStruct.comp f' g\u2082 = f\nt : PullbackCone f g\nht : IsLimit t\n\u22a2 Epi t.fst"}, {"line": "apply epi_fst_of_isLimit _ _ (PullbackCone.isLimitOfFactors f g g\u2082 f' g\u2081 hf hg t ht)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mono_inl_of_factor_thru_epi_mono_factorization (f : X \u27f6 Y) (g : X \u27f6 Z) (g\u2081 : X \u27f6 W) [Epi g\u2081]\n    (g\u2082 : W \u27f6 Z) [Mono g\u2082] (hg : g\u2081 \u226b g\u2082 = g) (f' : W \u27f6 Y) (hf : g\u2081 \u226b f' = f)\n    (t : PushoutCocone f g) (ht : IsColimit t) : Mono t.inl := by\n  apply mono_inl_of_isColimit _ _ (PushoutCocone.isColimitOfFactors _ _ _ _ _ hf hg t ht)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C]", "(C)", "{C : Type u} [Category.{v} C] [Preadditive C]", "[Limits.HasKernels C] [Limits.HasCokernels C]", "[\u2200 {X Y : C} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)]", "[Limits.HasFiniteProducts C]", "[\u2200 {X Y : C} (f : X \u27f6 Y), IsIso (Abelian.coimageImageComparison f)]", "{C : Type u} [Category.{v} C] [Abelian C]", "{P Q : C} (f : P \u27f6 Q)", "{P Q : C} (f : P \u27f6 Q)", "{f}", "{X Y : C} (f : X \u27f6 Y)", "{X Y : C} {f : X \u27f6 Y}", "(f)", "{D : Type*} [Category D] [HasZeroMorphisms D]", "[Limits.HasPullbacks C] {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "[Limits.HasPushouts C] {W X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "[Limits.HasPullbacks C] {W X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "[Limits.HasPushouts C] {W X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u2077 : Category.{v, u} C\ninst\u271d\u2076 : Abelian C\ninst\u271d\u2075 : HasPullbacks C\ninst\u271d\u2074 : HasPushouts C\ninst\u271d\u00b3 : HasPullbacks C\ninst\u271d\u00b2 : HasPushouts C\nW X Y Z : C\nf : X \u27f6 Y\ng : X \u27f6 Z\ng\u2081 : X \u27f6 W\ninst\u271d\u00b9 : Epi g\u2081\ng\u2082 : W \u27f6 Z\ninst\u271d : Mono g\u2082\nhg : CategoryStruct.comp g\u2081 g\u2082 = g\nf' : W \u27f6 Y\nhf : CategoryStruct.comp g\u2081 f' = f\nt : PushoutCocone f g\nht : IsColimit t\n\u22a2 Mono t.inl"}, {"line": "apply mono_inl_of_isColimit _ _ (PushoutCocone.isColimitOfFactors _ _ _ _ _ hf hg t ht)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coimage_image_factorisation : coimage.\u03c0 f \u226b coimageImageComparison f \u226b image.\u03b9 f = f := by\n  simp [coimageImageComparison]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits"], "variables": ["{C : Type u} [Category.{v} C] [HasZeroMorphisms C] [HasKernels C] [HasCokernels C]", "{P Q : C} (f : P \u27f6 Q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasKernels C\ninst\u271d : HasCokernels C\nP Q : C\nf : P \u27f6 Q\nx\u271d : Sort u_1\ncoimageImageComparison : x\u271d\n\u22a2 CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry) = f"}, {"line": "simp [coimageImageComparison]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasKernels C\ninst\u271d : HasCokernels C\nP Q : C\nf : P \u27f6 Q\nx\u271d : Sort u_1\ncoimageImageComparison : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ())) = f"}]}
{"declaration": "theorem homotopyEquiv_hom_\u03b9 {X : C} (I J : InjectiveResolution X) :\n    I.\u03b9 \u226b (homotopyEquiv I J).hom = J.\u03b9 := by simp [homotopyEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Injective/Resolution.lean", "context": {"open": ["CategoryTheory Category Limits", "Injective"], "variables": ["{C : Type u} [Category.{v} C]", "[HasZeroObject C] [HasZeroMorphisms C]", "[Abelian C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroObject C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : Abelian C\nx\u271d : Sort u_1\nhomotopyEquiv : x\u271d\nX : C\nI J : InjectiveResolution X\n\u22a2 CategoryStruct.comp I.\u03b9 sorry = J.\u03b9"}, {"line": "simp [homotopyEquiv]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroObject C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : Abelian C\nx\u271d : Sort u_1\nhomotopyEquiv : x\u271d\nX : C\nI J : InjectiveResolution X\n\u22a2 CategoryStruct.comp I.\u03b9 (sorry ()) = J.\u03b9"}]}
{"declaration": "theorem homotopyEquiv_inv_\u03b9 {X : C} (I J : InjectiveResolution X) :\n    J.\u03b9 \u226b (homotopyEquiv I J).inv = I.\u03b9 := by simp [homotopyEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Injective/Resolution.lean", "context": {"open": ["CategoryTheory Category Limits", "Injective"], "variables": ["{C : Type u} [Category.{v} C]", "[HasZeroObject C] [HasZeroMorphisms C]", "[Abelian C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroObject C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : Abelian C\nx\u271d : Sort u_1\nhomotopyEquiv : x\u271d\nX : C\nI J : InjectiveResolution X\n\u22a2 CategoryStruct.comp J.\u03b9 sorry = I.\u03b9"}, {"line": "simp [homotopyEquiv]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroObject C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : Abelian C\nx\u271d : Sort u_1\nhomotopyEquiv : x\u271d\nX : C\nI J : InjectiveResolution X\n\u22a2 CategoryStruct.comp J.\u03b9 (sorry ()) = I.\u03b9"}]}
{"declaration": "lemma ofCocomplex_d_0_1 :\n    (ofCocomplex Z).d 0 1 = d (Injective.\u03b9 Z) := by\n  simp [ofCocomplex]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Injective/Resolution.lean", "context": {"open": ["CategoryTheory Category Limits", "Injective"], "variables": ["{C : Type u} [Category.{v} C]", "[HasZeroObject C] [HasZeroMorphisms C]", "[Abelian C]", "[Abelian C]", "(C)", "[HasInjectiveResolutions C]", "{C}", "[Abelian C] [EnoughInjectives C]", "[Abelian C] [EnoughInjectives C] (Z : C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u2079 : Category.{v, u} C\ninst\u271d\u2078 : HasZeroObject C\ninst\u271d\u2077 : HasZeroMorphisms C\ninst\u271d\u2076 inst\u271d\u2075 : Abelian C\ninst\u271d\u2074 : HasInjectiveResolutions C\ninst\u271d\u00b3 : Abelian C\ninst\u271d\u00b2 : EnoughInjectives C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : EnoughInjectives C\nZ : C\nx\u271d : Sort u_1\nofCocomplex : x\u271d\n\u22a2 sorry = d (\u03b9 Z)"}, {"line": "simp [ofCocomplex]", "tactic_state": "C : Type u\ninst\u271d\u2079 : Category.{v, u} C\ninst\u271d\u2078 : HasZeroObject C\ninst\u271d\u2077 : HasZeroMorphisms C\ninst\u271d\u2076 inst\u271d\u2075 : Abelian C\ninst\u271d\u2074 : HasInjectiveResolutions C\ninst\u271d\u00b3 : Abelian C\ninst\u271d\u00b2 : EnoughInjectives C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : EnoughInjectives C\nZ : C\nx\u271d : Sort u_1\nofCocomplex : x\u271d\n\u22a2 sorry () = d (\u03b9 Z)"}]}
{"declaration": "lemma ofComplex_d_1_0 :\n    (ofComplex Z).d 1 0 = d (Projective.\u03c0 Z) := by\n  simp [ofComplex]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Abelian/Projective/Resolution.lean", "context": {"open": ["Category Limits Projective"], "variables": ["{C : Type u} [Category.{v} C]", "[HasZeroObject C] [HasZeroMorphisms C]", "[Abelian C]", "(C)", "[Abelian C]", "[HasProjectiveResolutions C]", "{C}", "[EnoughProjectives C]", "{C} in", "{C}", "(Z : C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nofComplex : x\u271d\u00b9\nx\u271d : Sort u_2\nd : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [ofComplex]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nofComplex : x\u271d\u00b9\nx\u271d : Sort u_2\nd : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem \u03c1_one {G : Type u} [Monoid G] (A : Action V G) : A.\u03c1 1 = \ud835\udfd9 A.V := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Action/Basic.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["(V : Type (u + 1)) [LargeCategory V]", "{V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type (u + 1)\ninst\u271d\u00b9 : LargeCategory V\nG : Type u\ninst\u271d : Monoid G\nA : Action V G\n\u22a2 A.\u03c1 1 = CategoryStruct.id A.V"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tensorUnit_\u03c1 {g : G} :\n    @DFunLike.coe (G \u2192* End (\ud835\udfd9_ V)) _ _ _ (\ud835\udfd9_ (Action V G)).\u03c1 g = \ud835\udfd9 (\ud835\udfd9_ V) := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Action/Monoidal.lean", "context": {"open": ["CategoryTheory Limits MonoidalCategory", "MonoidalCategory"], "variables": ["{V : Type (u + 1)} [LargeCategory V] {G : Type u} [Monoid G]", "[MonoidalCategory V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type (u + 1)\ninst\u271d\u00b2 : LargeCategory V\nG : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : MonoidalCategory V\ng : G\n\u22a2 (tensorUnit (Action V G)).\u03c1 g = CategoryStruct.id (tensorUnit V)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem homEquiv_leftAdjointUniq_hom_app {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G)\n    (x : C) : adj1.homEquiv _ _ ((leftAdjointUniq adj1 adj2).hom.app x) = adj2.unit.app x := by\n  simp [leftAdjointUniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Adjunction/Unique.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C D : Type*} [Category C] [Category D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nleftAdjointUniq : x\u271d\nF F' : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F' \u22a3 G\nx : C\n\u22a2 (adj1.homEquiv ((Functor.id C).obj x) (F'.obj x)) sorry = adj2.unit.app x"}, {"line": "simp [leftAdjointUniq]", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nleftAdjointUniq : x\u271d\nF F' : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F' \u22a3 G\nx : C\n\u22a2 (adj1.homEquiv x (F'.obj x)) (sorry ()) = adj2.unit.app x"}]}
{"declaration": "theorem leftAdjointUniq_trans {F F' F'' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G)\n    (adj3 : F'' \u22a3 G) :\n    (leftAdjointUniq adj1 adj2).hom \u226b (leftAdjointUniq adj2 adj3).hom =\n      (leftAdjointUniq adj1 adj3).hom := by\n  simp [leftAdjointUniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Adjunction/Unique.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C D : Type*} [Category C] [Category D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nleftAdjointUniq : x\u271d\nF F' F'' : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F' \u22a3 G\nadj3 : F'' \u22a3 G\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [leftAdjointUniq]", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nleftAdjointUniq : x\u271d\nF F' F'' : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F' \u22a3 G\nadj3 : F'' \u22a3 G\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "theorem leftAdjointUniq_refl {F : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) :\n    (leftAdjointUniq adj1 adj1).hom = \ud835\udfd9 _ := by\n  simp [leftAdjointUniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Adjunction/Unique.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C D : Type*} [Category C] [Category D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nleftAdjointUniq : x\u271d\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\n\u22a2 sorry = CategoryStruct.id (?m.3252 adj1)"}, {"line": "simp [leftAdjointUniq]", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nleftAdjointUniq : x\u271d\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\n\u22a2 sorry () = CategoryStruct.id (?m.3252 adj1)"}]}
{"declaration": "theorem homEquiv_symm_rightAdjointUniq_hom_app {F : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G)\n    (adj2 : F \u22a3 G') (x : D) :\n    (adj2.homEquiv _ _).symm ((rightAdjointUniq adj1 adj2).hom.app x) = adj1.counit.app x := by\n  simp [rightAdjointUniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Adjunction/Unique.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C D : Type*} [Category C] [Category D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nrightAdjointUniq : x\u271d\nF : CategoryTheory.Functor C D\nG G' : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F \u22a3 G'\nx : D\n\u22a2 (adj2.homEquiv (G.obj x) ((Functor.id D).obj x)).symm sorry = adj1.counit.app x"}, {"line": "simp [rightAdjointUniq]", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nrightAdjointUniq : x\u271d\nF : CategoryTheory.Functor C D\nG G' : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F \u22a3 G'\nx : D\n\u22a2 (adj2.homEquiv (G.obj x) x).symm (sorry ()) = adj1.counit.app x"}]}
{"declaration": "theorem rightAdjointUniq_hom_app_counit {F : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G')\n    (x : D) :\n    F.map ((rightAdjointUniq adj1 adj2).hom.app x) \u226b adj2.counit.app x = adj1.counit.app x := by\n  simp [rightAdjointUniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Adjunction/Unique.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C D : Type*} [Category C] [Category D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nrightAdjointUniq : x\u271d\nF : CategoryTheory.Functor C D\nG G' : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F \u22a3 G'\nx : D\n\u22a2 CategoryStruct.comp (F.map sorry) (adj2.counit.app x) = adj1.counit.app x"}, {"line": "simp [rightAdjointUniq]", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nrightAdjointUniq : x\u271d\nF : CategoryTheory.Functor C D\nG G' : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F \u22a3 G'\nx : D\n\u22a2 CategoryStruct.comp (F.map (sorry ())) (adj2.counit.app x) = adj1.counit.app x"}]}
{"declaration": "theorem rightAdjointUniq_trans {F : C \u2964 D} {G G' G'' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G')\n    (adj3 : F \u22a3 G'') :\n    (rightAdjointUniq adj1 adj2).hom \u226b (rightAdjointUniq adj2 adj3).hom =\n      (rightAdjointUniq adj1 adj3).hom := by\n  simp [rightAdjointUniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Adjunction/Unique.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C D : Type*} [Category C] [Category D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nrightAdjointUniq : x\u271d\nF : CategoryTheory.Functor C D\nG G' G'' : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F \u22a3 G'\nadj3 : F \u22a3 G''\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [rightAdjointUniq]", "tactic_state": "C : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Category.{u_5, u_2} D\nx\u271d : Sort u_3\nrightAdjointUniq : x\u271d\nF : CategoryTheory.Functor C D\nG G' G'' : CategoryTheory.Functor D C\nadj1 : F \u22a3 G\nadj2 : F \u22a3 G'\nadj3 : F \u22a3 G''\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "theorem leftZigzagIso_inv : (leftZigzagIso \u03b7 \u03b5).inv = rightZigzag \u03b5.inv \u03b7.inv := by\n  simp [bicategoricalComp, bicategoricalIsoComp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Bicategory/Adjunction/Basic.lean", "context": {"open": ["Category", "scoped Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B] {a b c : B} {f : a \u27f6 b} {g : b \u27f6 a}", "{f\u2081 : a \u27f6 b} {g\u2081 : b \u27f6 a} {f\u2082 : b \u27f6 c} {g\u2082 : c \u27f6 b}", "(\u03b7 : \ud835\udfd9 a \u2245 f \u226b g) (\u03b5 : g \u226b f \u2245 \ud835\udfd9 b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nleftZigzagIso : x\u271d\u00b9\nx\u271d : Sort u_2\nrightZigzag : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [bicategoricalComp, bicategoricalIsoComp]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nleftZigzagIso : x\u271d\u00b9\nx\u271d : Sort u_2\nrightZigzag : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem rightZigzagIso_inv : (rightZigzagIso \u03b7 \u03b5).inv = leftZigzag \u03b5.inv \u03b7.inv := by\n  simp [bicategoricalComp, bicategoricalIsoComp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Bicategory/Adjunction/Basic.lean", "context": {"open": ["Category", "scoped Bicategory"], "variables": ["{B : Type u} [Bicategory.{w, v} B] {a b c : B} {f : a \u27f6 b} {g : b \u27f6 a}", "{f\u2081 : a \u27f6 b} {g\u2081 : b \u27f6 a} {f\u2082 : b \u27f6 c} {g\u2082 : c \u27f6 b}", "(\u03b7 : \ud835\udfd9 a \u2245 f \u226b g) (\u03b5 : g \u226b f \u2245 \ud835\udfd9 b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nrightZigzagIso : x\u271d\u00b9\nx\u271d : Sort u_2\nleftZigzag : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [bicategoricalComp, bicategoricalIsoComp]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nrightZigzagIso : x\u271d\u00b9\nx\u271d : Sort u_2\nleftZigzag : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "example : MonoidalCategory Cat := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/ChosenFiniteProducts/Cat.lean", "context": {"open": ["Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nMonoidalCategory : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : SymmetricCategory Cat := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/ChosenFiniteProducts/Cat.lean", "context": {"open": ["Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nSymmetricCategory : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqToHom_right (X Y : Comma L R) (H : X = Y) :\n    CommaMorphism.right (eqToHom H) = eqToHom (by cases H; rfl) := by\n  cases H\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Comma/Basic.lean", "context": {"open": ["Category"], "variables": ["{A : Type u\u2081} [Category.{v\u2081} A]", "{B : Type u\u2082} [Category.{v\u2082} B]", "{T : Type u\u2083} [Category.{v\u2083} T]", "{A' : Type u\u2084} [Category.{v\u2084} A']", "{B' : Type u\u2085} [Category.{v\u2085} B']", "{T' : Type u\u2086} [Category.{v\u2086} T']", "{L : A \u2964 T} {R : B \u2964 T}", "{X Y Z : Comma L R} {f : X \u27f6 Y} {g : Y \u27f6 Z}", "(L) (R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Sort ?u.4541\nComma : ?m.4539\nL : A\nX\u271d : sorry\nY\u271d : sorry\nZ : sorry\nf : X\u271d \u27f6 Y\u271d\ng : Y\u271d \u27f6 Z\nR : ?m.6762 L\nx\u271d : Sort u_1\neqToHom : x\u271d\nX : sorry\nY : sorry\nH : X = Y\n\u22a2 sorry = sorry"}, {"line": "cases H", "tactic_state": "case refl\nA : Sort ?u.4541\nComma : ?m.4539\nL : A\nX\u271d : sorry\nY : sorry\nZ : sorry\nf : X\u271d \u27f6 Y\ng : Y \u27f6 Z\nR : ?m.6762 L\nx\u271d : Sort u_1\neqToHom : x\u271d\nX : sorry\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma counitForward_val_fst (s : CostructuredArrow yoneda A) (x : F.obj (op s)) :\n    (counitForward F s x).val.fst = s.hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Comma/Presheaf/Basic.lean", "context": {"open": ["Category Opposite"], "variables": ["{C : Type u} [Category.{v} C] {A : C\u1d52\u1d56 \u2964 Type v}", "{F : (CostructuredArrow yoneda A)\u1d52\u1d56 \u2964 Type v} {X : C}", "{F : (CostructuredArrow yoneda A)\u1d52\u1d56 \u2964 Type v} {X : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "CostructuredArrow : ?m.885\nF\u271d : sorry\u1d52\u1d56\nF : sorry\u1d52\u1d56\nx\u271d : Sort u_1\ncounitForward : x\u271d\ns : sorry\nx : sorry\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "CostructuredArrow : ?m.885\nF\u271d : sorry\u1d52\u1d56\nF : sorry\u1d52\u1d56\nx\u271d : Sort u_1\ncounitForward : x\u271d\ns : sorry\nx : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem effectiveEpi_desc_iff_effectiveEpiFamily {\u03b1 : Type} [Finite \u03b1]\n    {B : C} (X : \u03b1 \u2192 C) (\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B) :\n    EffectiveEpi (Sigma.desc \u03c0) \u2194 EffectiveEpiFamily X \u03c0 := by\n  exact \u27e8fun h \u21a6 \u27e8\u27e8@effectiveEpiFamilyStructOfEffectiveEpiDesc _ _ _ _ X \u03c0 _ h _ _ (fun g \u21a6\n    (FinitaryPreExtensive.sigma_desc_iso (fun a \u21a6 Sigma.\u03b9 X a) g inferInstance).epi_of_iso)\u27e9\u27e9,\n    fun _ \u21a6 inferInstance\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/EffectiveEpi/Extensive.lean", "context": {"open": ["Limits"], "variables": ["{C : Type*} [Category C] [FinitaryPreExtensive C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nx\u271d\u00b9 : Sort u_2\nEffectiveEpi : x\u271d\u00b9\nx\u271d : Sort u_3\nEffectiveEpiFamily : x\u271d\n\u03b1 : Type\ninst\u271d : Finite \u03b1\nB : C\nX : \u03b1 \u2192 C\n\u03c0 : \u03b1 \u2192 sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "exact \u27e8fun h \u21a6 \u27e8\u27e8@effectiveEpiFamilyStructOfEffectiveEpiDesc _ _ _ _ X \u03c0 _ h _ _ (fun g \u21a6\n    (FinitaryPreExtensive.sigma_desc_iso (fun a \u21a6 Sigma.\u03b9 X a) g inferInstance).epi_of_iso)\u27e9\u27e9,\n    fun _ \u21a6 inferInstance\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eHomWhiskerRight_id (X Y : C) : eHomWhiskerRight V (\ud835\udfd9 X) Y = \ud835\udfd9 _ := by\n  simp [eHomWhiskerRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Enriched/Ordinary/Basic.lean", "context": {"open": ["CategoryTheory Category MonoidalCategory Opposite"], "variables": ["(V : Type u') [Category.{v'} V] [MonoidalCategory V]", "[EnrichedOrdinaryCategory V C] {C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nX Y : C\n\u22a2 sorry = CategoryStruct.id (?m.1885 X Y)"}, {"line": "simp [eHomWhiskerRight]", "tactic_state": "C : Type u_1\nX Y : C\n\u22a2 sorry () = CategoryStruct.id (?m.1885 X Y)"}]}
{"declaration": "lemma eHomWhiskerLeft_id (X Y : C) : eHomWhiskerLeft V X (\ud835\udfd9 Y) = \ud835\udfd9 _ := by\n  simp [eHomWhiskerLeft]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Enriched/Ordinary/Basic.lean", "context": {"open": ["CategoryTheory Category MonoidalCategory Opposite"], "variables": ["(V : Type u') [Category.{v'} V] [MonoidalCategory V]", "[EnrichedOrdinaryCategory V C] {C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nX Y : C\n\u22a2 sorry = CategoryStruct.id (?m.1882 X Y)"}, {"line": "simp [eHomWhiskerLeft]", "tactic_state": "C : Type u_1\nX Y : C\n\u22a2 sorry () = CategoryStruct.id (?m.1882 X Y)"}]}
{"declaration": "lemma of_fac' {R S : \ud835\udcae} {a b : \ud835\udcb3} (f : R \u27f6 S) (\u03c6 : a \u27f6 b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : p.map \u03c6 = eqToHom ha \u226b f \u226b eqToHom hb.symm) : p.IsHomLift f \u03c6 := by\n  subst ha hb\n  obtain rfl : f = p.map \u03c6 := by simpa using h.symm\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/FiberedCategory/HomLift.lean", "context": {"open": ["CategoryTheory Category"], "variables": ["{\ud835\udcae : Type u\u2081} {\ud835\udcb3 : Type u\u2082} [Category.{v\u2081} \ud835\udcb3] [Category.{v\u2082} \ud835\udcae] (p : \ud835\udcb3 \u2964 \ud835\udcae)", "{R S : \ud835\udcae} {a b : \ud835\udcb3}", "(f : R \u27f6 S) (\u03c6 : a \u27f6 b) [p.IsHomLift f \u03c6]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : CategoryTheory.Functor \ud835\udcb3 \ud835\udcae\nR S : \ud835\udcae\na b : \ud835\udcb3\nf : R \u27f6 S\n\u03c6 : a \u27f6 b\nha : p.obj a = R\nhb : p.obj b = S\nh : p.map \u03c6 = CategoryStruct.comp (eqToHom ha) (CategoryStruct.comp f (eqToHom \u22ef))\n\u22a2 p.IsHomLift f \u03c6"}, {"line": "subst ha hb", "tactic_state": "\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : CategoryTheory.Functor \ud835\udcb3 \ud835\udcae\na b : \ud835\udcb3\n\u03c6 : a \u27f6 b\nf : p.obj a \u27f6 p.obj b\nh : p.map \u03c6 = CategoryStruct.comp (eqToHom \u22ef) (CategoryStruct.comp f (eqToHom \u22ef))\n\u22a2 p.IsHomLift f \u03c6"}, {"line": "obtain rfl : f = p.map \u03c6 := by simpa using h.symm", "tactic_state": "\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : CategoryTheory.Functor \ud835\udcb3 \ud835\udcae\na b : \ud835\udcb3\n\u03c6 : a \u27f6 b\nh : p.map \u03c6 = CategoryStruct.comp (eqToHom \u22ef) (CategoryStruct.comp sorry (eqToHom \u22ef))\n\u22a2 p.IsHomLift sorry \u03c6"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma of_commsq {R S : \ud835\udcae} {a b : \ud835\udcb3} (f : R \u27f6 S) (\u03c6 : a \u27f6 b) (ha : p.obj a = R) (hb : p.obj b = S)\n    (h : p.map \u03c6 \u226b eqToHom hb = (eqToHom ha) \u226b f) : p.IsHomLift f \u03c6 := by\n  subst ha hb\n  obtain rfl : f = p.map \u03c6 := by simpa using h.symm\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/FiberedCategory/HomLift.lean", "context": {"open": ["CategoryTheory Category"], "variables": ["{\ud835\udcae : Type u\u2081} {\ud835\udcb3 : Type u\u2082} [Category.{v\u2081} \ud835\udcb3] [Category.{v\u2082} \ud835\udcae] (p : \ud835\udcb3 \u2964 \ud835\udcae)", "{R S : \ud835\udcae} {a b : \ud835\udcb3}", "(f : R \u27f6 S) (\u03c6 : a \u27f6 b) [p.IsHomLift f \u03c6]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : CategoryTheory.Functor \ud835\udcb3 \ud835\udcae\nR S : \ud835\udcae\na b : \ud835\udcb3\nf : R \u27f6 S\n\u03c6 : a \u27f6 b\nha : p.obj a = R\nhb : p.obj b = S\nh : CategoryStruct.comp (p.map \u03c6) (eqToHom hb) = CategoryStruct.comp (eqToHom ha) f\n\u22a2 p.IsHomLift f \u03c6"}, {"line": "subst ha hb", "tactic_state": "\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : CategoryTheory.Functor \ud835\udcb3 \ud835\udcae\na b : \ud835\udcb3\n\u03c6 : a \u27f6 b\nf : p.obj a \u27f6 p.obj b\nh : CategoryStruct.comp (p.map \u03c6) (eqToHom \u22ef) = CategoryStruct.comp (eqToHom \u22ef) f\n\u22a2 p.IsHomLift f \u03c6"}, {"line": "obtain rfl : f = p.map \u03c6 := by simpa using h.symm", "tactic_state": "\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} \ud835\udcb3\ninst\u271d : Category.{v\u2082, u\u2081} \ud835\udcae\np : CategoryTheory.Functor \ud835\udcb3 \ud835\udcae\na b : \ud835\udcb3\n\u03c6 : a \u27f6 b\nh : CategoryStruct.comp (p.map \u03c6) (eqToHom \u22ef) = CategoryStruct.comp (eqToHom \u22ef) sorry\n\u22a2 p.IsHomLift sorry \u03c6"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 : Type u) [SemilatticeSup \u03b1] [OrderBot \u03b1] : IsFiltered \u03b1 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Filtered/Basic.lean", "context": {"open": ["Function"], "variables": ["(C : Type u) [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsFiltered : x\u271d\n\u03b1 : Type u\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 : Type u) [SemilatticeSup \u03b1] [OrderTop \u03b1] : IsFiltered \u03b1 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Filtered/Basic.lean", "context": {"open": ["Function"], "variables": ["(C : Type u) [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsFiltered : x\u271d\n\u03b1 : Type u\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderTop \u03b1\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 : Type u) [SemilatticeInf \u03b1] [OrderTop \u03b1] : IsCofiltered \u03b1 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Filtered/Basic.lean", "context": {"open": ["Function", "IsFiltered", "CategoryTheory.Limits", "CategoryTheory.Limits"], "variables": ["(C : Type u) [Category.{v} C]", "{C}", "[IsFilteredOrEmpty C]", "{C}", "[IsFilteredOrEmpty C]", "{D : Type u\u2081} [Category.{v\u2081} D]", "{C}", "[IsFiltered C]", "(O : Finset C) (H : Finset (\u03a3' (X Y : C) (_ : X \u2208 O) (_ : Y \u2208 O), X \u27f6 Y))", "{J : Type w} [SmallCategory J] [FinCategory J]", "{D : Type u\u2081} [Category.{v\u2081} D]", "{C}", "[IsFilteredOrEmpty C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : ?m.688\nx\u271d : Sort u_1\nIsCofiltered : x\u271d\n\u03b1 : Type u\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderTop \u03b1\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofOpSequence_map_homOfLE_succ (n : \u2115) :\n    (ofOpSequence f).map (homOfLE (Nat.le_add_right n 1)).op = f n := by\n  simp [ofOpSequence]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Functor/OfSequence.lean", "context": {"open": ["Category"], "variables": ["{C : Type*} [Category C]", "{X : \u2115 \u2192 C} (f : \u2200 n, X n \u27f6 X (n + 1))", "{F G : \u2115 \u2964 C} (app : \u2200 (n : \u2115), F.obj n \u27f6 G.obj n)", "{X : \u2115 \u2192 C} (f : \u2200 n, X (n + 1) \u27f6 X n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 sorry\nx\u271d : Sort u_1\nofOpSequence : x\u271d\nn : \u2115\n\u22a2 sorry = f n"}, {"line": "simp [ofOpSequence]", "tactic_state": "f : \u2115 \u2192 sorry\nx\u271d : Sort u_1\nofOpSequence : x\u271d\nn : \u2115\n\u22a2 sorry () = f n"}]}
{"declaration": "theorem fac (x : J) : lift F hc s \u226b (F.mapCone c).\u03c0.app x = s.\u03c0.app x := by\n  simp [lift, \u2190 Functor.map_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Functor/Flat.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "Opposite", "StructuredArrow"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]", "{E : Type u\u2083} [Category.{v\u2083} E]", "(F : C \u2964 D)", "{F}", "{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]", "{J : Type v\u2081} [SmallCategory J] [FinCategory J] {K : J \u2964 C}", "(F : C \u2964 D) [RepresentablyFlat F] {c : Cone K} (hc : IsLimit c) (s : Cone (K \u22d9 F))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nJ : Type v\u2081\ninst\u271d\u00b2 : SmallCategory J\ninst\u271d\u00b9 : FinCategory J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst\u271d : RepresentablyFlat F\nc : Cone K\ns : Cone (K.comp F)\nx\u271d : Sort u_1\nlift : x\u271d\nx : J\n\u22a2 CategoryStruct.comp sorry ((F.mapCone c).\u03c0.app x) = s.\u03c0.app x"}, {"line": "simp [lift, \u2190 Functor.map_comp]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nJ : Type v\u2081\ninst\u271d\u00b2 : SmallCategory J\ninst\u271d\u00b9 : FinCategory J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst\u271d : RepresentablyFlat F\nc : Cone K\ns : Cone (K.comp F)\nx\u271d : Sort u_1\nlift : x\u271d\nx : J\n\u22a2 CategoryStruct.comp (sorry ()) (F.map (c.\u03c0.app x)) = s.\u03c0.app x"}]}
{"declaration": "lemma not_initial_iff_fiber_nonempty (X : C) : (IsInitial X \u2192 False) \u2194 Nonempty (F.obj X) := by\n  rw [\u2190 not_isEmpty_iff]\n  refine \u27e8fun h he \u21a6 ?_, fun h hin \u21a6 h <| (initial_iff_fiber_empty F X).mp \u27e8hin\u27e9\u27e9\n  exact Nonempty.elim ((initial_iff_fiber_empty F X).mpr he) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Galois/Basic.lean", "context": {"open": ["Limits Functor"], "variables": ["{C : Type u\u2081} [Category.{u\u2082, u\u2081} C] [PreGaloisCategory C]", "{C : Type u\u2081} [Category.{u\u2082, u\u2081} C] {F : C \u2964 FintypeCat.{w}} [PreGaloisCategory C]", "{C : Type u\u2081} [Category.{u\u2082, u\u2081} C]", "[PreGaloisCategory C] [FiberFunctor F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_1\nx\u271d : Sort u_2\nIsInitial : x\u271d\nX : C\n\u22a2 sorry \u2192 False \u2194 Nonempty sorry"}, {"line": "rw [\u2190 not_isEmpty_iff]", "tactic_state": "C : Sort u_1\nx\u271d : Sort u_2\nIsInitial : x\u271d\nX : C\n\u22a2 sorry \u2192 False \u2194 \u00acIsEmpty sorry"}, {"line": "refine \u27e8fun h he \u21a6 ?_, fun h hin \u21a6 h <| (initial_iff_fiber_empty F X).mp \u27e8hin\u27e9\u27e9", "tactic_state": "C : Sort u_1\nx\u271d : Sort u_2\nIsInitial : x\u271d\nX : C\nh : sorry \u2192 False\nhe : IsEmpty sorry\n\u22a2 False"}, {"line": "exact Nonempty.elim ((initial_iff_fiber_empty F X).mpr he) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSeparator_iff_faithful_preadditiveCoyoneda (G : C) :\n    IsSeparator G \u2194 (preadditiveCoyoneda.obj (op G)).Faithful := by\n  rw [isSeparator_iff_faithful_coyoneda_obj]\n  rw [\u2190 whiskering_preadditiveCoyoneda]\n  rw [Functor.comp_obj]\n  rw [whiskeringRight_obj_obj]\n  exact \u27e8fun h => Functor.Faithful.of_comp _ (forget AddCommGrp),\n    fun h => Functor.Faithful.comp _ _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Generator/Preadditive.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 IsSeparator G \u2194 (preadditiveCoyoneda.obj (op G)).Faithful"}, {"line": "rw [isSeparator_iff_faithful_coyoneda_obj]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 (coyoneda.obj (op G)).Faithful \u2194 (preadditiveCoyoneda.obj (op G)).Faithful"}, {"line": "rw [\u2190 whiskering_preadditiveCoyoneda]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 ((preadditiveCoyoneda.comp ((whiskeringRight C AddCommGrp (Type v)).obj (forget AddCommGrp))).obj (op G)).Faithful \u2194\n    (preadditiveCoyoneda.obj (op G)).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "rw [Functor.comp_obj]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 (((whiskeringRight C AddCommGrp (Type v)).obj (forget AddCommGrp)).obj (preadditiveCoyoneda.obj (op G))).Faithful \u2194\n    (preadditiveCoyoneda.obj (op G)).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "rw [whiskeringRight_obj_obj]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 ((preadditiveCoyoneda.obj (op G)).comp (forget AddCommGrp)).Faithful \u2194 (preadditiveCoyoneda.obj (op G)).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "exact \u27e8fun h => Functor.Faithful.of_comp _ (forget AddCommGrp),\n    fun h => Functor.Faithful.comp _ _\u27e9", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}]}
{"declaration": "theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :\n    IsSeparator G \u2194 (preadditiveCoyonedaObj G).Faithful := by\n  rw [isSeparator_iff_faithful_preadditiveCoyoneda]\n  rw [preadditiveCoyoneda_obj]\n  exact \u27e8fun h => Functor.Faithful.of_comp _ (forget\u2082 _ AddCommGrp.{v}),\n    fun h => Functor.Faithful.comp _ _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Generator/Preadditive.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 IsSeparator G \u2194 (preadditiveCoyonedaObj G).Faithful"}, {"line": "rw [isSeparator_iff_faithful_preadditiveCoyoneda]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 (preadditiveCoyoneda.obj (op G)).Faithful \u2194 (preadditiveCoyonedaObj G).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "rw [preadditiveCoyoneda_obj]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 ((preadditiveCoyonedaObj (unop (op G))).comp (forget\u2082 (ModuleCat (End (unop (op G)))\u1d50\u1d52\u1d56) AddCommGrp)).Faithful \u2194\n    (preadditiveCoyonedaObj G).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "exact \u27e8fun h => Functor.Faithful.of_comp _ (forget\u2082 _ AddCommGrp.{v}),\n    fun h => Functor.Faithful.comp _ _\u27e9", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}]}
{"declaration": "theorem isCoseparator_iff_faithful_preadditiveYoneda (G : C) :\n    IsCoseparator G \u2194 (preadditiveYoneda.obj G).Faithful := by\n  rw [isCoseparator_iff_faithful_yoneda_obj]\n  rw [\u2190 whiskering_preadditiveYoneda]\n  rw [Functor.comp_obj]\n  rw [whiskeringRight_obj_obj]\n  exact \u27e8fun h => Functor.Faithful.of_comp _ (forget AddCommGrp),\n    fun h => Functor.Faithful.comp _ _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Generator/Preadditive.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 IsCoseparator G \u2194 (preadditiveYoneda.obj G).Faithful"}, {"line": "rw [isCoseparator_iff_faithful_yoneda_obj]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 (yoneda.obj G).Faithful \u2194 (preadditiveYoneda.obj G).Faithful"}, {"line": "rw [\u2190 whiskering_preadditiveYoneda]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 ((preadditiveYoneda.comp ((whiskeringRight C\u1d52\u1d56 AddCommGrp (Type v)).obj (forget AddCommGrp))).obj G).Faithful \u2194\n    (preadditiveYoneda.obj G).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "rw [Functor.comp_obj]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 (((whiskeringRight C\u1d52\u1d56 AddCommGrp (Type v)).obj (forget AddCommGrp)).obj (preadditiveYoneda.obj G)).Faithful \u2194\n    (preadditiveYoneda.obj G).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "rw [whiskeringRight_obj_obj]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 ((preadditiveYoneda.obj G).comp (forget AddCommGrp)).Faithful \u2194 (preadditiveYoneda.obj G).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "exact \u27e8fun h => Functor.Faithful.of_comp _ (forget AddCommGrp),\n    fun h => Functor.Faithful.comp _ _\u27e9", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}]}
{"declaration": "theorem isCoseparator_iff_faithful_preadditiveYonedaObj (G : C) :\n    IsCoseparator G \u2194 (preadditiveYonedaObj G).Faithful := by\n  rw [isCoseparator_iff_faithful_preadditiveYoneda]\n  rw [preadditiveYoneda_obj]\n  exact \u27e8fun h => Functor.Faithful.of_comp _ (forget\u2082 _ AddCommGrp.{v}),\n    fun h => Functor.Faithful.comp _ _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Generator/Preadditive.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 IsCoseparator G \u2194 (preadditiveYonedaObj G).Faithful"}, {"line": "rw [isCoseparator_iff_faithful_preadditiveYoneda]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 (preadditiveYoneda.obj G).Faithful \u2194 (preadditiveYonedaObj G).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "rw [preadditiveYoneda_obj]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 ((preadditiveYonedaObj G).comp (forget\u2082 (ModuleCat (End G)) AddCommGrp)).Faithful \u2194 (preadditiveYonedaObj G).Faithful\n---\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}, {"line": "exact \u27e8fun h => Functor.Faithful.of_comp _ (forget\u2082 _ AddCommGrp.{v}),\n    fun h => Functor.Faithful.comp _ _\u27e9", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nG : C\n\u22a2 Preadditive C"}]}
{"declaration": "theorem IsSeparator.of_equivalence {G : C} (h : IsSeparator G) (\u03b1 : C \u224c D) :\n    IsSeparator (\u03b1.functor.obj G) := by simpa using IsSeparating.of_equivalence h \u03b1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Generator/Basic.lean", "context": {"open": ["CategoryTheory.Limits Opposite"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]", "(S : D) (T : C \u2964 D)", "(S : C \u2964 D) (T : D)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_4\nx\u271d : Sort u_1\nIsSeparator : x\u271d\nG : C\nh : sorry\n\u03b1 : sorry\n\u22a2 sorry"}, {"line": "simpa using IsSeparating.of_equivalence h \u03b1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCoseparator.of_equivalence {G : C} (h : IsCoseparator G) (\u03b1 : C \u224c D) :\n    IsCoseparator (\u03b1.functor.obj G) := by simpa using IsCoseparating.of_equivalence h \u03b1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Generator/Basic.lean", "context": {"open": ["CategoryTheory.Limits Opposite"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]", "(S : D) (T : C \u2964 D)", "(S : C \u2964 D) (T : D)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_4\nx\u271d : Sort u_1\nIsCoseparator : x\u271d\nG : C\nh : sorry\n\u03b1 : sorry\n\u22a2 sorry"}, {"line": "simpa using IsCoseparating.of_equivalence h \u03b1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIdempotentComplete_iff_of_equivalence {D : Type*} [Category D] (\u03b5 : C \u224c D) :\n    IsIdempotentComplete C \u2194 IsIdempotentComplete D := by\n  constructor\n  \u00b7 exact Equivalence.isIdempotentComplete \u03b5\n  \u00b7 exact Equivalence.isIdempotentComplete \u03b5.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Idempotents/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "CategoryTheory.Limits", "CategoryTheory.Preadditive", "Opposite"], "variables": ["(C : Type*) [Category C]", "{C} in", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\nD : Type u_2\ninst\u271d : Category.{u_3, u_2} D\n\u03b5 : C \u224c D\n\u22a2 IsIdempotentComplete C \u2194 IsIdempotentComplete D"}, {"line": "constructor", "tactic_state": "case mp\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\nD : Type u_2\ninst\u271d : Category.{u_3, u_2} D\n\u03b5 : C \u224c D\n\u22a2 IsIdempotentComplete C \u2192 IsIdempotentComplete D\n---\ncase mpr\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\nD : Type u_2\ninst\u271d : Category.{u_3, u_2} D\n\u03b5 : C \u224c D\n\u22a2 IsIdempotentComplete D \u2192 IsIdempotentComplete C"}, {"line": "\u00b7 exact Equivalence.isIdempotentComplete \u03b5", "tactic_state": "case mpr\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\nD : Type u_2\ninst\u271d : Category.{u_3, u_2} D\n\u03b5 : C \u224c D\n\u22a2 IsIdempotentComplete D \u2192 IsIdempotentComplete C"}, {"line": "\u00b7 exact Equivalence.isIdempotentComplete \u03b5.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIdempotentComplete_iff_opposite : IsIdempotentComplete C\u1d52\u1d56 \u2194 IsIdempotentComplete C := by\n  constructor\n  \u00b7 exact isIdempotentComplete_of_isIdempotentComplete_opposite\n  \u00b7 intro h\n    apply isIdempotentComplete_of_isIdempotentComplete_opposite\n    rw [isIdempotentComplete_iff_of_equivalence (opOpEquivalence C)]\n    exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Idempotents/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "CategoryTheory.Limits", "CategoryTheory.Preadditive", "Opposite"], "variables": ["(C : Type*) [Category C]", "{C} in", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\n\u22a2 IsIdempotentComplete C\u1d52\u1d56 \u2194 IsIdempotentComplete C"}, {"line": "constructor", "tactic_state": "case mp\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\n\u22a2 IsIdempotentComplete C\u1d52\u1d56 \u2192 IsIdempotentComplete C\n---\ncase mpr\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\n\u22a2 IsIdempotentComplete C \u2192 IsIdempotentComplete C\u1d52\u1d56"}, {"line": "\u00b7 exact isIdempotentComplete_of_isIdempotentComplete_opposite", "tactic_state": "case mpr\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\n\u22a2 IsIdempotentComplete C \u2192 IsIdempotentComplete C\u1d52\u1d56"}, {"line": "\u00b7 intro h\n    apply isIdempotentComplete_of_isIdempotentComplete_opposite\n    rw [isIdempotentComplete_iff_of_equivalence (opOpEquivalence C)]\n    exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_X (X : C) : (X : Karoubi C).X = X := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Idempotents/Karoubi.lean", "context": {"open": ["CategoryTheory.Category CategoryTheory.Preadditive CategoryTheory.Limits"], "variables": ["(C : Type*) [Category C]", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_2\nx\u271d : Sort u_1\nKaroubi : x\u271d\nX : C\n\u22a2 sorry = X"}, {"line": "simp", "tactic_state": "C : Sort u_2\nx\u271d : Sort u_1\nKaroubi : x\u271d\nX : C\n\u22a2 sorry () = X"}]}
{"declaration": "theorem iff_of_arrow_iso_left {A B A' B' X Y : C} {i : A \u27f6 B} {i' : A' \u27f6 B'}\n    (e : Arrow.mk i \u2245 Arrow.mk i') (p : X \u27f6 Y) :\n    HasLiftingProperty i p \u2194 HasLiftingProperty i' p := by\n  constructor <;> intro\n  exacts [of_arrow_iso_left e p, of_arrow_iso_left e.symm p]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/LiftingProperties/Basic.lean", "context": {"open": ["Category"], "variables": ["{C : Type*} [Category C] {A B B' X Y Y' : C} (i : A \u27f6 B) (i' : B \u27f6 B') (p : X \u27f6 Y)", "{i p}", "(i p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nx\u271d : Sort u_2\nHasLiftingProperty : x\u271d\nA B A' B' X Y : C\ni : sorry\ni' : sorry\ne : sorry \u2245 sorry\np : sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor <;> intro", "tactic_state": "case mp\nC : Type u_1\nx\u271d : Sort u_2\nHasLiftingProperty : x\u271d\nA B A' B' X Y : C\ni : sorry\ni' : sorry\ne : sorry \u2245 sorry\np : sorry\na\u271d : sorry\n\u22a2 sorry\n---\ncase mpr\nC : Type u_1\nx\u271d : Sort u_2\nHasLiftingProperty : x\u271d\nA B A' B' X Y : C\ni : sorry\ni' : sorry\ne : sorry \u2245 sorry\np : sorry\na\u271d : sorry\n\u22a2 sorry"}, {"line": "exacts [of_arrow_iso_left e p, of_arrow_iso_left e.symm p]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iff_of_arrow_iso_right {A B X Y X' Y' : C} (i : A \u27f6 B) {p : X \u27f6 Y} {p' : X' \u27f6 Y'}\n    (e : Arrow.mk p \u2245 Arrow.mk p') : HasLiftingProperty i p \u2194 HasLiftingProperty i p' := by\n  constructor <;> intro\n  exacts [of_arrow_iso_right i e, of_arrow_iso_right i e.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/LiftingProperties/Basic.lean", "context": {"open": ["Category"], "variables": ["{C : Type*} [Category C] {A B B' X Y Y' : C} (i : A \u27f6 B) (i' : B \u27f6 B') (p : X \u27f6 Y)", "{i p}", "(i p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\nx\u271d : Sort u_2\nHasLiftingProperty : x\u271d\nA B X Y X' Y' : C\ni : sorry\np : sorry\np' : sorry\ne : sorry \u2245 sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor <;> intro", "tactic_state": "case mp\nC : Type u_1\nx\u271d : Sort u_2\nHasLiftingProperty : x\u271d\nA B X Y X' Y' : C\ni : sorry\np : sorry\np' : sorry\ne : sorry \u2245 sorry\na\u271d : sorry\n\u22a2 sorry\n---\ncase mpr\nC : Type u_1\nx\u271d : Sort u_2\nHasLiftingProperty : x\u271d\nA B X Y X' Y' : C\ni : sorry\np : sorry\np' : sorry\ne : sorry \u2245 sorry\na\u271d : sorry\n\u22a2 sorry"}, {"line": "exacts [of_arrow_iso_right i e, of_arrow_iso_right i e.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finallySmall_iff_exists_small_weakly_terminal_set [IsFilteredOrEmpty J] :\n    FinallySmall.{v} J \u2194 \u2203 (s : Set J) (_ : Small.{v} s), \u2200 i, \u2203 j \u2208 s, Nonempty (i \u27f6 j) := by\n  refine \u27e8fun _ => FinallySmall.exists_small_weakly_terminal_set _, fun h => ?_\u27e9\n  rcases h with \u27e8s, hs, hs'\u27e9\n  exact finallySmall_of_small_weakly_terminal_set s hs'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/FinallySmall.lean", "context": {"open": ["CategoryTheory Functor"], "variables": ["(J : Type u) [Category.{v} J]", "{J}", "{K : Type u\u2081} [Category.{v\u2081} K]", "(J : Type u) [Category.{v} J]", "{J}", "{K : Type u\u2081} [Category.{v\u2081} K]", "(J : Type u) [Category.{v} J]", "{J} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u\ninst\u271d\u00b9 : Category.{v, u} J\ninst\u271d : IsFilteredOrEmpty J\n\u22a2 FinallySmall J \u2194 \u2203 s, \u2203 (_ : Small.{v, u} \u2191s), \u2200 (i : J), \u2203 j \u2208 s, Nonempty (i \u27f6 j)"}, {"line": "refine \u27e8fun _ => FinallySmall.exists_small_weakly_terminal_set _, fun h => ?_\u27e9", "tactic_state": "J : Type u\ninst\u271d\u00b9 : Category.{v, u} J\ninst\u271d : IsFilteredOrEmpty J\nh : \u2203 s, \u2203 (_ : Small.{v, u} \u2191s), \u2200 (i : J), \u2203 j \u2208 s, Nonempty (i \u27f6 j)\n\u22a2 FinallySmall J"}, {"line": "rcases h with \u27e8s, hs, hs'\u27e9", "tactic_state": "case intro.intro\nJ : Type u\ninst\u271d\u00b9 : Category.{v, u} J\ninst\u271d : IsFilteredOrEmpty J\ns : Set J\nhs : Small.{v, u} \u2191s\nhs' : \u2200 (i : J), \u2203 j \u2208 s, Nonempty (i \u27f6 j)\n\u22a2 FinallySmall J"}, {"line": "exact finallySmall_of_small_weakly_terminal_set s hs'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem initiallySmall_iff_exists_small_weakly_initial_set [IsCofilteredOrEmpty J] :\n    InitiallySmall.{v} J \u2194 \u2203 (s : Set J) (_ : Small.{v} s), \u2200 i, \u2203 j \u2208 s, Nonempty (j \u27f6 i) := by\n  refine \u27e8fun _ => InitiallySmall.exists_small_weakly_initial_set _, fun h => ?_\u27e9\n  rcases h with \u27e8s, hs, hs'\u27e9\n  exact initiallySmall_of_small_weakly_initial_set s hs'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/FinallySmall.lean", "context": {"open": ["CategoryTheory Functor"], "variables": ["(J : Type u) [Category.{v} J]", "{J}", "{K : Type u\u2081} [Category.{v\u2081} K]", "(J : Type u) [Category.{v} J]", "{J}", "{K : Type u\u2081} [Category.{v\u2081} K]", "(J : Type u) [Category.{v} J]", "{J} in", "(J : Type u) [Category.{v} J]", "{J} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u\ninst\u271d\u00b9 : Category.{v, u} J\ninst\u271d : IsCofilteredOrEmpty J\n\u22a2 InitiallySmall J \u2194 \u2203 s, \u2203 (_ : Small.{v, u} \u2191s), \u2200 (i : J), \u2203 j \u2208 s, Nonempty (j \u27f6 i)"}, {"line": "refine \u27e8fun _ => InitiallySmall.exists_small_weakly_initial_set _, fun h => ?_\u27e9", "tactic_state": "J : Type u\ninst\u271d\u00b9 : Category.{v, u} J\ninst\u271d : IsCofilteredOrEmpty J\nh : \u2203 s, \u2203 (_ : Small.{v, u} \u2191s), \u2200 (i : J), \u2203 j \u2208 s, Nonempty (j \u27f6 i)\n\u22a2 InitiallySmall J"}, {"line": "rcases h with \u27e8s, hs, hs'\u27e9", "tactic_state": "case intro.intro\nJ : Type u\ninst\u271d\u00b9 : Category.{v, u} J\ninst\u271d : IsCofilteredOrEmpty J\ns : Set J\nhs : Small.{v, u} \u2191s\nhs' : \u2200 (i : J), \u2203 j \u2208 s, Nonempty (j \u27f6 i)\n\u22a2 InitiallySmall J"}, {"line": "exact initiallySmall_of_small_weakly_initial_set s hs'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma productEquiv_apply {\u03b9 : Type*} [Finite \u03b9] (X : \u03b9 \u2192 FintypeCat.{u})\n    (x : (\u220f\u1d9c X : FintypeCat)) (i : \u03b9) : productEquiv X x i = Pi.\u03c0 X i x := by\n  simpa [productEquiv] using (elementwise_of% piComparison_comp_\u03c0 FintypeCat.incl X i) x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/FintypeCat.lean", "context": {"open": ["CategoryTheory Limits Functor"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nproductEquiv : x\u271d\n\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\nX : \u03b9 \u2192 FintypeCat\nx : (\u220f\u1d9c X).carrier\ni : \u03b9\n\u22a2 sorry = Pi.\u03c0 X i x"}, {"line": "simpa [productEquiv] using (elementwise_of% piComparison_comp_\u03c0 FintypeCat.incl X i) x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coconeOfConeLeftOp_\u03b9_app (c : Cone F.leftOp) (j) :\n    (coconeOfConeLeftOp c).\u03b9.app j = (c.\u03c0.app (op j)).op := by\n  dsimp only [coconeOfConeLeftOp]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Cones.lean", "context": {"open": ["CategoryTheory", "CategoryTheory", "CategoryTheory.Category", "CategoryTheory.Functor", "Opposite", "CategoryTheory.Limits"], "variables": ["{J : Type u\u2081} [Category.{v\u2081} J]", "{K : Type u\u2082} [Category.{v\u2082} K]", "{C : Type u\u2083} [Category.{v\u2083} C]", "{D : Type u\u2084} [Category.{v\u2084} D]", "{E : Type u\u2085} [Category.{v\u2085} E]", "(F : J \u2964 C)", "(J C)", "{F : J \u2964 C}", "(F)", "(G : C \u2964 D)", "(F)", "(G : C \u2964 D)", "(H : C \u2964 D) {F : J \u2964 C} {G : J \u2964 C}", "{F : J \u2964 C}", "(F)", "{F : J \u2964 C\u1d52\u1d56}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} J\nC : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} C\nF : CategoryTheory.Functor J C\u1d52\u1d56\nc : Cone F.leftOp\nj : J\n\u22a2 (coconeOfConeLeftOp c).\u03b9.app j = (c.\u03c0.app (op j)).op"}, {"line": "dsimp only [coconeOfConeLeftOp]", "tactic_state": "J : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} J\nC : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} C\nF : CategoryTheory.Functor J C\u1d52\u1d56\nc : Cone F.leftOp\nj : J\n\u22a2 (NatTrans.removeLeftOp c.\u03c0).app j = (c.\u03c0.app (op j)).op"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem limitFlipCompLimIsoLimitCompLim_inv_\u03c0_\u03c0 (k) (j) :\n    (limitFlipCompLimIsoLimitCompLim F).inv \u226b limit.\u03c0 _ k \u226b limit.\u03c0 _ j =\n      (limit.\u03c0 _ j \u226b limit.\u03c0 _ k) := by\n  simp [limitFlipCompLimIsoLimitCompLim]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Fubini.lean", "context": {"open": ["CategoryTheory"], "variables": ["{J K : Type*} [Category J] [Category K]", "{C : Type*} [Category C]", "(F : J \u2964 K \u2964 C) (G : J \u00d7 K \u2964 C)", "{F}", "(F)", "[HasLimitsOfShape K C]", "[HasLimit (curry.obj G \u22d9 lim)]", "[HasLimit (uncurry.obj F)] [HasLimit (F \u22d9 lim)]", "(F)", "[HasColimitsOfShape K C]", "[HasColimit (curry.obj G \u22d9 colim)]", "[HasColimit (uncurry.obj F)] [HasColimit (F \u22d9 colim)]", "(F) [HasLimitsOfShape J C] [HasLimitsOfShape K C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nlimitFlipCompLimIsoLimitCompLim : x\u271d\nk : ?m.4347\nj : ?m.4348 k\n\u22a2 CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry) = CategoryStruct.comp sorry sorry"}, {"line": "simp [limitFlipCompLimIsoLimitCompLim]", "tactic_state": "x\u271d : Sort u_4\nlimitFlipCompLimIsoLimitCompLim : x\u271d\nk : ?m.4347\nj : ?m.4348 k\n\u22a2 CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ())) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "theorem limitIsoLimitCurryCompLim_hom_\u03c0_\u03c0 {j} {k} :\n    (limitIsoLimitCurryCompLim G).hom \u226b limit.\u03c0 _ j \u226b limit.\u03c0 _ k = limit.\u03c0 _ (j, k) := by\n  simp [limitIsoLimitCurryCompLim, Trans.simple]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Fubini.lean", "context": {"open": ["CategoryTheory"], "variables": ["{J K : Type*} [Category J] [Category K]", "{C : Type*} [Category C]", "(F : J \u2964 K \u2964 C) (G : J \u00d7 K \u2964 C)", "{F}", "(F)", "[HasLimitsOfShape K C]", "[HasLimit (curry.obj G \u22d9 lim)]", "[HasLimit (uncurry.obj F)] [HasLimit (F \u22d9 lim)]", "(F)", "[HasColimitsOfShape K C]", "[HasColimit (curry.obj G \u22d9 colim)]", "[HasColimit (uncurry.obj F)] [HasColimit (F \u22d9 colim)]", "(F) [HasLimitsOfShape J C] [HasLimitsOfShape K C]", "(F) [HasColimitsOfShape J C] [HasColimitsOfShape K C]", "[HasLimitsOfShape K C] [HasLimit (curry.obj G \u22d9 lim)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nlimitIsoLimitCurryCompLim : x\u271d\nj : ?m.3773\nk : ?m.3774\n\u22a2 CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry) = sorry"}, {"line": "simp [limitIsoLimitCurryCompLim, Trans.simple]", "tactic_state": "x\u271d : Sort u_4\nlimitIsoLimitCurryCompLim : x\u271d\nj : ?m.3773\nk : ?m.3774\n\u22a2 CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ())) = sorry ()"}]}
{"declaration": "theorem colimitIsoColimitCurryCompColim_\u03b9_\u03b9_inv {j} {k} :\n    colimit.\u03b9 ((curry.obj G).obj j) k \u226b colimit.\u03b9 (curry.obj G \u22d9 colim) j \u226b\n      (colimitIsoColimitCurryCompColim G).inv  = colimit.\u03b9 _ (j, k) := by\n  simp [colimitIsoColimitCurryCompColim, Trans.simple, colimitUncurryIsoColimitCompColim]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Fubini.lean", "context": {"open": ["CategoryTheory"], "variables": ["{J K : Type*} [Category J] [Category K]", "{C : Type*} [Category C]", "(F : J \u2964 K \u2964 C) (G : J \u00d7 K \u2964 C)", "{F}", "(F)", "[HasLimitsOfShape K C]", "[HasLimit (curry.obj G \u22d9 lim)]", "[HasLimit (uncurry.obj F)] [HasLimit (F \u22d9 lim)]", "(F)", "[HasColimitsOfShape K C]", "[HasColimit (curry.obj G \u22d9 colim)]", "[HasColimit (uncurry.obj F)] [HasColimit (F \u22d9 colim)]", "(F) [HasLimitsOfShape J C] [HasLimitsOfShape K C]", "(F) [HasColimitsOfShape J C] [HasColimitsOfShape K C]", "[HasLimitsOfShape K C] [HasLimit (curry.obj G \u22d9 lim)]", "[HasColimitsOfShape K C] [HasColimit (curry.obj G \u22d9 colim)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ncolimitIsoColimitCurryCompColim : x\u271d\nj : ?m.4102\nk : ?m.4103\n\u22a2 CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry) = sorry"}, {"line": "simp [colimitIsoColimitCurryCompColim, Trans.simple, colimitUncurryIsoColimitCompColim]", "tactic_state": "x\u271d : Sort u_4\ncolimitIsoColimitCurryCompColim : x\u271d\nj : ?m.4102\nk : ?m.4103\n\u22a2 CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ())) = sorry ()"}]}
{"declaration": "theorem limitCurrySwapCompLimIsoLimitCurryCompLim_inv_\u03c0_\u03c0 {j} {k} :\n    (limitCurrySwapCompLimIsoLimitCurryCompLim G).inv \u226b limit.\u03c0 _ k \u226b limit.\u03c0 _ j =\n      (limit.\u03c0 _ j \u226b limit.\u03c0 _ k) := by\n  simp [limitCurrySwapCompLimIsoLimitCurryCompLim]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Fubini.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.prod"], "variables": ["{J K : Type*} [Category J] [Category K]", "{C : Type*} [Category C]", "(F : J \u2964 K \u2964 C) (G : J \u00d7 K \u2964 C)", "{F}", "(F)", "[HasLimitsOfShape K C]", "[HasLimit (curry.obj G \u22d9 lim)]", "[HasLimit (uncurry.obj F)] [HasLimit (F \u22d9 lim)]", "(F)", "[HasColimitsOfShape K C]", "[HasColimit (curry.obj G \u22d9 colim)]", "[HasColimit (uncurry.obj F)] [HasColimit (F \u22d9 colim)]", "(F) [HasLimitsOfShape J C] [HasLimitsOfShape K C]", "(F) [HasColimitsOfShape J C] [HasColimitsOfShape K C]", "[HasLimitsOfShape K C] [HasLimit (curry.obj G \u22d9 lim)]", "[HasColimitsOfShape K C] [HasColimit (curry.obj G \u22d9 colim)]", "[HasLimitsOfShape K C] [HasLimitsOfShape J C] [HasLimit (curry.obj G \u22d9 lim)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nlimitCurrySwapCompLimIsoLimitCurryCompLim : x\u271d\nj : ?m.4839\nk : ?m.4840\n\u22a2 CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry) = CategoryStruct.comp sorry sorry"}, {"line": "simp [limitCurrySwapCompLimIsoLimitCurryCompLim]", "tactic_state": "x\u271d : Sort u_4\nlimitCurrySwapCompLimIsoLimitCurryCompLim : x\u271d\nj : ?m.4839\nk : ?m.4840\n\u22a2 CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ())) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "theorem binaryCofan_inr {A B : C} [MonoCoprod C] (c : BinaryCofan A B) (hc : IsColimit c) :\n    Mono c.inr := by\n  haveI hc' : IsColimit (BinaryCofan.mk c.inr c.inl) :=\n    BinaryCofan.IsColimit.mk _ (fun f\u2081 f\u2082 => hc.desc (BinaryCofan.mk f\u2082 f\u2081))\n      (by simp) (by simp)\n      (fun f\u2081 f\u2082 m h\u2081 h\u2082 => BinaryCofan.IsColimit.hom_ext hc (by aesop_cat) (by aesop_cat))\n  exact binaryCofan_inl _ hc'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/MonoCoprod.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["(C : Type*) [Category C]", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\nA B : C\ninst\u271d : MonoCoprod C\nc : BinaryCofan A B\nhc : IsColimit c\n\u22a2 Mono c.inr"}, {"line": "haveI hc' : IsColimit (BinaryCofan.mk c.inr c.inl) :=\n    BinaryCofan.IsColimit.mk _ (fun f\u2081 f\u2082 => hc.desc (BinaryCofan.mk f\u2082 f\u2081))\n      (by simp) (by simp)\n      (fun f\u2081 f\u2082 m h\u2081 h\u2082 => BinaryCofan.IsColimit.hom_ext hc (by aesop_cat) (by aesop_cat))", "tactic_state": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\nA B : C\ninst\u271d : MonoCoprod C\nc : BinaryCofan A B\nhc : IsColimit c\nhc' : sorry\n\u22a2 Mono c.inr"}, {"line": "exact binaryCofan_inl _ hc'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma opProdIsoCoprod_hom_fst : (opProdIsoCoprod A B).hom.unop \u226b prod.fst = coprod.inl.unop := by\n  simp [opProdIsoCoprod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Opposites.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Functor", "Opposite"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{J : Type u\u2082} [Category.{v\u2082} J]", "(X : Type v\u2082)", "{\u03b1 : Type*} {Z : \u03b1 \u2192 C}", "[HasCoproduct Z]", "(Z) in", "(Z) in", "{\u03b1 : Type*} {Z : \u03b1 \u2192 C}", "[HasProduct Z]", "(Z) in", "(Z) in", "{A B : C} [HasBinaryProduct A B]", "(A B) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nopProdIsoCoprod : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [opProdIsoCoprod]", "tactic_state": "x\u271d : Sort u_2\nopProdIsoCoprod : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma opProdIsoCoprod_hom_snd : (opProdIsoCoprod A B).hom.unop \u226b prod.snd = coprod.inr.unop := by\n  simp [opProdIsoCoprod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Opposites.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Functor", "Opposite"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{J : Type u\u2082} [Category.{v\u2082} J]", "(X : Type v\u2082)", "{\u03b1 : Type*} {Z : \u03b1 \u2192 C}", "[HasCoproduct Z]", "(Z) in", "(Z) in", "{\u03b1 : Type*} {Z : \u03b1 \u2192 C}", "[HasProduct Z]", "(Z) in", "(Z) in", "{A B : C} [HasBinaryProduct A B]", "(A B) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nopProdIsoCoprod : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [opProdIsoCoprod]", "tactic_state": "x\u271d : Sort u_2\nopProdIsoCoprod : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma small_sections_of_hasLimit\n    {C : Type u} [Category.{v} C] [HasForget.{v} C]\n    [(forget C).IsCorepresentable] {J : Type w} [Category.{t} J] (G : J \u2964 C) [HasLimit G] :\n    Small.{v} (G \u22d9 forget C).sections := by\n  rw [\u2190 Types.hasLimit_iff_small_sections]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/ConcreteCategory/Basic.lean", "context": {"open": ["CategoryTheory", "Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasForget C\ninst\u271d\u00b2 : (forget C).IsCorepresentable\nJ : Type w\ninst\u271d\u00b9 : Category.{t, w} J\nG : CategoryTheory.Functor J C\ninst\u271d : HasLimit G\n\u22a2 Small.{v, max v w} \u2191(G.comp (forget C)).sections"}, {"line": "rw [\u2190 Types.hasLimit_iff_small_sections]", "tactic_state": "C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasForget C\ninst\u271d\u00b2 : (forget C).IsCorepresentable\nJ : Type w\ninst\u271d\u00b9 : Category.{t, w} J\nG : CategoryTheory.Functor J C\ninst\u271d : HasLimit G\n\u22a2 HasLimit (G.comp (forget C))"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftToFinsetColimIso_aux (F : Discrete \u03b1 \u2964 C) {J : Finset (Discrete \u03b1)} (j : J) :\n    Sigma.\u03b9 (F.obj \u00b7.val) j \u226b colimit.\u03b9 (liftToFinsetObj F) J \u226b\n      (colimit.isoColimitCocone (liftToFinsetColimitCocone F)).inv\n    = colimit.\u03b9 F j := by\n  simp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Constructions/Filtered.lean", "context": {"open": ["CategoryTheory Opposite", "CoproductsFromFiniteFiltered"], "variables": ["{C : Type u} [Category.{v} C] {\u03b1 : Type w}", "[HasFiniteCoproducts C]", "(C) (\u03b1) in", "[HasFiniteCoproducts C] [HasColimitsOfShape (Finset (Discrete \u03b1)) C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\n\u03b1 : Type w\nF : CategoryTheory.Functor (Discrete \u03b1) C\nJ : Finset (Discrete \u03b1)\nj : { x // x \u2208 J }\n\u22a2 CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry) = sorry"}, {"line": "simp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\n\u03b1 : Type w\nF : CategoryTheory.Functor (Discrete \u03b1) C\nJ : Finset (Discrete \u03b1)\nj : { x // x \u2208 J }\n\u22a2 CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ())) = sorry ()"}]}
{"declaration": "theorem map_\u03c0_preserves_coequalizer_inv_desc {W : D} (k : G.obj Y \u27f6 W)\n    (wk : G.map f \u226b k = G.map g \u226b k) : G.map (coequalizer.\u03c0 f g) \u226b\n      (PreservesCoequalizer.iso G f g).inv \u226b coequalizer.desc k wk = k := by\n  rw [\u2190 Category.assoc]\n  rw [map_\u03c0_preserves_coequalizer_inv]\n  rw [coequalizer.\u03c0_desc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Equalizers.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(G : C \u2964 D)", "{X Y Z : C} {f g : X \u27f6 Y} {h : Z \u27f6 X} (w : h \u226b f = h \u226b g)", "(f g)", "[HasEqualizer f g]", "[HasEqualizer (G.map f) (G.map g)]", "[PreservesLimit (parallelPair f g) G]", "{X Y Z : C} {f g : X \u27f6 Y} {h : Y \u27f6 Z} (w : f \u226b h = g \u226b h)", "(f g)", "[HasCoequalizer f g]", "[HasCoequalizer (G.map f) (G.map g)]", "[PreservesColimit (parallelPair f g) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : X \u27f6 Y\ninst\u271d\u00b2 : HasCoequalizer f g\ninst\u271d\u00b9 : HasCoequalizer (G.map f) (G.map g)\ninst\u271d : PreservesColimit (parallelPair f g) G\nW : D\nk : G.obj Y \u27f6 W\nwk : CategoryStruct.comp (G.map f) k = CategoryStruct.comp (G.map g) k\n\u22a2 CategoryStruct.comp (G.map (coequalizer.\u03c0 f g))\n      (CategoryStruct.comp (PreservesCoequalizer.iso G f g).inv (coequalizer.desc k wk)) =\n    k"}, {"line": "rw [\u2190 Category.assoc]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : X \u27f6 Y\ninst\u271d\u00b2 : HasCoequalizer f g\ninst\u271d\u00b9 : HasCoequalizer (G.map f) (G.map g)\ninst\u271d : PreservesColimit (parallelPair f g) G\nW : D\nk : G.obj Y \u27f6 W\nwk : CategoryStruct.comp (G.map f) k = CategoryStruct.comp (G.map g) k\n\u22a2 CategoryStruct.comp (CategoryStruct.comp (G.map (coequalizer.\u03c0 f g)) (PreservesCoequalizer.iso G f g).inv)\n      (coequalizer.desc k wk) =\n    k"}, {"line": "rw [map_\u03c0_preserves_coequalizer_inv]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : X \u27f6 Y\ninst\u271d\u00b2 : HasCoequalizer f g\ninst\u271d\u00b9 : HasCoequalizer (G.map f) (G.map g)\ninst\u271d : PreservesColimit (parallelPair f g) G\nW : D\nk : G.obj Y \u27f6 W\nwk : CategoryStruct.comp (G.map f) k = CategoryStruct.comp (G.map g) k\n\u22a2 CategoryStruct.comp (coequalizer.\u03c0 (G.map f) (G.map g)) (coequalizer.desc k wk) = k"}, {"line": "rw [coequalizer.\u03c0_desc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_\u03c0_preserves_coequalizer_inv_colimMap {X' Y' : D} (f' g' : X' \u27f6 Y')\n    [HasCoequalizer f' g'] (p : G.obj X \u27f6 X') (q : G.obj Y \u27f6 Y') (wf : G.map f \u226b q = p \u226b f')\n    (wg : G.map g \u226b q = p \u226b g') :\n    G.map (coequalizer.\u03c0 f g) \u226b\n        (PreservesCoequalizer.iso G f g).inv \u226b\n          colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg) =\n      q \u226b coequalizer.\u03c0 f' g' := by\n  rw [\u2190 Category.assoc]\n  rw [map_\u03c0_preserves_coequalizer_inv]\n  rw [\u03b9_colimMap]\n  rw [parallelPairHom_app_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Equalizers.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(G : C \u2964 D)", "{X Y Z : C} {f g : X \u27f6 Y} {h : Z \u27f6 X} (w : h \u226b f = h \u226b g)", "(f g)", "[HasEqualizer f g]", "[HasEqualizer (G.map f) (G.map g)]", "[PreservesLimit (parallelPair f g) G]", "{X Y Z : C} {f g : X \u27f6 Y} {h : Y \u27f6 Z} (w : f \u226b h = g \u226b h)", "(f g)", "[HasCoequalizer f g]", "[HasCoequalizer (G.map f) (G.map g)]", "[PreservesColimit (parallelPair f g) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : X \u27f6 Y\ninst\u271d\u00b3 : HasCoequalizer f g\ninst\u271d\u00b2 : HasCoequalizer (G.map f) (G.map g)\ninst\u271d\u00b9 : PreservesColimit (parallelPair f g) G\nX' Y' : D\nf' g' : X' \u27f6 Y'\ninst\u271d : HasCoequalizer f' g'\np : G.obj X \u27f6 X'\nq : G.obj Y \u27f6 Y'\nwf : CategoryStruct.comp (G.map f) q = CategoryStruct.comp p f'\nwg : CategoryStruct.comp (G.map g) q = CategoryStruct.comp p g'\n\u22a2 CategoryStruct.comp (G.map (coequalizer.\u03c0 f g))\n      (CategoryStruct.comp (PreservesCoequalizer.iso G f g).inv\n        (colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg))) =\n    CategoryStruct.comp q (coequalizer.\u03c0 f' g')"}, {"line": "rw [\u2190 Category.assoc]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : X \u27f6 Y\ninst\u271d\u00b3 : HasCoequalizer f g\ninst\u271d\u00b2 : HasCoequalizer (G.map f) (G.map g)\ninst\u271d\u00b9 : PreservesColimit (parallelPair f g) G\nX' Y' : D\nf' g' : X' \u27f6 Y'\ninst\u271d : HasCoequalizer f' g'\np : G.obj X \u27f6 X'\nq : G.obj Y \u27f6 Y'\nwf : CategoryStruct.comp (G.map f) q = CategoryStruct.comp p f'\nwg : CategoryStruct.comp (G.map g) q = CategoryStruct.comp p g'\n\u22a2 CategoryStruct.comp (CategoryStruct.comp (G.map (coequalizer.\u03c0 f g)) (PreservesCoequalizer.iso G f g).inv)\n      (colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg)) =\n    CategoryStruct.comp q (coequalizer.\u03c0 f' g')"}, {"line": "rw [map_\u03c0_preserves_coequalizer_inv]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : X \u27f6 Y\ninst\u271d\u00b3 : HasCoequalizer f g\ninst\u271d\u00b2 : HasCoequalizer (G.map f) (G.map g)\ninst\u271d\u00b9 : PreservesColimit (parallelPair f g) G\nX' Y' : D\nf' g' : X' \u27f6 Y'\ninst\u271d : HasCoequalizer f' g'\np : G.obj X \u27f6 X'\nq : G.obj Y \u27f6 Y'\nwf : CategoryStruct.comp (G.map f) q = CategoryStruct.comp p f'\nwg : CategoryStruct.comp (G.map g) q = CategoryStruct.comp p g'\n\u22a2 CategoryStruct.comp (coequalizer.\u03c0 (G.map f) (G.map g))\n      (colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg)) =\n    CategoryStruct.comp q (coequalizer.\u03c0 f' g')"}, {"line": "rw [\u03b9_colimMap]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : X \u27f6 Y\ninst\u271d\u00b3 : HasCoequalizer f g\ninst\u271d\u00b2 : HasCoequalizer (G.map f) (G.map g)\ninst\u271d\u00b9 : PreservesColimit (parallelPair f g) G\nX' Y' : D\nf' g' : X' \u27f6 Y'\ninst\u271d : HasCoequalizer f' g'\np : G.obj X \u27f6 X'\nq : G.obj Y \u27f6 Y'\nwf : CategoryStruct.comp (G.map f) q = CategoryStruct.comp p f'\nwg : CategoryStruct.comp (G.map g) q = CategoryStruct.comp p g'\n\u22a2 CategoryStruct.comp ((parallelPairHom (G.map f) (G.map g) f' g' p q wf wg).app WalkingParallelPair.one)\n      (colimit.\u03b9 (parallelPair f' g') WalkingParallelPair.one) =\n    CategoryStruct.comp q (coequalizer.\u03c0 f' g')"}, {"line": "rw [parallelPairHom_app_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_\u03c0_preserves_coequalizer_inv_colimMap_desc {X' Y' : D} (f' g' : X' \u27f6 Y')\n    [HasCoequalizer f' g'] (p : G.obj X \u27f6 X') (q : G.obj Y \u27f6 Y') (wf : G.map f \u226b q = p \u226b f')\n    (wg : G.map g \u226b q = p \u226b g') {Z' : D} (h : Y' \u27f6 Z') (wh : f' \u226b h = g' \u226b h) :\n    G.map (coequalizer.\u03c0 f g) \u226b\n        (PreservesCoequalizer.iso G f g).inv \u226b\n          colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg) \u226b coequalizer.desc h wh =\n      q \u226b h := by\n  slice_lhs 1 3 => rw [map_\u03c0_preserves_coequalizer_inv_colimMap]\n  slice_lhs 2 3 => rw [coequalizer.\u03c0_desc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Equalizers.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(G : C \u2964 D)", "{X Y Z : C} {f g : X \u27f6 Y} {h : Z \u27f6 X} (w : h \u226b f = h \u226b g)", "(f g)", "[HasEqualizer f g]", "[HasEqualizer (G.map f) (G.map g)]", "[PreservesLimit (parallelPair f g) G]", "{X Y Z : C} {f g : X \u27f6 Y} {h : Y \u27f6 Z} (w : f \u226b h = g \u226b h)", "(f g)", "[HasCoequalizer f g]", "[HasCoequalizer (G.map f) (G.map g)]", "[PreservesColimit (parallelPair f g) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : X \u27f6 Y\ninst\u271d\u00b3 : HasCoequalizer f g\ninst\u271d\u00b2 : HasCoequalizer (G.map f) (G.map g)\ninst\u271d\u00b9 : PreservesColimit (parallelPair f g) G\nX' Y' : D\nf' g' : X' \u27f6 Y'\ninst\u271d : HasCoequalizer f' g'\np : G.obj X \u27f6 X'\nq : G.obj Y \u27f6 Y'\nwf : CategoryStruct.comp (G.map f) q = CategoryStruct.comp p f'\nwg : CategoryStruct.comp (G.map g) q = CategoryStruct.comp p g'\nZ' : D\nh : Y' \u27f6 Z'\nwh : CategoryStruct.comp f' h = CategoryStruct.comp g' h\n\u22a2 CategoryStruct.comp (G.map (coequalizer.\u03c0 f g))\n      (CategoryStruct.comp (PreservesCoequalizer.iso G f g).inv\n        (CategoryStruct.comp (colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg))\n          (coequalizer.desc h wh))) =\n    CategoryStruct.comp q h"}, {"line": "slice_lhs 1 3 => rw [map_\u03c0_preserves_coequalizer_inv_colimMap]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : X \u27f6 Y\ninst\u271d\u00b3 : HasCoequalizer f g\ninst\u271d\u00b2 : HasCoequalizer (G.map f) (G.map g)\ninst\u271d\u00b9 : PreservesColimit (parallelPair f g) G\nX' Y' : D\nf' g' : X' \u27f6 Y'\ninst\u271d : HasCoequalizer f' g'\np : G.obj X \u27f6 X'\nq : G.obj Y \u27f6 Y'\nwf : CategoryStruct.comp (G.map f) q = CategoryStruct.comp p f'\nwg : CategoryStruct.comp (G.map g) q = CategoryStruct.comp p g'\nZ' : D\nh : Y' \u27f6 Z'\nwh : CategoryStruct.comp f' h = CategoryStruct.comp g' h\n\u22a2 CategoryStruct.comp (CategoryStruct.comp q (coequalizer.\u03c0 f' g')) (coequalizer.desc h wh) = CategoryStruct.comp q h"}, {"line": "slice_lhs 2 3 => rw [coequalizer.\u03c0_desc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorThruImage_comp_hom {X Y : A} (f : X \u27f6 Y) :\n    factorThruImage (L.map f) \u226b (iso L f).hom = L.map (factorThruImage f) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits"], "variables": ["{A : Type u\u2081} {B : Type u\u2082} [Category.{v\u2081} A] [Category.{v\u2082} B]", "[HasEqualizers A] [HasImages A]", "[StrongEpiCategory B] [HasImages B]", "(L : A \u2964 B)", "[\u2200 {X Y Z : A} (f : X \u27f6 Z) (g : Y \u27f6 Z), PreservesLimit (cospan f g) L]", "[\u2200 {X Y Z : A} (f : X \u27f6 Y) (g : X \u27f6 Z), PreservesColimit (span f g) L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u\u2081\nB : Type u\u2082\ninst\u271d\u2077 : Category.{v\u2081, u\u2081} A\ninst\u271d\u2076 : Category.{v\u2082, u\u2082} B\ninst\u271d\u2075 : HasEqualizers A\ninst\u271d\u2074 : HasImages A\ninst\u271d\u00b3 : StrongEpiCategory B\ninst\u271d\u00b2 : HasImages B\nL : CategoryTheory.Functor A B\ninst\u271d\u00b9 : \u2200 {X Y Z : A} (f : X \u27f6 Z) (g : Y \u27f6 Z), PreservesLimit (cospan f g) L\ninst\u271d : \u2200 {X Y Z : A} (f : X \u27f6 Y) (g : X \u27f6 Z), PreservesColimit (span f g) L\nx\u271d : Sort u_1\niso : x\u271d\nX Y : A\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (factorThruImage (L.map f)) sorry = L.map (factorThruImage f)"}, {"line": "simp", "tactic_state": "A : Type u\u2081\nB : Type u\u2082\ninst\u271d\u2077 : Category.{v\u2081, u\u2081} A\ninst\u271d\u2076 : Category.{v\u2082, u\u2082} B\ninst\u271d\u2075 : HasEqualizers A\ninst\u271d\u2074 : HasImages A\ninst\u271d\u00b3 : StrongEpiCategory B\ninst\u271d\u00b2 : HasImages B\nL : CategoryTheory.Functor A B\ninst\u271d\u00b9 : \u2200 {X Y Z : A} (f : X \u27f6 Z) (g : Y \u27f6 Z), PreservesLimit (cospan f g) L\ninst\u271d : \u2200 {X Y Z : A} (f : X \u27f6 Y) (g : X \u27f6 Z), PreservesColimit (span f g) L\nx\u271d : Sort u_1\niso : x\u271d\nX Y : A\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (factorThruImage (L.map f)) (sorry ()) = L.map (factorThruImage f)"}]}
{"declaration": "theorem inv_comp_image_\u03b9_map {X Y : A} (f : X \u27f6 Y) :\n    (iso L f).inv \u226b image.\u03b9 (L.map f) = L.map (image.\u03b9 f) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits"], "variables": ["{A : Type u\u2081} {B : Type u\u2082} [Category.{v\u2081} A] [Category.{v\u2082} B]", "[HasEqualizers A] [HasImages A]", "[StrongEpiCategory B] [HasImages B]", "(L : A \u2964 B)", "[\u2200 {X Y Z : A} (f : X \u27f6 Z) (g : Y \u27f6 Z), PreservesLimit (cospan f g) L]", "[\u2200 {X Y Z : A} (f : X \u27f6 Y) (g : X \u27f6 Z), PreservesColimit (span f g) L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u\u2081\nB : Type u\u2082\ninst\u271d\u2077 : Category.{v\u2081, u\u2081} A\ninst\u271d\u2076 : Category.{v\u2082, u\u2082} B\ninst\u271d\u2075 : HasEqualizers A\ninst\u271d\u2074 : HasImages A\ninst\u271d\u00b3 : StrongEpiCategory B\ninst\u271d\u00b2 : HasImages B\nL : CategoryTheory.Functor A B\ninst\u271d\u00b9 : \u2200 {X Y Z : A} (f : X \u27f6 Z) (g : Y \u27f6 Z), PreservesLimit (cospan f g) L\ninst\u271d : \u2200 {X Y Z : A} (f : X \u27f6 Y) (g : X \u27f6 Z), PreservesColimit (span f g) L\nx\u271d : Sort u_1\niso : x\u271d\nX Y : A\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp sorry (image.\u03b9 (L.map f)) = L.map (image.\u03b9 f)"}, {"line": "simp", "tactic_state": "A : Type u\u2081\nB : Type u\u2082\ninst\u271d\u2077 : Category.{v\u2081, u\u2081} A\ninst\u271d\u2076 : Category.{v\u2082, u\u2082} B\ninst\u271d\u2075 : HasEqualizers A\ninst\u271d\u2074 : HasImages A\ninst\u271d\u00b3 : StrongEpiCategory B\ninst\u271d\u00b2 : HasImages B\nL : CategoryTheory.Functor A B\ninst\u271d\u00b9 : \u2200 {X Y Z : A} (f : X \u27f6 Z) (g : Y \u27f6 Z), PreservesLimit (cospan f g) L\ninst\u271d : \u2200 {X Y Z : A} (f : X \u27f6 Y) (g : X \u27f6 Z), PreservesColimit (span f g) L\nx\u271d : Sort u_1\niso : x\u271d\nX Y : A\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (sorry ()) (image.\u03b9 (L.map f)) = L.map (image.\u03b9 f)"}]}
{"declaration": "theorem PreservesKernel.iso_hom : (PreservesKernel.iso G f).hom = kernelComparison f G := by\n  rw [\u2190 cancel_mono (kernel.\u03b9 _)]\n  simp [PreservesKernel.iso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Kernels.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D]", "{X Y : C} {f : X \u27f6 Y} (c : KernelFork f)", "(G : C \u2964 D) [Functor.PreservesZeroMorphisms G]", "(f)", "[HasKernel f]", "[HasKernel (G.map f)]", "[PreservesLimit (parallelPair f 0) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2077 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2076 : HasZeroMorphisms C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\nX Y : C\nf : X \u27f6 Y\nG : CategoryTheory.Functor C D\ninst\u271d\u00b3 : G.PreservesZeroMorphisms\ninst\u271d\u00b2 : HasKernel f\ninst\u271d\u00b9 : HasKernel (G.map f)\ninst\u271d : PreservesLimit (parallelPair f 0) G\n\u22a2 (PreservesKernel.iso G f).hom = kernelComparison f G"}, {"line": "rw [\u2190 cancel_mono (kernel.\u03b9 _)]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2077 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2076 : HasZeroMorphisms C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\nX Y : C\nf : X \u27f6 Y\nG : CategoryTheory.Functor C D\ninst\u271d\u00b3 : G.PreservesZeroMorphisms\ninst\u271d\u00b2 : HasKernel f\ninst\u271d\u00b9 : HasKernel (G.map f)\ninst\u271d : PreservesLimit (parallelPair f 0) G\n\u22a2 CategoryStruct.comp (PreservesKernel.iso G f).hom (kernel.\u03b9 (G.map f)) =\n    CategoryStruct.comp (kernelComparison f G) (kernel.\u03b9 (G.map f))"}, {"line": "simp [PreservesKernel.iso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PreservesCokernel.iso_inv : (PreservesCokernel.iso G f).inv = cokernelComparison f G := by\n  rw [\u2190 cancel_epi (cokernel.\u03c0 _)]\n  simp [PreservesCokernel.iso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Kernels.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D]", "{X Y : C} {f : X \u27f6 Y} (c : KernelFork f)", "(G : C \u2964 D) [Functor.PreservesZeroMorphisms G]", "(f)", "[HasKernel f]", "[HasKernel (G.map f)]", "[PreservesLimit (parallelPair f 0) G]", "{X Y : C} {f : X \u27f6 Y} (c : CokernelCofork f)", "(G : C \u2964 D) [Functor.PreservesZeroMorphisms G]", "(f)", "[HasCokernel f]", "[HasCokernel (G.map f)]", "[PreservesColimit (parallelPair f 0) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2077 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2076 : HasZeroMorphisms C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\nX Y : C\nf : X \u27f6 Y\nG : CategoryTheory.Functor C D\ninst\u271d\u00b3 : G.PreservesZeroMorphisms\ninst\u271d\u00b2 : HasCokernel f\ninst\u271d\u00b9 : HasCokernel (G.map f)\ninst\u271d : PreservesColimit (parallelPair f 0) G\n\u22a2 (PreservesCokernel.iso G f).inv = cokernelComparison f G"}, {"line": "rw [\u2190 cancel_epi (cokernel.\u03c0 _)]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2077 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2076 : HasZeroMorphisms C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\nX Y : C\nf : X \u27f6 Y\nG : CategoryTheory.Functor C D\ninst\u271d\u00b3 : G.PreservesZeroMorphisms\ninst\u271d\u00b2 : HasCokernel f\ninst\u271d\u00b9 : HasCokernel (G.map f)\ninst\u271d : PreservesColimit (parallelPair f 0) G\n\u22a2 CategoryStruct.comp (cokernel.\u03c0 (G.map f)) (PreservesCokernel.iso G f).inv =\n    CategoryStruct.comp (cokernel.\u03c0 (G.map f)) (cokernelComparison f G)"}, {"line": "simp [PreservesCokernel.iso]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preservesKernel_zero' (f : X \u27f6 Y) (hf : f = 0) :\n    PreservesLimit (parallelPair f 0) G := by\n  rw [hf]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Kernels.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D]", "{X Y : C} {f : X \u27f6 Y} (c : KernelFork f)", "(G : C \u2964 D) [Functor.PreservesZeroMorphisms G]", "(f)", "[HasKernel f]", "[HasKernel (G.map f)]", "[PreservesLimit (parallelPair f 0) G]", "{X Y : C} {f : X \u27f6 Y} (c : CokernelCofork f)", "(G : C \u2964 D) [Functor.PreservesZeroMorphisms G]", "(f)", "[HasCokernel f]", "[HasCokernel (G.map f)]", "[PreservesColimit (parallelPair f 0) G]", "(X Y : C) (G : C \u2964 D) [Functor.PreservesZeroMorphisms G]", "{X Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b3 : HasZeroMorphisms C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\ninst\u271d\u00b9 : HasZeroMorphisms D\nX Y : C\nG : CategoryTheory.Functor C D\ninst\u271d : G.PreservesZeroMorphisms\nf : X \u27f6 Y\nhf : f = 0\n\u22a2 PreservesLimit (parallelPair f 0) G"}, {"line": "rw [hf]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b3 : HasZeroMorphisms C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\ninst\u271d\u00b9 : HasZeroMorphisms D\nX Y : C\nG : CategoryTheory.Functor C D\ninst\u271d : G.PreservesZeroMorphisms\nf : X \u27f6 Y\nhf : f = 0\n\u22a2 PreservesLimit (parallelPair 0 0) G"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preservesCokernel_zero' (f : X \u27f6 Y) (hf : f = 0) :\n    PreservesColimit (parallelPair f 0) G := by\n  rw [hf]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Kernels.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D]", "{X Y : C} {f : X \u27f6 Y} (c : KernelFork f)", "(G : C \u2964 D) [Functor.PreservesZeroMorphisms G]", "(f)", "[HasKernel f]", "[HasKernel (G.map f)]", "[PreservesLimit (parallelPair f 0) G]", "{X Y : C} {f : X \u27f6 Y} (c : CokernelCofork f)", "(G : C \u2964 D) [Functor.PreservesZeroMorphisms G]", "(f)", "[HasCokernel f]", "[HasCokernel (G.map f)]", "[PreservesColimit (parallelPair f 0) G]", "(X Y : C) (G : C \u2964 D) [Functor.PreservesZeroMorphisms G]", "{X Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b3 : HasZeroMorphisms C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\ninst\u271d\u00b9 : HasZeroMorphisms D\nX Y : C\nG : CategoryTheory.Functor C D\ninst\u271d : G.PreservesZeroMorphisms\nf : X \u27f6 Y\nhf : f = 0\n\u22a2 PreservesColimit (parallelPair f 0) G"}, {"line": "rw [hf]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b3 : HasZeroMorphisms C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\ninst\u271d\u00b9 : HasZeroMorphisms D\nX Y : C\nG : CategoryTheory.Functor C D\ninst\u271d : G.PreservesZeroMorphisms\nf : X \u27f6 Y\nhf : f = 0\n\u22a2 PreservesColimit (parallelPair 0 0) G"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PreservesPullback.iso_hom_fst :\n    (PreservesPullback.iso G f g).hom \u226b pullback.fst _ _ = G.map (pullback.fst f g) := by\n  simp [PreservesPullback.iso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {h : W \u27f6 X} {k : W \u27f6 Y} (comm : h \u226b f = k \u226b g)", "(f g) [PreservesLimit (cospan f g) G]", "[HasPullback f g] [HasPullback (G.map f) (G.map g)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d\u00b2 : PreservesLimit (cospan f g) G\ninst\u271d\u00b9 : HasPullback f g\ninst\u271d : HasPullback (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (PreservesPullback.iso G f g).hom (pullback.fst (G.map f) (G.map g)) = G.map (pullback.fst f g)"}, {"line": "simp [PreservesPullback.iso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PreservesPullback.iso_hom_snd :\n    (PreservesPullback.iso G f g).hom \u226b pullback.snd _ _ = G.map (pullback.snd f g) := by\n  simp [PreservesPullback.iso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {h : W \u27f6 X} {k : W \u27f6 Y} (comm : h \u226b f = k \u226b g)", "(f g) [PreservesLimit (cospan f g) G]", "[HasPullback f g] [HasPullback (G.map f) (G.map g)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d\u00b2 : PreservesLimit (cospan f g) G\ninst\u271d\u00b9 : HasPullback f g\ninst\u271d : HasPullback (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (PreservesPullback.iso G f g).hom (pullback.snd (G.map f) (G.map g)) = G.map (pullback.snd f g)"}, {"line": "simp [PreservesPullback.iso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PreservesPullback.iso_inv_fst :\n    (PreservesPullback.iso G f g).inv \u226b G.map (pullback.fst f g) = pullback.fst _ _ := by\n  simp [PreservesPullback.iso, Iso.inv_comp_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {h : W \u27f6 X} {k : W \u27f6 Y} (comm : h \u226b f = k \u226b g)", "(f g) [PreservesLimit (cospan f g) G]", "[HasPullback f g] [HasPullback (G.map f) (G.map g)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d\u00b2 : PreservesLimit (cospan f g) G\ninst\u271d\u00b9 : HasPullback f g\ninst\u271d : HasPullback (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (PreservesPullback.iso G f g).inv (G.map (pullback.fst f g)) = pullback.fst (G.map f) (G.map g)"}, {"line": "simp [PreservesPullback.iso, Iso.inv_comp_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PreservesPullback.iso_inv_snd :\n    (PreservesPullback.iso G f g).inv \u226b G.map (pullback.snd f g) = pullback.snd _ _ := by\n  simp [PreservesPullback.iso, Iso.inv_comp_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {h : W \u27f6 X} {k : W \u27f6 Y} (comm : h \u226b f = k \u226b g)", "(f g) [PreservesLimit (cospan f g) G]", "[HasPullback f g] [HasPullback (G.map f) (G.map g)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d\u00b2 : PreservesLimit (cospan f g) G\ninst\u271d\u00b9 : HasPullback f g\ninst\u271d : HasPullback (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (PreservesPullback.iso G f g).inv (G.map (pullback.snd f g)) = pullback.snd (G.map f) (G.map g)"}, {"line": "simp [PreservesPullback.iso, Iso.inv_comp_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PreservesPushout.inl_iso_hom :\n    pushout.inl _ _ \u226b (PreservesPushout.iso G f g).hom = G.map (pushout.inl _ _) := by\n  delta PreservesPushout.iso\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {h : W \u27f6 X} {k : W \u27f6 Y} (comm : h \u226b f = k \u226b g)", "(f g) [PreservesLimit (cospan f g) G]", "[HasPullback f g] [HasPullback (G.map f) (G.map g)]", "{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{W X Y : C} {f : W \u27f6 X} {g : W \u27f6 Y} (c : PushoutCocone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {h : X \u27f6 Z} {k : Y \u27f6 Z} {f : W \u27f6 X} {g : W \u27f6 Y} (comm : f \u226b h = g \u226b k)", "(f g) [PreservesColimit (span f g) G]", "[HasPushout f g] [HasPushout (G.map f) (G.map g)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : W \u27f6 X\ng : W \u27f6 Y\ninst\u271d\u00b2 : PreservesColimit (span f g) G\ninst\u271d\u00b9 : HasPushout f g\ninst\u271d : HasPushout (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (pushout.inl (G.map f) (G.map g)) (PreservesPushout.iso G f g).hom = G.map (pushout.inl f g)"}, {"line": "delta PreservesPushout.iso", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : W \u27f6 X\ng : W \u27f6 Y\ninst\u271d\u00b2 : PreservesColimit (span f g) G\ninst\u271d\u00b9 : HasPushout f g\ninst\u271d : HasPushout (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (pushout.inl (G.map f) (G.map g))\n      ((colimit.isColimit (span (G.map f) (G.map g))).coconePointUniqueUpToIso\n          (isColimitOfHasPushoutOfPreservesColimit G f g)).hom =\n    G.map (pushout.inl f g)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PreservesPushout.inr_iso_hom :\n    pushout.inr _ _ \u226b (PreservesPushout.iso G f g).hom = G.map (pushout.inr _ _) := by\n  delta PreservesPushout.iso\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {h : W \u27f6 X} {k : W \u27f6 Y} (comm : h \u226b f = k \u226b g)", "(f g) [PreservesLimit (cospan f g) G]", "[HasPullback f g] [HasPullback (G.map f) (G.map g)]", "{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{W X Y : C} {f : W \u27f6 X} {g : W \u27f6 Y} (c : PushoutCocone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {h : X \u27f6 Z} {k : Y \u27f6 Z} {f : W \u27f6 X} {g : W \u27f6 Y} (comm : f \u226b h = g \u226b k)", "(f g) [PreservesColimit (span f g) G]", "[HasPushout f g] [HasPushout (G.map f) (G.map g)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : W \u27f6 X\ng : W \u27f6 Y\ninst\u271d\u00b2 : PreservesColimit (span f g) G\ninst\u271d\u00b9 : HasPushout f g\ninst\u271d : HasPushout (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (pushout.inr (G.map f) (G.map g)) (PreservesPushout.iso G f g).hom = G.map (pushout.inr f g)"}, {"line": "delta PreservesPushout.iso", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : W \u27f6 X\ng : W \u27f6 Y\ninst\u271d\u00b2 : PreservesColimit (span f g) G\ninst\u271d\u00b9 : HasPushout f g\ninst\u271d : HasPushout (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (pushout.inr (G.map f) (G.map g))\n      ((colimit.isColimit (span (G.map f) (G.map g))).coconePointUniqueUpToIso\n          (isColimitOfHasPushoutOfPreservesColimit G f g)).hom =\n    G.map (pushout.inr f g)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PreservesPushout.inl_iso_inv :\n    G.map (pushout.inl _ _) \u226b (PreservesPushout.iso G f g).inv = pushout.inl _ _ := by\n  simp [PreservesPushout.iso, Iso.comp_inv_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {h : W \u27f6 X} {k : W \u27f6 Y} (comm : h \u226b f = k \u226b g)", "(f g) [PreservesLimit (cospan f g) G]", "[HasPullback f g] [HasPullback (G.map f) (G.map g)]", "{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{W X Y : C} {f : W \u27f6 X} {g : W \u27f6 Y} (c : PushoutCocone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {h : X \u27f6 Z} {k : Y \u27f6 Z} {f : W \u27f6 X} {g : W \u27f6 Y} (comm : f \u226b h = g \u226b k)", "(f g) [PreservesColimit (span f g) G]", "[HasPushout f g] [HasPushout (G.map f) (G.map g)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : W \u27f6 X\ng : W \u27f6 Y\ninst\u271d\u00b2 : PreservesColimit (span f g) G\ninst\u271d\u00b9 : HasPushout f g\ninst\u271d : HasPushout (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (G.map (pushout.inl f g)) (PreservesPushout.iso G f g).inv = pushout.inl (G.map f) (G.map g)"}, {"line": "simp [PreservesPushout.iso, Iso.comp_inv_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PreservesPushout.inr_iso_inv :\n    G.map (pushout.inr _ _) \u226b (PreservesPushout.iso G f g).inv = pushout.inr _ _ := by\n  simp [PreservesPushout.iso, Iso.comp_inv_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Functor"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} {h : W \u27f6 X} {k : W \u27f6 Y} (comm : h \u226b f = k \u226b g)", "(f g) [PreservesLimit (cospan f g) G]", "[HasPullback f g] [HasPullback (G.map f) (G.map g)]", "{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{W X Y : C} {f : W \u27f6 X} {g : W \u27f6 Y} (c : PushoutCocone f g) (G : C \u2964 D)", "(G : C \u2964 D)", "{W X Y Z : C} {h : X \u27f6 Z} {k : Y \u27f6 Z} {f : W \u27f6 X} {g : W \u27f6 Y} (comm : f \u226b h = g \u226b k)", "(f g) [PreservesColimit (span f g) G]", "[HasPushout f g] [HasPushout (G.map f) (G.map g)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : W \u27f6 X\ng : W \u27f6 Y\ninst\u271d\u00b2 : PreservesColimit (span f g) G\ninst\u271d\u00b9 : HasPushout f g\ninst\u271d : HasPushout (G.map f) (G.map g)\n\u22a2 CategoryStruct.comp (G.map (pushout.inr f g)) (PreservesPushout.iso G f g).inv = pushout.inr (G.map f) (G.map g)"}, {"line": "simp [PreservesPushout.iso, Iso.comp_inv_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma PreservesTerminal.of_iso_comparison [i : IsIso (terminalComparison G)] :\n    PreservesLimit (Functor.empty.{0} C) G := by\n  apply preservesLimit_of_preserves_limit_cone terminalIsTerminal\n  apply (isLimitMapConeEmptyConeEquiv _ _).symm _\n  exact @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (Functor.empty.{0} D)) i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Terminal.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(G : C \u2964 D)", "(X : C)", "[HasTerminal C]", "[HasTerminal D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasTerminal D\ni : IsIso (terminalComparison G)\n\u22a2 PreservesLimit (Functor.empty C) G"}, {"line": "apply preservesLimit_of_preserves_limit_cone terminalIsTerminal", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasTerminal D\ni : IsIso (terminalComparison G)\n\u22a2 IsLimit (G.mapCone (asEmptyCone (\u22a4_ C)))\n---\nC : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasTerminal D\ni : IsIso (terminalComparison G)\n\u22a2 HasTerminal C"}, {"line": "apply (isLimitMapConeEmptyConeEquiv _ _).symm _", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasTerminal D\ni : IsIso (terminalComparison G)\n\u22a2 HasTerminal C\n---\nC : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasTerminal D\ni : IsIso (terminalComparison G)\n\u22a2 IsTerminal (G.obj (\u22a4_ C))\n---\nC : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasTerminal D\ni : IsIso (terminalComparison G)\n\u22a2 HasTerminal C"}, {"line": "exact @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (Functor.empty.{0} D)) i", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasTerminal D\ni : IsIso (terminalComparison G)\n\u22a2 IsTerminal (G.obj (\u22a4_ C))"}]}
{"declaration": "lemma PreservesInitial.of_iso_comparison [i : IsIso (initialComparison G)] :\n    PreservesColimit (Functor.empty.{0} C) G := by\n  apply preservesColimit_of_preserves_colimit_cocone initialIsInitial\n  apply (isColimitMapCoconeEmptyCoconeEquiv _ _).symm _\n  exact @IsColimit.ofPointIso _ _ _ _ _ _ _ (colimit.isColimit (Functor.empty.{0} D)) i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Terminal.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(G : C \u2964 D)", "(X : C)", "[HasTerminal C]", "[HasTerminal D]", "[PreservesLimit (Functor.empty.{0} C) G]", "[HasInitial C]", "[HasInitial D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u2074 : HasTerminal C\ninst\u271d\u00b3 : HasTerminal D\ninst\u271d\u00b2 : PreservesLimit (Functor.empty C) G\ninst\u271d\u00b9 : HasInitial C\ninst\u271d : HasInitial D\ni : IsIso (initialComparison G)\n\u22a2 PreservesColimit (Functor.empty C) G"}, {"line": "apply preservesColimit_of_preserves_colimit_cocone initialIsInitial", "tactic_state": "C : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u2074 : HasTerminal C\ninst\u271d\u00b3 : HasTerminal D\ninst\u271d\u00b2 : PreservesLimit (Functor.empty C) G\ninst\u271d\u00b9 : HasInitial C\ninst\u271d : HasInitial D\ni : IsIso (initialComparison G)\n\u22a2 IsColimit (G.mapCocone (asEmptyCocone (\u22a5_ C)))\n---\nC : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u2074 : HasTerminal C\ninst\u271d\u00b3 : HasTerminal D\ninst\u271d\u00b2 : PreservesLimit (Functor.empty C) G\ninst\u271d\u00b9 : HasInitial C\ninst\u271d : HasInitial D\ni : IsIso (initialComparison G)\n\u22a2 HasInitial C"}, {"line": "apply (isColimitMapCoconeEmptyCoconeEquiv _ _).symm _", "tactic_state": "C : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u2074 : HasTerminal C\ninst\u271d\u00b3 : HasTerminal D\ninst\u271d\u00b2 : PreservesLimit (Functor.empty C) G\ninst\u271d\u00b9 : HasInitial C\ninst\u271d : HasInitial D\ni : IsIso (initialComparison G)\n\u22a2 HasInitial C\n---\nC : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u2074 : HasTerminal C\ninst\u271d\u00b3 : HasTerminal D\ninst\u271d\u00b2 : PreservesLimit (Functor.empty C) G\ninst\u271d\u00b9 : HasInitial C\ninst\u271d : HasInitial D\ni : IsIso (initialComparison G)\n\u22a2 IsInitial (G.obj (\u22a5_ C))\n---\nC : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u2074 : HasTerminal C\ninst\u271d\u00b3 : HasTerminal D\ninst\u271d\u00b2 : PreservesLimit (Functor.empty C) G\ninst\u271d\u00b9 : HasInitial C\ninst\u271d : HasInitial D\ni : IsIso (initialComparison G)\n\u22a2 HasInitial C"}, {"line": "exact @IsColimit.ofPointIso _ _ _ _ _ _ _ (colimit.isColimit (Functor.empty.{0} D)) i", "tactic_state": "C : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\nG : CategoryTheory.Functor C D\ninst\u271d\u2074 : HasTerminal C\ninst\u271d\u00b3 : HasTerminal D\ninst\u271d\u00b2 : PreservesLimit (Functor.empty C) G\ninst\u271d\u00b9 : HasInitial C\ninst\u271d : HasInitial D\ni : IsIso (initialComparison G)\n\u22a2 IsInitial (G.obj (\u22a5_ C))"}]}
{"declaration": "theorem PreservesImage.iso_hom_\u03b9 :\n    (PreservesImage.iso F f).hom \u226b Abelian.image.\u03b9 (F.map f) = F.map (Abelian.image.\u03b9 f) := by\n  simp [iso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/AbelianImages.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C] [HasKernels C] [HasCokernels C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D] [HasKernels D] [HasCokernels D]", "(F : C \u2964 D) [F.PreservesZeroMorphisms] [PreservesLimitsOfShape WalkingParallelPair F]", "{X Y : C} (f : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp sorry (Abelian.image.\u03b9 (F.map f)) = F.map (Abelian.image.\u03b9 f)"}, {"line": "simp [iso]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (sorry ()) (kernel.\u03b9 (cokernel.\u03c0 (F.map f))) = F.map (kernel.\u03b9 (cokernel.\u03c0 f))"}]}
{"declaration": "theorem PreservesImage.iso_inv_\u03b9 :\n    (PreservesImage.iso F f).inv \u226b F.map (Abelian.image.\u03b9 f) = Abelian.image.\u03b9 (F.map f) := by\n  simp [iso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/AbelianImages.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C] [HasKernels C] [HasCokernels C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D] [HasKernels D] [HasCokernels D]", "(F : C \u2964 D) [F.PreservesZeroMorphisms] [PreservesLimitsOfShape WalkingParallelPair F]", "{X Y : C} (f : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp sorry (F.map (Abelian.image.\u03b9 f)) = Abelian.image.\u03b9 (F.map f)"}, {"line": "simp [iso]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (sorry ()) (F.map (kernel.\u03b9 (cokernel.\u03c0 f))) = kernel.\u03b9 (cokernel.\u03c0 (F.map f))"}]}
{"declaration": "theorem PreservesImage.factorThruImage_iso_inv :\n    Abelian.factorThruImage (F.map f) \u226b (PreservesImage.iso F f).inv =\n      F.map (Abelian.factorThruImage f) := by\n  simp [Iso.comp_inv_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/AbelianImages.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C] [HasKernels C] [HasCokernels C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D] [HasKernels D] [HasCokernels D]", "(F : C \u2964 D) [F.PreservesZeroMorphisms] [PreservesLimitsOfShape WalkingParallelPair F]", "{X Y : C} (f : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (Abelian.factorThruImage (F.map f)) sorry = F.map (Abelian.factorThruImage f)"}, {"line": "simp [Iso.comp_inv_eq]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (Abelian.factorThruImage (F.map f)) (sorry ()) = F.map (Abelian.factorThruImage f)"}]}
{"declaration": "theorem PreservesCoimage.iso_hom_\u03c0 :\n    F.map (Abelian.coimage.\u03c0 f) \u226b (PreservesCoimage.iso F f).hom = Abelian.coimage.\u03c0 (F.map f) := by\n  simp [iso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/AbelianImages.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C] [HasKernels C] [HasCokernels C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D] [HasKernels D] [HasCokernels D]", "(F : C \u2964 D) [F.PreservesZeroMorphisms] [PreservesLimitsOfShape WalkingParallelPair F]", "{X Y : C} (f : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (F.map (Abelian.coimage.\u03c0 f)) sorry = Abelian.coimage.\u03c0 (F.map f)"}, {"line": "simp [iso]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (F.map (cokernel.\u03c0 (kernel.\u03b9 f))) (sorry ()) = cokernel.\u03c0 (kernel.\u03b9 (F.map f))"}]}
{"declaration": "theorem PreservesCoimage.factorThruCoimage_iso_hom :\n    (PreservesCoimage.iso F f).hom \u226b Abelian.factorThruCoimage (F.map f) =\n      F.map (Abelian.factorThruCoimage f) := by\n  simp [\u2190 Iso.eq_inv_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/AbelianImages.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C] [HasKernels C] [HasCokernels C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D] [HasKernels D] [HasCokernels D]", "(F : C \u2964 D) [F.PreservesZeroMorphisms] [PreservesLimitsOfShape WalkingParallelPair F]", "{X Y : C} (f : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp sorry (Abelian.factorThruCoimage (F.map f)) = F.map (Abelian.factorThruCoimage f)"}, {"line": "simp [\u2190 Iso.eq_inv_comp]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (sorry ()) (Abelian.factorThruCoimage (F.map f)) = F.map (Abelian.factorThruCoimage f)"}]}
{"declaration": "theorem PreservesCoimage.iso_inv_\u03c0 :\n    Abelian.coimage.\u03c0 (F.map f) \u226b (PreservesCoimage.iso F f).inv = F.map (Abelian.coimage.\u03c0 f) := by\n  simp [Iso.comp_inv_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Preserves/Shapes/AbelianImages.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [HasZeroMorphisms C] [HasKernels C] [HasCokernels C]", "{D : Type u\u2082} [Category.{v\u2082} D] [HasZeroMorphisms D] [HasKernels D] [HasCokernels D]", "(F : C \u2964 D) [F.PreservesZeroMorphisms] [PreservesLimitsOfShape WalkingParallelPair F]", "{X Y : C} (f : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (Abelian.coimage.\u03c0 (F.map f)) sorry = F.map (Abelian.coimage.\u03c0 f)"}, {"line": "simp [Iso.comp_inv_eq]", "tactic_state": "C : Type u\u2081\ninst\u271d\u2079 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2078 : HasZeroMorphisms C\ninst\u271d\u2077 : HasKernels C\ninst\u271d\u2076 : HasCokernels C\nD : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2074 : HasZeroMorphisms D\ninst\u271d\u00b3 : HasKernels D\ninst\u271d\u00b2 : HasCokernels D\nF : CategoryTheory.Functor C D\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : PreservesLimitsOfShape WalkingParallelPair F\nX Y : C\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (cokernel.\u03c0 (kernel.\u03b9 (F.map f))) (sorry ()) = F.map (cokernel.\u03c0 (kernel.\u03b9 f))"}]}
{"declaration": "theorem isoExt_hom_m : (isoExt hF hF').hom \u226b F'.m = F.m := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f}", "(f)", "{f}", "{F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MonoFactorisation : ?m.2104\nIsImage : ?m.2186\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nx\u271d : Sort u_1\nisoExt : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp", "tactic_state": "MonoFactorisation : ?m.2104\nIsImage : ?m.2186\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nx\u271d : Sort u_1\nisoExt : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "theorem isoExt_inv_m : (isoExt hF hF').inv \u226b F.m = F'.m := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f}", "(f)", "{f}", "{F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MonoFactorisation : ?m.2104\nIsImage : ?m.2186\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nx\u271d : Sort u_1\nisoExt : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp", "tactic_state": "MonoFactorisation : ?m.2104\nIsImage : ?m.2186\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nx\u271d : Sort u_1\nisoExt : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "theorem e_isoExt_hom : F.e \u226b (isoExt hF hF').hom = F'.e := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f}", "(f)", "{f}", "{F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MonoFactorisation : ?m.2104\nIsImage : ?m.2186\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nx\u271d : Sort u_1\nisoExt : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp", "tactic_state": "MonoFactorisation : ?m.2104\nIsImage : ?m.2186\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nx\u271d : Sort u_1\nisoExt : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "theorem e_isoExt_inv : F'.e \u226b (isoExt hF hF').inv = F.e := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f}", "(f)", "{f}", "{F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MonoFactorisation : ?m.2104\nIsImage : ?m.2186\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nx\u271d : Sort u_1\nisoExt : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp", "tactic_state": "MonoFactorisation : ?m.2104\nIsImage : ?m.2186\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nx\u271d : Sort u_1\nisoExt : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "theorem imageMonoIsoSource_inv_\u03b9 [Mono f] : (imageMonoIsoSource f).inv \u226b image.\u03b9 f = f := by\n  simp [imageMonoIsoSource]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f}", "(f)", "{f}", "{F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F')", "(f)", "[HasImage f]", "{f}", "(C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MonoFactorisation : ?m.9622\nIsImage : ?m.9704\nC\u271d : Type u\ninst\u271d\u00b2 : Category.{v, u} C\u271d\nX\u271d Y\u271d : C\u271d\nf\u271d : X\u271d \u27f6 Y\u271d\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nx\u271d : Sort u_1\nimageMonoIsoSource : x\u271d\ninst\u271d : Mono f\n\u22a2 CategoryStruct.comp sorry sorry = f"}, {"line": "simp [imageMonoIsoSource]", "tactic_state": "MonoFactorisation : ?m.9622\nIsImage : ?m.9704\nC\u271d : Type u\ninst\u271d\u00b2 : Category.{v, u} C\u271d\nX\u271d Y\u271d : C\u271d\nf\u271d : X\u271d \u27f6 Y\u271d\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nx\u271d : Sort u_1\nimageMonoIsoSource : x\u271d\ninst\u271d : Mono f\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = f"}]}
{"declaration": "theorem image.factor_map :\n    factorThruImage f.hom \u226b image.map sq = sq.left \u226b factorThruImage g.hom := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f}", "(f)", "{f}", "{F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F')", "(f)", "[HasImage f]", "{f}", "(C)", "{f}", "{f' : X \u27f6 Y} [HasImage f] [HasImage f']", "{Z : C} (g : Y \u27f6 Z)", "[HasEqualizers C]", "{C : Type u} [Category.{v} C]", "{f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f \u27f6 g)", "[HasImageMap sq]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MonoFactorisation : ?m.21449\nIsImage : ?m.21531\nC\u271d : Type u\ninst\u271d\u00b9 : Category.{v, u} C\u271d\nX Y : C\u271d\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nZ : C\u271d\ng : Y \u27f6 Z\nC : Type u\ninst\u271d : Category.{v, u} C\nx\u271d : Sort u_1\nfactorThruImage : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp", "tactic_state": "MonoFactorisation : ?m.21449\nIsImage : ?m.21531\nC\u271d : Type u\ninst\u271d\u00b9 : Category.{v, u} C\u271d\nX Y : C\u271d\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nZ : C\u271d\ng : Y \u27f6 Z\nC : Type u\ninst\u271d : Category.{v, u} C\nx\u271d : Sort u_1\nfactorThruImage : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "theorem image.map_\u03b9 : image.map sq \u226b image.\u03b9 g.hom = image.\u03b9 f.hom \u226b sq.right := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f}", "(f)", "{f}", "{F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F')", "(f)", "[HasImage f]", "{f}", "(C)", "{f}", "{f' : X \u27f6 Y} [HasImage f] [HasImage f']", "{Z : C} (g : Y \u27f6 Z)", "[HasEqualizers C]", "{C : Type u} [Category.{v} C]", "{f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f \u27f6 g)", "[HasImageMap sq]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MonoFactorisation : ?m.21449\nIsImage : ?m.21531\nC\u271d : Type u\ninst\u271d\u00b9 : Category.{v, u} C\u271d\nX Y : C\u271d\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nZ : C\u271d\ng : Y \u27f6 Z\nC : Type u\ninst\u271d : Category.{v, u} C\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp", "tactic_state": "MonoFactorisation : ?m.21449\nIsImage : ?m.21531\nC\u271d : Type u\ninst\u271d\u00b9 : Category.{v, u} C\u271d\nX Y : C\u271d\nf : X \u27f6 Y\nF : sorry\nF' : sorry\nhF : sorry\nhF' : sorry\nZ : C\u271d\ng : Y \u27f6 Z\nC : Type u\ninst\u271d : Category.{v, u} C\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "theorem KernelFork.app_one (s : KernelFork f) : s.\u03c0.app one = 0 := by\n  simp [Fork.app_one_eq_\u03b9_comp_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["{C : Type u} [Category.{v} C]", "[HasZeroMorphisms C]", "{X Y : C} (f : X \u27f6 Y)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nKernelFork : x\u271d\ns : sorry\n\u22a2 sorry = 0"}, {"line": "simp [Fork.app_one_eq_\u03b9_comp_right]", "tactic_state": "x\u271d : Sort u_1\nKernelFork : x\u271d\ns : sorry\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem CokernelCofork.\u03c0_eq_zero (s : CokernelCofork f) : s.\u03b9.app zero = 0 := by\n  simp [Cofork.app_zero_eq_comp_\u03c0_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair", "ZeroObject"], "variables": ["{C : Type u} [Category.{v} C]", "[HasZeroMorphisms C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f} {X' Y' : C} {f' : X' \u27f6 Y'}", "[HasKernel f]", "{f}", "[HasZeroObject C]", "(X Y)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCokernelCofork : x\u271d\ns : sorry\n\u22a2 sorry = 0"}, {"line": "simp [Cofork.app_zero_eq_comp_\u03c0_right]", "tactic_state": "x\u271d : Sort u_1\nCokernelCofork : x\u271d\ns : sorry\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem kernelFactorThruImage_hom_comp_\u03b9 :\n    (kernelFactorThruImage f).hom \u226b kernel.\u03b9 f = kernel.\u03b9 (factorThruImage f) := by\n  simp [kernelFactorThruImage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair", "ZeroObject", "ZeroObject"], "variables": ["{C : Type u} [Category.{v} C]", "[HasZeroMorphisms C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f} {X' Y' : C} {f' : X' \u27f6 Y'}", "[HasKernel f]", "{f}", "[HasZeroObject C]", "(X Y)", "{f}", "{f} {X' Y' : C} {f' : X' \u27f6 Y'}", "[HasCokernel f]", "{f}", "[HasZeroObject C]", "{f}", "(f : X \u27f6 Y) [HasKernel f] [HasImage f] [HasKernel (factorThruImage f)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nkernelFactorThruImage : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [kernelFactorThruImage]", "tactic_state": "x\u271d : Sort u_1\nkernelFactorThruImage : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "theorem kernelFactorThruImage_inv_comp_\u03b9 :\n    (kernelFactorThruImage f).inv \u226b kernel.\u03b9 (factorThruImage f) = kernel.\u03b9 f := by\n  simp [kernelFactorThruImage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits.WalkingParallelPair", "ZeroObject", "ZeroObject"], "variables": ["{C : Type u} [Category.{v} C]", "[HasZeroMorphisms C]", "{X Y : C} (f : X \u27f6 Y)", "{f}", "{f} {X' Y' : C} {f' : X' \u27f6 Y'}", "[HasKernel f]", "{f}", "[HasZeroObject C]", "(X Y)", "{f}", "{f} {X' Y' : C} {f' : X' \u27f6 Y'}", "[HasCokernel f]", "{f}", "[HasZeroObject C]", "{f}", "(f : X \u27f6 Y) [HasKernel f] [HasImage f] [HasKernel (factorThruImage f)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nkernelFactorThruImage : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [kernelFactorThruImage]", "tactic_state": "x\u271d : Sort u_1\nkernelFactorThruImage : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma hasBinaryProduct_of_products : HasBinaryProduct (\u220f\u1d9c (fun (i : {x : I // P x}) \u21a6 X i.val))\n    (\u220f\u1d9c (fun (i : {x : I // \u00ac P x}) \u21a6 X i.val)) := by\n  classical exact \u27e8Pi.binaryFanOfProp X P, Pi.binaryFanOfPropIsLimit X P\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/PiProd.lean", "context": {"open": [], "variables": ["{C I : Type*} [Category C] {X Y : I \u2192 C}", "(X) in", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nHasBinaryProduct : x\u271d\n\u22a2 sorry"}, {"line": "classical exact \u27e8Pi.binaryFanOfProp X P, Pi.binaryFanOfPropIsLimit X P\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasReflexiveCoequalizer_iff_hasCoequalizer :\n    HasColimit F \u2194 HasCoequalizer (F.map left) (F.map right) := by\n  simpa only [hasColimit_iff_hasInitial_cocone]\n    using Equivalence.hasInitial_iff (reflexiveCoforkEquivCofork F)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean", "context": {"open": ["WalkingReflexivePair", "Hom", "WalkingReflexivePair.Hom in", "WalkingReflexivePair", "WalkingReflexivePair WalkingReflexivePair.Hom", "WalkingReflexivePair WalkingReflexivePair.Hom", "WalkingReflexivePair WalkingReflexivePair.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "{A B : C} {f g : A \u27f6 B}", "{F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G)", "(C)", "{C : Type u} [Category.{v} C]", "{C : Type u} [Category.{v} C]", "{C : Type u} [Category.{v} C]", "{A B : C}", "{A B : C}", "(f g : A \u27f6 B) (s : B \u27f6 A) {sl : s \u226b f = \ud835\udfd9 B} {sr : s \u226b g = \ud835\udfd9 B}", "{C : Type u} [Category.{v} C]", "{F G : WalkingReflexivePair \u2964 C}", "{F G : WalkingReflexivePair \u2964 C}", "(F)", "{F : WalkingReflexivePair \u2964 C}", "(F : WalkingReflexivePair \u2964 C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nHasColimit : x\u271d\u00b9\nx\u271d : Sort u_2\nHasCoequalizer : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [hasColimit_iff_hasInitial_cocone]\n    using Equivalence.hasInitial_iff (reflexiveCoforkEquivCofork F)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StrongEpi.iff_of_arrow_iso {A B A' B' : C} {f : A \u27f6 B} {g : A' \u27f6 B'}\n    (e : Arrow.mk f \u2245 Arrow.mk g) : StrongEpi f \u2194 StrongEpi g := by\n  constructor <;> intro\n  exacts [StrongEpi.of_arrow_iso e, StrongEpi.of_arrow_iso e.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/StrongEpi.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C]", "{P Q : C}", "{R : C} (f : P \u27f6 Q) (g : Q \u27f6 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_6\nx\u271d : Sort u_1\nStrongEpi : x\u271d\nA B A' B' : C\nf : sorry\ng : sorry\ne : sorry \u2245 sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor <;> intro", "tactic_state": "case mp\nC : Type u_6\nx\u271d : Sort u_1\nStrongEpi : x\u271d\nA B A' B' : C\nf : sorry\ng : sorry\ne : sorry \u2245 sorry\na\u271d : sorry\n\u22a2 sorry\n---\ncase mpr\nC : Type u_6\nx\u271d : Sort u_1\nStrongEpi : x\u271d\nA B A' B' : C\nf : sorry\ng : sorry\ne : sorry \u2245 sorry\na\u271d : sorry\n\u22a2 sorry"}, {"line": "exacts [StrongEpi.of_arrow_iso e, StrongEpi.of_arrow_iso e.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StrongMono.iff_of_arrow_iso {A B A' B' : C} {f : A \u27f6 B} {g : A' \u27f6 B'}\n    (e : Arrow.mk f \u2245 Arrow.mk g) : StrongMono f \u2194 StrongMono g := by\n  constructor <;> intro\n  exacts [StrongMono.of_arrow_iso e, StrongMono.of_arrow_iso e.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/StrongEpi.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C]", "{P Q : C}", "{R : C} (f : P \u27f6 Q) (g : Q \u27f6 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_6\nx\u271d : Sort u_1\nStrongMono : x\u271d\nA B A' B' : C\nf : sorry\ng : sorry\ne : sorry \u2245 sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor <;> intro", "tactic_state": "case mp\nC : Type u_6\nx\u271d : Sort u_1\nStrongMono : x\u271d\nA B A' B' : C\nf : sorry\ng : sorry\ne : sorry \u2245 sorry\na\u271d : sorry\n\u22a2 sorry\n---\ncase mpr\nC : Type u_6\nx\u271d : Sort u_1\nStrongMono : x\u271d\nA B A' B' : C\nf : sorry\ng : sorry\ne : sorry \u2245 sorry\na\u271d : sorry\n\u22a2 sorry"}, {"line": "exacts [StrongMono.of_arrow_iso e, StrongMono.of_arrow_iso e.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Pi.\u03b9_\u03c0_eq_id (b : \u03b2) : Pi.\u03b9 f b \u226b Pi.\u03c0 f b = \ud835\udfd9 _ := by\n  simp [Pi.\u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Sort u_1\nb : \u03b2\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.id (?m.1261 b)"}, {"line": "simp [Pi.\u03b9]", "tactic_state": "\u03b2 : Sort u_1\nb : \u03b2\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.id (?m.1261 b)"}]}
{"declaration": "lemma Pi.\u03b9_\u03c0_of_ne {b c : \u03b2} (h : b \u2260 c) : Pi.\u03b9 f b \u226b Pi.\u03c0 f c = 0 := by\n  simp [Pi.\u03b9, Function.update_of_ne h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Sort u_1\nb c : \u03b2\nh : b \u2260 c\n\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simp [Pi.\u03b9, Function.update_of_ne h.symm]", "tactic_state": "\u03b2 : Sort u_1\nb c : \u03b2\nh : b \u2260 c\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = 0"}]}
{"declaration": "lemma Sigma.\u03b9_\u03c0_eq_id (b : \u03b2) : Sigma.\u03b9 f b \u226b Sigma.\u03c0 f b = \ud835\udfd9 _ := by\n  simp [Sigma.\u03c0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Sort u_1\nb : \u03b2\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.id (?m.1283 b)"}, {"line": "simp [Sigma.\u03c0]", "tactic_state": "\u03b2 : Sort u_1\nb : \u03b2\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.id (?m.1283 b)"}]}
{"declaration": "lemma Sigma.\u03b9_\u03c0_of_ne {b c : \u03b2} (h : b \u2260 c) : Sigma.\u03b9 f b \u226b Sigma.\u03c0 f c = 0 := by\n  simp [Sigma.\u03c0, Function.update_of_ne h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Sort u_1\nb c : \u03b2\nh : b \u2260 c\n\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simp [Sigma.\u03c0, Function.update_of_ne h]", "tactic_state": "\u03b2 : Sort u_1\nb c : \u03b2\nh : b \u2260 c\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = 0"}]}
{"declaration": "lemma prod.inl_fst : prod.inl X Y \u226b prod.fst = \ud835\udfd9 X := by\n  simp [prod.inl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryProduct X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u271d : Type u_1\nX : V\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.id X"}, {"line": "simp [prod.inl]", "tactic_state": "V\u271d : Type u_1\nX : V\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.id X"}]}
{"declaration": "lemma prod.inl_snd : prod.inl X Y \u226b prod.snd = 0 := by\n  simp [prod.inl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryProduct X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simp [prod.inl]", "tactic_state": "\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = 0"}]}
{"declaration": "lemma prod.inr_fst : prod.inr X Y \u226b prod.fst = 0 := by\n  simp [prod.inr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryProduct X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simp [prod.inr]", "tactic_state": "\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = 0"}]}
{"declaration": "lemma prod.inr_snd : prod.inr X Y \u226b prod.snd = \ud835\udfd9 Y := by\n  simp [prod.inr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryProduct X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u271d : Type u_1\nY : V\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.id Y"}, {"line": "simp [prod.inr]", "tactic_state": "V\u271d : Type u_1\nY : V\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.id Y"}]}
{"declaration": "lemma coprod.inl_fst : coprod.inl \u226b coprod.fst X Y = \ud835\udfd9 X := by\n  simp [coprod.fst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryProduct X Y]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryCoproduct X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u271d : Type u_1\nX : V\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.id X"}, {"line": "simp [coprod.fst]", "tactic_state": "V\u271d : Type u_1\nX : V\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.id X"}]}
{"declaration": "lemma coprod.inr_fst : coprod.inr \u226b coprod.fst X Y = 0 := by\n  simp [coprod.fst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryProduct X Y]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryCoproduct X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simp [coprod.fst]", "tactic_state": "\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = 0"}]}
{"declaration": "lemma coprod.inl_snd : coprod.inl \u226b coprod.snd X Y = 0 := by\n  simp [coprod.snd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryProduct X Y]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryCoproduct X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simp [coprod.snd]", "tactic_state": "\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = 0"}]}
{"declaration": "lemma coprod.inr_snd : coprod.inr \u226b coprod.snd X Y = \ud835\udfd9 Y := by\n  simp [coprod.snd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "Opposite HasZeroMorphisms", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["(C : Type u) [Category.{v} C]", "(D : Type u') [Category.{v'} D]", "{C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms D]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "{D}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "[HasZeroObject C]", "[HasZeroMorphisms C] [HasZeroObject C] {F : D \u2964 C}", "[HasZeroMorphisms C]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasProduct f]", "[HasZeroMorphisms C] {\u03b2 : Type w} [DecidableEq \u03b2] (f : \u03b2 \u2192 C) [HasCoproduct f]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryProduct X Y]", "[HasZeroMorphisms C] (X Y : C) [HasBinaryCoproduct X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u271d : Type u_1\nY : V\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.id Y"}, {"line": "simp [coprod.snd]", "tactic_state": "V\u271d : Type u_1\nY : V\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.id Y"}]}
{"declaration": "theorem Functor.isZero (F : C \u2964 D) (hF : \u2200 X, IsZero (F.obj X)) : IsZero F := by\n  constructor <;> intro G <;> refine \u27e8\u27e8\u27e8?_\u27e9, ?_\u27e9\u27e9\n  \u00b7 refine\n      { app := fun X => (hF _).to_ _\n        naturality := ?_ }\n    intros\n    exact (hF _).eq_of_src _ _\n  \u00b7 intro f\n    ext\n    apply (hF _).eq_of_src _ _\n  \u00b7 refine\n      { app := fun X => (hF _).from_ _\n        naturality := ?_ }\n    intros\n    exact (hF _).eq_of_tgt _ _\n  \u00b7 intro f\n    ext\n    apply (hF _).eq_of_tgt _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/ZeroObjects.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Category", "CategoryTheory.Limits"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u'} [Category.{v'} D]", "{X Y : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\n\u22a2 IsZero F"}, {"line": "constructor <;> intro G <;> refine \u27e8\u27e8\u27e8?_\u27e9, ?_\u27e9\u27e9", "tactic_state": "case unique_to.refine_1\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 F \u27f6 G\n---\ncase unique_to.refine_2\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 \u2200 (a : F \u27f6 G), a = default\n---\ncase unique_from.refine_1\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 G \u27f6 F\n---\ncase unique_from.refine_2\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 \u2200 (a : G \u27f6 F), a = default"}, {"line": "\u00b7 refine\n      { app := fun X => (hF _).to_ _\n        naturality := ?_ }\n    intros\n    exact (hF _).eq_of_src _ _", "tactic_state": "case unique_to.refine_2\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 \u2200 (a : F \u27f6 G), a = default\n---\ncase unique_from.refine_1\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 G \u27f6 F\n---\ncase unique_from.refine_2\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 \u2200 (a : G \u27f6 F), a = default"}, {"line": "\u00b7 intro f\n    ext\n    apply (hF _).eq_of_src _ _", "tactic_state": "case unique_from.refine_1\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 G \u27f6 F\n---\ncase unique_from.refine_2\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 \u2200 (a : G \u27f6 F), a = default"}, {"line": "\u00b7 refine\n      { app := fun X => (hF _).from_ _\n        naturality := ?_ }\n    intros\n    exact (hF _).eq_of_tgt _ _", "tactic_state": "case unique_from.refine_2\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : \u2200 (X : C), IsZero (F.obj X)\nG : CategoryTheory.Functor C D\n\u22a2 \u2200 (a : G \u27f6 F), a = default"}, {"line": "\u00b7 intro f\n    ext\n    apply (hF _).eq_of_tgt _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bicone_\u03b9_\u03c0_self {F : J \u2192 C} (B : Bicone F) (j : J) : B.\u03b9 j \u226b B.\u03c0 j = \ud835\udfd9 (F j) := by\n  simpa using B.\u03b9_\u03c0 j j\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean", "context": {"open": ["CategoryTheory Functor", "scoped Classical in"], "variables": ["{J : Type w}", "{C : Type uC} [Category.{uC'} C] [HasZeroMorphisms C]", "{D : Type uD} [Category.{uD'} D] [HasZeroMorphisms D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Sort u_1\nC : Type u_2\nF : J \u2192 C\nB : Bicone sorry\nj : J\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.id (F j)"}, {"line": "simpa using B.\u03b9_\u03c0 j j", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bicone_\u03b9_\u03c0_ne {F : J \u2192 C} (B : Bicone F) {j j' : J} (h : j \u2260 j') : B.\u03b9 j \u226b B.\u03c0 j' = 0 := by\n  simpa [h] using B.\u03b9_\u03c0 j j'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean", "context": {"open": ["CategoryTheory Functor", "scoped Classical in"], "variables": ["{J : Type w}", "{C : Type uC} [Category.{uC'} C] [HasZeroMorphisms C]", "{D : Type uD} [Category.{uD'} D] [HasZeroMorphisms D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Sort u_1\nC : Sort u_2\nF : J \u2192 C\nB : Bicone sorry\nj j' : J\nh : j \u2260 j'\n\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simpa [h] using B.\u03b9_\u03c0 j j'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biproduct.matrix_components (m : \u2200 j k, f j \u27f6 g k) (j : J) (k : K) :\n    biproduct.components (biproduct.matrix m) j k = m j k := by simp [biproduct.components]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean", "context": {"open": ["CategoryTheory Functor", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{J : Type w}", "{C : Type uC} [Category.{uC'} C] [HasZeroMorphisms C]", "{D : Type uD} [Category.{uD'} D] [HasZeroMorphisms D]", "{F : J \u2192 C}", "(F) in", "(G : C \u2964 D)", "{K : Type w'}", "(J C)", "{J}", "{C}", "{J : Type w} {K : Type*}", "{C : Type u} [Category.{v} C] [HasZeroMorphisms C]", "(f : J \u2192 C) [HasBiproduct f]", "(p : J \u2192 Prop) [HasBiproduct (Subtype.restrict p f)]", "(f : J \u2192 C) (i : J) [HasBiproduct f] [HasBiproduct (Subtype.restrict (fun j => j \u2260 i) f)]", "{K : Type} [Finite K] [HasFiniteBiproducts C] (f : K \u2192 C)", "{J : Type} [Finite J] {K : Type} [Finite K] {C : Type u} [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type\ninst\u271d\u00b9 : Finite J\nK : Type\ninst\u271d : Finite K\nx\u271d\u00b9 : Sort u_2\nf : x\u271d\u00b9\nx\u271d : Sort u_3\ng : x\u271d\nm : (j : J) \u2192 (k : K) \u2192 ?m.1250 \u27f6 ?m.1251\nj : J\nk : K\n\u22a2 sorry = m j k"}, {"line": "simp [biproduct.components]", "tactic_state": "J : Type\ninst\u271d\u00b9 : Finite J\nK : Type\ninst\u271d : Finite K\nx\u271d\u00b9 : Sort u_2\nf : x\u271d\u00b9\nx\u271d : Sort u_3\ng : x\u271d\nm : (j : J) \u2192 (k : K) \u2192 ?m.1250 \u27f6 ?m.1251\nj : J\nk : K\n\u22a2 sorry () = m j k"}]}
{"declaration": "theorem of_hasBinaryProduct [HasBinaryProduct X Y] [HasZeroObject C] [HasZeroMorphisms C] :\n    IsPullback Limits.prod.fst Limits.prod.snd (0 : X \u27f6 0) (0 : Y \u27f6 0) := by\n  convert @of_is_product _ _ X Y 0 _ (limit.isLimit _) HasZeroObject.zeroIsTerminal\n    <;> subsingleton\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "ZeroObject"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "{P X Y Z : C} {fst : P \u27f6 X} {snd : P \u27f6 Y} {f : X \u27f6 Z} {g : Y \u27f6 Z}", "(X Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nX Y : C\ninst\u271d\u00b2 : HasBinaryProduct X Y\ninst\u271d\u00b9 : HasZeroObject C\ninst\u271d : HasZeroMorphisms C\n\u22a2 IsPullback prod.fst prod.snd 0 0"}, {"line": "convert @of_is_product _ _ X Y 0 _ (limit.isLimit _) HasZeroObject.zeroIsTerminal\n    <;> subsingleton", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isoPullback_inv_fst (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.inv \u226b fst = pullback.fst _ _ := by simp [Iso.inv_comp_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "ZeroObject"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "{P X Y Z : C} {fst : P \u27f6 X} {snd : P \u27f6 Y} {f : X \u27f6 Z} {g : Y \u27f6 Z}", "(X Y)", "{P' : C} {fst' : P' \u27f6 X} {snd' : P' \u27f6 Y}", "{X Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nP X Y Z : C\nfst : P \u27f6 X\nsnd : P \u27f6 Y\nf : X \u27f6 Z\ng : Y \u27f6 Z\nh : IsPullback fst snd f g\ninst\u271d : HasPullback f g\n\u22a2 CategoryStruct.comp h.isoPullback.inv fst = pullback.fst f g"}, {"line": "simp [Iso.inv_comp_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isoPullback_inv_snd (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.inv \u226b snd = pullback.snd _ _ := by simp [Iso.inv_comp_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "ZeroObject"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "{P X Y Z : C} {fst : P \u27f6 X} {snd : P \u27f6 Y} {f : X \u27f6 Z} {g : Y \u27f6 Z}", "(X Y)", "{P' : C} {fst' : P' \u27f6 X} {snd' : P' \u27f6 Y}", "{X Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nP X Y Z : C\nfst : P \u27f6 X\nsnd : P \u27f6 Y\nf : X \u27f6 Z\ng : Y \u27f6 Z\nh : IsPullback fst snd f g\ninst\u271d : HasPullback f g\n\u22a2 CategoryStruct.comp h.isoPullback.inv snd = pullback.snd f g"}, {"line": "simp [Iso.inv_comp_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_hasBinaryCoproduct [HasBinaryCoproduct X Y] [HasZeroObject C] [HasZeroMorphisms C] :\n    IsPushout (0 : 0 \u27f6 X) (0 : 0 \u27f6 Y) coprod.inl coprod.inr := by\n  convert @of_is_coproduct _ _ 0 X Y _ (colimit.isColimit _) HasZeroObject.zeroIsInitial\n    <;> subsingleton\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "ZeroObject", "ZeroObject"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "{P X Y Z : C} {fst : P \u27f6 X} {snd : P \u27f6 Y} {f : X \u27f6 Z} {g : Y \u27f6 Z}", "(X Y)", "{P' : C} {fst' : P' \u27f6 X} {snd' : P' \u27f6 Y}", "{X Y}", "{P X Y : C} {fst : P \u27f6 X} {snd : P \u27f6 X} {f : X \u27f6 Y} [Mono f]", "{Z X Y P : C} {f : Z \u27f6 X} {g : Z \u27f6 Y} {inl : X \u27f6 P} {inr : Y \u27f6 P}", "(X Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nX Y : C\ninst\u271d\u00b2 : HasBinaryCoproduct X Y\ninst\u271d\u00b9 : HasZeroObject C\ninst\u271d : HasZeroMorphisms C\n\u22a2 IsPushout 0 0 coprod.inl coprod.inr"}, {"line": "convert @of_is_coproduct _ _ 0 X Y _ (colimit.isColimit _) HasZeroObject.zeroIsInitial\n    <;> subsingleton", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inl_isoPushout_hom (h : IsPushout f g inl inr) [HasPushout f g] :\n    inl \u226b h.isoPushout.hom = pushout.inl _ _ := by simp [\u2190 Iso.eq_comp_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "ZeroObject", "ZeroObject"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "{P X Y Z : C} {fst : P \u27f6 X} {snd : P \u27f6 Y} {f : X \u27f6 Z} {g : Y \u27f6 Z}", "(X Y)", "{P' : C} {fst' : P' \u27f6 X} {snd' : P' \u27f6 Y}", "{X Y}", "{P X Y : C} {fst : P \u27f6 X} {snd : P \u27f6 X} {f : X \u27f6 Y} [Mono f]", "{Z X Y P : C} {f : Z \u27f6 X} {g : Z \u27f6 Y} {inl : X \u27f6 P} {inr : Y \u27f6 P}", "(X Y)", "{P' : C} {inl' : X \u27f6 P'} {inr' : Y \u27f6 P'}", "{X Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nZ X Y P : C\nf : Z \u27f6 X\ng : Z \u27f6 Y\ninl : X \u27f6 P\ninr : Y \u27f6 P\nh : IsPushout f g inl inr\ninst\u271d : HasPushout f g\n\u22a2 CategoryStruct.comp inl h.isoPushout.hom = pushout.inl f g"}, {"line": "simp [\u2190 Iso.eq_comp_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inr_isoPushout_hom (h : IsPushout f g inl inr) [HasPushout f g] :\n    inr \u226b h.isoPushout.hom = pushout.inr _ _ := by simp [\u2190 Iso.eq_comp_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "ZeroObject", "ZeroObject"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "{P X Y Z : C} {fst : P \u27f6 X} {snd : P \u27f6 Y} {f : X \u27f6 Z} {g : Y \u27f6 Z}", "(X Y)", "{P' : C} {fst' : P' \u27f6 X} {snd' : P' \u27f6 Y}", "{X Y}", "{P X Y : C} {fst : P \u27f6 X} {snd : P \u27f6 X} {f : X \u27f6 Y} [Mono f]", "{Z X Y P : C} {f : Z \u27f6 X} {g : Z \u27f6 Y} {inl : X \u27f6 P} {inr : Y \u27f6 P}", "(X Y)", "{P' : C} {inl' : X \u27f6 P'} {inr' : Y \u27f6 P'}", "{X Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nZ X Y P : C\nf : Z \u27f6 X\ng : Z \u27f6 Y\ninl : X \u27f6 P\ninr : Y \u27f6 P\nh : IsPushout f g inl inr\ninst\u271d : HasPushout f g\n\u22a2 CategoryStruct.comp inr h.isoPushout.hom = pushout.inr f g"}, {"line": "simp [\u2190 Iso.eq_comp_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_has_biproduct\u2082 [HasBinaryBiproduct X Y] :\n    BicartesianSq (0 : 0 \u27f6 X) (0 : 0 \u27f6 Y) biprod.inl biprod.inr := by\n  convert of_is_biproduct\u2082 (BinaryBiproduct.isBilimit X Y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject", "ZeroObject"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "{P X Y Z : C} {fst : P \u27f6 X} {snd : P \u27f6 Y} {f : X \u27f6 Z} {g : Y \u27f6 Z}", "(X Y)", "{P' : C} {fst' : P' \u27f6 X} {snd' : P' \u27f6 Y}", "{X Y}", "{P X Y : C} {fst : P \u27f6 X} {snd : P \u27f6 X} {f : X \u27f6 Y} [Mono f]", "{Z X Y P : C} {f : Z \u27f6 X} {g : Z \u27f6 Y} {inl : X \u27f6 P} {inr : Y \u27f6 P}", "(X Y)", "{P' : C} {inl' : X \u27f6 P'} {inr' : Y \u27f6 P'}", "{X Y}", "{P X Y : C} {inl : X \u27f6 P} {inr : X \u27f6 P} {f : Y \u27f6 X} [Epi f]", "{P X Y Z : C} {fst : P \u27f6 X} {snd : P \u27f6 Y} {f : X \u27f6 Z} {g : Y \u27f6 Z}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroObject C] [HasZeroMorphisms C]", "{Z X Y P : C} {f : Z \u27f6 X} {g : Z \u27f6 Y} {inl : X \u27f6 P} {inr : Y \u27f6 P}", "[HasZeroObject C] [HasZeroMorphisms C]", "[HasZeroObject C] [HasZeroMorphisms C]", "{X Y Z : C} {f f' : X \u27f6 Y} {g g' : Y \u27f6 Z}", "{W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z}", "[HasZeroObject C] [HasZeroMorphisms C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9\u2070 : HasZeroObject C\ninst\u271d\u2079 : HasZeroMorphisms C\ninst\u271d\u2078 : HasZeroObject C\ninst\u271d\u2077 : HasZeroMorphisms C\ninst\u271d\u2076 : HasZeroObject C\ninst\u271d\u2075 : HasZeroMorphisms C\ninst\u271d\u2074 : HasZeroObject C\ninst\u271d\u00b3 : HasZeroMorphisms C\nX Y : C\ninst\u271d\u00b2 : HasZeroObject C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasBinaryBiproduct X Y\n\u22a2 BicartesianSq 0 0 biprod.inl biprod.inr"}, {"line": "convert of_is_biproduct\u2082 (BinaryBiproduct.isBilimit X Y)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cospanExt_app_left : (cospanExt iX iY iZ wf wg).app WalkingCospan.left = iX := by\n  dsimp [cospanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry = iX"}, {"line": "dsimp [cospanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry () = iX"}]}
{"declaration": "theorem cospanExt_app_right : (cospanExt iX iY iZ wf wg).app WalkingCospan.right = iY := by\n  dsimp [cospanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry = iY"}, {"line": "dsimp [cospanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry () = iY"}]}
{"declaration": "theorem cospanExt_app_one : (cospanExt iX iY iZ wf wg).app WalkingCospan.one = iZ := by\n  dsimp [cospanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry = iZ"}, {"line": "dsimp [cospanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry () = iZ"}]}
{"declaration": "theorem cospanExt_hom_app_left :\n    (cospanExt iX iY iZ wf wg).hom.app WalkingCospan.left = iX.hom := by dsimp [cospanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry = iX.hom"}, {"line": "dsimp [cospanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry () = iX.hom"}]}
{"declaration": "theorem cospanExt_hom_app_right :\n    (cospanExt iX iY iZ wf wg).hom.app WalkingCospan.right = iY.hom := by dsimp [cospanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry = iY.hom"}, {"line": "dsimp [cospanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry () = iY.hom"}]}
{"declaration": "theorem cospanExt_hom_app_one : (cospanExt iX iY iZ wf wg).hom.app WalkingCospan.one = iZ.hom := by\n  dsimp [cospanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry = iZ.hom"}, {"line": "dsimp [cospanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry () = iZ.hom"}]}
{"declaration": "theorem cospanExt_inv_app_left :\n    (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.left = iX.inv := by dsimp [cospanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry = iX.inv"}, {"line": "dsimp [cospanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry () = iX.inv"}]}
{"declaration": "theorem cospanExt_inv_app_right :\n    (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.right = iY.inv := by dsimp [cospanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry = iY.inv"}, {"line": "dsimp [cospanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry () = iY.inv"}]}
{"declaration": "theorem cospanExt_inv_app_one : (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.one = iZ.inv := by\n  dsimp [cospanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry = iZ.inv"}, {"line": "dsimp [cospanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\ncospanExt : x\u271d\n\u22a2 sorry () = iZ.inv"}]}
{"declaration": "theorem spanExt_app_left : (spanExt iX iY iZ wf wg).app WalkingSpan.left = iY := by\n  dsimp [spanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)", "{f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry = iY"}, {"line": "dsimp [spanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry () = iY"}]}
{"declaration": "theorem spanExt_app_right : (spanExt iX iY iZ wf wg).app WalkingSpan.right = iZ := by\n  dsimp [spanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)", "{f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry = iZ"}, {"line": "dsimp [spanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry () = iZ"}]}
{"declaration": "theorem spanExt_app_one : (spanExt iX iY iZ wf wg).app WalkingSpan.zero = iX := by\n  dsimp [spanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)", "{f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry = iX"}, {"line": "dsimp [spanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry () = iX"}]}
{"declaration": "theorem spanExt_hom_app_left : (spanExt iX iY iZ wf wg).hom.app WalkingSpan.left = iY.hom := by\n  dsimp [spanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)", "{f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry = iY.hom"}, {"line": "dsimp [spanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry () = iY.hom"}]}
{"declaration": "theorem spanExt_hom_app_right : (spanExt iX iY iZ wf wg).hom.app WalkingSpan.right = iZ.hom := by\n  dsimp [spanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)", "{f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry = iZ.hom"}, {"line": "dsimp [spanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry () = iZ.hom"}]}
{"declaration": "theorem spanExt_hom_app_zero : (spanExt iX iY iZ wf wg).hom.app WalkingSpan.zero = iX.hom := by\n  dsimp [spanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)", "{f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry = iX.hom"}, {"line": "dsimp [spanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry () = iX.hom"}]}
{"declaration": "theorem spanExt_inv_app_left : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.left = iY.inv := by\n  dsimp [spanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)", "{f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry = iY.inv"}, {"line": "dsimp [spanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nY Y' : C\niY : Y \u2245 Y'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry () = iY.inv"}]}
{"declaration": "theorem spanExt_inv_app_right : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.right = iZ.inv := by\n  dsimp [spanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)", "{f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry = iZ.inv"}, {"line": "dsimp [spanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nZ Z' : C\niZ : Z \u2245 Z'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry () = iZ.inv"}]}
{"declaration": "theorem spanExt_inv_app_zero : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.zero = iX.inv := by\n  dsimp [spanExt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Cospan.lean", "context": {"open": ["CategoryTheory", "WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom"], "variables": ["{C : Type u} [Category.{v} C]", "{D : Type u\u2082} [Category.{v\u2082} D]", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)", "(F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)", "{X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')", "{f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)", "{f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}", "(wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry = iX.inv"}, {"line": "dsimp [spanExt]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX X' : C\niX : X \u2245 X'\nx\u271d : Sort u_1\nspanExt : x\u271d\n\u22a2 sorry () = iX.inv"}]}
{"declaration": "theorem pullbackConeOfRightIso_\u03c0_app_none : (pullbackConeOfRightIso f g).\u03c0.app none = f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Iso.lean", "context": {"open": ["CategoryTheory", "WalkingCospan", "WalkingCospan"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f : X \u27f6 Z) (g : Y \u27f6 Z) [IsIso f]", "(f : X \u27f6 Z) (g : Y \u27f6 Z) [IsIso g]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX Z : C\nf : X \u27f6 Z\nx\u271d : Sort u_1\npullbackConeOfRightIso : x\u271d\n\u22a2 sorry = f"}, {"line": "simp", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX Z : C\nf : X \u27f6 Z\nx\u271d : Sort u_1\npullbackConeOfRightIso : x\u271d\n\u22a2 sorry () = f"}]}
{"declaration": "theorem pushoutCoconeOfLeftIso_\u03b9_app_none : (pushoutCoconeOfLeftIso f g).\u03b9.app none = g := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Iso.lean", "context": {"open": ["CategoryTheory", "WalkingCospan", "WalkingCospan", "WalkingSpan"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f : X \u27f6 Z) (g : Y \u27f6 Z) [IsIso f]", "(f : X \u27f6 Z) (g : Y \u27f6 Z) [IsIso g]", "(f : X \u27f6 Y) (g : X \u27f6 Z) [IsIso f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX Z : C\ng : X \u27f6 Z\nx\u271d : Sort u_1\npushoutCoconeOfLeftIso : x\u271d\n\u22a2 sorry = g"}, {"line": "simp", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX Z : C\ng : X \u27f6 Z\nx\u271d : Sort u_1\npushoutCoconeOfLeftIso : x\u271d\n\u22a2 sorry () = g"}]}
{"declaration": "theorem pushoutCoconeOfRightIso_\u03b9_app_none : (pushoutCoconeOfRightIso f g).\u03b9.app none = f := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Iso.lean", "context": {"open": ["CategoryTheory", "WalkingCospan", "WalkingCospan", "WalkingSpan", "WalkingSpan"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f : X \u27f6 Z) (g : Y \u27f6 Z) [IsIso f]", "(f : X \u27f6 Z) (g : Y \u27f6 Z) [IsIso g]", "(f : X \u27f6 Y) (g : X \u27f6 Z) [IsIso f]", "(f : X \u27f6 Y) (g : X \u27f6 Z) [IsIso g]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nx\u271d : Sort u_1\npushoutCoconeOfRightIso : x\u271d\n\u22a2 sorry = f"}, {"line": "simp", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\nx\u271d : Sort u_1\npushoutCoconeOfRightIso : x\u271d\n\u22a2 sorry () = f"}]}
{"declaration": "theorem colimit_eq {j j' : J} {x : F.obj j} {x' : F.obj j'}\n    (w : colimit.\u03b9 F j x = colimit.\u03b9 F j' x') :\n      Relation.EqvGen (Quot.Rel F) \u27e8j, x\u27e9 \u27e8j', x'\u27e9 := by\n  apply Quot.eq.1\n  simpa using congr_arg (colimitEquivQuot F) w\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Types/Colimits.lean", "context": {"open": [], "variables": ["{J : Type v} [Category.{w} J] {F : J \u2964 Type u}", "{F : J \u2964 Type u} (c : Cocone F)", "(F : J \u2964 Type u) [HasColimit F]", "{F} in", "{F} in", "{F} in", "{F} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Sort u_5\nj j' : J\nx : sorry\nx' : sorry\nw : sorry = sorry\n\u22a2 Relation.EqvGen sorry sorry sorry"}, {"line": "apply Quot.eq.1", "tactic_state": "J : Sort u_5\nj j' : J\nx : sorry\nx' : sorry\nw : sorry = sorry\n\u22a2 Quot.mk sorry sorry = Quot.mk sorry sorry\n---\n\u22a2 Type u_4"}, {"line": "simpa using congr_arg (colimitEquivQuot F) w", "tactic_state": "\u22a2 Type u_4"}]}
