{"declaration": "lemma rank_mul_sepDegree_of_isSeparable (K : Type v) [Field K] [Algebra F K]\n    [Algebra E K] [IsScalarTower F E K] [Algebra.IsSeparable F E] :\n    Module.rank F E * sepDegree E K = sepDegree F K := by\n  simpa only [Cardinal.lift_id] using lift_rank_mul_lift_sepDegree_of_isSeparable F E K\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PurelyInseparable/Tower.lean", "context": {"open": ["Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "[Algebra E K] [IsScalarTower F E K]", "{F K} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2077 : Field F\ninst\u271d\u2076 : Field E\ninst\u271d\u2075 : Algebra F E\nK : Type v\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra F K\ninst\u271d\u00b2 : Algebra E K\ninst\u271d\u00b9 : IsScalarTower F E K\ninst\u271d : Algebra.IsSeparable F E\n\u22a2 Module.rank F E * sepDegree E K = sepDegree F K"}, {"line": "simpa only [Cardinal.lift_id] using lift_rank_mul_lift_sepDegree_of_isSeparable F E K", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sepDegree_mul_sepDegree_of_isAlgebraic (K : Type v) [Field K] [Algebra F K]\n    [Algebra E K] [IsScalarTower F E K] [Algebra.IsAlgebraic F E] :\n    sepDegree F E * sepDegree E K = sepDegree F K := by\n  simpa only [Cardinal.lift_id] using lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic F E K\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PurelyInseparable/Tower.lean", "context": {"open": ["Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "[Algebra E K] [IsScalarTower F E K]", "{F K} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2077 : Field F\ninst\u271d\u2076 : Field E\ninst\u271d\u2075 : Algebra F E\nK : Type v\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra F K\ninst\u271d\u00b2 : Algebra E K\ninst\u271d\u00b9 : IsScalarTower F E K\ninst\u271d : Algebra.IsAlgebraic F E\n\u22a2 sepDegree F E * sepDegree E K = sepDegree F K"}, {"line": "simpa only [Cardinal.lift_id] using lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic F E K", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_fixedField_iff (x) :\n    x \u2208 fixedField H \u2194 \u2200 f \u2208 H, f x = x := by\n  show x \u2208 MulAction.fixedPoints H E \u2194 _\n  simp only [MulAction.mem_fixedPoints, Subtype.forall, Subgroup.mk_smul, AlgEquiv.smul_def]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Galois/Basic.lean", "context": {"open": ["scoped Polynomial IntermediateField", "Module AlgEquiv IntermediateField"], "variables": ["(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]", "{F E}", "(F E)", "{E}", "(E)", "(F K E : Type*) [Field F] [Field K] [Field E] {E' : Type*} [Field E'] [Algebra F E']", "[Algebra F K] [Algebra F E] [Algebra K E] [IsScalarTower F K E]", "{F E}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(H : Subgroup (E \u2243\u2090[F] E)) (K : IntermediateField F E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nH : Subgroup (E \u2243\u2090[F] E)\nx : E\n\u22a2 x \u2208 fixedField H \u2194 \u2200 f \u2208 H, f x = x"}, {"line": "show x \u2208 MulAction.fixedPoints H E \u2194 _", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nH : Subgroup (E \u2243\u2090[F] E)\nx : E\n\u22a2 x \u2208 MulAction.fixedPoints (\u21a5H) E \u2194 \u2200 f \u2208 H, f x = x"}, {"line": "simp only [MulAction.mem_fixedPoints, Subtype.forall, Subgroup.mk_smul, AlgEquiv.smul_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fixingSubgroup_anti : Antitone (IntermediateField.fixingSubgroup (F := F) (E := E)) := by\n  intro K K' h\n  rw [\u2190 le_iff_le]\n  exact le_trans h ((le_iff_le _ _).mpr (le_refl K'.fixingSubgroup))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Galois/Basic.lean", "context": {"open": ["scoped Polynomial IntermediateField", "Module AlgEquiv IntermediateField"], "variables": ["(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]", "{F E}", "(F E)", "{E}", "(E)", "(F K E : Type*) [Field F] [Field K] [Field E] {E' : Type*} [Field E'] [Algebra F E']", "[Algebra F K] [Algebra F E] [Algebra K E] [IsScalarTower F K E]", "{F E}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(H : Subgroup (E \u2243\u2090[F] E)) (K : IntermediateField F E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u22a2 Antitone IntermediateField.fixingSubgroup"}, {"line": "intro K K' h", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nK K' : IntermediateField F E\nh : K \u2264 K'\n\u22a2 K'.fixingSubgroup \u2264 K.fixingSubgroup"}, {"line": "rw [\u2190 le_iff_le]", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nK K' : IntermediateField F E\nh : K \u2264 K'\n\u22a2 K \u2264 fixedField K'.fixingSubgroup"}, {"line": "exact le_trans h ((le_iff_le _ _).mpr (le_refl K'.fixingSubgroup))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_fixedField_eq_bot [FiniteDimensional F E]\n    (h : IntermediateField.fixedField (\u22a4 : Subgroup (E \u2243\u2090[F] E)) = \u22a5) : IsGalois F E := by\n  rw [\u2190 isGalois_iff_isGalois_bot, \u2190 h]\n  classical exact IsGalois.of_fixed_field E (\u22a4 : Subgroup (E \u2243\u2090[F] E))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Galois/Basic.lean", "context": {"open": ["scoped Polynomial IntermediateField", "Module AlgEquiv IntermediateField", "IntermediateField", "scoped Pointwise", "scoped Pointwise"], "variables": ["(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]", "{F E}", "(F E)", "{E}", "(E)", "(F K E : Type*) [Field F] [Field K] [Field E] {E' : Type*} [Field E'] [Algebra F E']", "[Algebra F K] [Algebra F E] [Algebra K E] [IsScalarTower F K E]", "{F E}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(H : Subgroup (E \u2243\u2090[F] E)) (K : IntermediateField F E)", "{K L : Type*} [Field K] [Field L] [Algebra K L]", "(E : IntermediateField K L)", "(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_11\ninst\u271d\u00b3 : Field F\nE : Type u_12\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : FiniteDimensional F E\nh : fixedField \u22a4 = \u22a5\n\u22a2 IsGalois F E"}, {"line": "rw [\u2190 isGalois_iff_isGalois_bot, \u2190 h]", "tactic_state": "F : Type u_11\ninst\u271d\u00b3 : Field F\nE : Type u_12\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : FiniteDimensional F E\nh : fixedField \u22a4 = \u22a5\n\u22a2 IsGalois (\u21a5(fixedField \u22a4)) E"}, {"line": "classical exact IsGalois.of_fixed_field E (\u22a4 : Subgroup (E \u2243\u2090[F] E))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjoin_simple_map_algHom [IsGalois k K] (f : K \u2192\u2090[k] K) (x : K) :\n    adjoin k {f x} = adjoin k {x} := by\n  simpa only [Set.image_singleton] using adjoin_map f { x }\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Galois/GaloisClosure.lean", "context": {"open": ["IntermediateField"], "variables": ["(k K : Type*) [Field k] [Field K] [Algebra k K]", "{k K}", "(k) in", "(k) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nK : Type u_2\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra k K\ninst\u271d : IsGalois k K\nf : K \u2192\u2090[k] K\nx : K\n\u22a2 k\u27eef x\u27ef = k\u27eex\u27ef"}, {"line": "simpa only [Set.image_singleton] using adjoin_map f { x }", "tactic_state": "No Goals!"}]}
{"declaration": "example {F : IntermediateField K L} {E : IntermediateField F L} : Algebra K E := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(K L L' : Type*) [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L']", "{K L L'}", "(S : IntermediateField K L)", "{X Y}", "{E} [Field E] [Algebra L E] (T : IntermediateField S E) {S}", "(f : L \u2192\u2090[K] L')", "{f}", "{S}", "{F E : IntermediateField K L}", "(S)", "{S}", "(K)", "[Algebra L' L] [IsScalarTower K L' L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Field L'\ninst\u271d\u2075 : Algebra K L\ninst\u271d\u2074 : Algebra K L'\nS : IntermediateField K L\nX : ?m.12081\nY : ?m.12084\nE\u271d\u00b9 : Type ?u.12090\ninst\u271d\u00b3 : Field E\u271d\u00b9\ninst\u271d\u00b2 : Algebra L E\u271d\u00b9\nT : IntermediateField (\u21a5S) E\u271d\u00b9\nf : L \u2192\u2090[K] L'\nF\u271d E\u271d : IntermediateField K L\ninst\u271d\u00b9 : Algebra L' L\ninst\u271d : IsScalarTower K L' L\nF : IntermediateField K L\nE : IntermediateField (\u21a5F) L\n\u22a2 Algebra K \u21a5E"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSubalgebra_iSup_of_directed (dir : Directed (\u00b7 \u2264 \u00b7) t) :\n    (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 simp_rw [iSup_of_empty, bot_toSubalgebra]\n  \u00b7 exact SetLike.ext' ((coe_iSup_of_directed dir).trans (Subalgebra.coe_iSup_of_directed dir).symm)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Basic.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] {S : Set E}", "{F}", "{K L : Type*} [Field K] [Field L] [Algebra K L] (E1 E2 : IntermediateField K L)", "{\u03b9 : Type*} {t : \u03b9 \u2192 IntermediateField K L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\n\u03b9 : Type u_5\nt : \u03b9 \u2192 IntermediateField K L\ndir : Directed (fun x1 x2 => x1 \u2264 x2) t\n\u22a2 (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\nK : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\n\u03b9 : Type u_5\nt : \u03b9 \u2192 IntermediateField K L\ndir : Directed (fun x1 x2 => x1 \u2264 x2) t\nh\u271d : IsEmpty \u03b9\n\u22a2 (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra\n---\ncase inr\nK : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\n\u03b9 : Type u_5\nt : \u03b9 \u2192 IntermediateField K L\ndir : Directed (fun x1 x2 => x1 \u2264 x2) t\nh\u271d : Nonempty \u03b9\n\u22a2 (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra"}, {"line": "\u00b7 simp_rw [iSup_of_empty, bot_toSubalgebra]", "tactic_state": "case inr\nK : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\n\u03b9 : Type u_5\nt : \u03b9 \u2192 IntermediateField K L\ndir : Directed (fun x1 x2 => x1 \u2264 x2) t\nh\u271d : Nonempty \u03b9\n\u22a2 (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra"}, {"line": "\u00b7 exact SetLike.ext' ((coe_iSup_of_directed dir).trans (Subalgebra.coe_iSup_of_directed dir).symm)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalMk_adjoin_le {E : Type u} [Field E] [Algebra F E] (s : Set E) :\n    #(adjoin F s) \u2264 #F \u2294 #s \u2294 \u2135\u2080 := by\n  simpa using lift_cardinalMk_adjoin_le F s\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Basic.lean", "context": {"open": ["Module Polynomial", "Set CompleteLattice", "Module Module", "Module AdjoinRoot in", "AlgEquiv", "IntermediateField", "IntermediateField", "Cardinal"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] {S : Set E}", "{F}", "{K L : Type*} [Field K] [Field L] [Algebra K L] (E1 E2 : IntermediateField K L)", "{\u03b9 : Type*} {t : \u03b9 \u2192 IntermediateField K L}", "(E)", "{K : Type*} [Field K] [Algebra F K] [Algebra E K] [IsScalarTower F E K]", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E] {\u03b1 : E} {S : Set E}", "{K L : IntermediateField F E}", "(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] {\u03b1 : E}", "{K : Type u} [Field K] [Algebra F K]", "{L : Type*} [Field L] [Algebra K L]", "{F} in", "{K L : Type _} [Field K] [Field L] [Algebra K L]", "{K L : Type*} [Field K] [Field L] [Algebra K L]", "(F : Type u) [Field F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\ninst\u271d\u00b2 : Field F\nE : Type u\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\ns : Set E\n\u22a2 Cardinal.mk \u21a5(adjoin F s) \u2264 max (max (Cardinal.mk F) (Cardinal.mk \u2191s)) aleph0"}, {"line": "simpa using lift_cardinalMk_adjoin_le F s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fg_of_fg_toSubalgebra (S : IntermediateField F E) (h : S.toSubalgebra.FG) : S.FG := by\n  obtain \u27e8t, ht\u27e9 := h\n  exact \u27e8t, (eq_adjoin_of_eq_algebra_adjoin _ _ _ ht.symm).symm\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Algebra.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "(\u03b1 : E)", "{F} {\u03b1}", "{K L : Type*} [Field K] [Field L] [Algebra K L] (E1 E2 : IntermediateField K L)", "(E)", "{K : Type*} [Field K] [Algebra F K] [Algebra E K] [IsScalarTower F E K]", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_6\ninst\u271d\u00b2 : Field F\nE : Type u_7\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS : IntermediateField F E\nh : S.FG\n\u22a2 S.FG"}, {"line": "obtain \u27e8t, ht\u27e9 := h", "tactic_state": "case intro\nF : Type u_6\ninst\u271d\u00b2 : Field F\nE : Type u_7\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS : IntermediateField F E\nt : Finset E\nht : Algebra.adjoin F \u2191t = S.toSubalgebra\n\u22a2 S.FG"}, {"line": "exact \u27e8t, (eq_adjoin_of_eq_algebra_adjoin _ _ _ ht.symm).symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iInf {\u03b9 : Sort*} (S : \u03b9 \u2192 IntermediateField F E) : (\u2191(iInf S) : Set E) = \u22c2 i, S i := by\n  simp [iInf]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u03b9 : Sort u_3\nS : \u03b9 \u2192 IntermediateField F E\n\u22a2 \u2191(iInf S) = \u22c2 i, \u2191(S i)"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_toSubfield {\u03b9 : Sort*} [Nonempty \u03b9] (S : \u03b9 \u2192 IntermediateField F E) :\n    (iSup S).toSubfield = \u2a06 i, (S i).toSubfield := by\n  simp only [iSup, Set.range_nonempty, sSup_toSubfield, \u2190 Set.range_comp, Function.comp_def]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b3 : Field F\nE : Type u_2\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\n\u03b9 : Sort u_3\ninst\u271d : Nonempty \u03b9\nS : \u03b9 \u2192 IntermediateField F E\n\u22a2 (iSup S).toSubfield = \u2a06 i, (S i).toSubfield"}, {"line": "simp only [iSup, Set.range_nonempty, sSup_toSubfield, \u2190 Set.range_comp, Function.comp_def]", "tactic_state": "F : Type u_1\ninst\u271d\u00b3 : Field F\nE : Type u_2\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\n\u03b9 : Sort u_3\ninst\u271d : Nonempty \u03b9\nS : \u03b9 \u2192 IntermediateField F E\n\u22a2 (sSup (Set.range S)).toSubfield = sSup (Set.range fun i => (S i).toSubfield)"}]}
{"declaration": "theorem botEquiv_def (x : F) : botEquiv F E (algebraMap F (\u22a5 : IntermediateField F E) x) = x := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F E)", "{F E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : Field F\nx\u271d : Sort u_3\nbotEquiv : x\u271d\nx : F\n\u22a2 sorry = x"}, {"line": "simp", "tactic_state": "F : Type u_1\ninst\u271d : Field F\nx\u271d : Sort u_3\nbotEquiv : x\u271d\nx : F\n\u22a2 sorry () = x"}]}
{"declaration": "theorem adjoin.range_algebraMap_subset : Set.range (algebraMap F E) \u2286 adjoin F S := by\n  intro x hx\n  obtain \u27e8f, hf\u27e9 := hx\n  rw [\u2190 hf]\n  exact adjoin.algebraMap_mem F S f\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F E)", "{F E}", "{K : Type*} [Field K] [Algebra K E] [Algebra K F] [IsScalarTower K F E]", "(K)", "(L L' : IntermediateField F E)", "{K : Type*} [Field K] [Algebra F K]", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx\u271d : Sort u_9\nadjoin : x\u271d\n\u22a2 Set.range \u21d1(algebraMap F E) \u2286 sorry"}, {"line": "intro x hx", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx\u271d : Sort u_9\nadjoin : x\u271d\nx : E\nhx : x \u2208 Set.range \u21d1(algebraMap F E)\n\u22a2 x \u2208 sorry"}, {"line": "obtain \u27e8f, hf\u27e9 := hx", "tactic_state": "case intro\nF : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx\u271d : Sort u_9\nadjoin : x\u271d\nx : E\nf : F\nhf : (algebraMap F E) f = x\n\u22a2 x \u2208 sorry"}, {"line": "rw [\u2190 hf]", "tactic_state": "case intro\nF : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx\u271d : Sort u_9\nadjoin : x\u271d\nx : E\nf : F\nhf : (algebraMap F E) f = x\n\u22a2 (algebraMap F E) f \u2208 sorry"}, {"line": "exact adjoin.algebraMap_mem F S f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap_eq_self {f : L \u2192\u2090[K] L'} {S : IntermediateField K L'} (h : S \u2264 f.fieldRange) :\n    (S.comap f).map f = S := by\n  simpa only [inf_of_le_left h] using map_comap_eq f S\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial", "Lean in", "Lean PrettyPrinter.Delaborator SubExpr in"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F E)", "{F E}", "{K : Type*} [Field K] [Algebra K E] [Algebra K F] [IsScalarTower K F E]", "(K)", "(L L' : IntermediateField F E)", "{K : Type*} [Field K] [Algebra F K]", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F} in", "{F} in", "{K : Type*} [Semiring K] [Algebra F K]", "(\u03b1 : E)", "{F} {\u03b1}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E] {\u03b1 : E} {S : Set E}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "{K L L' : Type*} [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_9\nL : Type u_10\nL' : Type u_11\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Field L'\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : Algebra K L'\nf : L \u2192\u2090[K] L'\nS : IntermediateField K L'\nh : S \u2264 f.fieldRange\n\u22a2 IntermediateField.map f (IntermediateField.comap f S) = S"}, {"line": "simpa only [inf_of_le_left h] using map_comap_eq f S", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irreducible_factor (f : K[X]) : Irreducible (factor f) := by\n  rw [factor]\n  split_ifs with H\n  \u00b7 exact (Classical.choose_spec H).1\n  \u00b7 exact irreducible_X\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SplittingField/Construction.lean", "context": {"open": ["Polynomial", "Classical in"], "variables": ["{F : Type u} {K : Type v} {L : Type w}", "[Field K] [Field L] [Field F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nf : Polynomial K\n\u22a2 Irreducible f.factor"}, {"line": "rw [factor]", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nf : Polynomial K\n\u22a2 Irreducible (if H : \u2203 g, Irreducible g \u2227 g \u2223 f then Classical.choose H else X)"}, {"line": "split_ifs with H", "tactic_state": "case pos\nK : Type u_1\ninst\u271d : Field K\nf : Polynomial K\nH : \u2203 g, Irreducible g \u2227 g \u2223 f\n\u22a2 Irreducible (Classical.choose H)\n---\ncase neg\nK : Type u_1\ninst\u271d : Field K\nf : Polynomial K\nH : \u00ac\u2203 g, Irreducible g \u2227 g \u2223 f\n\u22a2 Irreducible X"}, {"line": "\u00b7 exact (Classical.choose_spec H).1", "tactic_state": "case neg\nK : Type u_1\ninst\u271d : Field K\nf : Polynomial K\nH : \u00ac\u2203 g, Irreducible g \u2227 g \u2223 f\n\u22a2 Irreducible X"}, {"line": "\u00b7 exact irreducible_X", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_removeFactor' {f : K[X]} {n : \u2115} (hfn : f.natDegree = n + 1) :\n    f.removeFactor.natDegree = n := by rw [natDegree_removeFactor, hfn, n.add_sub_cancel]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SplittingField/Construction.lean", "context": {"open": ["Polynomial", "Classical in"], "variables": ["{F : Type u} {K : Type v} {L : Type w}", "[Field K] [Field L] [Field F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nf : Polynomial K\nn : \u2115\nhfn : f.natDegree = n + 1\n\u22a2 f.removeFactor.natDegree = n"}, {"line": "rw [natDegree_removeFactor, hfn, n.add_sub_cancel]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinal_le_max_transcendence_basis' (hv : IsTranscendenceBasis R v') :\n    #K' \u2264 max (max #R #\u03b9') \u2135\u2080 := by\n  simpa using cardinal_le_max_transcendence_basis v' hv\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IsAlgClosed/Classification.lean", "context": {"open": ["scoped Cardinal Polynomial", "Cardinal"], "variables": ["{R L K : Type*} [CommRing R]", "[Field K] [Algebra R K]", "[Field L] [Algebra R L]", "{\u03b9 : Type*} (v : \u03b9 \u2192 K)", "{\u03ba : Type*} (w : \u03ba \u2192 L)", "(hv : AlgebraicIndependent R v)", "(hw : AlgebraicIndependent R w)", "{R : Type u} {K : Type v} [CommRing R] [Field K] [Algebra R K] [IsAlgClosed K]", "{\u03b9 : Type w} (v : \u03b9 \u2192 K)", "{K' : Type u} [Field K'] [Algebra R K'] [IsAlgClosed K']", "{\u03b9' : Type u} (v' : \u03b9' \u2192 K')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : CommRing R\nK' : Type u\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsAlgClosed K'\n\u03b9' : Type u\nv' : \u03b9' \u2192 K'\nhv : IsTranscendenceBasis R v'\n\u22a2 mk K' \u2264 max (max (mk R) (mk \u03b9')) aleph0"}, {"line": "simpa using cardinal_le_max_transcendence_basis v' hv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinal_eq_cardinal_transcendence_basis_of_aleph0_lt' [Nontrivial R]\n    (hv : IsTranscendenceBasis R v') (hR : #R \u2264 \u2135\u2080) (hK : \u2135\u2080 < #K') : #K' = #\u03b9' := by\n  simpa using cardinal_eq_cardinal_transcendence_basis_of_aleph0_lt v' hv hR hK\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IsAlgClosed/Classification.lean", "context": {"open": ["scoped Cardinal Polynomial", "Cardinal"], "variables": ["{R L K : Type*} [CommRing R]", "[Field K] [Algebra R K]", "[Field L] [Algebra R L]", "{\u03b9 : Type*} (v : \u03b9 \u2192 K)", "{\u03ba : Type*} (w : \u03ba \u2192 L)", "(hv : AlgebraicIndependent R v)", "(hw : AlgebraicIndependent R w)", "{R : Type u} {K : Type v} [CommRing R] [Field K] [Algebra R K] [IsAlgClosed K]", "{\u03b9 : Type w} (v : \u03b9 \u2192 K)", "{K' : Type u} [Field K'] [Algebra R K'] [IsAlgClosed K']", "{\u03b9' : Type u} (v' : \u03b9' \u2192 K')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\nK' : Type u\ninst\u271d\u00b3 : Field K'\ninst\u271d\u00b2 : Algebra R K'\ninst\u271d\u00b9 : IsAlgClosed K'\n\u03b9' : Type u\nv' : \u03b9' \u2192 K'\ninst\u271d : Nontrivial R\nhv : IsTranscendenceBasis R v'\nhR : mk R \u2264 aleph0\nhK : aleph0 < mk K'\n\u22a2 mk K' = mk \u03b9'"}, {"line": "simpa using cardinal_eq_cardinal_transcendence_basis_of_aleph0_lt v' hv hR hK", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frobenius_zmod (p : \u2115) [Fact p.Prime] : frobenius (ZMod p) p = RingHom.id _ := by\n  ext a\n  rw [frobenius_def, ZMod.pow_card, RingHom.id_apply]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/Basic.lean", "context": {"open": ["Finset", "scoped Polynomial", "Polynomial", "Polynomial in", "Polynomial", "Polynomial", "FiniteField Polynomial", "scoped Nat", "ZMod", "FiniteField"], "variables": ["{K : Type*} {R : Type*}", "[CommRing R] [IsDomain R]", "[GroupWithZero K] [Fintype K]", "(K) [Field K] [Fintype K]", "(R) [CommRing R] [Algebra K R]", "(L : Type*) [Field L] [Algebra K L]", "[Finite L]", "[Fintype K] (K' : Type*) [Field K'] {p n : \u2115}", "{K}", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 frobenius (ZMod p) p = RingHom.id (ZMod p)"}, {"line": "ext a", "tactic_state": "case a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\n\u22a2 (frobenius (ZMod p) p) a = (RingHom.id (ZMod p)) a"}, {"line": "rw [frobenius_def, ZMod.pow_card, RingHom.id_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_card_sub_one (a : ZMod p) :\n    a ^ (p - 1) = if a \u2260 0 then 1 else 0 := by\n  split_ifs with ha\n  \u00b7 exact pow_card_sub_one_eq_one ha\n  \u00b7 simp [of_not_not ha, (Fact.out : p.Prime).one_lt, tsub_eq_zero_iff_le]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/Basic.lean", "context": {"open": ["Finset", "scoped Polynomial", "Polynomial", "Polynomial in", "Polynomial", "Polynomial", "FiniteField Polynomial", "scoped Nat", "ZMod", "FiniteField"], "variables": ["{K : Type*} {R : Type*}", "[CommRing R] [IsDomain R]", "[GroupWithZero K] [Fintype K]", "(K) [Field K] [Fintype K]", "(R) [CommRing R] [Algebra K R]", "(L : Type*) [Field L] [Algebra K L]", "[Finite L]", "[Fintype K] (K' : Type*) [Field K'] {p n : \u2115}", "{K}", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\n\u22a2 a ^ (p - 1) = if a \u2260 0 then 1 else 0"}, {"line": "split_ifs with ha", "tactic_state": "case pos\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\n\u22a2 a ^ (p - 1) = 1\n---\ncase neg\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : \u00aca \u2260 0\n\u22a2 a ^ (p - 1) = 0"}, {"line": "\u00b7 exact pow_card_sub_one_eq_one ha", "tactic_state": "case neg\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : \u00aca \u2260 0\n\u22a2 a ^ (p - 1) = 0"}, {"line": "\u00b7 simp [of_not_not ha, (Fact.out : p.Prime).one_lt, tsub_eq_zero_iff_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_algebraMap {B : Type*} [CommRing B] [Algebra A B] (x : B)\n    (a : A) : minpoly A (x - algebraMap A B a) = (minpoly A x).comp (X + C a) := by\n  simpa [sub_eq_add_neg] using add_algebraMap x (-a)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Field.lean", "context": {"open": ["Polynomial Set Function minpoly"], "variables": ["{A B : Type*}", "(A) [Field A]", "[Ring B] [Algebra A B] (x : B)", "{A x} in", "{A x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u00b2 : Field A\nB : Type u_3\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra A B\nx : B\na : A\n\u22a2 minpoly A (x - (algebraMap A B) a) = (minpoly A x).comp (X + C a)"}, {"line": "simpa [sub_eq_add_neg] using add_algebraMap x (-a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prime (hx : IsIntegral A x) : Prime (minpoly A x) := by\n  refine \u27e8minpoly.ne_zero hx, not_isUnit A x, ?_\u27e9\n  rintro p q \u27e8d, h\u27e9\n  have : Polynomial.aeval x (p * q) = 0 := by simp [h, aeval A x]\n  replace : Polynomial.aeval x p = 0 \u2228 Polynomial.aeval x q = 0 := by simpa\n  exact Or.imp (dvd A x) (dvd A x) this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Field.lean", "context": {"open": ["Polynomial Set Function minpoly", "scoped Classical in"], "variables": ["{A B : Type*}", "(A) [Field A]", "[Ring B] [Algebra A B] (x : B)", "{A x} in", "{A x}", "(F E K : Type*) [Field F] [Ring E] [CommRing K] [IsDomain K] [Algebra F E] [Algebra F K]", "(B) [Nontrivial B]", "(A)", "[Ring B] [IsDomain B] [Algebra A B]", "{A} {x : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 Prime (minpoly A x)"}, {"line": "refine \u27e8minpoly.ne_zero hx, not_isUnit A x, ?_\u27e9", "tactic_state": "A : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 \u2200 (a b : Polynomial A), minpoly A x \u2223 a * b \u2192 minpoly A x \u2223 a \u2228 minpoly A x \u2223 b"}, {"line": "rintro p q \u27e8d, h\u27e9", "tactic_state": "case intro\nA : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\np q d : Polynomial A\nh : p * q = minpoly A x * d\n\u22a2 minpoly A x \u2223 p \u2228 minpoly A x \u2223 q"}, {"line": "have : Polynomial.aeval x (p * q) = 0 := by simp [h, aeval A x]", "tactic_state": "case intro\nA : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\np q d : Polynomial A\nh : p * q = minpoly A x * d\nthis : sorry = 0\n\u22a2 minpoly A x \u2223 p \u2228 minpoly A x \u2223 q"}, {"line": "replace : Polynomial.aeval x p = 0 \u2228 Polynomial.aeval x q = 0 := by simpa", "tactic_state": "case intro\nA : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\np q d : Polynomial A\nh : p * q = minpoly A x * d\nthis : sorry = 0 \u2228 sorry = 0\n\u22a2 minpoly A x \u2223 p \u2228 minpoly A x \u2223 q"}, {"line": "exact Or.imp (dvd A x) (dvd A x) this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monic (hx : IsIntegral A x) : Monic (minpoly A x) := by\n  delta minpoly\n  rw [dif_pos hx]\n  exact (degree_lt_wf.min_mem _ hx).1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Basic.lean", "context": {"open": ["Polynomial Set Function", "scoped Classical in"], "variables": ["{A B B' : Type*}", "(A) [CommRing A] [Ring B] [Algebra A B]", "[CommRing A] [Ring B] [Ring B'] [Algebra A B] [Algebra A B']", "{x : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 (minpoly A x).Monic"}, {"line": "delta minpoly", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 (if hx : IsIntegral A x then \u22ef.min (fun x_1 => x_1.Monic \u2227 eval\u2082 (algebraMap A B) x x_1 = 0) hx else 0).Monic"}, {"line": "rw [dif_pos hx]", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 (\u22ef.min (fun x_1 => x_1.Monic \u2227 eval\u2082 (algebraMap A B) x x_1 = 0) hx).Monic"}, {"line": "exact (degree_lt_wf.min_mem _ hx).1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aeval : aeval x (minpoly A x) = 0 := by\n  delta minpoly\n  split_ifs with hx\n  \u00b7 exact (degree_lt_wf.min_mem _ hx).2\n  \u00b7 exact aeval_zero _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Basic.lean", "context": {"open": ["Polynomial Set Function", "scoped Classical in"], "variables": ["{A B B' : Type*}", "(A) [CommRing A] [Ring B] [Algebra A B]", "[CommRing A] [Ring B] [Ring B'] [Algebra A B] [Algebra A B']", "{x : B}", "(A x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\n\u22a2 (Polynomial.aeval x) (minpoly A x) = 0"}, {"line": "delta minpoly", "tactic_state": "B : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\n\u22a2 (Polynomial.aeval x)\n      (if hx : IsIntegral A x then \u22ef.min (fun x_1 => x_1.Monic \u2227 eval\u2082 (algebraMap A B) x x_1 = 0) hx else 0) =\n    0"}, {"line": "split_ifs with hx", "tactic_state": "case pos\nB : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 (Polynomial.aeval x) (\u22ef.min (fun x_1 => x_1.Monic \u2227 eval\u2082 (algebraMap A B) x x_1 = 0) hx) = 0\n---\ncase neg\nB : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : \u00acIsIntegral A x\n\u22a2 (Polynomial.aeval x) 0 = 0"}, {"line": "\u00b7 exact (degree_lt_wf.min_mem _ hx).2", "tactic_state": "case neg\nB : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : \u00acIsIntegral A x\n\u22a2 (Polynomial.aeval x) 0 = 0"}, {"line": "\u00b7 exact aeval_zero _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_eq_one_iff :\n    (minpoly A x).natDegree = 1 \u2194 x \u2208 (algebraMap A B).range := by\n  rw [\u2190 Polynomial.degree_eq_iff_natDegree_eq_of_pos zero_lt_one]\n  exact degree_eq_one_iff\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Basic.lean", "context": {"open": ["Polynomial Set Function", "scoped Classical in", "Polynomial in"], "variables": ["{A B B' : Type*}", "(A) [CommRing A] [Ring B] [Algebra A B]", "[CommRing A] [Ring B] [Ring B'] [Algebra A B] [Algebra A B']", "{x : B}", "(A x)", "[CommRing A]", "[Ring B] [Algebra A B]", "{x : B}", "[Nontrivial B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : Ring B\ninst\u271d\u2077 : Algebra A B\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Nontrivial B\n\u22a2 (minpoly A x).natDegree = 1 \u2194 x \u2208 (algebraMap A B).range"}, {"line": "rw [\u2190 Polynomial.degree_eq_iff_natDegree_eq_of_pos zero_lt_one]", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : Ring B\ninst\u271d\u2077 : Algebra A B\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Nontrivial B\n\u22a2 (minpoly A x).degree = \u21911 \u2194 x \u2208 (algebraMap A B).range"}, {"line": "exact degree_eq_one_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_C {c : K} : eval f a (C c) = f c := by simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/AsPolynomial.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc"], "variables": ["{K : Type u}", "[CommRing K] [IsDomain K]", "[Field K]", "{L : Type u} [Field L]", "{f : K \u2192+* L} {a : L}", "(f a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nc : K\n\u22a2 eval f a sorry = f c"}, {"line": "simp [eval]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nc : K\n\u22a2 Polynomial.eval\u2082 f a (sorry ()).num / Polynomial.eval\u2082 f a (sorry ()).denom = f c"}]}
{"declaration": "theorem eval_X : eval f a X = a := by simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/AsPolynomial.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc"], "variables": ["{K : Type u}", "[CommRing K] [IsDomain K]", "[Field K]", "{L : Type u} [Field L]", "{f : K \u2192+* L} {a : L}", "(f a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 eval f a sorry = a"}, {"line": "simp [eval]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 Polynomial.eval\u2082 f a (sorry ()).num / Polynomial.eval\u2082 f a (sorry ()).denom = a"}]}
{"declaration": "theorem eval_zero : eval f a 0 = 0 := by simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/AsPolynomial.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc"], "variables": ["{K : Type u}", "[CommRing K] [IsDomain K]", "[Field K]", "{L : Type u} [Field L]", "{f : K \u2192+* L} {a : L}", "(f a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 eval f a 0 = 0"}, {"line": "simp [eval]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 0 / 1 = 0"}]}
{"declaration": "theorem eval_one : eval f a 1 = 1 := by simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/AsPolynomial.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc"], "variables": ["{K : Type u}", "[CommRing K] [IsDomain K]", "[Field K]", "{L : Type u} [Field L]", "{f : K \u2192+* L} {a : L}", "(f a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 eval f a 1 = 1"}, {"line": "simp [eval]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 1 / 1 = 1"}]}
{"declaration": "theorem num_zero : num (0 : RatFunc K) = 0 := by convert num_div' (0 : K[X]) one_ne_zero <;> simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\n\u22a2 num 0 = 0"}, {"line": "convert num_div' (0 : K[X]) one_ne_zero <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem num_div (p q : K[X]) :\n    num (algebraMap _ _ p / algebraMap _ _ q) =\n      Polynomial.C (q / gcd p q).leadingCoeff\u207b\u00b9 * (p / gcd p q) := by\n  by_cases hq : q = 0\n  \u00b7 simp [hq]\n  \u00b7 exact num_div' p hq\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\np q : Polynomial K\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p / (algebraMap (Polynomial K) (RatFunc K)) q).num =\n    Polynomial.C (q / sorry).leadingCoeff\u207b\u00b9 * (p / sorry)"}, {"line": "by_cases hq : q = 0", "tactic_state": "case pos\nK : Type u_7\ninst\u271d : Field K\np q : Polynomial K\nhq : q = 0\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p / (algebraMap (Polynomial K) (RatFunc K)) q).num =\n    Polynomial.C (q / sorry).leadingCoeff\u207b\u00b9 * (p / sorry)\n---\ncase neg\nK : Type u_7\ninst\u271d : Field K\np q : Polynomial K\nhq : \u00acq = 0\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p / (algebraMap (Polynomial K) (RatFunc K)) q).num =\n    Polynomial.C (q / sorry).leadingCoeff\u207b\u00b9 * (p / sorry)"}, {"line": "\u00b7 simp [hq]", "tactic_state": "case neg\nK : Type u_7\ninst\u271d : Field K\np q : Polynomial K\nhq : \u00acq = 0\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p / (algebraMap (Polynomial K) (RatFunc K)) q).num =\n    Polynomial.C (q / sorry).leadingCoeff\u207b\u00b9 * (p / sorry)"}, {"line": "\u00b7 exact num_div' p hq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem num_algebraMap (p : K[X]) : num (algebraMap _ _ p) = p := by convert num_div p 1 <;> simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\np : Polynomial K\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p).num = p"}, {"line": "convert num_div p 1 <;> simp", "tactic_state": "case h.e'_3\nK : Type u_7\ninst\u271d : Field K\np : Polynomial K\n\u22a2 p = Polynomial.C 1\u207b\u00b9 * p"}]}
{"declaration": "theorem num_div_dvd' (p : K[X]) {q : K[X]} (hq : q \u2260 0) :\n    C (q / gcd p q).leadingCoeff\u207b\u00b9 * (p / gcd p q) \u2223 p := by simpa using num_div_dvd p hq\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\np q : Polynomial K\nhq : q \u2260 0\n\u22a2 C (q / sorry).leadingCoeff\u207b\u00b9 * (\u2191p / sorry) \u2223 \u2191p"}, {"line": "simpa using num_div_dvd p hq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem denom_algebraMap (p : K[X]) : denom (algebraMap _ (RatFunc K) p) = 1 := by\n  convert denom_div p one_ne_zero <;> simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\np : Polynomial K\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p).denom = 1"}, {"line": "convert denom_div p one_ne_zero <;> simp", "tactic_state": "case h.e'_3\nK : Type u_7\ninst\u271d : Field K\np : Polynomial K\n\u22a2 1 = Polynomial.C 1\u207b\u00b9"}]}
{"declaration": "theorem num_mul_denom_add_denom_mul_num_ne_zero {x y : RatFunc K} (hxy : x + y \u2260 0) :\n    x.num * y.denom + x.denom * y.num \u2260 0 := by\n  intro h_zero\n  have h := num_denom_add x y\n  rw [h_zero, zero_mul] at h\n  exact (mul_ne_zero (num_ne_zero hxy) (mul_ne_zero x.denom_ne_zero y.denom_ne_zero)) h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\nx y : RatFunc K\nhxy : x + y \u2260 0\n\u22a2 x.num * y.denom + x.denom * y.num \u2260 0"}, {"line": "intro h_zero", "tactic_state": "K : Type u_7\ninst\u271d : Field K\nx y : RatFunc K\nhxy : x + y \u2260 0\nh_zero : x.num * y.denom + x.denom * y.num = 0\n\u22a2 False"}, {"line": "have h := num_denom_add x y", "tactic_state": "K : Type u_7\ninst\u271d : Field K\nx y : RatFunc K\nhxy : x + y \u2260 0\nh_zero : x.num * y.denom + x.denom * y.num = 0\nh : (x + y).num * (x.denom * y.denom) = (x.num * y.denom + x.denom * y.num) * (x + y).denom\n\u22a2 False"}, {"line": "rw [h_zero, zero_mul] at h", "tactic_state": "K : Type u_7\ninst\u271d : Field K\nx y : RatFunc K\nhxy : x + y \u2260 0\nh_zero : x.num * y.denom + x.denom * y.num = 0\nh : (x + y).num * (x.denom * y.denom) = 0\n\u22a2 False"}, {"line": "exact (mul_ne_zero (num_ne_zero hxy) (mul_ne_zero x.denom_ne_zero y.denom_ne_zero)) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_eq_div' (p q : K[X]) :\n    RatFunc.mk p q = ofFractionRing (algebraMap _ _ p / algebraMap _ _ q) := by rw [RatFunc.mk]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Defs.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial"], "variables": ["(K : Type u)", "{K}", "[CommRing K]", "[IsDomain K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b9 : CommRing K\ninst\u271d : IsDomain K\nx\u271d : Sort u_1\nofFractionRing : x\u271d\np q : Polynomial K\n\u22a2 RatFunc.mk p q = sorry"}, {"line": "rw [RatFunc.mk]", "tactic_state": "K : Type u\ninst\u271d\u00b9 : CommRing K\ninst\u271d : IsDomain K\nx\u271d : Sort u_1\nofFractionRing : x\u271d\np q : Polynomial K\n\u22a2 {\n      toFractionRing :=\n        (algebraMap (Polynomial K) (FractionRing (Polynomial K))) p /\n          (algebraMap (Polynomial K) (FractionRing (Polynomial K))) q } =\n    sorry"}]}
{"declaration": "theorem computable_iff_re_compl_re' {p : \u03b1 \u2192 Prop} :\n    ComputablePred p \u2194 REPred p \u2227 REPred fun a => \u00acp a := by\n  classical exact computable_iff_re_compl_re\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Halting.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable", "Computable Part", "Computable Part", "Nat.Partrec (Code)", "Nat.Partrec.Code", "Nat.Partrec (Code)", "Nat.Partrec.Code Computable"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : Primcodable \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 ComputablePred p \u2194 REPred p \u2227 REPred fun a => \u00acp a"}, {"line": "classical exact computable_iff_re_compl_re", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp\u2081 {n} (f : \u2115 \u2192. \u2115) {g : List.Vector \u2115 n \u2192 \u2115} (hf : @Partrec' 1 fun v => f v.head)\n    (hg : @Partrec' n g) : @Partrec' n fun v => f (g v) := by\n  simpa using hf.comp' (Partrec'.cons hg Partrec'.nil)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Halting.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable", "Computable Part", "Computable Part", "Nat.Partrec (Code)", "Nat.Partrec.Code", "Nat.Partrec (Code)", "Nat.Partrec.Code Computable", "Vector Part", "List.Vector Partrec Computable", "Nat.Partrec'"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_6\nPartrec' : x\u271d\nn : \u2115\nf : \u2115 \u2192. \u2115\ng : List.Vector \u2115 n \u2192 \u2115\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.comp' (Partrec'.cons hg Partrec'.nil)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_decode_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} :\n    (Primrec\u2082 fun a n => (@decode \u03b2 _ n).map (f a)) \u2194 Primrec\u2082 f := by\n  simp only [Option.map_eq_bind]\n  exact bind_decode_iff.trans Primrec\u2082.option_some_iff\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_16\n\u03b2 : Type u_17\n\u03c3 : Type u_18\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\n\u22a2 (Primrec\u2082 fun a n => Option.map (f a) (decode n)) \u2194 Primrec\u2082 f"}, {"line": "simp only [Option.map_eq_bind]", "tactic_state": "\u03b1 : Type u_16\n\u03b2 : Type u_17\n\u03c3 : Type u_18\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\n\u22a2 (Primrec\u2082 fun a n => (decode n).bind (some \u2218 f a)) \u2194 Primrec\u2082 f"}, {"line": "exact bind_decode_iff.trans Primrec\u2082.option_some_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem list_getD (d : \u03b1) : Primrec\u2082 fun l n => List.getD l n d := by\n  simp only [List.getD_eq_getElem?_getD]\n  exact option_getD.comp\u2082 list_getElem? (const _)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Primrec", "Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "(H : Nat.Primrec fun n => Encodable.encode (@decode (List \u03b2) _ n))", "{\u03b1 : Type*} {\u03b2 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_24\ninst\u271d : Primcodable \u03b1\nd : \u03b1\n\u22a2 Primrec\u2082 fun l n => l.getD n d"}, {"line": "simp only [List.getD_eq_getElem?_getD]", "tactic_state": "\u03b1 : Type u_24\ninst\u271d : Primcodable \u03b1\nd : \u03b1\n\u22a2 Primrec\u2082 fun l n => l[n]?.getD d"}, {"line": "exact option_getD.comp\u2082 list_getElem? (const _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fin_val_iff {n} {f : \u03b1 \u2192 Fin n} : (Primrec fun a => (f a).1) \u2194 Primrec f := by\n  letI : Primcodable { a // id a < n } := Primcodable.subtype (nat_lt.comp .id (const _))\n  exact (Iff.trans (by rfl) subtype_val_iff).trans (of_equiv_iff _)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Primrec", "Primrec", "Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "(H : Nat.Primrec fun n => Encodable.encode (@decode (List \u03b2) _ n))", "{\u03b1 : Type*} {\u03b2 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_29\ninst\u271d : Primcodable \u03b1\nn : \u2115\nf : \u03b1 \u2192 Fin n\n\u22a2 (Primrec fun a => \u2191(f a)) \u2194 Primrec f"}, {"line": "letI : Primcodable { a // id a < n } := Primcodable.subtype (nat_lt.comp .id (const _))", "tactic_state": "\u03b1 : Type u_29\ninst\u271d : Primcodable \u03b1\nn : \u2115\nf : \u03b1 \u2192 Fin n\nthis : Primcodable { a // id a < n } := Primcodable.subtype \u22ef\n\u22a2 (Primrec fun a => \u2191(f a)) \u2194 Primrec f"}, {"line": "exact (Iff.trans (by rfl) subtype_val_iff).trans (of_equiv_iff _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp\u2082 (f : \u2115 \u2192 \u2115 \u2192 \u2115) (hf : @Primrec' 2 fun v => f v.head v.tail.head) {n g h}\n    (hg : @Primrec' n g) (hh : @Primrec' n h) : Primrec' fun v => f (g v) (h v) := by\n  simpa using hf.comp' (hg.cons <| hh.cons Primrec'.nil)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Primrec", "Primrec", "Primrec", "List.Vector", "List.Vector Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "(H : Nat.Primrec fun n => Encodable.encode (@decode (List \u03b2) _ n))", "{\u03b1 : Type*} {\u03b2 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_32\nPrimrec' : x\u271d\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nhf : sorry\nn : ?m.4819 f hf\ng : ?m.4820 f hf\nh : ?m.4821 f hf\nhg : sorry\nhh : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.comp' (hg.cons <| hh.cons Primrec'.nil)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prec' {n f g h} (hf : @Primrec' n f) (hg : @Primrec' n g) (hh : @Primrec' (n + 2) h) :\n    @Primrec' n fun v => (f v).rec (g v) fun y IH : \u2115 => h (y ::\u1d65 IH ::\u1d65 v) := by\n  simpa using comp' (prec hg hh) (hf.cons idv)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Primrec", "Primrec", "Primrec", "List.Vector", "List.Vector Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "(H : Nat.Primrec fun n => Encodable.encode (@decode (List \u03b2) _ n))", "{\u03b1 : Type*} {\u03b2 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_32\nPrimrec' : x\u271d\nn : ?m.4820\nf : ?m.4821\ng : ?m.4822\nh : ?m.4823\nhf : sorry\nhg : sorry\nhh : sorry\n\u22a2 sorry"}, {"line": "simpa using comp' (prec hg hh) (hf.cons idv)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero'_eval : zero'.eval = fun v => pure (0 :: v) := by simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = fun v => pure (0 :: v)"}, {"line": "simp [eval]", "tactic_state": "\u22a2 sorry () = fun v => pure (0 :: v)"}]}
{"declaration": "theorem succ_eval : succ.eval = fun v => pure [v.headI.succ] := by simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = fun v => pure [?m.16]"}, {"line": "simp [eval]", "tactic_state": "\u22a2 sorry () = fun v => pure [?m.16]"}]}
{"declaration": "theorem tail_eval : tail.eval = fun v => pure v.tail := by simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = fun v => pure ?m.14"}, {"line": "simp [eval]", "tactic_state": "\u22a2 sorry () = fun v => pure ?m.14"}]}
{"declaration": "theorem cons_eval (f fs) : (cons f fs).eval = fun v => do {\n    let n \u2190 Code.eval f v\n    let ns \u2190 Code.eval fs v\n    pure (n.headI :: ns) } := by simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncons : x\u271d\nf : ?m.722\nfs : ?m.723 f\n\u22a2 sorry = fun v => ?m.34"}, {"line": "simp [eval]", "tactic_state": "x\u271d : Sort u_1\ncons : x\u271d\nf : ?m.722\nfs : ?m.723 f\n\u22a2 sorry () = fun v => ?m.34"}]}
{"declaration": "theorem comp_eval (f g) : (comp f g).eval = fun v => g.eval v >>= f.eval := by simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncomp : x\u271d\nf : ?m.539\ng : ?m.540 f\n\u22a2 sorry = fun v => ?m.38 >>= ?m.39"}, {"line": "simp [eval]", "tactic_state": "x\u271d : Sort u_1\ncomp : x\u271d\nf : ?m.539\ng : ?m.540 f\n\u22a2 sorry () = fun v => ?m.38 >>= ?m.39"}]}
{"declaration": "theorem case_eval (f g) :\n    (case f g).eval = fun v => v.headI.rec (f.eval v.tail) fun y _ => g.eval (y::v.tail) := by\n  simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncase : x\u271d\nf : ?m.466\ng : ?m.467 f\n\u22a2 sorry = fun v => ?m.34"}, {"line": "simp [eval]", "tactic_state": "x\u271d : Sort u_1\ncase : x\u271d\nf : ?m.466\ng : ?m.467 f\n\u22a2 sorry () = fun v => ?m.34"}]}
{"declaration": "theorem fix_eval (f) : (fix f).eval =\n    PFun.fix fun v => (f.eval v).map fun v =>\n      if v.headI = 0 then Sum.inl v.tail else Sum.inr v.tail := by\n  simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfix : x\u271d\nf : ?m.470\n\u22a2 sorry = PFun.fix fun v => ?m.33"}, {"line": "simp [eval]", "tactic_state": "x\u271d : Sort u_1\nfix : x\u271d\nf : ?m.470\n\u22a2 sorry () = PFun.fix fun v => ?m.33"}]}
{"declaration": "theorem nil_eval (v) : nil.eval v = pure [] := by simp [nil]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : ?m.2\n\u22a2 sorry = pure []"}, {"line": "simp [nil]", "tactic_state": "v : ?m.2\n\u22a2 sorry () = pure []"}]}
{"declaration": "theorem head_eval (v) : head.eval v = pure [v.headI] := by simp [head]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : ?m.2\n\u22a2 sorry = pure [sorry]"}, {"line": "simp [head]", "tactic_state": "v : ?m.2\n\u22a2 sorry () = pure [sorry ()]"}]}
{"declaration": "theorem zero_eval (v) : zero.eval v = pure [0] := by simp [zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : ?m.2\n\u22a2 sorry = pure [0]"}, {"line": "simp [zero]", "tactic_state": "v : ?m.2\n\u22a2 sorry () = pure [0]"}]}
{"declaration": "theorem mem_one (x : List \u03b1) : x \u2208 (1 : Language \u03b1) \u2194 x = [] := by rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Language.lean", "context": {"open": ["List Set Computability"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{l m : Language \u03b1} {a b x : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : List \u03b1\n\u22a2 x \u2208 1 \u2194 x = []"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map {f : \u03b1 \u2192. \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} (hf : Partrec f) (hg : Computable\u2082 g) :\n    Partrec fun a => (f a).map (g a) := by\n  simpa [bind_some_eq_map] using Partrec.bind (g := fun a x => some (g a x)) hf hg\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Partrec.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable Part", "Computable"], "variables": ["(p : \u2115 \u2192. Bool)", "(H : \u2203 n, true \u2208 p n \u2227 \u2200 k < n, (p k).Dom)", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\n\u03c3 : Type u_7\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192. \u03b2\ng : \u03b1 \u2192 \u03b2 \u2192 \u03c3\nhf : Partrec f\nhg : Computable\u2082 g\n\u22a2 Partrec fun a => Part.map (g a) (f a)"}, {"line": "simpa [bind_some_eq_map] using Partrec.bind (g := fun a x => some (g a x)) hf hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_iff {f : \u2115 \u2192. \u2115} : Partrec f \u2194 Nat.Partrec f := by simp [Partrec, map_id']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Partrec.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable Part", "Computable"], "variables": ["(p : \u2115 \u2192. Bool)", "(H : \u2203 n, true \u2208 p n \u2227 \u2200 k < n, (p k).Dom)", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192. \u2115\n\u22a2 Partrec f \u2194 Nat.Partrec f"}, {"line": "simp [Partrec, map_id']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_decode_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} :\n    (Computable\u2082 fun a n => (decode (\u03b1 := \u03b2) n).map (f a)) \u2194 Computable\u2082 f := by\n  convert (bind_decode_iff (f := fun a => Option.some \u2218 f a)).trans option_some_iff\n  apply Option.map_eq_bind\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Partrec.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable Part", "Computable", "Computable"], "variables": ["(p : \u2115 \u2192. Bool)", "(H : \u2203 n, true \u2208 p n \u2227 \u2200 k < n, (p k).Dom)", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_24\n\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\n\u22a2 (Computable\u2082 fun a n => Option.map (f a) (decode n)) \u2194 Computable\u2082 f"}, {"line": "convert (bind_decode_iff (f := fun a => Option.some \u2218 f a)).trans option_some_iff", "tactic_state": "case h.e'_1.h.e'_7.h.h\n\u03b1 : Type u_24\n\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\nx\u271d\u00b9 : \u03b1\nx\u271d : \u2115\n\u22a2 Option.map (f x\u271d\u00b9) (decode x\u271d) = (decode x\u271d).bind (Option.some \u2218 f x\u271d\u00b9)"}, {"line": "apply Option.map_eq_bind", "tactic_state": "No Goals!"}]}
{"declaration": "theorem option_map {f : \u03b1 \u2192 Option \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} (hf : Computable f) (hg : Computable\u2082 g) :\n    Computable fun a => (f a).map (g a) := by\n  convert option_bind hf (option_some.comp\u2082 hg)\n  apply Option.map_eq_bind\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Partrec.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable Part", "Computable", "Computable"], "variables": ["(p : \u2115 \u2192. Bool)", "(H : \u2203 n, true \u2208 p n \u2227 \u2200 k < n, (p k).Dom)", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_24\n\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 Option \u03b2\ng : \u03b1 \u2192 \u03b2 \u2192 \u03c3\nhf : Computable f\nhg : Computable\u2082 g\n\u22a2 Computable fun a => Option.map (g a) (f a)"}, {"line": "convert option_bind hf (option_some.comp\u2082 hg)", "tactic_state": "case h.e'_5.h\n\u03b1 : Type u_24\n\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 Option \u03b2\ng : \u03b1 \u2192 \u03b2 \u2192 \u03c3\nhf : Computable f\nhg : Computable\u2082 g\nx\u271d : \u03b1\n\u22a2 Option.map (g x\u271d) (f x\u271d) = (f x\u271d).bind fun b => Option.some (g x\u271d b)"}, {"line": "apply Option.map_eq_bind", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_id (n) : eval Code.id n = Part.some n := by simp! [Seq.seq, Code.id]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/PartrecCode.lean", "context": {"open": ["Encodable Denumerable", "Primrec", "Computable"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\neval : x\u271d\nn : ?m.427\n\u22a2 sorry = Part.some n"}, {"line": "simp! [Seq.seq, Code.id]", "tactic_state": "x\u271d : Sort u_1\neval : x\u271d\nn : ?m.427\n\u22a2 sorry () = Part.some n"}]}
{"declaration": "theorem eval_curry (c n x) : eval (curry c n) x = eval c (Nat.pair n x) := by simp! [Seq.seq, curry]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/PartrecCode.lean", "context": {"open": ["Encodable Denumerable", "Primrec", "Computable"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\neval : x\u271d\nc : ?m.844\nn : ?m.845 c\nx : ?m.846 c n\n\u22a2 sorry = sorry"}, {"line": "simp! [Seq.seq, curry]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stepSet_empty (a : \u03b1) : M.stepSet \u2205 a = \u2205 := by simp [stepSet]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/NFA.lean", "context": {"open": ["Set", "Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 \u03c3' : Type v} (M : NFA \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\na : \u03b1\n\u22a2 M.stepSet \u2205 a = \u2205"}, {"line": "simp [stepSet]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_accepts {x : List \u03b1} : x \u2208 M.accepts \u2194 \u2203 S \u2208 M.accept, S \u2208 M.evalFrom M.start x := by\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/NFA.lean", "context": {"open": ["Set", "Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 \u03c3' : Type v} (M : NFA \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nx : List \u03b1\n\u22a2 x \u2208 M.accepts \u2194 \u2203 S \u2208 M.accept, S \u2208 M.evalFrom M.start x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tape.move_right_n_head {\u0393} [Inhabited \u0393] (T : Tape \u0393) (i : \u2115) :\n    ((Tape.move Dir.right)^[i] T).head = T.nth i := by\n  induction i generalizing T\n  \u00b7 rfl\n  \u00b7 simp only [*, Tape.move_right_nth, Int.natCast_succ, iterate_succ, Function.comp_apply]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Tape.lean", "context": {"open": ["Function (iterate_succ iterate_succ_apply iterate_zero_apply)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nTape : x\u271d\n\u0393 : Sort u_2\ninst\u271d : Inhabited \u0393\nT : sorry\ni : \u2115\n\u22a2 sorry = sorry"}, {"line": "induction i generalizing T", "tactic_state": "case zero\nx\u271d : Sort u_1\nTape : x\u271d\n\u0393 : Sort u_2\ninst\u271d : Inhabited \u0393\nT : sorry\n\u22a2 sorry = sorry\n---\ncase succ\nx\u271d : Sort u_1\nTape : x\u271d\n\u0393 : Sort u_2\ninst\u271d : Inhabited \u0393\nn\u271d : \u2115\na\u271d : \u2200 (T : sorry), sorry = sorry\nT : sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 rfl", "tactic_state": "case succ\nx\u271d : Sort u_1\nTape : x\u271d\n\u0393 : Sort u_2\ninst\u271d : Inhabited \u0393\nn\u271d : \u2115\na\u271d : \u2200 (T : sorry), sorry = sorry\nT : sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp only [*, Tape.move_right_nth, Int.natCast_succ, iterate_succ, Function.comp_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tape.map_mk\u2082 {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (L R : List \u0393) :\n    (Tape.mk\u2082 L R).map f = Tape.mk\u2082 (L.map f) (R.map f) := by\n  simp only [Tape.mk\u2082, Tape.map_mk', ListBlank.map_mk]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/Tape.lean", "context": {"open": ["Function (iterate_succ iterate_succ_apply iterate_zero_apply)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nPointedMap : x\u271d\n\u0393 : Type u_2\n\u0393' : Sort u_3\ninst\u271d\u00b9 : Inhabited \u0393\ninst\u271d : Inhabited \u0393'\nf : sorry\nL R : List \u0393\n\u22a2 sorry = sorry"}, {"line": "simp only [Tape.mk\u2082, Tape.map_mk', ListBlank.map_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_rmatch (x : List \u03b1) : rmatch 0 x = false := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/RegularExpressions.lean", "context": {"open": ["List Set", "Computability"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{a b : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_4\nrmatch : x\u271d\nx : List \u03b1\n\u22a2 sorry = false"}, {"line": "induction x <;> simp [rmatch, matchEpsilon, *]", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_4\nrmatch : x\u271d\n\u22a2 sorry () = false"}]}
{"declaration": "theorem one_rmatch_iff (x : List \u03b1) : rmatch 1 x \u2194 x = [] := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/RegularExpressions.lean", "context": {"open": ["List Set", "Computability"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{a b : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_4\nrmatch : x\u271d\nx : List \u03b1\n\u22a2 sorry \u2194 x = []"}, {"line": "induction x <;> simp [rmatch, matchEpsilon, *]", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_4\nrmatch : x\u271d\n\u22a2 sorry ()\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_4\nrmatch : x\u271d\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : sorry \u2194 tail\u271d = []\n\u22a2 \u00actail\u271d = []"}]}
{"declaration": "theorem evalFrom_empty (x : List \u03b1) : M.evalFrom \u2205 x = \u2205 := by\n  induction' x using List.reverseRecOn with x a ih\n  \u00b7 rw [evalFrom_nil, \u03b5Closure_empty]\n  \u00b7 rw [evalFrom_append_singleton, ih, stepSet_empty]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/EpsilonNFA.lean", "context": {"open": ["Set", "Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : \u03b5NFA \u03b1 \u03c3) {S : Set \u03c3} {s t u : \u03c3} {a : \u03b1}", "{M}", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nx : List \u03b1\n\u22a2 M.evalFrom \u2205 x = \u2205"}, {"line": "induction' x using List.reverseRecOn with x a ih", "tactic_state": "case nil\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\n\u22a2 M.evalFrom \u2205 [] = \u2205\n---\ncase append_singleton\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nx : List \u03b1\na : \u03b1\nih : M.evalFrom \u2205 x = \u2205\n\u22a2 M.evalFrom \u2205 (x ++ [a]) = \u2205"}, {"line": "\u00b7 rw [evalFrom_nil, \u03b5Closure_empty]", "tactic_state": "case append_singleton\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nx : List \u03b1\na : \u03b1\nih : M.evalFrom \u2205 x = \u2205\n\u22a2 M.evalFrom \u2205 (x ++ [a]) = \u2205"}, {"line": "\u00b7 rw [evalFrom_append_singleton, ih, stepSet_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem to\u03b5NFA_\u03b5Closure (M : NFA \u03b1 \u03c3) (S : Set \u03c3) : M.to\u03b5NFA.\u03b5Closure S = S := by\n  ext a\n  refine \u27e8?_, \u03b5NFA.\u03b5Closure.base _\u27e9\n  rintro (\u27e8_, h\u27e9 | \u27e8_, _, h, _\u27e9)\n  \u00b7 exact h\n  \u00b7 cases h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/EpsilonNFA.lean", "context": {"open": ["Set", "Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : \u03b5NFA \u03b1 \u03c3) {S : Set \u03c3} {s t u : \u03c3} {a : \u03b1}", "{M}", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\n\u22a2 M.to\u03b5NFA.\u03b5Closure S = S"}, {"line": "ext a", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na : \u03c3\n\u22a2 a \u2208 M.to\u03b5NFA.\u03b5Closure S \u2194 a \u2208 S"}, {"line": "refine \u27e8?_, \u03b5NFA.\u03b5Closure.base _\u27e9", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na : \u03c3\n\u22a2 a \u2208 M.to\u03b5NFA.\u03b5Closure S \u2192 a \u2208 S"}, {"line": "rintro (\u27e8_, h\u27e9 | \u27e8_, _, h, _\u27e9)", "tactic_state": "case h.base\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na : \u03c3\nh : a \u2208 S\n\u22a2 a \u2208 S\n---\ncase h.step\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na s\u271d : \u03c3\na\u271d : M.to\u03b5NFA.\u03b5Closure S s\u271d\nh : a \u2208 M.to\u03b5NFA.step s\u271d none\n\u22a2 a \u2208 S"}, {"line": "\u00b7 exact h", "tactic_state": "case h.step\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na s\u271d : \u03c3\na\u271d : M.to\u03b5NFA.\u03b5Closure S s\u271d\nh : a \u2208 M.to\u03b5NFA.step s\u271d none\n\u22a2 a \u2208 S"}, {"line": "\u00b7 cases h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_acceptsFrom {s : \u03c3} {x : List \u03b1} :\n    x \u2208 M.acceptsFrom s \u2194 M.evalFrom s x \u2208 M.accept := by rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\ns : \u03c3\nx : List \u03b1\n\u22a2 x \u2208 M.acceptsFrom s \u2194 M.evalFrom s x \u2208 M.accept"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_accepts {x : List \u03b1} : x \u2208 M.accepts \u2194 M.eval x \u2208 M.accept := by rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\nx : List \u03b1\n\u22a2 x \u2208 M.accepts \u2194 M.eval x \u2208 M.accept"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_comap (f : \u03b1' \u2192 \u03b1) (x : List \u03b1') : (M.comap f).eval x = M.eval (x.map f) := by\n  simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)", "{\u03b1' \u03c3' : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03b1' : Type u_1\nf : \u03b1' \u2192 \u03b1\nx : List \u03b1'\n\u22a2 (DFA.comap f M).eval x = M.eval (List.map f x)"}, {"line": "simp [eval]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_reindex (g : \u03c3 \u2243 \u03c3') (x : List \u03b1) : (reindex g M).eval x = g (M.eval x) := by\n  simp [eval]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)", "{\u03b1' \u03c3' : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\nx : List \u03b1\n\u22a2 sorry = g (M.eval x)"}, {"line": "simp [eval]", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\nx : List \u03b1\n\u22a2 sorry () = g (M.eval x)"}]}
{"declaration": "theorem accepts_reindex (g : \u03c3 \u2243 \u03c3') : (reindex g M).accepts = M.accepts := by\n  ext x\n  simp [mem_accepts]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)", "{\u03b1' \u03c3' : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\n\u22a2 sorry = M.accepts"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\nx : List \u03b1\n\u22a2 x \u2208 sorry \u2194 x \u2208 M.accepts"}, {"line": "simp [mem_accepts]", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\nx : List \u03b1\n\u22a2 x \u2208 sorry () \u2194 x \u2208 M.accepts"}]}
{"declaration": "lemma Rewrites.input_output : r.Rewrites [.nonterminal r.input] r.output := by\n  simpa using head []\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/ContextFreeGrammar.lean", "context": {"open": ["Function"], "variables": ["{T : Type*}", "{N : Type*} {r : ContextFreeRule T N} {u v : List (Symbol T N)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : Type u_1\nN : Type u_2\nr : ContextFreeRule T N\n\u22a2 r.Rewrites [Symbol.nonterminal r.input] r.output"}, {"line": "simpa using head []", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_language_iff (g : ContextFreeGrammar T) (w : List T) :\n    w \u2208 g.language \u2194 g.Derives [Symbol.nonterminal g.initial] (w.map Symbol.terminal) := by\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/ContextFreeGrammar.lean", "context": {"open": ["Function"], "variables": ["{T : Type*}", "{N : Type*} {r : ContextFreeRule T N} {u v : List (Symbol T N)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : Type u_1\ng : ContextFreeGrammar T\nw : List T\n\u22a2 w \u2208 g.language \u2194 g.Derives [Symbol.nonterminal g.initial] (List.map Symbol.terminal w)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Produces.exists_nonterminal_input_mem {u v : List (Symbol T g.NT)} (hguv : g.Produces u v) :\n    \u2203 r \u2208 g.rules, .nonterminal r.input \u2208 u := by\n  obtain \u27e8w, l, r\u27e9 := hguv\n  exact \u27e8w, l, r.nonterminal_input_mem\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/ContextFreeGrammar.lean", "context": {"open": ["Function"], "variables": ["{T : Type*}", "{N : Type*} {r : ContextFreeRule T N} {u v : List (Symbol T N)}", "{g : ContextFreeGrammar T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : Type u_1\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\nhguv : g.Produces u v\n\u22a2 \u2203 r \u2208 g.rules, Symbol.nonterminal r.input \u2208 u"}, {"line": "obtain \u27e8w, l, r\u27e9 := hguv", "tactic_state": "case intro.intro\nT : Type u_1\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\nw : ContextFreeRule T g.NT\nl : w \u2208 g.rules\nr : w.Rewrites u v\n\u22a2 \u2203 r \u2208 g.rules, Symbol.nonterminal r.input \u2208 u"}, {"line": "exact \u27e8w, l, r.nonterminal_input_mem\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma generates_reverse : g.reverse.Generates u.reverse \u2194 g.Generates u := by simp [Generates]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/ContextFreeGrammar.lean", "context": {"open": ["Function"], "variables": ["{T : Type*}", "{N : Type*} {r : ContextFreeRule T N} {u v : List (Symbol T N)}", "{g : ContextFreeGrammar T}", "{N : Type*} {r : ContextFreeRule T N} {u v : List (Symbol T N)}", "{g : ContextFreeGrammar T} {u v : List (Symbol T g.NT)} {w : List T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : Type u_1\ng : ContextFreeGrammar T\nu : List (Symbol T g.NT)\n\u22a2 g.reverse.Generates u.reverse \u2194 g.Generates u"}, {"line": "simp [Generates]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem supports_insert {K S q} :\n    Supports (insert q K) S \u2194 TM2.SupportsStmt S (tr q) \u2227 Supports K S := by simp [Supports]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMToPartrec.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation", "ToPartrec", "K'", "TM2.Stmt"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nSupports : x\u271d\nK : ?m.836\nS : ?m.837\nq : ?m.838\n\u22a2 sorry \u2194 sorry \u2227 sorry"}, {"line": "simp [Supports]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem supports_singleton {S q} : Supports {q} S \u2194 TM2.SupportsStmt S (tr q) := by simp [Supports]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/TMToPartrec.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation", "ToPartrec", "K'", "TM2.Stmt"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nSupports : x\u271d\nS : ?m.425\nq : ?m.426\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [Supports]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventually_r_lt_n : \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, r i n < n := by\n  filter_upwards [eventually_ge_atTop R.n\u2080] with n hn\n  exact fun i => R.r_lt_n i n hn\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), r i n < n"}, {"line": "filter_upwards [eventually_ge_atTop R.n\u2080] with n hn", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : sorry \u2264 n\n\u22a2 \u2200 (i : \u03b1), r i n < n"}, {"line": "exact fun i => R.r_lt_n i n hn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_eventually_const_mul_le_r :\n    \u2203 c \u2208 Set.Ioo (0 : \u211d) 1, \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, c * n \u2264 r i n := by\n  have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)\n  exact \u27e8b (min_bi b) / 2, \u27e8\u27e8by positivity, R.bi_min_div_two_lt_one\u27e9, R.eventually_bi_mul_le_r\u27e9\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2203 c \u2208 Set.Ioo 0 1, \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c * \u2191n \u2264 \u2191(r i n)"}, {"line": "have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\ngt_zero : 0 < sorry\n\u22a2 \u2203 c \u2208 Set.Ioo 0 1, \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c * \u2191n \u2264 \u2191(r i n)"}, {"line": "exact \u27e8b (min_bi b) / 2, \u27e8\u27e8by positivity, R.bi_min_div_two_lt_one\u27e9, R.eventually_bi_mul_le_r\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventually_r_pos : \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, 0 < r i n := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r i).eventually_gt_atTop 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), 0 < r i n"}, {"line": "rw [Filter.eventually_all]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200 (i : \u03b1), \u2200\u1da0 (x : \u2115) in atTop, 0 < r i x\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 Finite \u03b1"}, {"line": "exact fun i => (R.tendsto_atTop_r i).eventually_gt_atTop 0", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 Finite \u03b1"}]}
{"declaration": "lemma deriv_smoothingFn {x : \u211d} (hx : 1 < x) : deriv \u03b5 x = -x\u207b\u00b9 / (log x ^ 2) := by\n  have : log x \u2260 0 := Real.log_ne_zero_of_pos_of_ne_one (by positivity) (ne_of_gt hx)\n  show deriv (fun z => 1 / log z) x = -x\u207b\u00b9 / (log x ^ 2)\n  rw [deriv_div] <;> aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b5 : \u211d \u2192 \u211d\nx : \u211d\nhx : 1 < x\n\u22a2 deriv \u03b5 x = -x\u207b\u00b9 / log x ^ 2"}, {"line": "have : log x \u2260 0 := Real.log_ne_zero_of_pos_of_ne_one (by positivity) (ne_of_gt hx)", "tactic_state": "\u03b5 : \u211d \u2192 \u211d\nx : \u211d\nhx : 1 < x\nthis : log x \u2260 0\n\u22a2 deriv \u03b5 x = -x\u207b\u00b9 / log x ^ 2"}, {"line": "show deriv (fun z => 1 / log z) x = -x\u207b\u00b9 / (log x ^ 2)", "tactic_state": "\u03b5 : \u211d \u2192 \u211d\nx : \u211d\nhx : 1 < x\nthis : log x \u2260 0\n\u22a2 deriv (fun z => 1 / log z) x = -x\u207b\u00b9 / log x ^ 2"}, {"line": "rw [deriv_div] <;> aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMonoOn_one_sub_smoothingFn :\n    StrictMonoOn (fun (x : \u211d) => (1 : \u211d) - \u03b5 x) (Set.Ioi 1) := by\n  simp_rw [sub_eq_add_neg]\n  exact StrictMonoOn.const_add (StrictAntiOn.neg <| strictAntiOn_smoothingFn) 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\n\u03b5 : x\u271d\n\u22a2 StrictMonoOn (fun x => 1 - sorry) (Set.Ioi 1)"}, {"line": "simp_rw [sub_eq_add_neg]", "tactic_state": "x\u271d : Sort u_3\n\u03b5 : x\u271d\n\u22a2 StrictMonoOn (fun x => 1 + -sorry) (Set.Ioi 1)"}, {"line": "exact StrictMonoOn.const_add (StrictAntiOn.neg <| strictAntiOn_smoothingFn) 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma continuous_sumCoeffsExp : Continuous (fun (p : \u211d) => \u2211 i, a i * (b i) ^ p) := by\n  refine continuous_finset_sum Finset.univ fun i _ => Continuous.mul (by fun_prop) ?_\n  exact Continuous.rpow continuous_const continuous_id (fun x => Or.inl (ne_of_gt (R.b_pos i)))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 Continuous fun p => \u2211 i, a i * b i ^ p"}, {"line": "refine continuous_finset_sum Finset.univ fun i _ => Continuous.mul (by fun_prop) ?_", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\ni : \u03b1\nx\u271d : i \u2208 univ\n\u22a2 Continuous (HPow.hPow (b i))"}, {"line": "exact Continuous.rpow continuous_const continuous_id (fun x => Or.inl (ne_of_gt (R.b_pos i)))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictAnti_sumCoeffsExp : StrictAnti (fun (p : \u211d) => \u2211 i, a i * (b i) ^ p) := by\n  rw [\u2190 Finset.sum_fn]\n  refine Finset.sum_induction_nonempty _ _ (fun _ _ => StrictAnti.add) univ_nonempty ?terms\n  refine fun i _ => StrictAnti.const_mul ?_ (R.a_pos i)\n  exact Real.strictAnti_rpow_of_base_lt_one (R.b_pos i) (R.b_lt_one i)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 StrictAnti fun p => \u2211 i, a i * b i ^ p"}, {"line": "rw [\u2190 Finset.sum_fn]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 StrictAnti (\u2211 c, fun p => a c * b c ^ p)"}, {"line": "refine Finset.sum_induction_nonempty _ _ (fun _ _ => StrictAnti.add) univ_nonempty ?terms", "tactic_state": "case terms\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200 x \u2208 univ, StrictAnti fun p => a x * b x ^ p"}, {"line": "refine fun i _ => StrictAnti.const_mul ?_ (R.a_pos i)", "tactic_state": "case terms\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\ni : \u03b1\nx\u271d : i \u2208 univ\n\u22a2 StrictAnti (HPow.hPow (b i))"}, {"line": "exact Real.strictAnti_rpow_of_base_lt_one (R.b_pos i) (R.b_lt_one i)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventually_asympBound_pos : \u2200\u1da0 (n : \u2115) in atTop, 0 < asympBound g a b n := by\n  filter_upwards [eventually_gt_atTop 0] with n hn\n  exact R.asympBound_pos n hn\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)", "(a b) in", "(g) (a) (b)", "{g} {a} {b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nasympBound : x\u271d\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, 0 < sorry"}, {"line": "filter_upwards [eventually_gt_atTop 0] with n hn", "tactic_state": "case h\nx\u271d : Sort u_3\nasympBound : x\u271d\nn : \u2115\nhn : 0 < n\n\u22a2 0 < sorry"}, {"line": "exact R.asympBound_pos n hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem to_ofList (l : List (Lists \u03b1)) : toList (ofList l) = l := by induction l <;> simp [*]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Lists.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\nl : List (Lists \u03b1)\n\u22a2 sorry = l"}, {"line": "induction l <;> simp [*]", "tactic_state": "case nil\n\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\n\u22a2 sorry () = []\n---\ncase cons\n\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\nhead\u271d : Lists \u03b1\ntail\u271d : List (Lists \u03b1)\ntail_ih\u271d : sorry = tail\u271d\n\u22a2 False"}]}
{"declaration": "theorem to_ofList (l : List (Lists \u03b1)) : toList (ofList l) = l := by simp [ofList, of']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Lists.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\nl : List (Lists \u03b1)\n\u22a2 sorry = l"}, {"line": "simp [ofList, of']", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoList : x\u271d\nl : List (Lists \u03b1)\n\u22a2 sorry () = l"}]}
{"declaration": "theorem lt_sizeof_cons' {b} (a : Lists' \u03b1 b) (l) :\n    SizeOf.sizeOf (\u27e8b, a\u27e9 : Lists \u03b1) < SizeOf.sizeOf (Lists'.cons' a l) := by\n  simp only [Sigma.mk.sizeOf_spec, Lists'.cons'.sizeOf_spec, lt_add_iff_pos_right]\n  apply sizeof_pos\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Lists.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nb : Bool\na : Lists' \u03b1 b\nl : Lists' \u03b1 true\n\u22a2 sizeOf \u27e8b, a\u27e9 < sizeOf (a.cons' l)"}, {"line": "simp only [Sigma.mk.sizeOf_spec, Lists'.cons'.sizeOf_spec, lt_add_iff_pos_right]", "tactic_state": "\u03b1 : Type u_1\nb : Bool\na : Lists' \u03b1 b\nl : Lists' \u03b1 true\n\u22a2 0 < sizeOf l"}, {"line": "apply sizeof_pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonneg : \u00acG < 0 := by\n  simpa using nonpos (-G)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Impartial.lean", "context": {"open": ["scoped PGame"], "variables": ["(G : PGame) [Impartial G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : \u2115\n\u22a2 \u00acG < 0"}, {"line": "simpa using nonpos (-G)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem birthday_zero : birthday 0 = 0 := by simp [inferInstanceAs (IsEmpty PEmpty)]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Birthday.lean", "context": {"open": ["Ordinal", "scoped NaturalOps PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbirthday : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [inferInstanceAs (IsEmpty PEmpty)]", "tactic_state": "x\u271d : Sort u_1\nbirthday : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem neg_birthday_le : -x.birthday.toPGame \u2264 x := by\n  simpa only [birthday_neg, \u2190 neg_le_iff] using le_birthday (-x)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Birthday.lean", "context": {"open": ["Ordinal", "scoped NaturalOps PGame"], "variables": ["(x : PGame.{u})"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : ?m.10\nx : sorry\n\u22a2 sorry"}, {"line": "simpa only [birthday_neg, \u2190 neg_le_iff] using le_birthday (-x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem moveLeft_toLeftMovesNim {o : Ordinal} (i) :\n    (nim o).moveLeft (toLeftMovesNim i) = nim i := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnim : x\u271d\no : Ordinal.{u_2}\ni : ?m.856\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem moveRight_toRightMovesNim {o : Ordinal} (i) :\n    (nim o).moveRight (toRightMovesNim i) = nim i := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnim : x\u271d\no : Ordinal.{u_2}\ni : ?m.856\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toLeftMovesNim_one_symm (i) :\n    (@toLeftMovesNim 1).symm i = \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9 := by\n  simp [eq_iff_true_of_subsingleton]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoLeftMovesNim : x\u271d\ni : ?m.446\n\u22a2 sorry = sorry"}, {"line": "simp [eq_iff_true_of_subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toRightMovesNim_one_symm (i) :\n    (@toRightMovesNim 1).symm i = \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9 := by\n  simp [eq_iff_true_of_subsingleton]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoRightMovesNim : x\u271d\ni : ?m.446\n\u22a2 sorry = sorry"}, {"line": "simp [eq_iff_true_of_subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nim_one_moveLeft (x) : (nim 1).moveLeft x = nim 0 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnim : x\u271d\nx : ?m.850\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nim_one_moveRight (x) : (nim 1).moveRight x = nim 0 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnim : x\u271d\nx : ?m.850\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_grundyValue_of_Iio_subset_moveLeft {G : PGame} {o : Nimber}\n    (h : Set.Iio o \u2286 Set.range (grundyValue \u2218 G.moveLeft)) : o \u2264 grundyValue G := by\n  by_contra! ho\n  obtain \u27e8i, hi\u27e9 := h ho\n  exact grundyValue_ne_moveLeft i hi\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Sort u_1\ngrundyValue : PGame \u2192 Nimber\nG : PGame\no : Nimber\nh : Set.Iio o \u2286 Set.range (grundyValue \u2218 sorry)\n\u22a2 o \u2264 grundyValue G"}, {"line": "by_contra! ho", "tactic_state": "PGame : Sort u_1\ngrundyValue : PGame \u2192 Nimber\nG : PGame\no : Nimber\nh : Set.Iio o \u2286 Set.range (grundyValue \u2218 sorry)\nho : grundyValue G < o\n\u22a2 False"}, {"line": "obtain \u27e8i, hi\u27e9 := h ho", "tactic_state": "case intro\nPGame : Sort u_1\ngrundyValue : PGame \u2192 Nimber\nG : PGame\no : Nimber\nh : Set.Iio o \u2286 Set.range (grundyValue \u2218 sorry)\nho : grundyValue G < o\ni : ?m.652\nhi : (grundyValue \u2218 sorry) i = grundyValue G\n\u22a2 False"}, {"line": "exact grundyValue_ne_moveLeft i hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem grundyValue_le_of_forall_moveLeft {G : PGame} {o : Nimber}\n    (h : \u2200 i, grundyValue (G.moveLeft i) \u2260 o) : G.grundyValue \u2264 o := by\n  contrapose! h\n  exact exists_grundyValue_moveLeft_of_lt h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Nim.lean", "context": {"open": ["scoped PGame", "Ordinal Nimber"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Sort u_1\nx\u271d : Sort u_2\ngrundyValue : x\u271d\nG : PGame\no : Nimber\nh : ?m.596 \u2192 sorry \u2260 o\n\u22a2 sorry \u2264 o"}, {"line": "contrapose! h", "tactic_state": "PGame : Sort u_1\nx\u271d : Sort u_2\ngrundyValue : x\u271d\nG : PGame\no : Nimber\nh : o < sorry\n\u22a2 \u2203 i, sorry = o"}, {"line": "exact exists_grundyValue_moveLeft_of_lt h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bddAbove_of_small (s : Set Game.{u}) [Small.{u} s] : BddAbove s := by\n  simpa using bddAbove_range_of_small (Subtype.val : s \u2192 Game.{u})\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Basic.lean", "context": {"open": ["Function PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nGame : x\u271d\ns : Set sorry\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry"}, {"line": "simpa using bddAbove_range_of_small (Subtype.val : s \u2192 Game.{u})", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bddBelow_of_small (s : Set Game.{u}) [Small.{u} s] : BddBelow s := by\n  simpa using bddBelow_range_of_small (Subtype.val : s \u2192 Game.{u})\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Basic.lean", "context": {"open": ["Function PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nGame : x\u271d\ns : Set sorry\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry"}, {"line": "simpa using bddBelow_range_of_small (Subtype.val : s \u2192 Game.{u})", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quot_neg_mul_neg (x y : PGame) : \u27e6-x * -y\u27e7 = (\u27e6x * y\u27e7 : Game) := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Basic.lean", "context": {"open": ["Function PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nGame : Sort u_2\nx y : PGame\n\u22a2 \u27e6sorry\u27e7 = sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nGame : Sort u_2\nx y : PGame\n\u22a2 \u27e6sorry ()\u27e7 = sorry ()"}]}
{"declaration": "lemma mulOption_neg_neg {x} (y) {i j} :\n    mulOption x y i j = mulOption x (-(-y)) i (toLeftMovesNeg <| toRightMovesNeg j) := by\n  simp [mulOption]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Basic.lean", "context": {"open": ["Function PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nmulOption : x\u271d\nx : ?m.850\ny : ?m.851\ni : ?m.852 y\nj : ?m.853 y\n\u22a2 sorry = sorry"}, {"line": "simp [mulOption]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toPGame_moveLeft {o : Ordinal} (i) :\n    o.toPGame.moveLeft (toLeftMovesToPGame i) = i.val.toPGame := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Ordinal.lean", "context": {"open": ["SetTheory PGame", "scoped NaturalOps PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoLeftMovesToPGame : x\u271d\no : Ordinal.{u_2}\ni : ?m.473\n\u22a2 o.toPGame.moveLeft sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\ntoLeftMovesToPGame : x\u271d\no : Ordinal.{u_2}\ni : ?m.473\n\u22a2 (\u2191(Ordinal.toLeftMovesToPGame.symm (sorry ()))).toPGame = sorry ()"}]}
{"declaration": "theorem to_leftMoves_one_toPGame_symm (i) :\n    (@toLeftMovesToPGame 1).symm i = \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9 := by\n  simp [eq_iff_true_of_subsingleton]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Ordinal.lean", "context": {"open": ["SetTheory PGame", "scoped NaturalOps PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoLeftMovesToPGame : x\u271d\ni : ?m.446\n\u22a2 sorry = sorry"}, {"line": "simp [eq_iff_true_of_subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_toPGame_moveLeft (x) : (toPGame 1).moveLeft x = toPGame 0 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Ordinal.lean", "context": {"open": ["SetTheory PGame", "scoped NaturalOps PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoPGame : x\u271d\nx : ?m.850\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short 0 := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short 1 := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short 2 := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short (-2) := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short (ofLists [0] [1]) := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short (ofLists [-2, -1] [1]) := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Short (0 + 0) := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nShort : x\u271d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Decidable ((1 : PGame) \u2264 1) := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Game/Short.lean", "context": {"open": ["scoped PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\n\u22a2 Decidable sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bddAbove_of_small (s : Set PGame.{u}) [Small.{u} s] : BddAbove s := by\n  simpa using bddAbove_range_of_small (Subtype.val : s \u2192 PGame.{u})\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Order.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nPGame : x\u271d\ns : Set sorry\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry"}, {"line": "simpa using bddAbove_range_of_small (Subtype.val : s \u2192 PGame.{u})", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bddBelow_of_small (s : Set PGame.{u}) [Small.{u} s] : BddBelow s := by\n  simpa using bddBelow_range_of_small (Subtype.val : s \u2192 PGame.{u})\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Order.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nPGame : x\u271d\ns : Set sorry\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry"}, {"line": "simpa using bddBelow_range_of_small (Subtype.val : s \u2192 PGame.{u})", "tactic_state": "No Goals!"}]}
{"declaration": "theorem moveLeft_neg_toLeftMovesNeg {x : PGame} (i) :\n    (-x).moveLeft (toLeftMovesNeg i) = -x.moveRight i := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.6605\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.6605\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveRight_neg_toRightMovesNeg {x : PGame} (i) :\n    (-x).moveRight (toRightMovesNeg i) = -x.moveLeft i := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.6605\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.6605\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveLeft_neg_symm {x : PGame} (i) :\n    x.moveLeft (toRightMovesNeg.symm i) = -(-x).moveRight i := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveLeft_neg_symm' {x : PGame} (i) :\n    x.moveLeft i = -(-x).moveRight (toRightMovesNeg i) := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveRight_neg_symm {x : PGame} (i) :\n    x.moveRight (toLeftMovesNeg.symm i) = -(-x).moveLeft i := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem moveRight_neg_symm' {x : PGame} (i) :\n    x.moveRight i = -(-x).moveLeft (toLeftMovesNeg i) := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/PGame/Algebra.lean", "context": {"open": ["Function Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry = -sorry"}, {"line": "simp", "tactic_state": "PGame : Type u_1\nx : PGame\ni : ?m.5987\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem aleph_mul_aleph (o\u2081 o\u2082 : Ordinal) : \u2135_ o\u2081 * \u2135_ o\u2082 = \u2135_ (max o\u2081 o\u2082) := by\n  rw [Cardinal.mul_eq_max (aleph0_le_aleph o\u2081) (aleph0_le_aleph o\u2082), aleph_max]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o\u2081 o\u2082 : Ordinal.{u_1}\n\u22a2 aleph o\u2081 * aleph o\u2082 = aleph (max o\u2081 o\u2082)"}, {"line": "rw [Cardinal.mul_eq_max (aleph0_le_aleph o\u2081) (aleph0_le_aleph o\u2082), aleph_max]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_max_of_aleph0_le_left {a b : Cardinal} (h : \u2135\u2080 \u2264 a) : a * b \u2264 max a b := by\n  convert mul_le_mul' (le_max_left a b) (le_max_right a b) using 1\n  rw [mul_eq_self]\n  exact h.trans (le_max_left a b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : aleph0 \u2264 a\n\u22a2 a * b \u2264 max a b"}, {"line": "convert mul_le_mul' (le_max_left a b) (le_max_right a b) using 1", "tactic_state": "case h.e'_4\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\n\u22a2 max a b = max a b * max a b"}, {"line": "rw [mul_eq_self]", "tactic_state": "case h.e'_4\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\n\u22a2 aleph0 \u2264 max a b"}, {"line": "exact h.trans (le_max_left a b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_max_of_aleph0_le_left {a b : Cardinal} (h : \u2135\u2080 \u2264 a) (h' : b \u2260 0) :\n    a * b = max a b := by\n  rcases le_or_lt \u2135\u2080 b with hb | hb\n  \u00b7 exact mul_eq_max h hb\n  refine (mul_le_max_of_aleph0_le_left h).antisymm ?_\n  have : b \u2264 a := hb.le.trans h\n  rw [max_eq_left this]\n  convert mul_le_mul_left' (one_le_iff_ne_zero.mpr h') a\n  rw [mul_one]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\n\u22a2 a * b = max a b"}, {"line": "rcases le_or_lt \u2135\u2080 b with hb | hb", "tactic_state": "case inl\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : sorry \u2264 b\n\u22a2 a * b = max a b\n---\ncase inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\n\u22a2 a * b = max a b"}, {"line": "\u00b7 exact mul_eq_max h hb", "tactic_state": "case inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\n\u22a2 a * b = max a b"}, {"line": "refine (mul_le_max_of_aleph0_le_left h).antisymm ?_", "tactic_state": "case inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\n\u22a2 max a b \u2264 a * b"}, {"line": "have : b \u2264 a := hb.le.trans h", "tactic_state": "case inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\nthis : b \u2264 a\n\u22a2 max a b \u2264 a * b"}, {"line": "rw [max_eq_left this]", "tactic_state": "case inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\nthis : b \u2264 a\n\u22a2 a \u2264 a * b"}, {"line": "convert mul_le_mul_left' (one_le_iff_ne_zero.mpr h') a", "tactic_state": "case h.e'_3\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a\nh' : b \u2260 0\nhb : b < sorry\nthis : b \u2264 a\n\u22a2 a = a * 1"}, {"line": "rw [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_max_of_aleph0_le_right {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a * b \u2264 max a b := by\n  simpa only [mul_comm b, max_comm b] using mul_le_max_of_aleph0_le_left h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : aleph0 \u2264 b\n\u22a2 a * b \u2264 max a b"}, {"line": "simpa only [mul_comm b, max_comm b] using mul_le_max_of_aleph0_le_left h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_max_of_aleph0_le_right {a b : Cardinal} (h' : a \u2260 0) (h : \u2135\u2080 \u2264 b) :\n    a * b = max a b := by\n  rw [mul_comm, max_comm]\n  exact mul_eq_max_of_aleph0_le_left h h'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh' : a \u2260 0\nh : aleph0 \u2264 b\n\u22a2 a * b = max a b"}, {"line": "rw [mul_comm, max_comm]", "tactic_state": "a b : Cardinal.{u_1}\nh' : a \u2260 0\nh : aleph0 \u2264 b\n\u22a2 b * a = max b a"}, {"line": "exact mul_eq_max_of_aleph0_le_left h h'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_max' {a b : Cardinal} (h : \u2135\u2080 \u2264 a * b) : a * b = max a b := by\n  rcases aleph0_le_mul_iff.mp h with \u27e8ha, hb, ha' | hb'\u27e9\n  \u00b7 exact mul_eq_max_of_aleph0_le_left ha' hb\n  \u00b7 exact mul_eq_max_of_aleph0_le_right ha hb'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nh : aleph0 \u2264 a * b\n\u22a2 a * b = max a b"}, {"line": "rcases aleph0_le_mul_iff.mp h with \u27e8ha, hb, ha' | hb'\u27e9", "tactic_state": "case intro.intro.inl\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a * b\nha : a \u2260 0\nhb : b \u2260 0\nha' : aleph0 \u2264 a\n\u22a2 a * b = max a b\n---\ncase intro.intro.inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a * b\nha : a \u2260 0\nhb : b \u2260 0\nhb' : aleph0 \u2264 b\n\u22a2 a * b = max a b"}, {"line": "\u00b7 exact mul_eq_max_of_aleph0_le_left ha' hb", "tactic_state": "case intro.intro.inr\na b : Cardinal.{u_1}\nh : aleph0 \u2264 a * b\nha : a \u2260 0\nhb : b \u2260 0\nhb' : aleph0 \u2264 b\n\u22a2 a * b = max a b"}, {"line": "\u00b7 exact mul_eq_max_of_aleph0_le_right ha hb'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_max' {a b : Cardinal} (ha : \u2135\u2080 \u2264 b) : a + b = max a b := by\n  rw [add_comm, max_comm, add_eq_max ha]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 b\n\u22a2 a + b = max a b"}, {"line": "rw [add_comm, max_comm, add_eq_max ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_right_iff {a b : Cardinal} : a + b = b \u2194 max \u2135\u2080 a \u2264 b \u2228 a = 0 := by\n  rw [add_comm, add_eq_left_iff]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\n\u22a2 a + b = b \u2194 max aleph0 a \u2264 b \u2228 a = 0"}, {"line": "rw [add_comm, add_eq_left_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_add_eq {a : Cardinal} (n : \u2115) (ha : \u2135\u2080 \u2264 a) : n + a = a := by\n  rw [add_comm, add_nat_eq n ha]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Cardinal.{u_1}\nn : \u2115\nha : aleph0 \u2264 a\n\u22a2 \u2191n + a = a"}, {"line": "rw [add_comm, add_nat_eq n ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_eq_iSup_lift {f : \u03b9 \u2192 Cardinal.{max u v}} (h\u03b9 : \u2135\u2080 \u2264 #\u03b9)\n    (h : lift.{v} #\u03b9 \u2264 iSup f) : sum f = iSup f := by\n  apply (iSup_le_sum f).antisymm'\n  convert sum_le_iSup_lift f\n  rw [mul_eq_max (aleph0_le_lift.mpr h\u03b9) ((aleph0_le_lift.mpr h\u03b9).trans h), max_eq_right h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{max u v}\nh\u03b9 : aleph0 \u2264 Cardinal.mk \u03b9\nh : Cardinal.lift.{v, u} (Cardinal.mk \u03b9) \u2264 iSup f\n\u22a2 sum f = iSup f"}, {"line": "apply (iSup_le_sum f).antisymm'", "tactic_state": "\u03b9 : Type u\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{max u v}\nh\u03b9 : aleph0 \u2264 Cardinal.mk \u03b9\nh : Cardinal.lift.{v, u} (Cardinal.mk \u03b9) \u2264 iSup f\n\u22a2 sum f \u2264 iSup f"}, {"line": "convert sum_le_iSup_lift f", "tactic_state": "case h.e'_4\n\u03b9 : Type u\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Cardinal.{max u v}\nh\u03b9 : aleph0 \u2264 Cardinal.mk \u03b9\nh : Cardinal.lift.{v, u} (Cardinal.mk \u03b9) \u2264 iSup f\n\u22a2 iSup f = Cardinal.lift.{v, u} (Cardinal.mk \u03b9) * iSup f"}, {"line": "rw [mul_eq_max (aleph0_le_lift.mpr h\u03b9) ((aleph0_le_lift.mpr h\u03b9).trans h), max_eq_right h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph_add_aleph (o\u2081 o\u2082 : Ordinal) : \u2135_ o\u2081 + \u2135_ o\u2082 = \u2135_ (max o\u2081 o\u2082) := by\n  rw [Cardinal.add_eq_max (aleph0_le_aleph o\u2081), aleph_max]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o\u2081 o\u2082 : Ordinal.{u_1}\n\u22a2 aleph o\u2081 + aleph o\u2082 = aleph (max o\u2081 o\u2082)"}, {"line": "rw [Cardinal.add_eq_max (aleph0_le_aleph o\u2081), aleph_max]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_le_add_iff_of_lt_aleph0 {\u03b1 \u03b2 \u03b3 : Cardinal} (\u03b3\u2080 : \u03b3 < \u2135\u2080) :\n    \u03b1 + \u03b3 \u2264 \u03b2 + \u03b3 \u2194 \u03b1 \u2264 \u03b2 := by\n  refine \u27e8fun h => ?_, fun h => add_le_add_right h \u03b3\u27e9\n  contrapose h\n  rw [not_le, lt_iff_le_and_ne, Ne] at h \u22a2\n  exact \u27e8add_le_add_right h.1 \u03b3, mt (add_right_inj_of_lt_aleph0 \u03b3\u2080).1 h.2\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\n\u22a2 \u03b1 + \u03b3 \u2264 \u03b2 + \u03b3 \u2194 \u03b1 \u2264 \u03b2"}, {"line": "refine \u27e8fun h => ?_, fun h => add_le_add_right h \u03b3\u27e9", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\nh : \u03b1 + \u03b3 \u2264 \u03b2 + \u03b3\n\u22a2 \u03b1 \u2264 \u03b2"}, {"line": "contrapose h", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\nh : \u00ac\u03b1 \u2264 \u03b2\n\u22a2 \u00ac\u03b1 + \u03b3 \u2264 \u03b2 + \u03b3"}, {"line": "rw [not_le, lt_iff_le_and_ne, Ne] at h \u22a2", "tactic_state": "\u03b1 \u03b2 \u03b3 : Cardinal.{u_1}\n\u03b3\u2080 : \u03b3 < aleph0\nh : \u03b2 \u2264 \u03b1 \u2227 \u00ac\u03b2 = \u03b1\n\u22a2 \u03b2 + \u03b3 \u2264 \u03b1 + \u03b3 \u2227 \u00ac\u03b2 + \u03b3 = \u03b1 + \u03b3"}, {"line": "exact \u27e8add_le_add_right h.1 \u03b3, mt (add_right_inj_of_lt_aleph0 \u03b3\u2080).1 h.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem power_self_eq {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c ^ c = 2 ^ c := by\n  apply ((power_le_power_right <| (cantor c).le).trans _).antisymm\n  \u00b7 exact power_le_power_right ((nat_lt_aleph0 2).le.trans h)\n  \u00b7 rw [\u2190 power_mul, mul_eq_self h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nh : aleph0 \u2264 c\n\u22a2 c ^ c = 2 ^ c"}, {"line": "apply ((power_le_power_right <| (cantor c).le).trans _).antisymm", "tactic_state": "c : Cardinal.{u_1}\nh : aleph0 \u2264 c\n\u22a2 2 ^ c \u2264 c ^ c\n---\nc : Cardinal.{u_1}\nh : aleph0 \u2264 c\n\u22a2 (2 ^ c) ^ c \u2264 2 ^ c"}, {"line": "\u00b7 exact power_le_power_right ((nat_lt_aleph0 2).le.trans h)", "tactic_state": "c : Cardinal.{u_1}\nh : aleph0 \u2264 c\n\u22a2 (2 ^ c) ^ c \u2264 2 ^ c"}, {"line": "\u00b7 rw [\u2190 power_mul, mul_eq_self h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem power_nat_le_max {c : Cardinal.{u}} {n : \u2115} : c ^ (n : Cardinal.{u}) \u2264 max c \u2135\u2080 := by\n  rcases le_or_lt \u2135\u2080 c with hc | hc\n  \u00b7 exact le_max_of_le_left (power_nat_le hc)\n  \u00b7 exact le_max_of_le_right (power_lt_aleph0 hc (nat_lt_aleph0 _)).le\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\nn : \u2115\n\u22a2 c ^ \u2191n \u2264 max c aleph0"}, {"line": "rcases le_or_lt \u2135\u2080 c with hc | hc", "tactic_state": "case inl\nc : Cardinal.{u}\nn : \u2115\nhc : sorry \u2264 c\n\u22a2 c ^ \u2191n \u2264 max c aleph0\n---\ncase inr\nc : Cardinal.{u}\nn : \u2115\nhc : c < sorry\n\u22a2 c ^ \u2191n \u2264 max c aleph0"}, {"line": "\u00b7 exact le_max_of_le_left (power_nat_le hc)", "tactic_state": "case inr\nc : Cardinal.{u}\nn : \u2115\nhc : c < sorry\n\u22a2 c ^ \u2191n \u2264 max c aleph0"}, {"line": "\u00b7 exact le_max_of_le_right (power_lt_aleph0 hc (nat_lt_aleph0 _)).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_equiv_eq_zero_iff_lift_ne : #(\u03b1 \u2243 \u03b2') = 0 \u2194 lift.{v} #\u03b1 \u2260 lift.{u} #\u03b2' := by\n  rw [mk_eq_zero_iff, \u2190 not_nonempty_iff, \u2190 lift_mk_eq']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk (\u03b1 \u2243 \u03b2') = 0 \u2194 Cardinal.lift.{v, u} (Cardinal.mk \u03b1) \u2260 Cardinal.lift.{u, v} (Cardinal.mk \u03b2')"}, {"line": "rw [mk_eq_zero_iff, \u2190 not_nonempty_iff, \u2190 lift_mk_eq']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_embedding_eq_zero_iff_lift_lt : #(\u03b1 \u21aa \u03b2') = 0 \u2194 lift.{u} #\u03b2' < lift.{v} #\u03b1 := by\n  rw [mk_eq_zero_iff, \u2190 not_nonempty_iff, \u2190 lift_mk_le', not_le]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk (\u03b1 \u21aa \u03b2') = 0 \u2194 Cardinal.lift.{u, v} (Cardinal.mk \u03b2') < Cardinal.lift.{v, u} (Cardinal.mk \u03b1)"}, {"line": "rw [mk_eq_zero_iff, \u2190 not_nonempty_iff, \u2190 lift_mk_le', not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_arrow_eq_zero_iff : #(\u03b1 \u2192 \u03b2') = 0 \u2194 #\u03b1 \u2260 0 \u2227 #\u03b2' = 0 := by\n  simp_rw [mk_eq_zero_iff, mk_ne_zero_iff, isEmpty_fun]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2' : Type v\n\u22a2 Cardinal.mk (\u03b1 \u2192 \u03b2') = 0 \u2194 Cardinal.mk \u03b1 \u2260 0 \u2227 Cardinal.mk \u03b2' = 0"}, {"line": "simp_rw [mk_eq_zero_iff, mk_ne_zero_iff, isEmpty_fun]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_list_eq_mk (\u03b1 : Type u) [Infinite \u03b1] : #(List \u03b1) = #\u03b1 :=\n  have H1 : \u2135\u2080 \u2264 #\u03b1 := aleph0_le_mk \u03b1\n  Eq.symm <|\n    le_antisymm ((le_def _ _).2 \u27e8\u27e8fun a => [a], fun _ => by simp\u27e9\u27e9) <|\n      calc\n        #(List \u03b1) = sum fun n : \u2115 => #\u03b1 ^ (n : Cardinal.{u}) := mk_list_eq_sum_pow \u03b1\n        _ \u2264 sum fun _ : \u2115 => #\u03b1 := sum_le_sum _ _ fun n => pow_le H1 <| nat_lt_aleph0 n\n        _ = #\u03b1 := by simp [H1]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}", "(\u03b1 \u03b2')", "[Infinite \u03b1] {\u03b1 \u03b2'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Infinite \u03b1\nH1 : aleph0 \u2264 Cardinal.mk \u03b1\n\u22a2 (sum fun x => Cardinal.mk \u03b1) = Cardinal.mk \u03b1\n---\n\u03b1 : Type u\ninst\u271d : Infinite \u03b1\nH1 : \u2135\u2080 \u2264 #\u03b1\nx\u271d : \u03b1\n\u22a2 \u2200 \u2983a\u2082 : \u03b1\u2984, (fun a => [a]) x\u271d = (fun a => [a]) a\u2082 \u2192 x\u271d = a\u2082"}, {"line": "simp [H1]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_compl_of_infinite {\u03b1 : Type*} [Infinite \u03b1] (s : Set \u03b1) (h2 : #s < #\u03b1) :\n    #(s\u1d9c : Set \u03b1) = #\u03b1 := by\n  refine eq_of_add_eq_of_aleph0_le ?_ h2 (aleph0_le_mk \u03b1)\n  exact mk_sum_compl s\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Arithmetic.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})", "[Nonempty \u03b9] [Nonempty \u03b9']", "{\u03b1 \u03b2 : Type u} {\u03b2' : Type v}", "(\u03b1 \u03b2')", "[Infinite \u03b1] {\u03b1 \u03b2'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Infinite \u03b1\ns : Set \u03b1\nh2 : Cardinal.mk \u2191s < Cardinal.mk \u03b1\n\u22a2 Cardinal.mk \u2191s\u1d9c = Cardinal.mk \u03b1"}, {"line": "refine eq_of_add_eq_of_aleph0_le ?_ h2 (aleph0_le_mk \u03b1)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Infinite \u03b1\ns : Set \u03b1\nh2 : Cardinal.mk \u2191s < Cardinal.mk \u03b1\n\u22a2 Cardinal.mk \u2191s + Cardinal.mk \u2191s\u1d9c = Cardinal.mk \u03b1"}, {"line": "exact mk_sum_compl s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInitial.card_le_card {a b : Ordinal} (ha : IsInitial a) : a.card \u2264 b.card \u2194 a \u2264 b := by\n  refine \u27e8fun h \u21a6 ?_, Ordinal.card_le_card\u27e9\n  rw [\u2190 ord_le_ord, ha.ord_card] at h\n  exact h.trans (ord_card_le b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nha : a.IsInitial\n\u22a2 a.card \u2264 b.card \u2194 a \u2264 b"}, {"line": "refine \u27e8fun h \u21a6 ?_, Ordinal.card_le_card\u27e9", "tactic_state": "a b : Ordinal.{u_1}\nha : a.IsInitial\nh : a.card \u2264 b.card\n\u22a2 a \u2264 b"}, {"line": "rw [\u2190 ord_le_ord, ha.ord_card] at h", "tactic_state": "a b : Ordinal.{u_1}\nha : a.IsInitial\nh : a \u2264 b.card.ord\n\u22a2 a \u2264 b"}, {"line": "exact h.trans (ord_card_le b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_ord (c : Cardinal) : IsInitial c.ord := by\n  rw [IsInitial, card_ord]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c.ord.IsInitial"}, {"line": "rw [IsInitial, card_ord]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_natCast (n : \u2115) : IsInitial n := by\n  rw [IsInitial, card_nat, ord_nat]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (\u2191n).IsInitial"}, {"line": "rw [IsInitial, card_nat, ord_nat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_zero : IsInitial 0 := by\n  exact_mod_cast isInitial_natCast 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 IsInitial 0"}, {"line": "exact_mod_cast isInitial_natCast 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_one : IsInitial 1 := by\n  exact_mod_cast isInitial_natCast 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 IsInitial 1"}, {"line": "exact_mod_cast isInitial_natCast 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInitial_omega0 : IsInitial \u03c9 := by\n  rw [IsInitial, card_omega0, ord_aleph0]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 omega0.IsInitial"}, {"line": "rw [IsInitial, card_omega0, ord_aleph0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_bddAbove_isInitial : \u00ac BddAbove {x | IsInitial x} := by\n  rintro \u27e8a, ha\u27e9\n  have := ha (isInitial_ord (succ a.card))\n  rw [ord_le] at this\n  exact (lt_succ _).not_le this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acBddAbove {x | x.IsInitial}"}, {"line": "rintro \u27e8a, ha\u27e9", "tactic_state": "case intro\na : Ordinal.{u_1}\nha : a \u2208 upperBounds {x | x.IsInitial}\n\u22a2 False"}, {"line": "have := ha (isInitial_ord (succ a.card))", "tactic_state": "case intro\na : Ordinal.{u_1}\nha : a \u2208 upperBounds {x | x.IsInitial}\nthis : (succ a.card).ord \u2264 a\n\u22a2 False"}, {"line": "rw [ord_le] at this", "tactic_state": "case intro\na : Ordinal.{u_1}\nha : a \u2208 upperBounds {x | x.IsInitial}\nthis : succ a.card \u2264 a.card\n\u22a2 False"}, {"line": "exact (lt_succ _).not_le this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preOmega_zero : preOmega 0 = 0 := by\n  rw [coe_preOmega, enumOrd_zero]\n  exact csInf_eq_bot_of_bot_mem isInitial_zero\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preOmega 0 = 0"}, {"line": "rw [coe_preOmega, enumOrd_zero]", "tactic_state": "\u22a2 sInf {x | x.IsInitial} = 0"}, {"line": "exact csInf_eq_bot_of_bot_mem isInitial_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_range_preOmega_iff {x : Ordinal} : x \u2208 range preOmega \u2194 IsInitial x := by\n  rw [range_preOmega, mem_setOf]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 x \u2208 range \u21d1preOmega \u2194 x.IsInitial"}, {"line": "rw [range_preOmega, mem_setOf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preOmega_omega0 : preOmega \u03c9 = \u03c9 := by\n  simp_rw [\u2190 isNormal_preOmega.apply_omega0, preOmega_natCast, iSup_natCast]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preOmega omega0 = omega0"}, {"line": "simp_rw [\u2190 isNormal_preOmega.apply_omega0, preOmega_natCast, iSup_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega0_le_preOmega_iff {x : Ordinal} : \u03c9 \u2264 preOmega x \u2194 \u03c9 \u2264 x := by\n  conv_lhs => rw [\u2190 preOmega_omega0, preOmega_le_preOmega]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 omega0 \u2264 preOmega x \u2194 omega0 \u2264 x"}, {"line": "conv_lhs => rw [\u2190 preOmega_omega0, preOmega_le_preOmega]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega0_lt_preOmega_iff {x : Ordinal} : \u03c9 < preOmega x \u2194 \u03c9 < x := by\n  conv_lhs => rw [\u2190 preOmega_omega0, preOmega_lt_preOmega]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 omega0 < preOmega x \u2194 omega0 < x"}, {"line": "conv_lhs => rw [\u2190 preOmega_omega0, preOmega_lt_preOmega]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega_zero : \u03c9_ 0 = \u03c9 := by\n  rw [omega_eq_preOmega, add_zero, preOmega_omega0]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 omega 0 = omega0"}, {"line": "rw [omega_eq_preOmega, add_zero, preOmega_omega0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega0_le_omega (o : Ordinal) : \u03c9 \u2264 \u03c9_ o := by\n  rw [\u2190 omega_zero, omega_le_omega]\n  exact Ordinal.zero_le o\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 omega0 \u2264 omega o"}, {"line": "rw [\u2190 omega_zero, omega_le_omega]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 0 \u2264 o"}, {"line": "exact Ordinal.zero_le o", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omega0_lt_omega1 : \u03c9 < \u03c9\u2081 := by\n  rw [\u2190 omega_zero, omega_lt_omega]\n  exact zero_lt_one\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 omega0 < omega 1"}, {"line": "rw [\u2190 omega_zero, omega_lt_omega]", "tactic_state": "\u22a2 0 < 1"}, {"line": "exact zero_lt_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_range_omega_iff {x : Ordinal} : x \u2208 range omega \u2194 \u03c9 \u2264 x \u2227 IsInitial x := by\n  rw [range_omega, mem_setOf]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Ordinal.{u_1}\n\u22a2 x \u2208 range \u21d1omega \u2194 omega0 \u2264 x \u2227 x.IsInitial"}, {"line": "rw [range_omega, mem_setOf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ord_preAleph (o : Ordinal) : (preAleph o).ord = preOmega o := by\n  rw [\u2190 o.card_preOmega, (isInitial_preOmega o).ord_card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 (preAleph o).ord = preOmega o"}, {"line": "rw [\u2190 o.card_preOmega, (isInitial_preOmega o).ord_card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem type_cardinal : typeLT Cardinal = Ordinal.univ.{u, u + 1} := by\n  rw [Ordinal.univ_id]\n  exact Quotient.sound \u27e8preAleph.symm.toRelIsoLT\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (type fun x1 x2 => x1 < x2) = Ordinal.univ.{u, u + 1}"}, {"line": "rw [Ordinal.univ_id]", "tactic_state": "\u22a2 (type fun x1 x2 => x1 < x2) = type fun x1 x2 => x1 < x2"}, {"line": "exact Quotient.sound \u27e8preAleph.symm.toRelIsoLT\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_nat (n : \u2115) : preAleph n = n := by\n  rw [\u2190 card_preOmega, preOmega_natCast, card_nat]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 preAleph \u2191n = \u2191n"}, {"line": "rw [\u2190 card_preOmega, preOmega_natCast, card_nat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_omega0 : preAleph \u03c9 = \u2135\u2080 := by\n  rw [\u2190 card_preOmega, preOmega_omega0, card_omega0]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preAleph omega0 = aleph0"}, {"line": "rw [\u2190 card_preOmega, preOmega_omega0, card_omega0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_pos {o : Ordinal} : 0 < preAleph o \u2194 0 < o := by\n  rw [\u2190 preAleph_zero, preAleph_lt_preAleph]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 0 < preAleph o \u2194 0 < o"}, {"line": "rw [\u2190 preAleph_zero, preAleph_lt_preAleph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_le_preAleph {o : Ordinal} : \u2135\u2080 \u2264 preAleph o \u2194 \u03c9 \u2264 o := by\n  rw [\u2190 preAleph_omega0, preAleph_le_preAleph]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 aleph0 \u2264 preAleph o \u2194 omega0 \u2264 o"}, {"line": "rw [\u2190 preAleph_omega0, preAleph_le_preAleph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_limit {o : Ordinal} (ho : o.IsLimit) : preAleph o = \u2a06 a : Iio o, preAleph a := by\n  refine le_antisymm ?_ (ciSup_le' fun i => preAleph_le_preAleph.2 i.2.le)\n  rw [preAleph_le_of_isLimit ho]\n  exact fun a ha => le_ciSup (bddAbove_of_small _) (\u27e8a, ha\u27e9 : Iio o)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nho : o.IsLimit\n\u22a2 preAleph o = \u2a06 a, preAleph \u2191a"}, {"line": "refine le_antisymm ?_ (ciSup_le' fun i => preAleph_le_preAleph.2 i.2.le)", "tactic_state": "o : Ordinal.{u_1}\nho : o.IsLimit\n\u22a2 preAleph o \u2264 \u2a06 a, preAleph \u2191a"}, {"line": "rw [preAleph_le_of_isLimit ho]", "tactic_state": "o : Ordinal.{u_1}\nho : o.IsLimit\n\u22a2 \u2200 o' < o, preAleph o' \u2264 \u2a06 a, preAleph \u2191a"}, {"line": "exact fun a ha => le_ciSup (bddAbove_of_small _) (\u27e8a, ha\u27e9 : Iio o)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preAleph_le_of_strictMono {f : Ordinal \u2192 Cardinal} (hf : StrictMono f) (o : Ordinal) :\n    preAleph o \u2264 f o := by\n  simpa using (hf.comp preAleph.symm.strictMono).id_le (preAleph o)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : Ordinal.{u_1} \u2192 Cardinal.{u_1}\nhf : StrictMono f\no : Ordinal.{u_1}\n\u22a2 preAleph o \u2264 f o"}, {"line": "simpa using (hf.comp preAleph.symm.strictMono).id_le (preAleph o)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph_succ (o : Ordinal) : \u2135_ (succ o) = succ (\u2135_ o) := by\n  rw [aleph_eq_preAleph, add_succ, preAleph_succ, aleph_eq_preAleph]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 aleph (succ o) = succ (aleph o)"}, {"line": "rw [aleph_eq_preAleph, add_succ, preAleph_succ, aleph_eq_preAleph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph_zero : \u2135_ 0 = \u2135\u2080 := by rw [aleph_eq_preAleph, add_zero, preAleph_omega0]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 aleph 0 = aleph0"}, {"line": "rw [aleph_eq_preAleph, add_zero, preAleph_omega0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_aleph (o : Ordinal.{u}) : lift.{v} (aleph o) = aleph (Ordinal.lift.{v} o) := by\n  simp [aleph_eq_preAleph]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\n\u22a2 Cardinal.lift.{v, u} (aleph o) = aleph (Ordinal.lift.{v, u} o)"}, {"line": "simp [aleph_eq_preAleph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_le_aleph (o : Ordinal) : \u2135\u2080 \u2264 \u2135_ o := by\n  rw [aleph_eq_preAleph, aleph0_le_preAleph]\n  apply Ordinal.le_add_right\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 aleph0 \u2264 aleph o"}, {"line": "rw [aleph_eq_preAleph, aleph0_le_preAleph]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 omega0 \u2264 omega0 + o"}, {"line": "apply Ordinal.le_add_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLimit_omega (o : Ordinal) : Ordinal.IsLimit (\u03c9_ o) := by\n  rw [\u2190 ord_aleph]\n  exact isLimit_ord (aleph0_le_aleph _)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 (omega o).IsLimit"}, {"line": "rw [\u2190 ord_aleph]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 (aleph o).ord.IsLimit"}, {"line": "exact isLimit_ord (aleph0_le_aleph _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_range_aleph_iff {c : Cardinal} : c \u2208 range aleph \u2194 \u2135\u2080 \u2264 c := by\n  rw [range_aleph, mem_Ici]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c \u2208 range \u21d1aleph \u2194 aleph0 \u2264 c"}, {"line": "rw [range_aleph, mem_Ici]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_aleph0 : succ \u2135\u2080 = \u2135\u2081 := by\n  rw [\u2190 aleph_zero, \u2190 aleph_succ, Ordinal.succ_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 succ aleph0 = aleph 1"}, {"line": "rw [\u2190 aleph_zero, \u2190 aleph_succ, Ordinal.succ_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_lt_aleph_one : \u2135\u2080 < \u2135\u2081 := by\n  rw [\u2190 succ_aleph0]\n  apply lt_succ\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 aleph0 < aleph 1"}, {"line": "rw [\u2190 succ_aleph0]", "tactic_state": "\u22a2 aleph0 < succ aleph0"}, {"line": "apply lt_succ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem countable_iff_lt_aleph_one {\u03b1 : Type*} (s : Set \u03b1) : s.Countable \u2194 #s < \u2135\u2081 := by\n  rw [\u2190 succ_aleph0, lt_succ_iff, le_aleph0_iff_set_countable]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s.Countable \u2194 Cardinal.mk \u2191s < aleph 1"}, {"line": "rw [\u2190 succ_aleph0, lt_succ_iff, le_aleph0_iff_set_countable]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph1_le_lift {c : Cardinal.{u}} : \u2135\u2081 \u2264 lift.{v} c \u2194 \u2135\u2081 \u2264 c := by\n  simpa using lift_le (a := \u2135\u2081)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 aleph 1 \u2264 Cardinal.lift.{v, u} c \u2194 aleph 1 \u2264 c"}, {"line": "simpa using lift_le (a := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_le_aleph1 {c : Cardinal.{u}} : lift.{v} c \u2264 \u2135\u2081 \u2194 c \u2264 \u2135\u2081 := by\n  simpa using lift_le (b := \u2135\u2081)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 Cardinal.lift.{v, u} c \u2264 aleph 1 \u2194 c \u2264 aleph 1"}, {"line": "simpa using lift_le (b := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph1_lt_lift {c : Cardinal.{u}} : \u2135\u2081 < lift.{v} c \u2194 \u2135\u2081 < c := by\n  simpa using lift_lt (a := \u2135\u2081)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 aleph 1 < Cardinal.lift.{v, u} c \u2194 aleph 1 < c"}, {"line": "simpa using lift_lt (a := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_lt_aleph1 {c : Cardinal.{u}} : lift.{v} c < \u2135\u2081 \u2194 c < \u2135\u2081 := by\n  simpa using lift_lt (b := \u2135\u2081)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 Cardinal.lift.{v, u} c < aleph 1 \u2194 c < aleph 1"}, {"line": "simpa using lift_lt (b := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph1_eq_lift {c : Cardinal.{u}} : \u2135\u2081 = lift.{v} c \u2194 \u2135\u2081 = c := by\n  simpa using lift_inj (a := \u2135\u2081)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 aleph 1 = Cardinal.lift.{v, u} c \u2194 aleph 1 = c"}, {"line": "simpa using lift_inj (a := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_eq_aleph1 {c : Cardinal.{u}} : lift.{v} c = \u2135\u2081 \u2194 c = \u2135\u2081 := by\n  simpa using lift_inj (b := \u2135\u2081)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u}\n\u22a2 Cardinal.lift.{v, u} c = aleph 1 \u2194 c = aleph 1"}, {"line": "simpa using lift_inj (b := \u2135\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_omega_iff_card_lt {x o : Ordinal} : x < \u03c9_ o \u2194 x.card < \u2135_ o := by\n  rw [\u2190 (isInitial_omega o).card_lt_card, card_omega]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x o : Ordinal.{u_1}\n\u22a2 x < omega o \u2194 x.card < aleph o"}, {"line": "rw [\u2190 (isInitial_omega o).card_lt_card, card_omega]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preBeth_zero : preBeth 0 = 0 := by\n  rw [preBeth]\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preBeth 0 = 0"}, {"line": "rw [preBeth]", "tactic_state": "\u22a2 \u2a06 a, 2 ^ preBeth \u2191a = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preBeth_one : preBeth 1 = 1 := by\n  simpa using preBeth_nat 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 preBeth 1 = 1"}, {"line": "simpa using preBeth_nat 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preBeth_pos {o : Ordinal} : 0 < preBeth o \u2194 0 < o := by\n  simpa using preBeth_lt_preBeth (o\u2081 := 0)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 0 < preBeth o \u2194 0 < o"}, {"line": "simpa using preBeth_lt_preBeth (o\u2081 := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem beth_zero : \u2136_ 0 = \u2135\u2080 := by\n  simp [beth]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 beth 0 = aleph0"}, {"line": "simp [beth]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem beth_succ (o : Ordinal) : \u2136_ (succ o) = 2 ^ \u2136_ o := by\n  simp [beth]\n  simp [add_succ]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Aleph.lean", "context": {"open": ["Function Set Cardinal Equiv Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 beth (succ o) = 2 ^ beth o"}, {"line": "simp [beth]", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 preBeth (omega0 + succ o) = 2 ^ preBeth (omega0 + o)"}, {"line": "simp [add_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsRegular.cof_omega_eq {o : Ordinal} (H : (\u2135_ o).IsRegular) : (\u03c9_ o).cof = \u2135_ o := by\n  rw [\u2190 ord_aleph, H.cof_eq]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nH : (aleph o).IsRegular\n\u22a2 (omega o).cof = aleph o"}, {"line": "rw [\u2190 ord_aleph, H.cof_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsRegular.ord_pos {c : Cardinal} (H : c.IsRegular) : 0 < c.ord := by\n  rw [Cardinal.lt_ord, card_zero]\n  exact H.pos\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nH : c.IsRegular\n\u22a2 0 < c.ord"}, {"line": "rw [Cardinal.lt_ord, card_zero]", "tactic_state": "c : Cardinal.{u_1}\nH : c.IsRegular\n\u22a2 0 < c"}, {"line": "exact H.pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_lt_of_card_biUnion_lt {\u03b1 \u03b2 : Type u} {s : Set \u03b1} {t : \u2200 a \u2208 s, Set \u03b2} {c : Cardinal}\n    (h : #(\u22c3 a \u2208 s, t a \u2039_\u203a) < c) (a : \u03b1) (ha : a \u2208 s) : # (t a ha) < c := by\n  rw [biUnion_eq_iUnion] at h\n  have := card_lt_of_card_iUnion_lt h\n  simp_all only [iUnion_coe_set, Subtype.forall]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nh : mk \u2191(\u22c3 a, \u22c3 (h : a \u2208 s), t a h) < c\na : \u03b1\nha : a \u2208 s\n\u22a2 mk \u2191(t a ha) < c\n---\n\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\na : \u03b1\nh\u271d : a \u2208 s\n\u22a2 a \u2208 s"}, {"line": "rw [biUnion_eq_iUnion] at h", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nh : mk \u2191(\u22c3 x, t \u2191x \u22ef) < c\na : \u03b1\nha : a \u2208 s\n\u22a2 mk \u2191(t a ha) < c"}, {"line": "have := card_lt_of_card_iUnion_lt h", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nh : mk \u2191(\u22c3 x, t \u2191x \u22ef) < c\na : \u03b1\nha : a \u2208 s\nthis : \u2200 (i : \u2191s), mk \u2191(t \u2191i \u22ef) < c\n\u22a2 mk \u2191(t a ha) < c"}, {"line": "simp_all only [iUnion_coe_set, Subtype.forall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_biUnion_lt_iff_forall_of_isRegular {\u03b1 \u03b2 : Type u} {s : Set \u03b1} {t : \u2200 a \u2208 s, Set \u03b2}\n    {c : Cardinal} (hc : c.IsRegular) (hs : #s < c) :\n    #(\u22c3 a \u2208 s, t a \u2039_\u203a) < c \u2194 \u2200 a (ha : a \u2208 s), # (t a ha) < c := by\n  rw [biUnion_eq_iUnion, card_iUnion_lt_iff_forall_of_isRegular hc hs, SetCoe.forall']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nhc : c.IsRegular\nhs : mk \u2191s < c\n\u22a2 mk \u2191(\u22c3 a, \u22c3 (h : a \u2208 s), t a h) < c \u2194 \u2200 (a : \u03b1) (ha : a \u2208 s), mk \u2191(t a ha) < c\n---\n\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nc : Cardinal.{u}\nhc : c.IsRegular\nhs : #\u2191s < c\na : \u03b1\nh\u271d : a \u2208 s\n\u22a2 a \u2208 s"}, {"line": "rw [biUnion_eq_iUnion, card_iUnion_lt_iff_forall_of_isRegular hc hs, SetCoe.forall']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nfpFamily_lt_ord_lift_of_isRegular {\u03b9} {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c) (hc' : c \u2260 \u2135\u2080) (hf : \u2200 (i), \u2200 b < c.ord, f i b < c.ord) {a}\n    (ha : a < c.ord) : nfpFamily f a < c.ord := by\n  apply nfpFamily_lt_ord_lift _ _ hf ha <;> rw [hc.cof_eq]\n  \u00b7 exact lt_of_le_of_ne hc.1 hc'.symm\n  \u00b7 exact h\u03b9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nh\u03b9 : Cardinal.lift.{v, u} (mk \u03b9) < c\nhc' : c \u2260 aleph0\nhf : \u2200 (i : \u03b9), \u2200 b < c.ord, f i b < c.ord\na : Ordinal.{max u v}\nha : a < c.ord\n\u22a2 nfpFamily f a < c.ord"}, {"line": "apply nfpFamily_lt_ord_lift _ _ hf ha <;> rw [hc.cof_eq]", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nh\u03b9 : Cardinal.lift.{v, u} (mk \u03b9) < c\nhc' : c \u2260 aleph0\nhf : \u2200 (i : \u03b9), \u2200 b < c.ord, f i b < c.ord\na : Ordinal.{max u v}\nha : a < c.ord\n\u22a2 aleph0 < c\n---\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nh\u03b9 : Cardinal.lift.{v, u} (mk \u03b9) < c\nhc' : c \u2260 aleph0\nhf : \u2200 (i : \u03b9), \u2200 b < c.ord, f i b < c.ord\na : Ordinal.{max u v}\nha : a < c.ord\n\u22a2 Cardinal.lift.{v, u} (mk \u03b9) < c"}, {"line": "\u00b7 exact lt_of_le_of_ne hc.1 hc'.symm", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nh\u03b9 : Cardinal.lift.{v, u} (mk \u03b9) < c\nhc' : c \u2260 aleph0\nhf : \u2200 (i : \u03b9), \u2200 b < c.ord, f i b < c.ord\na : Ordinal.{max u v}\nha : a < c.ord\n\u22a2 Cardinal.lift.{v, u} (mk \u03b9) < c"}, {"line": "\u00b7 exact h\u03b9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iSup_sequence_lt_omega1 {\u03b1 : Type u} [Countable \u03b1]\n    (o : \u03b1 \u2192 Ordinal.{max u v}) (ho : \u2200 n, o n < (aleph 1).ord) :\n    iSup o < (aleph 1).ord := by\n  apply iSup_lt_ord_lift _ ho\n  rw [Cardinal.isRegular_aleph_one.cof_eq]\n  exact lt_of_le_of_lt mk_le_aleph0 aleph0_lt_aleph_one\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Regular.lean", "context": {"open": ["Function Cardinal Set Order Ordinal", "Cardinal", "scoped Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Countable \u03b1\no : \u03b1 \u2192 Ordinal.{max u v}\nho : \u2200 (n : \u03b1), o n < (aleph 1).ord\n\u22a2 iSup o < (aleph 1).ord"}, {"line": "apply iSup_lt_ord_lift _ ho", "tactic_state": "\u03b1 : Type u\ninst\u271d : Countable \u03b1\no : \u03b1 \u2192 Ordinal.{max u v}\nho : \u2200 (n : \u03b1), o n < (aleph 1).ord\n\u22a2 Cardinal.lift.{v, u} (mk \u03b1) < (aleph 1).ord.cof"}, {"line": "rw [Cardinal.isRegular_aleph_one.cof_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Countable \u03b1\no : \u03b1 \u2192 Ordinal.{max u v}\nho : \u2200 (n : \u03b1), o n < (aleph 1).ord\n\u22a2 Cardinal.lift.{v, u} (mk \u03b1) < aleph 1"}, {"line": "exact lt_of_le_of_lt mk_le_aleph0 aleph0_lt_aleph_one", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_eq_finsetCard (s : Finset \u03b1) : Nat.card s = s.card := by\n  simp only [Nat.card_eq_fintype_card, Fintype.card_coe]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\n\u22a2 Nat.card { x // x \u2208 s } = s.card"}, {"line": "simp only [Nat.card_eq_fintype_card, Fintype.card_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_eq_card_toFinset (s : Set \u03b1) [Fintype s] : Nat.card s = s.toFinset.card := by\n  simp only [\u2190 Nat.card_eq_finsetCard, s.mem_toFinset]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 Nat.card \u2191s = s.toFinset.card"}, {"line": "simp only [\u2190 Nat.card_eq_finsetCard, s.mem_toFinset]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 Nat.card \u2191s = Nat.card { x // x \u2208 s.toFinset }"}]}
{"declaration": "lemma card_eq_card_finite_toFinset {s : Set \u03b1} (hs : s.Finite) : Nat.card s = hs.toFinset.card := by\n  simp only [\u2190 Nat.card_eq_finsetCard, hs.mem_toFinset]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\n\u22a2 Nat.card \u2191s = hs.toFinset.card"}, {"line": "simp only [\u2190 Nat.card_eq_finsetCard, hs.mem_toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cast_card [Finite \u03b1] : (Nat.card \u03b1 : Cardinal) = Cardinal.mk \u03b1 := by\n  rw [Nat.card, Cardinal.cast_toNat_of_lt_aleph0]\n  exact Cardinal.lt_aleph0_of_finite _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 \u2191(Nat.card \u03b1) = mk \u03b1"}, {"line": "rw [Nat.card, Cardinal.cast_toNat_of_lt_aleph0]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 mk \u03b1 < aleph0"}, {"line": "exact Cardinal.lt_aleph0_of_finite _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_eq_zero : Nat.card \u03b1 = 0 \u2194 IsEmpty \u03b1 \u2228 Infinite \u03b1 := by\n  simp [Nat.card]\n  simp [mk_eq_zero_iff]\n  simp [aleph0_le_mk_iff]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Nat.card \u03b1 = 0 \u2194 IsEmpty \u03b1 \u2228 Infinite \u03b1"}, {"line": "simp [Nat.card]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 mk \u03b1 = 0 \u2228 aleph0 \u2264 mk \u03b1 \u2194 IsEmpty \u03b1 \u2228 Infinite \u03b1"}, {"line": "simp [mk_eq_zero_iff]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 IsEmpty \u03b1 \u2228 aleph0 \u2264 mk \u03b1 \u2194 IsEmpty \u03b1 \u2228 Infinite \u03b1"}, {"line": "simp [aleph0_le_mk_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_ne_zero : Nat.card \u03b1 \u2260 0 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1 := by simp [card_eq_zero, not_or]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Nat.card \u03b1 \u2260 0 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1"}, {"line": "simp [card_eq_zero, not_or]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u00acNat.card \u03b1 = 0 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1"}]}
{"declaration": "lemma card_pos_iff : 0 < Nat.card \u03b1 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1 := by\n  simp [Nat.card]\n  simp [mk_eq_zero_iff]\n  simp [mk_lt_aleph0_iff]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 0 < Nat.card \u03b1 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1"}, {"line": "simp [Nat.card]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u00acmk \u03b1 = 0 \u2227 mk \u03b1 < aleph0 \u2194 Nonempty \u03b1 \u2227 Finite \u03b1"}, {"line": "simp [mk_eq_zero_iff]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u03b1 \u2192 (mk \u03b1 < aleph0 \u2194 Finite \u03b1)"}, {"line": "simp [mk_lt_aleph0_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_le_card_of_injective {\u03b1 : Type u} {\u03b2 : Type v} [Finite \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hf : Injective f) : Nat.card \u03b1 \u2264 Nat.card \u03b2 := by\n  simpa using toNat_le_toNat (lift_mk_le_lift_mk_of_injective hf) (by simp [lt_aleph0_of_finite])\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Finite \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\n\u22a2 Nat.card \u03b1 \u2264 Nat.card \u03b2"}, {"line": "simpa using toNat_le_toNat (lift_mk_le_lift_mk_of_injective hf) (by simp [lt_aleph0_of_finite])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_of_equiv_fin {\u03b1 : Type*} {n : \u2115} (f : \u03b1 \u2243 Fin n) : Nat.card \u03b1 = n := by\n  simpa only [card_eq_fintype_card, Fintype.card_fin] using card_congr f\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nn : \u2115\nf : \u03b1 \u2243 Fin n\n\u22a2 Nat.card \u03b1 = n"}, {"line": "simpa only [card_eq_fintype_card, Fintype.card_fin] using card_congr f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_preimage_of_injOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (hf : (f \u207b\u00b9' s).InjOn f) (hsf : s \u2286 range f) :\n    Nat.card (f \u207b\u00b9' s) = Nat.card s := by\n  rw [\u2190 Nat.card_image_of_injOn hf, image_preimage_eq_iff.2 hsf]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhf : InjOn f (f \u207b\u00b9' s)\nhsf : s \u2286 range f\n\u22a2 Nat.card \u2191(f \u207b\u00b9' s) = Nat.card \u2191s"}, {"line": "rw [\u2190 Nat.card_image_of_injOn hf, image_preimage_eq_iff.2 hsf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_range_of_injective {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    Nat.card (range f) = Nat.card \u03b1 := by\n  rw [\u2190 Nat.card_preimage_of_injective hf le_rfl]\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\n\u22a2 Nat.card \u2191(range f) = Nat.card \u03b1"}, {"line": "rw [\u2190 Nat.card_preimage_of_injective hf le_rfl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\n\u22a2 Nat.card \u2191(f \u207b\u00b9' range f) = Nat.card \u03b1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_sum [Finite \u03b1] [Finite \u03b2] : Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2 := by\n  have := Fintype.ofFinite \u03b1\n  have := Fintype.ofFinite \u03b2\n  simp_rw [Nat.card_eq_fintype_card, Fintype.card_sum]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"line": "have := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"line": "have := Fintype.ofFinite \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"line": "simp_rw [Nat.card_eq_fintype_card, Fintype.card_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_prod (\u03b1 \u03b2 : Type*) : Nat.card (\u03b1 \u00d7 \u03b2) = Nat.card \u03b1 * Nat.card \u03b2 := by\n  simp only [Nat.card, mk_prod, toNat_mul, toNat_lift]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u22a2 Nat.card (\u03b1 \u00d7 \u03b2) = Nat.card \u03b1 * Nat.card \u03b2"}, {"line": "simp only [Nat.card, mk_prod, toNat_mul, toNat_lift]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fun [Finite \u03b1] : Nat.card (\u03b1 \u2192 \u03b2) = Nat.card \u03b2 ^ Nat.card \u03b1 := by\n  haveI := Fintype.ofFinite \u03b1\n  rw [Nat.card_pi, Finset.prod_const, Finset.card_univ, \u2190 Nat.card_eq_fintype_card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Finite \u03b1\n\u22a2 Nat.card (\u03b1 \u2192 \u03b2) = Nat.card \u03b2 ^ Nat.card \u03b1"}, {"line": "haveI := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2192 \u03b2) = Nat.card \u03b2 ^ Nat.card \u03b1"}, {"line": "rw [Nat.card_pi, Finset.prod_const, Finset.card_univ, \u2190 Nat.card_eq_fintype_card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_zmod (n : \u2115) : Nat.card (ZMod n) = n := by\n  cases n\n  \u00b7 exact @Nat.card_eq_zero_of_infinite _ Int.infinite\n  \u00b7 rw [Nat.card_eq_fintype_card, ZMod.card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Nat.card (ZMod n) = n"}, {"line": "cases n", "tactic_state": "case zero\n\u22a2 Nat.card (ZMod 0) = 0\n---\ncase succ\nn\u271d : \u2115\n\u22a2 Nat.card (ZMod (n\u271d + 1)) = n\u271d + 1"}, {"line": "\u00b7 exact @Nat.card_eq_zero_of_infinite _ Int.infinite", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 Nat.card (ZMod (n\u271d + 1)) = n\u271d + 1"}, {"line": "\u00b7 rw [Nat.card_eq_fintype_card, ZMod.card]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_singleton_prod (a : \u03b1) (t : Set \u03b2) : Nat.card ({a} \u00d7\u02e2 t) = Nat.card t := by\n  rw [singleton_prod, Nat.card_image_of_injective (Prod.mk_right_injective a)]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nt : Set \u03b2\n\u22a2 Nat.card \u2191({a} \u00d7\u02e2 t) = Nat.card \u2191t"}, {"line": "rw [singleton_prod, Nat.card_image_of_injective (Prod.mk_right_injective a)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_prod_singleton (s : Set \u03b1) (b : \u03b2) : Nat.card (s \u00d7\u02e2 {b}) = Nat.card s := by\n  rw [prod_singleton, Nat.card_image_of_injective (Prod.mk_left_injective b)]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nb : \u03b2\n\u22a2 Nat.card \u2191(s \u00d7\u02e2 {b}) = Nat.card \u2191s"}, {"line": "rw [prod_singleton, Nat.card_image_of_injective (Prod.mk_left_injective b)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCard_pos (hs : s.Finite) : 0 < Nat.card s \u2194 s.Nonempty := by\n  simp [pos_iff_ne_zero]\n  simp [Nat.card_eq_zero]\n  simp [hs.to_subtype]\n  simp [nonempty_iff_ne_empty]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\n\u22a2 0 < Nat.card \u2191s \u2194 s.Nonempty"}, {"line": "simp [pos_iff_ne_zero]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\n\u22a2 \u00acNat.card \u2191s = 0 \u2194 s.Nonempty"}, {"line": "simp [Nat.card_eq_zero]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\n\u22a2 \u00acs = \u2205 \u2227 Finite \u2191s \u2194 s.Nonempty"}, {"line": "simp [hs.to_subtype]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\n\u22a2 \u00acs = \u2205 \u2194 s.Nonempty"}, {"line": "simp [nonempty_iff_ne_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_coe_fintype_card [Fintype \u03b1] : card \u03b1 = Fintype.card \u03b1 := by\n  simp [card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ncard : x\u271d\ninst\u271d : Fintype \u03b1\n\u22a2 sorry = Fintype.card \u03b1"}, {"line": "simp [card]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ncard : x\u271d\ninst\u271d : Fintype \u03b1\n\u22a2 sorry () = Fintype.card \u03b1"}]}
{"declaration": "theorem card_eq_zero_iff_empty (\u03b1 : Type*) : card \u03b1 = 0 \u2194 IsEmpty \u03b1 := by\n  rw [\u2190 Cardinal.mk_eq_zero_iff]\n  simp [card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry = 0 \u2194 IsEmpty \u03b1"}, {"line": "rw [\u2190 Cardinal.mk_eq_zero_iff]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry = 0 \u2194 mk \u03b1 = 0"}, {"line": "simp [card]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry () = 0 \u2194 mk \u03b1 = 0"}]}
{"declaration": "theorem card_le_one_iff_subsingleton (\u03b1 : Type*) : card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1 := by\n  rw [\u2190 le_one_iff_subsingleton]\n  simp [card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry \u2264 1 \u2194 Subsingleton \u03b1"}, {"line": "rw [\u2190 le_one_iff_subsingleton]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry \u2264 1 \u2194 mk \u03b1 \u2264 1"}, {"line": "simp [card]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 sorry () \u2264 1 \u2194 mk \u03b1 \u2264 1"}]}
{"declaration": "theorem one_lt_card_iff_nontrivial (\u03b1 : Type*) : 1 < card \u03b1 \u2194 Nontrivial \u03b1 := by\n  rw [\u2190 Cardinal.one_lt_iff_nontrivial]\n  conv_rhs => rw [\u2190 Nat.cast_one]\n  rw [\u2190 natCast_lt_toENat_iff]\n  simp only [ENat.card, Nat.cast_one]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 1 < sorry \u2194 Nontrivial \u03b1"}, {"line": "rw [\u2190 Cardinal.one_lt_iff_nontrivial]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 1 < sorry \u2194 1 < mk \u03b1"}, {"line": "conv_rhs => rw [\u2190 Nat.cast_one]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 1 < sorry \u2194 \u21911 < mk \u03b1"}, {"line": "rw [\u2190 natCast_lt_toENat_iff]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 1 < sorry \u2194 \u21911 < toENat (mk \u03b1)"}, {"line": "simp only [ENat.card, Nat.cast_one]", "tactic_state": "x\u271d : Sort u_4\ncard : x\u271d\n\u03b1 : Type u_3\n\u22a2 1 < sorry \u2194 1 < toENat (mk \u03b1)"}]}
{"declaration": "theorem card_prod (\u03b1 \u03b2 : Type*) : ENat.card (\u03b1 \u00d7 \u03b2) = .card \u03b1 * .card \u03b2 := by\n  simp [ENat.card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Finite.lean", "context": {"open": ["Cardinal Function", "Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Set \u03b1}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u22a2 ENat.card (\u03b1 \u00d7 \u03b2) = ENat.card \u03b1 * ENat.card \u03b2"}, {"line": "simp [ENat.card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_le_cardinal : (count p n : Cardinal) \u2264 Cardinal.mk { k | p k } := by\n  rw [count_eq_card_fintype, \u2190 Cardinal.mk_fintype]\n  exact Cardinal.mk_subtype_mono fun x hx \u21a6 hx.2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/NatCount.lean", "context": {"open": ["Nat Count"], "variables": ["{p : \u2115 \u2192 Prop} [DecidablePred p] (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 Cardinal.mk \u2191{k | p k}"}, {"line": "rw [count_eq_card_fintype, \u2190 Cardinal.mk_fintype]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 Cardinal.mk { k // k < n \u2227 p k } \u2264 Cardinal.mk \u2191{k | p k}"}, {"line": "exact Cardinal.mk_subtype_mono fun x hx \u21a6 hx.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_le_setENCard : count p n \u2264 Set.encard { k | p k } := by\n  simp only [Set.encard, ENat.card, Set.coe_setOf, Cardinal.natCast_le_toENat_iff]\n  exact Nat.count_le_cardinal n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/NatCount.lean", "context": {"open": ["Nat Count"], "variables": ["{p : \u2115 \u2192 Prop} [DecidablePred p] (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 {k | p k}.encard"}, {"line": "simp only [Set.encard, ENat.card, Set.coe_setOf, Cardinal.natCast_le_toENat_iff]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 Cardinal.mk { k // p k }"}, {"line": "exact Nat.count_le_cardinal n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_le_setNCard (h : { k | p k }.Finite) : count p n \u2264 Set.ncard { k | p k } := by\n  rw [Set.ncard_def, \u2190 ENat.coe_le_coe, ENat.coe_toNat (by simpa)]\n  exact count_le_setENCard n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/NatCount.lean", "context": {"open": ["Nat Count"], "variables": ["{p : \u2115 \u2192 Prop} [DecidablePred p] (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\nh : {k | p k}.Finite\n\u22a2 count p n \u2264 {k | p k}.ncard"}, {"line": "rw [Set.ncard_def, \u2190 ENat.coe_le_coe, ENat.coe_toNat (by simpa)]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\nh : {k | p k}.Finite\n\u22a2 \u2191(count p n) \u2264 {k | p k}.encard"}, {"line": "exact count_le_setENCard n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_continuum : lift.{v} \ud835\udd20 = \ud835\udd20 := by\n  rw [\u2190 two_power_aleph0, lift_two_power, lift_aleph0, two_power_aleph0]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 lift.{v, u_1} continuum = continuum"}, {"line": "rw [\u2190 two_power_aleph0, lift_two_power, lift_aleph0, two_power_aleph0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem beth_one : \u2136_ 1 = \ud835\udd20 := by simpa using beth_succ 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 beth 1 = continuum"}, {"line": "simpa using beth_succ 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_set_nat : #(Set \u2115) = \ud835\udd20 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 mk (Set \u2115) = continuum"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph_one_le_continuum : \u2135\u2081 \u2264 \ud835\udd20 := by\n  rw [\u2190 succ_aleph0]\n  exact Order.succ_le_of_lt aleph0_lt_continuum\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 aleph 1 \u2264 continuum"}, {"line": "rw [\u2190 succ_aleph0]", "tactic_state": "\u22a2 Order.succ aleph0 \u2264 continuum"}, {"line": "exact Order.succ_le_of_lt aleph0_lt_continuum", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuum_power_aleph0 : \ud835\udd20 ^ \u2135\u2080 = \ud835\udd20 := by\n  rw [\u2190 two_power_aleph0, \u2190 power_mul, mul_eq_left le_rfl le_rfl aleph0_ne_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Continuum.lean", "context": {"open": ["Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 continuum ^ aleph0 = continuum"}, {"line": "rw [\u2190 two_power_aleph0, \u2190 power_mul, mul_eq_left le_rfl le_rfl aleph0_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_ne_zero {\u03b9} (f : \u03b9 \u2192 Cardinal) : prod f \u2260 0 \u2194 \u2200 i, f i \u2260 0 := by simp [prod_eq_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Defs.lean", "context": {"open": ["List Function Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 Cardinal.{u_2}\n\u22a2 sorry \u2260 0 \u2194 \u2200 (i : \u03b9), f i \u2260 0"}, {"line": "simp [prod_eq_zero]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 Cardinal.{u_2}\n\u22a2 \u00acsorry () = 0 \u2194 \u2200 (i : \u03b9), \u00acf i = 0"}]}
{"declaration": "theorem is_prime_iff {a : Cardinal} : Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p : \u2115, a = p \u2227 p.Prime := by\n  rcases le_or_lt \u2135\u2080 a with h | h\n  \u00b7 simp [h]\n  lift a to \u2115 using id h\n  simp [not_le.mpr h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Divisibility.lean", "context": {"open": [], "variables": ["{a b : Cardinal.{u}} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 a : Cardinal.{u_1}\n\u22a2 Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p, a = \u2191p \u2227 Nat.Prime p"}, {"line": "rcases le_or_lt \u2135\u2080 a with h | h", "tactic_state": "case inl\n\u2135\u2080 a : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\n\u22a2 Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p, a = \u2191p \u2227 Nat.Prime p\n---\ncase inr\n\u2135\u2080 a : Cardinal.{u_1}\nh : a < \u2135\u2080\n\u22a2 Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p, a = \u2191p \u2227 Nat.Prime p"}, {"line": "\u00b7 simp [h]", "tactic_state": "case inr\n\u2135\u2080 a : Cardinal.{u_1}\nh : a < \u2135\u2080\n\u22a2 Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p, a = \u2191p \u2227 Nat.Prime p"}, {"line": "lift a to \u2115 using id h", "tactic_state": "case inr.intro\n\u2135\u2080 : Cardinal.{u_1}\na : \u2115\nh : \u2191a < \u2135\u2080\n\u22a2 Prime \u2191a \u2194 \u2135\u2080 \u2264 \u2191a \u2228 \u2203 p, \u2191a = \u2191p \u2227 Nat.Prime p"}, {"line": "simp [not_le.mpr h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toENatAux_eq_nat {x : Cardinal} {n : \u2115} : toENatAux x = n \u2194 x = n := by\n  simp only [le_antisymm_iff, toENatAux_le_nat, \u2190 toENatAux_gc _, ofENat_nat]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/ENat.lean", "context": {"open": ["Function Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoENatAux : x\u271d\nx : Cardinal.{u_2}\nn : \u2115\n\u22a2 sorry = n \u2194 x = \u2191n"}, {"line": "simp only [le_antisymm_iff, toENatAux_le_nat, \u2190 toENatAux_gc _, ofENat_nat]", "tactic_state": "x\u271d : Sort u_1\ntoENatAux : x\u271d\nx : Cardinal.{u_2}\nn : \u2115\n\u22a2 sorry \u2264 n \u2227 n \u2264 sorry \u2194 x \u2264 \u2191n \u2227 \u2191n \u2264 x"}]}
{"declaration": "lemma toENat_ne_top {a : Cardinal} : toENat a \u2260 \u22a4 \u2194 a < \u2135\u2080 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/ENat.lean", "context": {"open": ["Function Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoENat : x\u271d\n\u2135\u2080 a : Cardinal.{u_2}\n\u22a2 sorry \u2260 \u22a4 \u2194 a < \u2135\u2080"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\ntoENat : x\u271d\n\u2135\u2080 a : Cardinal.{u_2}\n\u22a2 \u00acsorry () = \u22a4 \u2194 a < \u2135\u2080"}]}
{"declaration": "lemma ofENat_add (m n : \u2115\u221e) : ofENat (m + n) = m + n := by apply toENat_injOn <;> simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/ENat.lean", "context": {"open": ["Function Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofENat : x\u271d\nm n : \u2115\u221e\n\u22a2 sorry = m + n"}, {"line": "apply toENat_injOn <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem power_mul {a b c : Cardinal} : a ^ (b * c) = (a ^ b) ^ c := by\n  rw [mul_comm b c]\n  exact inductionOn\u2083 a b c fun \u03b1 \u03b2 \u03b3 => mk_congr <| Equiv.curry \u03b3 \u03b2 \u03b1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Cardinal.{u_1}\n\u22a2 a ^ (b * c) = (a ^ b) ^ c"}, {"line": "rw [mul_comm b c]", "tactic_state": "a b c : Cardinal.{u_1}\n\u22a2 a ^ (c * b) = (a ^ b) ^ c"}, {"line": "exact inductionOn\u2083 a b c fun \u03b1 \u03b2 \u03b3 => mk_congr <| Equiv.curry \u03b3 \u03b2 \u03b1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_two : lift.{u, v} 2 = 2 := by simp [\u2190 one_add_one_eq_two]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u22a2 sorry = 2"}, {"line": "simp [\u2190 one_add_one_eq_two]", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u22a2 sorry () = 2"}]}
{"declaration": "theorem lift_two_power (a : Cardinal) : lift.{v} (2 ^ a) = 2 ^ lift.{v} a := by\n  simp [\u2190 one_add_one_eq_two]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u_2}\n\u22a2 sorry = 2 ^ sorry"}, {"line": "simp [\u2190 one_add_one_eq_two]", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u_2}\n\u22a2 sorry () = 2 ^ sorry ()"}]}
{"declaration": "theorem power_le_max_power_one {a b c : Cardinal} (h : b \u2264 c) : a ^ b \u2264 max (a ^ c) 1 := by\n  by_cases ha : a = 0\n  \u00b7 simp [ha, zero_power_le]\n  \u00b7 exact (power_le_power_left ha h).trans (le_max_left _ _)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Cardinal.{u_1}\nh : b \u2264 c\n\u22a2 a ^ b \u2264 max (a ^ c) 1"}, {"line": "by_cases ha : a = 0", "tactic_state": "case pos\na b c : Cardinal.{u_1}\nh : b \u2264 c\nha : a = 0\n\u22a2 a ^ b \u2264 max (a ^ c) 1\n---\ncase neg\na b c : Cardinal.{u_1}\nh : b \u2264 c\nha : \u00aca = 0\n\u22a2 a ^ b \u2264 max (a ^ c) 1"}, {"line": "\u00b7 simp [ha, zero_power_le]", "tactic_state": "case neg\na b c : Cardinal.{u_1}\nh : b \u2264 c\nha : \u00aca = 0\n\u22a2 a ^ b \u2264 max (a ^ c) 1"}, {"line": "\u00b7 exact (power_le_power_left ha h).trans (le_max_left _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_eq_of_iSup_eq_of_not_isSuccPrelimit\n    {\u03b9 : Type u} (f : \u03b9 \u2192 Cardinal.{v}) (\u03c9 : Cardinal.{v})\n    (h\u03c9 : \u00ac IsSuccPrelimit \u03c9)\n    (h : \u2a06 i : \u03b9, f i = \u03c9) : \u2203 i, f i = \u03c9 := by\n  subst h\n  suffices BddAbove (range f) from (isLUB_csSup' this).mem_of_not_isSuccPrelimit h\u03c9\n  contrapose! h\u03c9 with hf\n  rw [iSup, csSup_of_not_bddAbove hf, csSup_empty]\n  exact isSuccPrelimit_bot\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\n\u03c9 : Cardinal.{v}\nh\u03c9 : \u00acIsSuccPrelimit \u03c9\nh : \u2a06 i, f i = \u03c9\n\u22a2 \u2203 i, f i = \u03c9"}, {"line": "subst h", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nh\u03c9 : \u00acIsSuccPrelimit (\u2a06 i, f i)\n\u22a2 \u2203 i, f i = \u2a06 i, f i"}, {"line": "suffices BddAbove (range f) from (isLUB_csSup' this).mem_of_not_isSuccPrelimit h\u03c9", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nh\u03c9 : \u00acIsSuccPrelimit (\u2a06 i, f i)\n\u22a2 BddAbove (Set.range f)"}, {"line": "contrapose! h\u03c9 with hf", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : \u00acBddAbove (Set.range f)\n\u22a2 IsSuccPrelimit (\u2a06 i, f i)"}, {"line": "rw [iSup, csSup_of_not_bddAbove hf, csSup_empty]", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : \u00acBddAbove (Set.range f)\n\u22a2 IsSuccPrelimit \u22a5"}, {"line": "exact isSuccPrelimit_bot", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_le_lift {c : Cardinal.{u}} : \u2135\u2080 \u2264 lift.{v} c \u2194 \u2135\u2080 \u2264 c := by\n  simpa using lift_le (a := \u2135\u2080)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 : Cardinal.{u}\nx\u271d : Sort u_1\nlift : x\u271d\nc : Cardinal.{u}\n\u22a2 \u2135\u2080 \u2264 sorry \u2194 \u2135\u2080 \u2264 c"}, {"line": "simpa using lift_le (a := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c \u2264 \u2135\u2080 \u2194 c \u2264 \u2135\u2080 := by\n  simpa using lift_le (b := \u2135\u2080)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u2135\u2080 c : Cardinal.{u}\n\u22a2 sorry \u2264 \u2135\u2080 \u2194 c \u2264 \u2135\u2080"}, {"line": "simpa using lift_le (b := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_lt_lift {c : Cardinal.{u}} : \u2135\u2080 < lift.{v} c \u2194 \u2135\u2080 < c := by\n  simpa using lift_lt (a := \u2135\u2080)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 : Cardinal.{u}\nx\u271d : Sort u_1\nlift : x\u271d\nc : Cardinal.{u}\n\u22a2 \u2135\u2080 < sorry \u2194 \u2135\u2080 < c"}, {"line": "simpa using lift_lt (a := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_lt_aleph0 {c : Cardinal.{u}} : lift.{v} c < \u2135\u2080 \u2194 c < \u2135\u2080 := by\n  simpa using lift_lt (b := \u2135\u2080)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u2135\u2080 c : Cardinal.{u}\n\u22a2 sorry < \u2135\u2080 \u2194 c < \u2135\u2080"}, {"line": "simpa using lift_lt (b := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_eq_lift {c : Cardinal.{u}} : \u2135\u2080 = lift.{v} c \u2194 \u2135\u2080 = c := by\n  simpa using lift_inj (a := \u2135\u2080)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 : Cardinal.{u}\nx\u271d : Sort u_1\nlift : x\u271d\nc : Cardinal.{u}\n\u22a2 \u2135\u2080 = sorry \u2194 \u2135\u2080 = c"}, {"line": "simpa using lift_inj (a := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_eq_aleph0 {c : Cardinal.{u}} : lift.{v} c = \u2135\u2080 \u2194 c = \u2135\u2080 := by\n  simpa using lift_inj (b := \u2135\u2080)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\n\u2135\u2080 c : Cardinal.{u}\n\u22a2 sorry = \u2135\u2080 \u2194 c = \u2135\u2080"}, {"line": "simpa using lift_inj (b := \u2135\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_natCast (n : \u2115) : lift.{u} (n : Cardinal.{v}) = n := by induction n <;> simp [*]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\nn : \u2115\n\u22a2 sorry = n"}, {"line": "induction n <;> simp [*]", "tactic_state": "case zero\nx\u271d : Sort u_1\nlift : x\u271d\n\u22a2 sorry () = 0\n---\ncase succ\nx\u271d : Sort u_1\nlift : x\u271d\nn\u271d : \u2115\na\u271d : sorry = n\u271d\n\u22a2 False"}]}
{"declaration": "theorem zero_eq_lift_iff {a : Cardinal.{u}} :\n    (0 : Cardinal) = lift.{v} a \u2194 0 = a := by\n  simpa using nat_eq_lift_iff (n := 0)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 0 = sorry \u2194 0 = a"}, {"line": "simpa using nat_eq_lift_iff (n := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_eq_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) = lift.{v} a \u2194 1 = a := by\n  simpa using nat_eq_lift_iff (n := 1)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 1 = sorry \u2194 1 = a"}, {"line": "simpa using nat_eq_lift_iff (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_le_one_iff {a : Cardinal.{u}} :\n    lift.{v} a \u2264 1 \u2194 a \u2264 1 := by\n  simpa using lift_le_nat_iff (n := 1)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 sorry \u2264 1 \u2194 a \u2264 1"}, {"line": "simpa using lift_le_nat_iff (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) \u2264 lift.{v} a \u2194 1 \u2264 a := by\n  simpa using nat_le_lift_iff (n := 1)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 1 \u2264 sorry \u2194 1 \u2264 a"}, {"line": "simpa using nat_le_lift_iff (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_lt_lift_iff {a : Cardinal.{u}} :\n    (0 : Cardinal) < lift.{v} a \u2194 0 < a := by\n  simpa using nat_lt_lift_iff (n := 0)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 0 < sorry \u2194 0 < a"}, {"line": "simpa using nat_lt_lift_iff (n := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) < lift.{v} a \u2194 1 < a := by\n  simpa using nat_lt_lift_iff (n := 1)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Order.lean", "context": {"open": ["List Function Order Set", "Cardinal in"], "variables": ["{\u03b1 \u03b2 : Type u}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\na : Cardinal.{u}\n\u22a2 1 < sorry \u2194 1 < a"}, {"line": "simpa using nat_lt_lift_iff (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem cof_le_lift [IsRefl \u03b2 s] (f : r \u2243r s) :\n    Cardinal.lift.{v} (Order.cof r) \u2264 Cardinal.lift.{u} (Order.cof s) := by\n  rw [Order.cof, Order.cof, lift_sInf, lift_sInf, le_csInf_iff'' ((Order.cof_nonempty s).image _)]\n  rintro - \u27e8-, \u27e8u, H, rfl\u27e9, rfl\u27e9\n  apply csInf_le'\n  refine \u27e8_, \u27e8f.symm '' u, fun a => ?_, rfl\u27e9, lift_mk_eq'.2 \u27e8(f.symm.toEquiv.image u).symm\u27e9\u27e9\n  rcases H (f a) with \u27e8b, hb, hb'\u27e9\n  refine \u27e8f.symm b, mem_image_of_mem _ hb, f.map_rel_iff.1 ?_\u27e9\n  rwa [RelIso.apply_symm_apply]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\n\u22a2 lift.{v, u} (cof r) \u2264 lift.{u, v} (cof s)"}, {"line": "rw [Order.cof, Order.cof, lift_sInf, lift_sInf, le_csInf_iff'' ((Order.cof_nonempty s).image _)]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\n\u22a2 \u2200 b \u2208 lift.{u, v} '' {c | \u2203 S, (\u2200 (a : \u03b2), \u2203 b \u2208 S, s a b) \u2227 mk \u2191S = c},\n    sInf (lift.{v, u} '' {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}) \u2264 b"}, {"line": "rintro - \u27e8-, \u27e8u, H, rfl\u27e9, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\n\u22a2 sInf (lift.{v, u} '' {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}) \u2264 lift.{u, v} (mk \u2191u)"}, {"line": "apply csInf_le'", "tactic_state": "case intro.intro.intro.intro.h\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\n\u22a2 lift.{u, v} (mk \u2191u) \u2208 lift.{v, u} '' {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 mk \u2191S = c}"}, {"line": "refine \u27e8_, \u27e8f.symm '' u, fun a => ?_, rfl\u27e9, lift_mk_eq'.2 \u27e8(f.symm.toEquiv.image u).symm\u27e9\u27e9", "tactic_state": "case intro.intro.intro.intro.h\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\na : \u03b1\n\u22a2 \u2203 b \u2208 \u21d1f.symm '' u, r a b"}, {"line": "rcases H (f a) with \u27e8b, hb, hb'\u27e9", "tactic_state": "case intro.intro.intro.intro.h.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\na : \u03b1\nb : \u03b2\nhb : b \u2208 u\nhb' : s (f a) b\n\u22a2 \u2203 b \u2208 \u21d1f.symm '' u, r a b"}, {"line": "refine \u27e8f.symm b, mem_image_of_mem _ hb, f.map_rel_iff.1 ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.h.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsRefl \u03b2 s\nf : r \u2243r s\nu : Set \u03b2\nH : \u2200 (a : \u03b2), \u2203 b \u2208 u, s a b\na : \u03b1\nb : \u03b2\nhb : b \u2208 u\nhb' : s (f a) b\n\u22a2 s (f a) (f (f.symm b))"}, {"line": "rwa [RelIso.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cof_ord_le (c : Cardinal) : c.ord.cof \u2264 c := by simpa using cof_le_card c.ord\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c.ord.cof \u2264 c"}, {"line": "simpa using cof_le_card c.ord", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cof_preOmega {o : Ordinal} (ho : IsSuccPrelimit o) : (preOmega o).cof = o.cof := by\n  by_cases h : IsMin o\n  \u00b7 simp [h.eq_bot]\n  \u00b7 exact isNormal_preOmega.cof_eq \u27e8h, ho\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{a o : Ordinal.{u}} {f : \u2200 b < o, Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\npreOmega : x\u271d\no : Ordinal.{u_2}\nho : IsSuccPrelimit o\n\u22a2 sorry = o.cof"}, {"line": "by_cases h : IsMin o", "tactic_state": "case pos\nx\u271d : Sort u_1\npreOmega : x\u271d\no : Ordinal.{u_2}\nho : IsSuccPrelimit o\nh : IsMin o\n\u22a2 sorry = o.cof\n---\ncase neg\nx\u271d : Sort u_1\npreOmega : x\u271d\no : Ordinal.{u_2}\nho : IsSuccPrelimit o\nh : \u00acIsMin o\n\u22a2 sorry = o.cof"}, {"line": "\u00b7 simp [h.eq_bot]", "tactic_state": "case neg\nx\u271d : Sort u_1\npreOmega : x\u271d\no : Ordinal.{u_2}\nho : IsSuccPrelimit o\nh : \u00acIsMin o\n\u22a2 sorry = o.cof"}, {"line": "\u00b7 exact isNormal_preOmega.cof_eq \u27e8h, ho\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unbounded_of_unbounded_sUnion (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [wo : IsWellOrder \u03b1 r] {s : Set (Set \u03b1)}\n    (h\u2081 : Unbounded r <| \u22c3\u2080 s) (h\u2082 : #s < Order.cof (swap r\u1d9c)) : \u2203 x \u2208 s, Unbounded r x := by\n  by_contra! h\n  simp_rw [not_unbounded_iff] at h\n  let f : s \u2192 \u03b1 := fun x : s => wo.wf.sup x (h x.1 x.2)\n  refine h\u2082.not_le (le_trans (csInf_le' \u27e8range f, fun x => ?_, rfl\u27e9) mk_range_le)\n  rcases h\u2081 x with \u27e8y, \u27e8c, hc, hy\u27e9, hxy\u27e9\n  exact \u27e8f \u27e8c, hc\u27e9, mem_range_self _, fun hxz => hxy (Trans.trans (wo.wf.lt_sup _ hy) hxz)\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{a o : Ordinal.{u}} {f : \u2200 b < o, Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\n\u22a2 \u2203 x \u2208 s, Unbounded r x"}, {"line": "by_contra! h", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, \u00acUnbounded r x\n\u22a2 False"}, {"line": "simp_rw [not_unbounded_iff] at h", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, Bounded r x\n\u22a2 False"}, {"line": "let f : s \u2192 \u03b1 := fun x : s => wo.wf.sup x (h x.1 x.2)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, Bounded r x\nf : \u2191s \u2192 \u03b1 := fun x => \u22ef.sup \u2191x \u22ef\n\u22a2 False"}, {"line": "refine h\u2082.not_le (le_trans (csInf_le' \u27e8range f, fun x => ?_, rfl\u27e9) mk_range_le)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, Bounded r x\nf : \u2191s \u2192 \u03b1 := fun x => \u22ef.sup \u2191x \u22ef\nx : \u03b1\n\u22a2 \u2203 b \u2208 range f, swap r\u1d9c x b"}, {"line": "rcases h\u2081 x with \u27e8y, \u27e8c, hc, hy\u27e9, hxy\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nwo : IsWellOrder \u03b1 r\ns : Set (Set \u03b1)\nh\u2081 : Unbounded r (\u22c3\u2080 s)\nh\u2082 : mk \u2191s < Order.cof (swap r\u1d9c)\nh : \u2200 x \u2208 s, Bounded r x\nf : \u2191s \u2192 \u03b1 := fun x => \u22ef.sup \u2191x \u22ef\nx y : \u03b1\nhxy : \u00acr y x\nc : Set \u03b1\nhc : c \u2208 s\nhy : y \u2208 c\n\u22a2 \u2203 b \u2208 range f, swap r\u1d9c x b"}, {"line": "exact \u27e8f \u27e8c, hc\u27e9, mem_range_self _, fun hxz => hxy (Trans.trans (wo.wf.lt_sup _ hy) hxz)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_cof_power {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (b1 : 1 < b) : a < (b ^ a).ord.cof := by\n  have b0 : b \u2260 0 := (zero_lt_one.trans b1).ne'\n  apply lt_imp_lt_of_le_imp_le (power_le_power_left <| power_ne_zero a b0)\n  rw [\u2190 power_mul, mul_eq_self ha]\n  exact lt_power_cof (ha.trans <| (cantor' _ b1).le)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Cofinality.lean", "context": {"open": ["Function Cardinal Set Order", "scoped Ordinal", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{a o : Ordinal.{u}} {f : \u2200 b < o, Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nb1 : 1 < b\n\u22a2 a < (b ^ a).ord.cof"}, {"line": "have b0 : b \u2260 0 := (zero_lt_one.trans b1).ne'", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nb1 : 1 < b\nb0 : b \u2260 0\n\u22a2 a < (b ^ a).ord.cof"}, {"line": "apply lt_imp_lt_of_le_imp_le (power_le_power_left <| power_ne_zero a b0)", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nb1 : 1 < b\nb0 : b \u2260 0\n\u22a2 (b ^ a) ^ a < (b ^ a) ^ (b ^ a).ord.cof"}, {"line": "rw [\u2190 power_mul, mul_eq_self ha]", "tactic_state": "a b : Cardinal.{u_1}\nha : aleph0 \u2264 a\nb1 : 1 < b\nb0 : b \u2260 0\n\u22a2 b ^ a < (b ^ a) ^ (b ^ a).ord.cof"}, {"line": "exact lt_power_cof (ha.trans <| (cantor' _ b1).le)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bddAbove_range_comp {\u03b9 : Type u} {f : \u03b9 \u2192 Cardinal.{v}} (hf : BddAbove (range f))\n    (g : Cardinal.{v} \u2192 Cardinal.{max v w}) : BddAbove (range (g \u2218 f)) := by\n  rw [range_comp]\n  exact bddAbove_image g hf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : BddAbove (range f)\ng : Cardinal.{v} \u2192 Cardinal.{max v w}\n\u22a2 BddAbove (range (g \u2218 f))"}, {"line": "rw [range_comp]", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\nhf : BddAbove (range f)\ng : Cardinal.{v} \u2192 Cardinal.{max v w}\n\u22a2 BddAbove (g '' range f)"}, {"line": "exact bddAbove_image g hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succ_natCast (n : \u2115) : Order.succ (n : Cardinal) = n + 1 := by\n  rw [\u2190 Cardinal.nat_succ]\n  norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 succ \u2191n = \u2191n + 1"}, {"line": "rw [\u2190 Cardinal.nat_succ]", "tactic_state": "n : \u2115\n\u22a2 \u2191n.succ = \u2191n + 1"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natCast_add_one_le_iff {n : \u2115} {c : Cardinal} : n + 1 \u2264 c \u2194 n < c := by\n  rw [\u2190 Order.succ_le_iff, Cardinal.succ_natCast]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u2191n + 1 \u2264 c \u2194 \u2191n < c"}, {"line": "rw [\u2190 Order.succ_le_iff, Cardinal.succ_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_zero : succ (0 : Cardinal) = 1 := by norm_cast\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 succ 0 = 1"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantor' (a) {b : Cardinal} (hb : 1 < b) : a < b ^ a := by\n  rw [\u2190 succ_le_iff, (by norm_cast : succ (1 : Cardinal) = 2)] at hb\n  exact (cantor a).trans_le (power_le_power_right hb)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Cardinal.{u_1}\nhb : 1 < b\n\u22a2 a < b ^ a"}, {"line": "rw [\u2190 succ_le_iff, (by norm_cast : succ (1 : Cardinal) = 2)] at hb", "tactic_state": "a b : Cardinal.{u_1}\nhb : 2 \u2264 b\n\u22a2 a < b ^ a"}, {"line": "exact (cantor a).trans_le (power_le_power_right hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_iff_ne_zero {c : Cardinal} : 1 \u2264 c \u2194 c \u2260 0 := by\n  rw [one_le_iff_pos, pos_iff_ne_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 1 \u2264 c \u2194 c \u2260 0"}, {"line": "rw [one_le_iff_pos, pos_iff_ne_zero]", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 SuccAddOrder Cardinal.{u_1}"}]}
{"declaration": "theorem lt_one_iff_zero {c : Cardinal} : c < 1 \u2194 c = 0 := by\n  simpa using lt_succ_bot_iff (a := c)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 c < 1 \u2194 c = 0"}, {"line": "simpa using lt_succ_bot_iff (a := c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_aleph0 : 1 < \u2135\u2080 := by simpa using nat_lt_aleph0 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 : \u2115\n\u22a2 1 < \u2135\u2080"}, {"line": "simpa using nat_lt_aleph0 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_le_of_isSuccLimit {c : Cardinal} (h : IsSuccLimit c) : \u2135\u2080 \u2264 c := by\n  contrapose! h\n  exact not_isSuccLimit_of_lt_aleph0 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 c : Cardinal.{u_1}\nh : IsSuccLimit c\n\u22a2 \u2135\u2080 \u2264 c"}, {"line": "contrapose! h", "tactic_state": "\u2135\u2080 c : Cardinal.{u_1}\nh : c < \u2135\u2080\n\u22a2 \u00acIsSuccLimit c"}, {"line": "exact not_isSuccLimit_of_lt_aleph0 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aleph0_le_add_iff {a b : Cardinal} : \u2135\u2080 \u2264 a + b \u2194 \u2135\u2080 \u2264 a \u2228 \u2135\u2080 \u2264 b := by\n  simp only [\u2190 not_lt, add_lt_aleph0_iff, not_and_or]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u2135\u2080 a b : Cardinal.{u_1}\n\u22a2 \u2135\u2080 \u2264 a + b \u2194 \u2135\u2080 \u2264 a \u2228 \u2135\u2080 \u2264 b"}, {"line": "simp only [\u2190 not_lt, add_lt_aleph0_iff, not_and_or]", "tactic_state": "\u2135\u2080 a b : Cardinal.{u_1}\n\u22a2 \u00aca + b < \u2135\u2080 \u2194 \u00aca < \u2135\u2080 \u2228 \u00acb < \u2135\u2080"}]}
{"declaration": "theorem exists_nat_eq_of_le_nat {c : Cardinal} {n : \u2115} (h : c \u2264 n) : \u2203 m, m \u2264 n \u2227 c = m := by\n  lift c to \u2115 using h.trans_lt (nat_lt_aleph0 _)\n  exact \u27e8c, mod_cast h, rfl\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nn : \u2115\nh : c \u2264 \u2191n\n\u22a2 \u2203 m \u2264 n, c = \u2191m"}, {"line": "lift c to \u2115 using h.trans_lt (nat_lt_aleph0 _)", "tactic_state": "case intro\nn c : \u2115\nh : \u2191c \u2264 \u2191n\n\u22a2 \u2203 m \u2264 n, \u2191c = \u2191m"}, {"line": "exact \u27e8c, mod_cast h, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_powerlt {b c : Cardinal.{u}} (a) (h : c < b) : (a^c) \u2264 a ^< b := by\n  refine le_ciSup (f := fun y : Iio b => a ^ (y : Cardinal)) ?_ \u27e8c, h\u27e9\n  rw [\u2190 image_eq_range]\n  exact bddAbove_image.{u, u} _ bddAbove_Iio\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b c a : Cardinal.{u}\nh : c < b\n\u22a2 a ^ c \u2264 a ^< b"}, {"line": "refine le_ciSup (f := fun y : Iio b => a ^ (y : Cardinal)) ?_ \u27e8c, h\u27e9", "tactic_state": "b c a : Cardinal.{u}\nh : c < b\n\u22a2 BddAbove (range fun y => a ^ \u2191y)"}, {"line": "rw [\u2190 image_eq_range]", "tactic_state": "b c a : Cardinal.{u}\nh : c < b\n\u22a2 BddAbove (HPow.hPow a '' Iio b)"}, {"line": "exact bddAbove_image.{u, u} _ bddAbove_Iio", "tactic_state": "No Goals!"}]}
{"declaration": "theorem powerlt_zero {a : Cardinal} : a ^< 0 = 0 := by\n  convert Cardinal.iSup_of_empty _\n  exact Subtype.isEmpty_of_false fun x => mem_Iio.not.mpr (Cardinal.zero_le x).not_lt\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Basic.lean", "context": {"open": ["List (Vector)", "Function Order Set"], "variables": ["{\u03b1 \u03b2 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Cardinal.{u_1}\n\u22a2 a ^< 0 = 0"}, {"line": "convert Cardinal.iSup_of_empty _", "tactic_state": "case convert_3\na : Cardinal.{u_1}\n\u22a2 IsEmpty \u2191(Iio 0)"}, {"line": "exact Subtype.isEmpty_of_false fun x => mem_Iio.not.mpr (Cardinal.zero_le x).not_lt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_iUnion_Ordinal_le_of_le {\u03b2 : Type*} {o : Ordinal} {c : Cardinal}\n    (ho : o.card \u2264 c) (hc : \u2135\u2080 \u2264 c) (A : Ordinal \u2192 Set \u03b2)\n    (hA : \u2200 j < o, #(A j) \u2264 c) : #(\u22c3 j < o, A j) \u2264 c := by\n  apply mk_iUnion_Ordinal_lift_le_of_le _ hc A hA\n  rwa [Cardinal.lift_le]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_1\no : Ordinal.{u_1}\nc : Cardinal.{u_1}\nho : o.card \u2264 c\nhc : aleph0 \u2264 c\nA : Ordinal.{u_1} \u2192 Set \u03b2\nhA : \u2200 j < o, mk \u2191(A j) \u2264 c\n\u22a2 mk \u2191(\u22c3 j, \u22c3 (_ : j < o), A j) \u2264 c"}, {"line": "apply mk_iUnion_Ordinal_lift_le_of_le _ hc A hA", "tactic_state": "\u03b2 : Type u_1\no : Ordinal.{u_1}\nc : Cardinal.{u_1}\nho : o.card \u2264 c\nhc : aleph0 \u2264 c\nA : Ordinal.{u_1} \u2192 Set \u03b2\nhA : \u2200 j < o, mk \u2191(A j) \u2264 c\n\u22a2 Cardinal.lift.{u_1, u_1} o.card \u2264 Cardinal.lift.{u_1, u_1} c"}, {"line": "rwa [Cardinal.lift_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_iSup_le_sum_card {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    (\u2a06 i, f i).card \u2264 Cardinal.sum (fun i \u21a6 (f i).card) := by\n  have := lift_card_iSup_le_sum_card f\n  rwa [Cardinal.lift_id'] at this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\n\u22a2 (\u2a06 i, f i).card \u2264 sum fun i => (f i).card"}, {"line": "have := lift_card_iSup_le_sum_card f", "tactic_state": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nthis : Cardinal.lift.{u, max u v} (\u2a06 i, f i).card \u2264 sum fun i => (f i).card\n\u22a2 (\u2a06 i, f i).card \u2264 sum fun i => (f i).card"}, {"line": "rwa [Cardinal.lift_id'] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_iSup_Iio_le_sum_card {o : Ordinal.{u}} (f : Iio o \u2192 Ordinal.{max u v}) :\n    (\u2a06 a : Iio o, f a).card \u2264 Cardinal.sum fun i \u21a6 (f ((enumIsoToType o).symm i)).card := by\n  apply le_of_eq_of_le (congr_arg _ _).symm (card_iSup_le_sum_card _)\n  simpa using (enumIsoToType o).symm.iSup_comp (g := fun x \u21a6 f x)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 (\u2a06 a, f a).card \u2264 sum fun i => (f (o.enumIsoToType.symm i)).card"}, {"line": "apply le_of_eq_of_le (congr_arg _ _).symm (card_iSup_le_sum_card _)", "tactic_state": "o : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 \u2a06 i, f (o.enumIsoToType.symm i) = \u2a06 a, f a"}, {"line": "simpa using (enumIsoToType o).symm.iSup_comp (g := fun x \u21a6 f x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_iSup_Iio_le_card_mul_iSup {o : Ordinal.{u}} (f : Iio o \u2192 Ordinal.{max u v}) :\n    (\u2a06 a : Iio o, f a).card \u2264 Cardinal.lift.{v} o.card * \u2a06 a : Iio o, (f a).card := by\n  apply (card_iSup_Iio_le_sum_card f).trans\n  convert \u2190 sum_le_iSup_lift _\n  \u00b7 exact mk_toType o\n  \u00b7 exact (enumIsoToType o).symm.iSup_comp (g := fun x \u21a6 (f x).card)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 (\u2a06 a, f a).card \u2264 Cardinal.lift.{v, u} o.card * \u2a06 a, (f a).card"}, {"line": "apply (card_iSup_Iio_le_sum_card f).trans", "tactic_state": "o : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 (sum fun i => (f (o.enumIsoToType.symm i)).card) \u2264 Cardinal.lift.{v, u} o.card * \u2a06 a, (f a).card"}, {"line": "convert \u2190 sum_le_iSup_lift _", "tactic_state": "case h.e'_4.h.e'_5.h.e'_1\no : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 mk o.toType = o.card\n---\ncase h.e'_4.h.e'_6\no : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 \u2a06 i, (f (o.enumIsoToType.symm i)).card = \u2a06 a, (f a).card"}, {"line": "\u00b7 exact mk_toType o", "tactic_state": "case h.e'_4.h.e'_6\no : Ordinal.{u}\nf : \u2191(Iio o) \u2192 Ordinal.{max u v}\n\u22a2 \u2a06 i, (f (o.enumIsoToType.symm i)).card = \u2a06 a, (f a).card"}, {"line": "\u00b7 exact (enumIsoToType o).symm.iSup_comp (g := fun x \u21a6 (f x).card)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_omega0_opow {a : Ordinal} (h : a \u2260 0) : card (\u03c9 ^ a) = max \u2135\u2080 a.card := by\n  rw [card_opow_eq_of_omega0_le_left le_rfl h.bot_lt, card_omega0]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 (omega0 ^ a).card = max aleph0 a.card"}, {"line": "rw [card_opow_eq_of_omega0_le_left le_rfl h.bot_lt, card_omega0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_opow_omega0 {a : Ordinal} (h : 1 < a) : card (a ^ \u03c9) = max \u2135\u2080 a.card := by\n  rw [card_opow_eq_of_omega0_le_right h le_rfl, card_omega0, max_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\nh : 1 < a\n\u22a2 (a ^ omega0).card = max aleph0 a.card"}, {"line": "rw [card_opow_eq_of_omega0_le_right h le_rfl, card_omega0, max_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInitial.principal_opow {o : Ordinal} (h : IsInitial o) (ho : \u03c9 \u2264 o) :\n    Principal (\u00b7 ^ \u00b7) o := by\n  obtain \u27e8a, rfl\u27e9 := mem_range_omega_iff.2 \u27e8ho, h\u27e9\n  exact principal_opow_omega a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 ^ x2) o"}, {"line": "obtain \u27e8a, rfl\u27e9 := mem_range_omega_iff.2 \u27e8ho, h\u27e9", "tactic_state": "case intro\na : Ordinal.{u_1}\nh : (omega a).IsInitial\nho : omega0 \u2264 omega a\n\u22a2 Principal (fun x1 x2 => x1 ^ x2) (omega a)"}, {"line": "exact principal_opow_omega a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem principal_opow_ord {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : Principal (\u00b7 ^ \u00b7) c.ord := by\n  apply (isInitial_ord c).principal_opow\n  rwa [omega0_le_ord]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\n\u22a2 Principal (fun x1 x2 => x1 ^ x2) c.ord"}, {"line": "apply (isInitial_ord c).principal_opow", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\n\u22a2 omega0 \u2264 c.ord"}, {"line": "rwa [omega0_le_ord]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem principal_add_ord {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : Principal (\u00b7 + \u00b7) c.ord := by\n  intro a b ha hb\n  rw [lt_ord, card_add] at *\n  exact add_lt_of_lt hc ha hb\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\n\u22a2 Principal (fun x1 x2 => x1 + x2) c.ord"}, {"line": "intro a b ha hb", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a < c.ord\nhb : b < c.ord\n\u22a2 (fun x1 x2 => x1 + x2) a b < c.ord"}, {"line": "rw [lt_ord, card_add] at *", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a.card < c\nhb : b.card < c\n\u22a2 a.card + b.card < c"}, {"line": "exact add_lt_of_lt hc ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInitial.principal_add {o : Ordinal} (h : IsInitial o) (ho : \u03c9 \u2264 o) :\n    Principal (\u00b7 + \u00b7) o := by\n  rw [\u2190 h.ord_card]\n  apply principal_add_ord\n  rwa [aleph0_le_card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 + x2) o"}, {"line": "rw [\u2190 h.ord_card]", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 + x2) o.card.ord"}, {"line": "apply principal_add_ord", "tactic_state": "case hc\no : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 aleph0 \u2264 o.card"}, {"line": "rwa [aleph0_le_card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem principal_mul_ord {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : Principal (\u00b7 * \u00b7) c.ord := by\n  intro a b ha hb\n  rw [lt_ord, card_mul] at *\n  exact mul_lt_of_lt hc ha hb\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\n\u22a2 Principal (fun x1 x2 => x1 * x2) c.ord"}, {"line": "intro a b ha hb", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a < c.ord\nhb : b < c.ord\n\u22a2 (fun x1 x2 => x1 * x2) a b < c.ord"}, {"line": "rw [lt_ord, card_mul] at *", "tactic_state": "c : Cardinal.{u_1}\nhc : aleph0 \u2264 c\na b : Ordinal.{u_1}\nha : a.card < c\nhb : b.card < c\n\u22a2 a.card * b.card < c"}, {"line": "exact mul_lt_of_lt hc ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInitial.principal_mul {o : Ordinal} (h : IsInitial o) (ho : \u03c9 \u2264 o) :\n    Principal (\u00b7 * \u00b7) o := by\n  rw [\u2190 h.ord_card]\n  apply principal_mul_ord\n  rwa [aleph0_le_card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Cardinal/Ordinal.lean", "context": {"open": ["Cardinal Ordinal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 * x2) o"}, {"line": "rw [\u2190 h.ord_card]", "tactic_state": "o : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 Principal (fun x1 x2 => x1 * x2) o.card.ord"}, {"line": "apply principal_mul_ord", "tactic_state": "case hc\no : Ordinal.{u_1}\nh : o.IsInitial\nho : omega0 \u2264 o\n\u22a2 aleph0 \u2264 o.card"}, {"line": "rwa [aleph0_le_card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_def (a b : Nimber) :\n    a * b = sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c := by\n  change Nimber.mul a b = _\n  rw [Nimber.mul]\n  simp_rw [exists_prop]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Field.lean", "context": {"open": ["Function Order"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Nimber\n\u22a2 a * b = sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c"}, {"line": "change Nimber.mul a b = _", "tactic_state": "a b : Nimber\n\u22a2 a.mul b = sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c"}, {"line": "rw [Nimber.mul]", "tactic_state": "a b : Nimber\n\u22a2 sInf {x | \u2203 a', \u2203 (_ : a' < a), \u2203 b', \u2203 (_ : b' < b), a'.mul b + a.mul b' + a'.mul b' = x}\u1d9c =\n    sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c"}, {"line": "simp_rw [exists_prop]", "tactic_state": "a b : Nimber\n\u22a2 sInf {x | \u2203 a' < a, \u2203 b' < b, a'.mul b + a.mul b' + a'.mul b' = x}\u1d9c =\n    sInf {x | \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x}\u1d9c"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_def (a b : Nimber) :\n    a + b = sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c := by\n  change Nimber.add a b = _\n  rw [Nimber.add]\n  simp_rw [exists_prop]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Nimber\n\u22a2 a + b = sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c"}, {"line": "change Nimber.add a b = _", "tactic_state": "a b : Nimber\n\u22a2 a.add b = sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c"}, {"line": "rw [Nimber.add]", "tactic_state": "a b : Nimber\n\u22a2 sInf {x | (\u2203 a', \u2203 (_ : a' < a), a'.add b = x) \u2228 \u2203 b', \u2203 (_ : b' < b), a.add b' = x}\u1d9c =\n    sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c"}, {"line": "simp_rw [exists_prop]", "tactic_state": "a b : Nimber\n\u22a2 sInf {x | (\u2203 a' < a, a'.add b = x) \u2228 \u2203 b' < b, a.add b' = x}\u1d9c =\n    sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_of_lt_add (h : c < a + b) : (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c := by\n  rw [add_def] at h\n  have := not_mem_of_lt_csInf' h\n  rwa [Set.mem_compl_iff, not_not] at this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Nimber\nh : c < a + b\n\u22a2 (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c"}, {"line": "rw [add_def] at h", "tactic_state": "a b c : Nimber\nh : c < sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c\n\u22a2 (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c"}, {"line": "have := not_mem_of_lt_csInf' h", "tactic_state": "a b c : Nimber\nh : c < sInf {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c\nthis : c \u2209 {x | (\u2203 a' < a, a' + b = x) \u2228 \u2203 b' < b, a + b' = x}\u1d9c\n\u22a2 (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c"}, {"line": "rwa [Set.mem_compl_iff, not_not] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_le_of_forall_ne (h\u2081 : \u2200 a' < a, a' + b \u2260 c) (h\u2082 : \u2200 b' < b, a + b' \u2260 c) :\n    a + b \u2264 c := by\n  by_contra! h\n  have := exists_of_lt_add h\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Nimber\nh\u2081 : \u2200 a' < a, a' + b \u2260 c\nh\u2082 : \u2200 b' < b, a + b' \u2260 c\n\u22a2 a + b \u2264 c"}, {"line": "by_contra! h", "tactic_state": "a b c : Nimber\nh\u2081 : \u2200 a' < a, a' + b \u2260 c\nh\u2082 : \u2200 b' < b, a + b' \u2260 c\nh : c < a + b\n\u22a2 False"}, {"line": "have := exists_of_lt_add h", "tactic_state": "a b c : Nimber\nh\u2081 : \u2200 a' < a, a' + b \u2260 c\nh\u2082 : \u2200 b' < b, a + b' \u2260 c\nh : c < a + b\nthis : (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c\n\u22a2 False"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_cancel_right (a b : Nimber) : a + b + b = a := by\n  rw [add_assoc, add_self, add_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Nimber\n\u22a2 a + b + b = a"}, {"line": "rw [add_assoc, add_self, add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_cancel_left (a b : Nimber) : a + (a + b) = b := by\n  rw [\u2190 add_assoc, add_self, zero_add]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Nimber\n\u22a2 a + (a + b) = b"}, {"line": "rw [\u2190 add_assoc, add_self, zero_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_add_cases {a b c : Nimber} (h : a < b + c) : a + c < b \u2228 a + b < c := by\n  obtain ha | hb | hc := add_trichotomy <| add_assoc a b c \u25b8 add_ne_zero_iff.2 h.ne\n  exacts [(h.asymm ha).elim, Or.inl <| add_comm c a \u25b8 hb, Or.inr hc]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Nimber/Basic.lean", "context": {"open": ["Function Order", "Ordinal", "Nimber"], "variables": ["{a b c : Nimber.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Nimber\nh : a < b + c\n\u22a2 a + c < b \u2228 a + b < c"}, {"line": "obtain ha | hb | hc := add_trichotomy <| add_assoc a b c \u25b8 add_ne_zero_iff.2 h.ne", "tactic_state": "case inl\na b c : Nimber\nh : a < b + c\nha : b + c < a\n\u22a2 a + c < b \u2228 a + b < c\n---\ncase inr.inl\na b c : Nimber\nh : a < b + c\nhb : c + a < b\n\u22a2 a + c < b \u2228 a + b < c\n---\ncase inr.inr\na b c : Nimber\nh : a < b + c\nhc : a + b < c\n\u22a2 a + c < b \u2228 a + b < c"}, {"line": "exacts [(h.asymm ha).elim, Or.inl <| add_comm c a \u25b8 hb, Or.inr hc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem func_mem (x : PSet) (i : x.Type) : x.Func i \u2208 x := by\n  cases x\n  apply Mem.mk\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : PSet.{u_1}\ni : x.Type\n\u22a2 x.Func i \u2208 x"}, {"line": "cases x", "tactic_state": "case mk\n\u03b1\u271d : Type u_1\nA\u271d : \u03b1\u271d \u2192 PSet.{u_1}\ni : (PSet.mk \u03b1\u271d A\u271d).Type\n\u22a2 (PSet.mk \u03b1\u271d A\u271d).Func i \u2208 PSet.mk \u03b1\u271d A\u271d"}, {"line": "apply Mem.mk", "tactic_state": "No Goals!"}]}
{"declaration": "theorem empty_def : (\u2205 : PSet) = \u27e8_, PEmpty.elim\u27e9 := by\n  simp [EmptyCollection.emptyCollection]\n  simp [PSet.empty]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2205 = PSet.mk PEmpty.{u_1 + 1} PEmpty.elim"}, {"line": "simp [EmptyCollection.emptyCollection]", "tactic_state": "\u22a2 PSet.empty = PSet.mk PEmpty.{u_1 + 1} PEmpty.elim"}, {"line": "simp [PSet.empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_empty : toSet \u2205 = \u2205 := by simp [toSet]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoSet : x\u271d\n\u22a2 sorry = \u2205"}, {"line": "simp [toSet]", "tactic_state": "x\u271d : Sort u_1\ntoSet : x\u271d\n\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem mem_pair {x y z : PSet} : x \u2208 ({y, z} : PSet) \u2194 Equiv x y \u2228 Equiv x z := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : PSet.{u_1}\n\u22a2 x \u2208 {y, z} \u2194 sorry \u2228 sorry"}, {"line": "simp", "tactic_state": "x y z : PSet.{u_1}\n\u22a2 x.Equiv y \u2228 x.Equiv z \u2194 sorry ()"}]}
{"declaration": "theorem toSet_sUnion (x : PSet.{u}) : (\u22c3\u2080 x).toSet = \u22c3\u2080 (toSet '' x.toSet) := by\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/PSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u_1\ntoSet : PSet.{u} \u2192 Set \u03b1\u271d\nx : PSet.{u}\n\u22a2 (\u22c3\u2080 x).toSet = sorry"}, {"line": "ext", "tactic_state": "case h\n\u03b1\u271d : Type u_1\ntoSet : PSet.{u} \u2192 Set \u03b1\u271d\nx x\u271d : PSet.{u}\n\u22a2 x\u271d \u2208 (\u22c3\u2080 x).toSet \u2194 x\u271d \u2208 sorry"}, {"line": "simp", "tactic_state": "case h\n\u03b1\u271d : Type u_1\ntoSet : PSet.{u} \u2192 Set \u03b1\u271d\nx x\u271d : PSet.{u}\n\u22a2 (\u2203 i \u2208 x, x\u271d \u2208 i) \u2194 x\u271d \u2208 sorry ()"}]}
{"declaration": "theorem toSet_empty : toSet \u2205 = \u2205 := by simp [toSet]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u2205"}, {"line": "simp [toSet]", "tactic_state": "\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem nonempty_mk_iff {x : PSet} : (mk x).Nonempty \u2194 x.Nonempty := by\n  refine \u27e8?_, fun \u27e8a, h\u27e9 => \u27e8mk a, h\u27e9\u27e9\n  rintro \u27e8a, h\u27e9\n  induction a using Quotient.inductionOn\n  exact \u27e8_, h\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : PSet.{u_1}\n\u22a2 (ZFSet.mk x).Nonempty \u2194 x.Nonempty"}, {"line": "refine \u27e8?_, fun \u27e8a, h\u27e9 => \u27e8mk a, h\u27e9\u27e9", "tactic_state": "x : PSet.{u_1}\n\u22a2 (ZFSet.mk x).Nonempty \u2192 x.Nonempty"}, {"line": "rintro \u27e8a, h\u27e9", "tactic_state": "case intro\nx : PSet.{u_1}\na : ZFSet.{u_1}\nh : a \u2208 (ZFSet.mk x).toSet\n\u22a2 x.Nonempty"}, {"line": "induction a using Quotient.inductionOn", "tactic_state": "case intro.h\nx a\u271d : PSet.{u_1}\nh : \u27e6a\u271d\u27e7 \u2208 (ZFSet.mk x).toSet\n\u22a2 x.Nonempty"}, {"line": "exact \u27e8_, h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_empty (x : ZFSet.{u}) : x = \u2205 \u2194 \u2200 y : ZFSet.{u}, y \u2209 x := by\n  simp [ZFSet.ext_iff]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ZFSet.{u}\n\u22a2 x = \u2205 \u2194 \u2200 (y : ZFSet.{u}), y \u2209 x"}, {"line": "simp [ZFSet.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_empty_or_nonempty (u : ZFSet) : u = \u2205 \u2228 u.Nonempty := by\n  rw [eq_empty, \u2190 not_exists]\n  apply em'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : ZFSet.{u_1}\n\u22a2 u = \u2205 \u2228 u.Nonempty"}, {"line": "rw [eq_empty, \u2190 not_exists]", "tactic_state": "u : ZFSet.{u_1}\n\u22a2 (\u00ac\u2203 x, x \u2208 u) \u2228 u.Nonempty"}, {"line": "apply em'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_insert (x y : ZFSet) : (insert x y).toSet = insert x y.toSet := by\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u_1}\n\u22a2 (insert x y).toSet = insert x y.toSet"}, {"line": "ext", "tactic_state": "case h\nx y x\u271d : ZFSet.{u_1}\n\u22a2 x\u271d \u2208 (insert x y).toSet \u2194 x\u271d \u2208 insert x y.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_singleton (x : ZFSet) : ({x} : ZFSet).toSet = {x} := by\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ZFSet.{u_1}\n\u22a2 {x}.toSet = {x}"}, {"line": "ext", "tactic_state": "case h\nx x\u271d : ZFSet.{u_1}\n\u22a2 x\u271d \u2208 {x}.toSet \u2194 x\u271d \u2208 {x}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_pair {x y z : ZFSet.{u}} : x \u2208 ({y, z} : ZFSet) \u2194 x = y \u2228 x = z := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u}\n\u22a2 x \u2208 {y, z} \u2194 x = y \u2228 x = z"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pair_eq_singleton (x : ZFSet) : {x, x} = ({x} : ZFSet) := by\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ZFSet.{u_1}\n\u22a2 {x, x} = {x}"}, {"line": "ext", "tactic_state": "case a\nx z\u271d : ZFSet.{u_1}\n\u22a2 z\u271d \u2208 {x, x} \u2194 z\u271d \u2208 {x}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_eq_pair_iff {x y z : ZFSet} : ({x} : ZFSet) = {y, z} \u2194 x = y \u2227 x = z := by\n  rw [eq_comm, pair_eq_singleton_iff]\n  simp_rw [eq_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u_1}\n\u22a2 {x} = {y, z} \u2194 x = y \u2227 x = z"}, {"line": "rw [eq_comm, pair_eq_singleton_iff]", "tactic_state": "x y z : ZFSet.{u_1}\n\u22a2 y = x \u2227 z = x \u2194 x = y \u2227 x = z"}, {"line": "simp_rw [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_sep (a : ZFSet) (p : ZFSet \u2192 Prop) :\n    (ZFSet.sep p a).toSet = { x \u2208 a.toSet | p x } := by\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ZFSet.{u_1}\np : ZFSet.{u_1} \u2192 Prop\n\u22a2 (ZFSet.sep p a).toSet = {x | x \u2208 a.toSet \u2227 p x}"}, {"line": "ext", "tactic_state": "case h\na : ZFSet.{u_1}\np : ZFSet.{u_1} \u2192 Prop\nx\u271d : ZFSet.{u_1}\n\u22a2 x\u271d \u2208 (ZFSet.sep p a).toSet \u2194 x\u271d \u2208 {x | x \u2208 a.toSet \u2227 p x}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_empty : \u22c2\u2080 (\u2205 : ZFSet) = \u2205 := by simp [sInter]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u2205"}, {"line": "simp [sInter]", "tactic_state": "\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem mem_of_mem_sInter {x y z : ZFSet} (hy : y \u2208 \u22c2\u2080 x) (hz : z \u2208 x) : y \u2208 z := by\n  rcases eq_empty_or_nonempty x with (rfl | hx)\n  \u00b7 exact (not_mem_empty z hz).elim\n  \u00b7 exact (mem_sInter hx).1 hy z hz\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u_1}\nhy : y \u2208 sorry\nhz : z \u2208 x\n\u22a2 y \u2208 z"}, {"line": "rcases eq_empty_or_nonempty x with (rfl | hx)", "tactic_state": "case inl\ny z : ZFSet.{u_1}\nhy : y \u2208 sorry\nhz : z \u2208 \u2205\n\u22a2 y \u2208 z\n---\ncase inr\nx y z : ZFSet.{u_1}\nhy : y \u2208 sorry\nhz : z \u2208 x\nhx : x.Nonempty\n\u22a2 y \u2208 z"}, {"line": "\u00b7 exact (not_mem_empty z hz).elim", "tactic_state": "case inr\nx y z : ZFSet.{u_1}\nhy : y \u2208 sorry\nhz : z \u2208 x\nhx : x.Nonempty\n\u22a2 y \u2208 z"}, {"line": "\u00b7 exact (mem_sInter hx).1 hy z hz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_union (x y : ZFSet.{u}) : (x \u222a y).toSet = x.toSet \u222a y.toSet := by\n  change (\u22c3\u2080 {x, y}).toSet = _\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (x \u222a y).toSet = x.toSet \u222a y.toSet"}, {"line": "change (\u22c3\u2080 {x, y}).toSet = _", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (\u22c3\u2080 {x, y}).toSet = x.toSet \u222a y.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_inter (x y : ZFSet.{u}) : (x \u2229 y).toSet = x.toSet \u2229 y.toSet := by\n  change (ZFSet.sep (fun z => z \u2208 y) x).toSet = _\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (x \u2229 y).toSet = x.toSet \u2229 y.toSet"}, {"line": "change (ZFSet.sep (fun z => z \u2208 y) x).toSet = _", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (ZFSet.sep (fun z => z \u2208 y) x).toSet = x.toSet \u2229 y.toSet"}, {"line": "ext", "tactic_state": "case h\nx y x\u271d : ZFSet.{u}\n\u22a2 x\u271d \u2208 (ZFSet.sep (fun z => z \u2208 y) x).toSet \u2194 x\u271d \u2208 x.toSet \u2229 y.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_sdiff (x y : ZFSet.{u}) : (x \\ y).toSet = x.toSet \\ y.toSet := by\n  change (ZFSet.sep (fun z => z \u2209 y) x).toSet = _\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (x \\ y).toSet = x.toSet \\ y.toSet"}, {"line": "change (ZFSet.sep (fun z => z \u2209 y) x).toSet = _", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (ZFSet.sep (fun z => z \u2209 y) x).toSet = x.toSet \\ y.toSet"}, {"line": "ext", "tactic_state": "case h\nx y x\u271d : ZFSet.{u}\n\u22a2 x\u271d \u2208 (ZFSet.sep (fun z => z \u2209 y) x).toSet \u2194 x\u271d \u2208 x.toSet \\ y.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_image (f : ZFSet \u2192 ZFSet) [Definable\u2081 f] (x : ZFSet) :\n    (image f x).toSet = f '' x.toSet := by\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : ZFSet.{u_1} \u2192 ZFSet.{u_1}\ninst\u271d : Definable\u2081 f\nx : ZFSet.{u_1}\n\u22a2 (ZFSet.image f x).toSet = f '' x.toSet"}, {"line": "ext", "tactic_state": "case h\nf : ZFSet.{u_1} \u2192 ZFSet.{u_1}\ninst\u271d : Definable\u2081 f\nx x\u271d : ZFSet.{u_1}\n\u22a2 x\u271d \u2208 (ZFSet.image f x).toSet \u2194 x\u271d \u2208 f '' x.toSet"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_range {\u03b1} [Small.{u} \u03b1] (f : \u03b1 \u2192 ZFSet.{u}) :\n    (range f).toSet = Set.range f := by\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Small.{u, u_1} \u03b1\nf : \u03b1 \u2192 ZFSet.{u}\n\u22a2 (range f).toSet = Set.range f"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : Small.{u, u_1} \u03b1\nf : \u03b1 \u2192 ZFSet.{u}\nx\u271d : ZFSet.{u}\n\u22a2 x\u271d \u2208 (range f).toSet \u2194 x\u271d \u2208 Set.range f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSet_pair (x y : ZFSet.{u}) : (pair x y).toSet = {{x}, {x, y}} := by simp [pair]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ZFSet.{u}\n\u22a2 (x.pair y).toSet = {{x}, {x, y}}"}, {"line": "simp [pair]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_prod {x y z : ZFSet.{u}} : z \u2208 prod x y \u2194 \u2203 a \u2208 x, \u2203 b \u2208 y, z = pair a b := by\n  simp [prod]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u}\n\u22a2 z \u2208 x.prod y \u2194 \u2203 a \u2208 x, \u2203 b \u2208 y, z = a.pair b"}, {"line": "simp [prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pair_mem_prod {x y a b : ZFSet.{u}} : pair a b \u2208 prod x y \u2194 a \u2208 x \u2227 b \u2208 y := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y a b : ZFSet.{u}\n\u22a2 a.pair b \u2208 x.prod y \u2194 a \u2208 x \u2227 b \u2208 y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_funs {x y f : ZFSet.{u}} : f \u2208 funs x y \u2194 IsFunc x y f := by simp [funs, IsFunc]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y f : ZFSet.{u}\n\u22a2 f \u2208 x.funs y \u2194 x.IsFunc y f"}, {"line": "simp [funs, IsFunc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hereditarily_iff : Hereditarily p x \u2194 p x \u2227 \u2200 y \u2208 x, Hereditarily p y := by\n  rw [\u2190 Hereditarily]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": ["{p : ZFSet.{u} \u2192 Prop} {x y : ZFSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ZFSet.{u} \u2192 Prop\nx : ZFSet.{u}\n\u22a2 Hereditarily p x \u2194 p x \u2227 \u2200 y \u2208 x, Hereditarily p y"}, {"line": "rw [\u2190 Hereditarily]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Hereditarily.empty : Hereditarily p x \u2192 p \u2205 := by\n  apply @ZFSet.inductionOn _ x\n  intro y IH h\n  rcases ZFSet.eq_empty_or_nonempty y with (rfl | \u27e8a, ha\u27e9)\n  \u00b7 exact h.self\n  \u00b7 exact IH a ha (h.mem ha)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Basic.lean", "context": {"open": ["PSet ZFSet", "PSet"], "variables": ["{p : ZFSet.{u} \u2192 Prop} {x y : ZFSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ZFSet.{u} \u2192 Prop\nx : ZFSet.{u}\n\u22a2 Hereditarily p x \u2192 p \u2205"}, {"line": "apply @ZFSet.inductionOn _ x", "tactic_state": "p : ZFSet.{u} \u2192 Prop\nx : ZFSet.{u}\n\u22a2 \u2200 (x : ZFSet.{u}), (\u2200 y \u2208 x, Hereditarily p y \u2192 p \u2205) \u2192 Hereditarily p x \u2192 p \u2205"}, {"line": "intro y IH h", "tactic_state": "p : ZFSet.{u} \u2192 Prop\nx y : ZFSet.{u}\nIH : \u2200 y_1 \u2208 y, Hereditarily p y_1 \u2192 p \u2205\nh : Hereditarily p y\n\u22a2 p \u2205"}, {"line": "rcases ZFSet.eq_empty_or_nonempty y with (rfl | \u27e8a, ha\u27e9)", "tactic_state": "case inl\np : ZFSet.{u} \u2192 Prop\nx : ZFSet.{u}\nIH : \u2200 y \u2208 \u2205, Hereditarily p y \u2192 p \u2205\nh : Hereditarily p \u2205\n\u22a2 p \u2205\n---\ncase inr.intro\np : ZFSet.{u} \u2192 Prop\nx y : ZFSet.{u}\nIH : \u2200 y_1 \u2208 y, Hereditarily p y_1 \u2192 p \u2205\nh : Hereditarily p y\na : ZFSet.{u}\nha : a \u2208 y.toSet\n\u22a2 p \u2205"}, {"line": "\u00b7 exact h.self", "tactic_state": "case inr.intro\np : ZFSet.{u} \u2192 Prop\nx y : ZFSet.{u}\nIH : \u2200 y_1 \u2208 y, Hereditarily p y_1 \u2192 p \u2205\nh : Hereditarily p y\na : ZFSet.{u}\nha : a \u2208 y.toSet\n\u22a2 p \u2205"}, {"line": "\u00b7 exact IH a ha (h.mem ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_of_subset_of_mem (h : x.IsOrdinal) (hz : z.IsOrdinal) (hx : x \u2286 y) (hy : y \u2208 z) :\n    x \u2208 z := by\n  obtain rfl | hx := h.eq_or_mem_of_subset (hz.mem hy) hx\n  \u00b7 exact hy\n  \u00b7 exact hz.mem_trans hx hy\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Ordinal.lean", "context": {"open": [], "variables": ["{x y z w : ZFSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : ZFSet.{u}\nh : x.IsOrdinal\nhz : z.IsOrdinal\nhx : x \u2286 y\nhy : y \u2208 z\n\u22a2 x \u2208 z"}, {"line": "obtain rfl | hx := h.eq_or_mem_of_subset (hz.mem hy) hx", "tactic_state": "case inl\nx z : ZFSet.{u}\nh : x.IsOrdinal\nhz : z.IsOrdinal\nhx : x \u2286 x\nhy : x \u2208 z\n\u22a2 x \u2208 z\n---\ncase inr\nx y z : ZFSet.{u}\nh : x.IsOrdinal\nhz : z.IsOrdinal\nhx\u271d : x \u2286 y\nhy : y \u2208 z\nhx : x \u2208 y\n\u22a2 x \u2208 z"}, {"line": "\u00b7 exact hy", "tactic_state": "case inr\nx y z : ZFSet.{u}\nh : x.IsOrdinal\nhz : z.IsOrdinal\nhx\u271d : x \u2286 y\nhy : y \u2208 z\nhx : x \u2208 y\n\u22a2 x \u2208 z"}, {"line": "\u00b7 exact hz.mem_trans hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_apply {x : Class.{u}} {y : ZFSet.{u}} : (\u22c2\u2080 x) y \u2194 \u2200 z : ZFSet.{u}, x z \u2192 y \u2208 z := by\n  refine \u27e8fun hxy z hxz => hxy _ \u27e8z, rfl, hxz\u27e9, ?_\u27e9\n  rintro H - \u27e8z, rfl, hxz\u27e9\n  exact H _ hxz\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Class.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Class.{u}\ny : ZFSet.{u}\n\u22a2 (\u22c2\u2080 x) y \u2194 \u2200 (z : ZFSet.{u}), x z \u2192 y \u2208 z"}, {"line": "refine \u27e8fun hxy z hxz => hxy _ \u27e8z, rfl, hxz\u27e9, ?_\u27e9", "tactic_state": "x : Class.{u}\ny : ZFSet.{u}\n\u22a2 (\u2200 (z : ZFSet.{u}), x z \u2192 y \u2208 z) \u2192 (\u22c2\u2080 x) y"}, {"line": "rintro H - \u27e8z, rfl, hxz\u27e9", "tactic_state": "case intro.intro\nx : Class.{u}\ny : ZFSet.{u}\nH : \u2200 (z : ZFSet.{u}), x z \u2192 y \u2208 z\nz : ZFSet.{u}\nhxz : x z\n\u22a2 y \u2208 \u2191z"}, {"line": "exact H _ hxz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_of_mem_sInter {x y z : Class} (hy : y \u2208 \u22c2\u2080 x) (hz : z \u2208 x) : y \u2208 z := by\n  obtain \u27e8w, rfl, hw\u27e9 := hy\n  exact coe_mem.2 (hw z hz)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Class.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : Class.{u_1}\nhy : y \u2208 \u22c2\u2080 x\nhz : z \u2208 x\n\u22a2 y \u2208 z"}, {"line": "obtain \u27e8w, rfl, hw\u27e9 := hy", "tactic_state": "case intro.intro\nx z : Class.{u_1}\nhz : z \u2208 x\nw : ZFSet.{u_1}\nhw : (\u22c2\u2080 x) w\n\u22a2 \u2191w \u2208 z"}, {"line": "exact coe_mem.2 (hw z hz)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_empty : \u22c3\u2080 (\u2205 : Class.{u}) = (\u2205 : Class.{u}) := by\n  ext\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Class.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u22c3\u2080 \u2205 = \u2205"}, {"line": "ext", "tactic_state": "case a\nz\u271d : ZFSet.{u}\n\u22a2 (\u22c3\u2080 \u2205) z\u271d \u2194 \u2205 z\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_empty : rank \u2205 = 0 := by simp [empty_def, rank]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Rank.lean", "context": {"open": ["Ordinal Order"], "variables": ["{x y : PSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [empty_def, rank]", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem rank_pair (x y : PSet) : rank {x, y} = max (succ (rank x)) (succ (rank y)) := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Rank.lean", "context": {"open": ["Ordinal Order"], "variables": ["{x y : PSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\nx : PSet.{u_2}\ny : PSet.{u_3}\n\u22a2 sorry = succ sorry \u2294 succ sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\nx : PSet.{u_2}\ny : PSet.{u_3}\n\u22a2 sorry () = succ (sorry ()) \u2294 succ (sorry ())"}]}
{"declaration": "theorem rank_pair (x y : ZFSet) : rank {x, y} = max (succ (rank x)) (succ (rank y)) := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/ZFC/Rank.lean", "context": {"open": ["Ordinal Order"], "variables": ["{x y : PSet.{u}}", "{x y : ZFSet.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\nx : ZFSet.{u_2}\ny : ZFSet.{u_3}\n\u22a2 sorry = succ sorry \u2294 succ sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nrank : x\u271d\nx : ZFSet.{u_2}\ny : ZFSet.{u_3}\n\u22a2 sorry () = succ (sorry ()) \u2294 succ (sorry ())"}]}
{"declaration": "theorem nfpFamily_le_apply [Nonempty \u03b9] [Small.{u} \u03b9] (H : \u2200 i, IsNormal (f i)) {a b} :\n    (\u2203 i, nfpFamily f a \u2264 f i b) \u2194 nfpFamily f a \u2264 b := by\n  rw [\u2190 not_iff_not]\n  push_neg\n  exact apply_lt_nfpFamily_iff H\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/FixedPoint.lean", "context": {"open": ["Function Order"], "variables": ["{\u03b9 : Type*} {f : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_2\nnfpFamily : x\u271d\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : ?m.1241 H\nb : Ordinal.{u}\n\u22a2 (\u2203 i, sorry \u2264 f i b) \u2194 sorry \u2264 b"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_2\nnfpFamily : x\u271d\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : ?m.1241 H\nb : Ordinal.{u}\n\u22a2 (\u00ac\u2203 i, sorry \u2264 f i b) \u2194 \u00acsorry \u2264 b"}, {"line": "push_neg", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_2\nnfpFamily : x\u271d\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : ?m.1241 H\nb : Ordinal.{u}\n\u22a2 (\u2200 (i : \u03b9), f i b < sorry) \u2194 b < sorry"}, {"line": "exact apply_lt_nfpFamily_iff H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_bddAbove_fp_family [Small.{u} \u03b9] (H : \u2200 i, IsNormal (f i)) :\n    \u00ac BddAbove (\u22c2 i, Function.fixedPoints (f i)) := by\n  rw [not_bddAbove_iff]\n  refine fun a \u21a6 \u27e8nfpFamily f (succ a), ?_, (lt_succ a).trans_le (le_nfpFamily f _)\u27e9\n  rintro _ \u27e8i, rfl\u27e9\n  exact nfpFamily_fp (H i) _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/FixedPoint.lean", "context": {"open": ["Function Order"], "variables": ["{\u03b9 : Type*} {f : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 \u00acBddAbove (\u22c2 i, fixedPoints (f i))"}, {"line": "rw [not_bddAbove_iff]", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 \u2200 (x : Ordinal.{u}), \u2203 y \u2208 \u22c2 i, fixedPoints (f i), x < y"}, {"line": "refine fun a \u21a6 \u27e8nfpFamily f (succ a), ?_, (lt_succ a).trans_le (le_nfpFamily f _)\u27e9", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{u}\n\u22a2 sorry \u2208 \u22c2 i, fixedPoints (f i)"}, {"line": "rintro _ \u27e8i, rfl\u27e9", "tactic_state": "case intro\n\u03b9 : Type u_1\nf : \u03b9 \u2192 Ordinal.{u} \u2192 Ordinal.{u}\ninst\u271d : Small.{u, u_1} \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{u}\ni : \u03b9\n\u22a2 sorry \u2208 (fun i => fixedPoints (f i)) i"}, {"line": "exact nfpFamily_fp (H i) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NF.zero_of_zero {e n a} (h : NF (ONote.oadd e n a)) (e0 : e = 0) : a = 0 := by\n  simpa [e0, NFBelow_zero] using h.snd'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nNF : x\u271d\ne : \u2115\nn : ?m.959\na : \u2115\nh : sorry\ne0 : e = 0\n\u22a2 a = 0"}, {"line": "simpa [e0, NFBelow_zero] using h.snd'", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem exists_lt_mul_omega0' {o : Ordinal} \u2983a\u2984 (h : a < o * \u03c9) :\n    \u2203 i : \u2115, a < o * \u2191i + o := by\n  obtain \u27e8i, hi, h'\u27e9 := (lt_mul_of_limit isLimit_omega0).1 h\n  obtain \u27e8i, rfl\u27e9 := lt_omega0.1 hi\n  exact \u27e8i, h'.trans_le (le_add_right _ _)\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o a : Ordinal.{u_1}\nh : a < o * omega0\n\u22a2 \u2203 i, a < o * \u2191i + o"}, {"line": "obtain \u27e8i, hi, h'\u27e9 := (lt_mul_of_limit isLimit_omega0).1 h", "tactic_state": "case intro.intro\no a : Ordinal.{u_1}\nh : a < o * omega0\ni : Ordinal.{u_1}\nhi : i < omega0\nh' : a < o * i\n\u22a2 \u2203 i, a < o * \u2191i + o"}, {"line": "obtain \u27e8i, rfl\u27e9 := lt_omega0.1 hi", "tactic_state": "case intro.intro.intro\no a : Ordinal.{u_1}\nh : a < o * omega0\ni : \u2115\nhi : \u2191i < omega0\nh' : a < o * \u2191i\n\u22a2 \u2203 i, a < o * \u2191i + o"}, {"line": "exact \u27e8i, h'.trans_le (le_add_right _ _)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem exists_lt_omega0_opow' {\u03b1} {o b : Ordinal} (hb : 1 < b) (ho : o.IsLimit)\n    {f : \u03b1 \u2192 Ordinal} (H : \u2200 \u2983a\u2984, a < o \u2192 \u2203 i, a < f i) \u2983a\u2984 (h : a < b ^ o) :\n        \u2203 i, a < b ^ f i := by\n  obtain \u27e8d, hd, h'\u27e9 := (lt_opow_of_limit (zero_lt_one.trans hb).ne' ho).1 h\n  exact (H hd).imp fun i hi => h'.trans <| (opow_lt_opow_iff_right hb).2 hi\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\no b : Ordinal.{u_2}\nhb : 1 < b\nho : o.IsLimit\nf : \u03b1 \u2192 Ordinal.{u_2}\nH : \u2200 \u2983a : Ordinal.{u_2}\u2984, a < o \u2192 \u2203 i, a < f i\na : Ordinal.{u_2}\nh : a < b ^ o\n\u22a2 \u2203 i, a < b ^ f i"}, {"line": "obtain \u27e8d, hd, h'\u27e9 := (lt_opow_of_limit (zero_lt_one.trans hb).ne' ho).1 h", "tactic_state": "case intro.intro\n\u03b1 : Sort u_1\no b : Ordinal.{u_2}\nhb : 1 < b\nho : o.IsLimit\nf : \u03b1 \u2192 Ordinal.{u_2}\nH : \u2200 \u2983a : Ordinal.{u_2}\u2984, a < o \u2192 \u2203 i, a < f i\na : Ordinal.{u_2}\nh : a < b ^ o\nd : Ordinal.{u_2}\nhd : d < o\nh' : a < b ^ d\n\u22a2 \u2203 i, a < b ^ f i"}, {"line": "exact (H hd).imp fun i hi => h'.trans <| (opow_lt_opow_iff_right hb).2 hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fastGrowing\u03b5\u2080_zero : fastGrowing\u03b5\u2080 0 = 1 := by simp [fastGrowing\u03b5\u2080]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Notation.lean", "context": {"open": ["Ordinal Order", "Lean in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfastGrowing\u03b5\u2080 : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [fastGrowing\u03b5\u2080]", "tactic_state": "x\u271d : Sort u_1\nfastGrowing\u03b5\u2080 : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem not_principal_iff : \u00ac Principal op o \u2194 \u2203 a < o, \u2203 b < o, o \u2264 op a b := by\n  simp [Principal]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Principal.lean", "context": {"open": ["Order"], "variables": ["{a b c o : Ordinal.{u}}", "{op : Ordinal \u2192 Ordinal \u2192 Ordinal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\nop : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_1\nPrincipal : x\u271d\n\u22a2 \u00acsorry \u2194 \u2203 a < o, \u2203 b < o, o \u2264 op a b"}, {"line": "simp [Principal]", "tactic_state": "o : Ordinal.{u}\nop : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_1\nPrincipal : x\u271d\n\u22a2 \u00acsorry () \u2194 \u2203 a < o, \u2203 b < o, o \u2264 op a b"}]}
{"declaration": "theorem not_principal_iff_of_monotone\n    (h\u2081 : \u2200 a, Monotone (op a)) (h\u2082 : \u2200 a, Monotone (Function.swap op a)) :\n    \u00ac Principal op o \u2194 \u2203 a < o, o \u2264 op a a := by\n  simp [principal_iff_of_monotone h\u2081 h\u2082]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Principal.lean", "context": {"open": ["Order"], "variables": ["{a b c o : Ordinal.{u}}", "{op : Ordinal \u2192 Ordinal \u2192 Ordinal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u}\nop : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_1\nPrincipal : x\u271d\nh\u2081 : \u2200 (a : Ordinal.{u}), Monotone (op a)\nh\u2082 : \u2200 (a : Ordinal.{u}), Monotone (Function.swap op a)\n\u22a2 \u00acsorry \u2194 \u2203 a < o, o \u2264 op a a"}, {"line": "simp [principal_iff_of_monotone h\u2081 h\u2082]", "tactic_state": "o : Ordinal.{u}\nop : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\nx\u271d : Sort u_1\nPrincipal : x\u271d\nh\u2081 : \u2200 (a : Ordinal.{u}), Monotone (op a)\nh\u2082 : \u2200 (a : Ordinal.{u}), Monotone (Function.swap op a)\n\u22a2 \u00acsorry () \u2194 \u2203 a < o, o \u2264 op a a"}]}
{"declaration": "theorem not_bddAbove_principal (op : Ordinal \u2192 Ordinal \u2192 Ordinal) :\n    \u00ac BddAbove { o | Principal op o } := by\n  rintro \u27e8a, ha\u27e9\n  exact ((le_nfp _ _).trans (ha (principal_nfp_iSup op (succ a)))).not_lt (lt_succ a)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Principal.lean", "context": {"open": ["Order"], "variables": ["{a b c o : Ordinal.{u}}", "{op : Ordinal \u2192 Ordinal \u2192 Ordinal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nPrincipal : x\u271d\nop : Ordinal.{u_2} \u2192 Ordinal.{u_3} \u2192 Ordinal.{u_4}\n\u22a2 \u00acBddAbove {o | sorry}"}, {"line": "rintro \u27e8a, ha\u27e9", "tactic_state": "case intro\nx\u271d : Sort u_1\nPrincipal : x\u271d\nop : Ordinal.{u_2} \u2192 Ordinal.{u_3} \u2192 Ordinal.{u_4}\na : ?m.1310 op\nha : a \u2208 upperBounds {o | sorry}\n\u22a2 False"}, {"line": "exact ((le_nfp _ _).trans (ha (principal_nfp_iSup op (succ a)))).not_lt (lt_succ a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem type_ne_zero_iff_nonempty [IsWellOrder \u03b1 r] : type r \u2260 0 \u2194 Nonempty \u03b1 := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\ntype : x\u271d\ninst\u271d : IsWellOrder \u03b1 r\n\u22a2 sorry \u2260 0 \u2194 Nonempty \u03b1"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\ntype : x\u271d\ninst\u271d : IsWellOrder \u03b1 r\n\u22a2 \u00acsorry () = 0 \u2194 Nonempty \u03b1"}]}
{"declaration": "theorem type_eq_one_of_unique (r) [IsWellOrder \u03b1 r] [Nonempty \u03b1] [Subsingleton \u03b1] : type r = 1 := by\n  cases nonempty_unique \u03b1\n  exact (RelIso.ofUniqueOfIrrefl r _).ordinal_type_eq\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ntype : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b2 : IsWellOrder \u03b1 r\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Subsingleton \u03b1\n\u22a2 sorry = 1"}, {"line": "cases nonempty_unique \u03b1", "tactic_state": "case zero\n\u03b1 : Type u\nx\u271d : Sort u_1\ntype : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b2 : IsWellOrder \u03b1 r\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Subsingleton \u03b1\n\u22a2 0 = 1\n---\ncase succ\n\u03b1 : Type u\nx\u271d : Sort u_1\ntype : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b2 : IsWellOrder \u03b1 r\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Subsingleton \u03b1\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = 1"}, {"line": "exact (RelIso.ofUniqueOfIrrefl r _).ordinal_type_eq", "tactic_state": "case succ\n\u03b1 : Type u\nx\u271d : Sort u_1\ntype : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b2 : IsWellOrder \u03b1 r\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Subsingleton \u03b1\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = 1"}]}
{"declaration": "theorem enum_zero_le' {o : Ordinal} (h0 : 0 < o) (a : o.toType) :\n    enum (\u03b1 := o.toType) (\u00b7 < \u00b7) \u27e80, type_toType _ \u25b8 h0\u27e9 \u2264 a := by\n  rw [\u2190 not_lt]\n  apply enum_zero_le\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nenum : x\u271d\no : Ordinal.{u_2}\nh0 : 0 < o\na : o.toType\n\u22a2 sorry \u2264 a"}, {"line": "rw [\u2190 not_lt]", "tactic_state": "x\u271d : Sort u_1\nenum : x\u271d\no : Ordinal.{u_2}\nh0 : 0 < o\na : o.toType\n\u22a2 \u00aca < sorry"}, {"line": "apply enum_zero_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_lt {a b : Ordinal} : lift.{u, v} a < lift.{u, v} b \u2194 a < b := by\n  simp_rw [lt_iff_le_not_le, lift_le]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 lift.{u, v} sorry < lift.{u, v} sorry \u2194 a < b"}, {"line": "simp_rw [lt_iff_le_not_le, lift_le]", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 sorry \u2264 sorry \u2227 \u00acsorry \u2264 sorry \u2194 a \u2264 b \u2227 \u00acb \u2264 a"}]}
{"declaration": "theorem card_nat (n : \u2115) : card.{u} n = n := by\n  induction n <;> [simp; simp only [card_add, card_one, Nat.cast_succ, *]]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\nn : \u2115\n\u22a2 sorry = n"}, {"line": "induction n <;> [simp; simp only [card_add, card_one, Nat.cast_succ, *]]", "tactic_state": "case zero\nx\u271d : Sort u_1\ncard : x\u271d\n\u22a2 sorry () = 0\n---\ncase succ\nx\u271d : Sort u_1\ncard : x\u271d\nn\u271d : \u2115\na\u271d : sorry = n\u271d\n\u22a2 n\u271d = n\u271d + 1"}]}
{"declaration": "theorem one_le_iff_ne_zero {o : Ordinal} : 1 \u2264 o \u2194 o \u2260 0 := by\n  rw [Order.one_le_iff_pos, Ordinal.pos_iff_ne_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 1 \u2264 o \u2194 o \u2260 0"}, {"line": "rw [Order.one_le_iff_pos, Ordinal.pos_iff_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_one_iff_zero {a : Ordinal} : a < 1 \u2194 a = 0 := by\n  simpa using @lt_succ_bot_iff _ _ _ a _ _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a < 1 \u2194 a = 0"}, {"line": "simpa using @lt_succ_bot_iff _ _ _ a _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_one_iff {a : Ordinal} : a \u2264 1 \u2194 a = 0 \u2228 a = 1 := by\n  simpa using @le_succ_bot_iff _ _ _ a _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a \u2264 1 \u2194 a = 0 \u2228 a = 1"}, {"line": "simpa using @le_succ_bot_iff _ _ _ a _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem typein_le_typein' (o : Ordinal) {x y : o.toType} :\n    typein (\u03b1 := o.toType) (\u00b7 < \u00b7) x \u2264 typein (\u03b1 := o.toType) (\u00b7 < \u00b7) y \u2194 x \u2264 y := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntypein : x\u271d\no : Ordinal.{u_2}\nx y : o.toType\n\u22a2 sorry \u2264 sorry \u2194 x \u2264 y"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\ntypein : x\u271d\no : Ordinal.{u_2}\nx y : o.toType\n\u22a2 sorry () \u2264 sorry () \u2194 x \u2264 y"}]}
{"declaration": "theorem liftPrincipalSeg_top' : liftPrincipalSeg.{u, u + 1}.top = typeLT Ordinal := by\n  simp only [liftPrincipalSeg_top, univ_id]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nliftPrincipalSeg : x\u271d\u00b9\nx\u271d : Sort u_2\ntypeLT : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp only [liftPrincipalSeg_top, univ_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_le_iff {o : Ordinal} {c : Cardinal} : o.card \u2264 c \u2194 o < (succ c).ord := by\n  rw [lt_ord, lt_succ_iff]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\nc : Cardinal.{u_1}\n\u22a2 o.card \u2264 c \u2194 o < (succ c).ord"}, {"line": "rw [lt_ord, lt_succ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ord_one : ord 1 = 1 := by simpa using ord_nat 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ord 1 = 1"}, {"line": "simpa using ord_nat 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_ord_toType (c : Cardinal) : #c.ord.toType = c := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\n\u22a2 Cardinal.mk c.ord.toType = c"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ord_injective : Injective ord := by\n  intro c c' h\n  rw [\u2190 card_ord c, \u2190 card_ord c', h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Injective ord"}, {"line": "intro c c' h", "tactic_state": "c c' : Cardinal.{u_1}\nh : c.ord = c'.ord\n\u22a2 c = c'"}, {"line": "rw [\u2190 card_ord c, \u2190 card_ord c', h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_card {o} : 1 \u2264 card o \u2194 1 \u2264 o := by\n  simpa using nat_le_card (n := 1)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 1 \u2264 sorry \u2194 1 \u2264 o"}, {"line": "simpa using nat_le_card (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_lt_card {o} : 0 < card o \u2194 0 < o := by\n  simpa using nat_lt_card (n := 0)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 0 < sorry \u2194 0 < o"}, {"line": "simpa using nat_lt_card (n := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_card {o} : 1 < card o \u2194 1 < o := by\n  simpa using nat_lt_card (n := 1)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 1 < sorry \u2194 1 < o"}, {"line": "simpa using nat_lt_card (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_le_one {o} : card o \u2264 1 \u2194 o \u2264 1 := by\n  simpa using card_le_nat (n := 1)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 sorry \u2264 1 \u2194 o \u2264 1"}, {"line": "simpa using card_le_nat (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_nat {o} {n : \u2115} : card o = n \u2194 o = n := by\n  simp only [le_antisymm_iff, card_le_nat, nat_le_card]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no n : \u2115\n\u22a2 sorry = n \u2194 o = n"}, {"line": "simp only [le_antisymm_iff, card_le_nat, nat_le_card]", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no n : \u2115\n\u22a2 sorry \u2264 n \u2227 n \u2264 sorry \u2194 o \u2264 n \u2227 n \u2264 o"}]}
{"declaration": "theorem card_eq_zero {o} : card o = 0 \u2194 o = 0 := by\n  simpa using card_eq_nat (n := 0)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 sorry = 0 \u2194 o = 0"}, {"line": "simpa using card_eq_nat (n := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_one {o} : card o = 1 \u2194 o = 1 := by\n  simpa using card_eq_nat (n := 1)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\no : \u2115\n\u22a2 sorry = 1 \u2194 o = 1"}, {"line": "simpa using card_eq_nat (n := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem type_fin (n : \u2115) : typeLT (Fin n) = n := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Basic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Cardinal InitialSeg", "Classical in", "Classical in", "Ordinal"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntypeLT : x\u271d\nn : \u2115\n\u22a2 sorry = n"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\ntypeLT : x\u271d\nn : \u2115\n\u22a2 sorry () = n"}]}
{"declaration": "theorem rank_eq (h : Acc r a) :\n    h.rank = \u2a06 b : { b // r b a }, Order.succ (h.inv b.2).rank := by\n  change (Acc.intro a fun _ => h.inv).rank = _\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Rank.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {a b : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\na : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Acc r a\n\u22a2 h.rank = \u2a06 b, Order.succ \u22ef.rank"}, {"line": "change (Acc.intro a fun _ => h.inv).rank = _", "tactic_state": "\u03b1 : Type u\na : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Acc r a\n\u22a2 \u22ef.rank = \u2a06 b, Order.succ \u22ef.rank"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem opow_zero (a : Ordinal) : a ^ (0 : Ordinal) = 1 := by\n  obtain rfl | h := eq_or_ne a 0\n  \u00b7 rw [zero_opow', Ordinal.sub_zero]\n  \u00b7 rw [opow_of_ne_zero h, limitRecOn_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a ^ 0 = 1"}, {"line": "obtain rfl | h := eq_or_ne a 0", "tactic_state": "case inl\n\u22a2 0 ^ 0 = 1\n---\ncase inr\na : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 a ^ 0 = 1"}, {"line": "\u00b7 rw [zero_opow', Ordinal.sub_zero]", "tactic_state": "case inr\na : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 a ^ 0 = 1"}, {"line": "\u00b7 rw [opow_of_ne_zero h, limitRecOn_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem opow_succ (a b : Ordinal) : a ^ succ b = a ^ b * a := by\n  obtain rfl | h := eq_or_ne a 0\n  \u00b7 rw [zero_opow (succ_ne_zero b), mul_zero]\n  \u00b7 rw [opow_of_ne_zero h, opow_of_ne_zero h, limitRecOn_succ]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a ^ succ b = a ^ b * a"}, {"line": "obtain rfl | h := eq_or_ne a 0", "tactic_state": "case inl\nb : Ordinal.{u_1}\n\u22a2 0 ^ succ b = 0 ^ b * 0\n---\ncase inr\na b : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 a ^ succ b = a ^ b * a"}, {"line": "\u00b7 rw [zero_opow (succ_ne_zero b), mul_zero]", "tactic_state": "case inr\na b : Ordinal.{u_1}\nh : a \u2260 0\n\u22a2 a ^ succ b = a ^ b * a"}, {"line": "\u00b7 rw [opow_of_ne_zero h, opow_of_ne_zero h, limitRecOn_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_opow_of_limit {a b c : Ordinal} (b0 : b \u2260 0) (h : IsLimit c) :\n    a < b ^ c \u2194 \u2203 c' < c, a < b ^ c' := by\n  rw [\u2190 not_iff_not, not_exists]\n  simp only [not_lt, opow_le_of_limit b0 h, exists_prop, not_and]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\na b c : Ordinal.{u_2}\nb0 : b \u2260 0\nh : sorry\n\u22a2 a < b ^ c \u2194 \u2203 c' < c, a < b ^ c'"}, {"line": "rw [\u2190 not_iff_not, not_exists]", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\na b c : Ordinal.{u_2}\nb0 : b \u2260 0\nh : sorry\n\u22a2 \u00aca < b ^ c \u2194 \u2200 (x : Ordinal.{u_2}), \u00ac(x < c \u2227 a < b ^ x)"}, {"line": "simp only [not_lt, opow_le_of_limit b0 h, exists_prop, not_and]", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\na b c : Ordinal.{u_2}\nb0 : b \u2260 0\nh : sorry\n\u22a2 b ^ c \u2264 a \u2194 \u2200 x < c, b ^ x \u2264 a"}]}
{"declaration": "theorem log_one_right (b : Ordinal) : log b 1 = 0 := by\n  obtain hb | hb := lt_or_le 1 b\n  \u00b7 exact log_eq_zero hb\n  \u00b7 exact log_of_left_le_one hb 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\n\u22a2 sorry = 0"}, {"line": "obtain hb | hb := lt_or_le 1 b", "tactic_state": "case inl\nx\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nhb : 1 < b\n\u22a2 sorry = 0\n---\ncase inr\nx\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nhb : b \u2264 1\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact log_eq_zero hb", "tactic_state": "case inr\nx\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nhb : b \u2264 1\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact log_of_left_le_one hb 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mod_opow_log_lt_self (b : Ordinal) {o : Ordinal} (ho : o \u2260 0) : o % (b ^ log b o) < o := by\n  rcases eq_or_ne b 0 with (rfl | hb)\n  \u00b7 simpa using Ordinal.pos_iff_ne_zero.2 ho\n  \u00b7 exact (mod_lt _ <| opow_ne_zero _ hb).trans_le (opow_log_le_self _ ho)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb o : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 o % b ^ sorry < o"}, {"line": "rcases eq_or_ne b 0 with (rfl | hb)", "tactic_state": "case inl\nx\u271d : Sort u_1\nlog : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 o % 0 ^ sorry < o\n---\ncase inr\nx\u271d : Sort u_1\nlog : x\u271d\nb o : Ordinal.{u_2}\nho : o \u2260 0\nhb : b \u2260 0\n\u22a2 o % b ^ sorry < o"}, {"line": "\u00b7 simpa using Ordinal.pos_iff_ne_zero.2 ho", "tactic_state": "case inr\nx\u271d : Sort u_1\nlog : x\u271d\nb o : Ordinal.{u_2}\nho : o \u2260 0\nhb : b \u2260 0\n\u22a2 o % b ^ sorry < o"}, {"line": "\u00b7 exact (mod_lt _ <| opow_ne_zero _ hb).trans_le (opow_log_le_self _ ho)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_opow_mul {b v : Ordinal} (hb : 1 < b) (u : Ordinal) (hv : v \u2260 0) :\n    log b (b ^ u * v) = u + log b v := by\n  simpa using log_opow_mul_add hb hv (opow_pos u (bot_lt_of_lt hb))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Exponential.lean", "context": {"open": ["Function Set Equiv Order", "scoped Cardinal Ordinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb : Ordinal.{u_2}\nv : Ordinal.{u_3}\nhb : 1 < b\nu : Ordinal.{u_4}\nhv : v \u2260 0\n\u22a2 sorry = u + sorry"}, {"line": "simpa using log_opow_mul_add hb hv (opow_pos u (bot_lt_of_lt hb))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_nadd_iff : a < b \u266f c \u2194 (\u2203 b' < b, a \u2264 b' \u266f c) \u2228 \u2203 c' < c, a \u2264 b \u266f c' := by\n  rw [nadd]\n  simp [Ordinal.lt_iSup_iff]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u}\n\u22a2 a < b.nadd c \u2194 (\u2203 b' < b, a \u2264 b'.nadd c) \u2228 \u2203 c' < c, a \u2264 b.nadd c'"}, {"line": "rw [nadd]", "tactic_state": "a b c : Ordinal.{u}\n\u22a2 a < max (\u2a06 x, succ ((\u2191x).nadd c)) (\u2a06 x, succ (b.nadd \u2191x)) \u2194 (\u2203 b' < b, a \u2264 b'.nadd c) \u2228 \u2203 c' < c, a \u2264 b.nadd c'"}, {"line": "simp [Ordinal.lt_iSup_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_le_iff : b \u266f c \u2264 a \u2194 (\u2200 b' < b, b' \u266f c < a) \u2227 \u2200 c' < c, b \u266f c' < a := by\n  rw [\u2190 not_lt, lt_nadd_iff]\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u}\n\u22a2 b.nadd c \u2264 a \u2194 (\u2200 b' < b, b'.nadd c < a) \u2227 \u2200 c' < c, b.nadd c' < a"}, {"line": "rw [\u2190 not_lt, lt_nadd_iff]", "tactic_state": "a b c : Ordinal.{u}\n\u22a2 \u00ac((\u2203 b' < b, a \u2264 b'.nadd c) \u2228 \u2203 c' < c, a \u2264 b.nadd c') \u2194 (\u2200 b' < b, b'.nadd c < a) \u2227 \u2200 c' < c, b.nadd c' < a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_le_nadd_left (h : b \u2264 c) (a) : a \u266f b \u2264 a \u266f c := by\n  rcases lt_or_eq_of_le h with (h | rfl)\n  \u00b7 exact (nadd_lt_nadd_left h a).le\n  \u00b7 exact le_rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b c : Ordinal.{u}\nh : b \u2264 c\na : Ordinal.{u}\n\u22a2 a.nadd b \u2264 a.nadd c"}, {"line": "rcases lt_or_eq_of_le h with (h | rfl)", "tactic_state": "case inl\nb c : Ordinal.{u}\nh\u271d : b \u2264 c\na : Ordinal.{u}\nh : b < c\n\u22a2 a.nadd b \u2264 a.nadd c\n---\ncase inr\nb a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 a.nadd b \u2264 a.nadd b"}, {"line": "\u00b7 exact (nadd_lt_nadd_left h a).le", "tactic_state": "case inr\nb a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 a.nadd b \u2264 a.nadd b"}, {"line": "\u00b7 exact le_rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_le_nadd_right (h : b \u2264 c) (a) : b \u266f a \u2264 c \u266f a := by\n  rcases lt_or_eq_of_le h with (h | rfl)\n  \u00b7 exact (nadd_lt_nadd_right h a).le\n  \u00b7 exact le_rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b c : Ordinal.{u}\nh : b \u2264 c\na : Ordinal.{u}\n\u22a2 b.nadd a \u2264 c.nadd a"}, {"line": "rcases lt_or_eq_of_le h with (h | rfl)", "tactic_state": "case inl\nb c : Ordinal.{u}\nh\u271d : b \u2264 c\na : Ordinal.{u}\nh : b < c\n\u22a2 b.nadd a \u2264 c.nadd a\n---\ncase inr\nb a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 b.nadd a \u2264 b.nadd a"}, {"line": "\u00b7 exact (nadd_lt_nadd_right h a).le", "tactic_state": "case inr\nb a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 b.nadd a \u2264 b.nadd a"}, {"line": "\u00b7 exact le_rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_comm (a b) : a \u266f b = b \u266f a := by\n  rw [nadd, nadd, max_comm]\n  congr <;> ext x <;> cases x <;> apply congr_arg _ (nadd_comm _ _)", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a.nadd b = b.nadd a"}, {"line": "rw [nadd, nadd, max_comm]", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 max (\u2a06 x, succ (a.nadd \u2191x)) (\u2a06 x, succ ((\u2191x).nadd b)) = max (\u2a06 x, succ ((\u2191x).nadd a)) (\u2a06 x, succ (b.nadd \u2191x))"}, {"line": "congr <;> ext x <;> cases x <;> apply congr_arg _ (nadd_comm _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_zero (a : Ordinal) : a \u266f 0 = a := by\n  rw [nadd, ciSup_of_empty fun _ : Iio 0 \u21a6 _, sup_bot_eq]\n  convert iSup_succ a\n  rename_i x\n  cases x\n  exact nadd_zero _", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a.nadd 0 = a"}, {"line": "rw [nadd, ciSup_of_empty fun _ : Iio 0 \u21a6 _, sup_bot_eq]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 \u2a06 x, succ ((\u2191x).nadd 0) = a"}, {"line": "convert iSup_succ a", "tactic_state": "case h.e'_2.h.e'_4.h.h.e'_4\na : Ordinal.{u_1}\nx\u271d : \u2191(Iio a)\n\u22a2 (\u2191x\u271d).nadd 0 = \u2191x\u271d"}, {"line": "rename_i x", "tactic_state": "case h.e'_2.h.e'_4.h.h.e'_4\na : Ordinal.{u_1}\nx : \u2191(Iio a)\n\u22a2 (\u2191x).nadd 0 = \u2191x"}, {"line": "cases x", "tactic_state": "case h.e'_2.h.e'_4.h.h.e'_4.mk\na val\u271d : Ordinal.{u_1}\nproperty\u271d : val\u271d \u2208 Iio a\n\u22a2 (\u2191\u27e8val\u271d, property\u271d\u27e9).nadd 0 = \u2191\u27e8val\u271d, property\u271d\u27e9"}, {"line": "exact nadd_zero _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_nadd : 0 \u266f a = a := by rw [nadd_comm, nadd_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u}\n\u22a2 nadd 0 a = a"}, {"line": "rw [nadd_comm, nadd_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_nadd : 1 \u266f a = succ a := by rw [nadd_comm, nadd_one]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u}\n\u22a2 nadd 1 a = succ a"}, {"line": "rw [nadd_comm, nadd_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_nat (n : \u2115) : a \u266f n = a + n := by\n  induction' n with n hn\n  \u00b7 simp\n  \u00b7 rw [Nat.cast_succ, add_one_eq_succ, nadd_succ, add_succ, hn]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u}\nn : \u2115\n\u22a2 a.nadd \u2191n = a + \u2191n"}, {"line": "induction' n with n hn", "tactic_state": "case zero\na : Ordinal.{u}\n\u22a2 a.nadd \u21910 = a + \u21910\n---\ncase succ\na : Ordinal.{u}\nn : \u2115\nhn : a.nadd \u2191n = a + \u2191n\n\u22a2 a.nadd \u2191(n + 1) = a + \u2191(n + 1)"}, {"line": "\u00b7 simp", "tactic_state": "case succ\na : Ordinal.{u}\nn : \u2115\nhn : a.nadd \u2191n = a + \u2191n\n\u22a2 a.nadd \u2191(n + 1) = a + \u2191(n + 1)"}, {"line": "\u00b7 rw [Nat.cast_succ, add_one_eq_succ, nadd_succ, add_succ, hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_nadd (n : \u2115) : \u2191n \u266f a = a + n := by rw [nadd_comm, nadd_nat]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u}\nn : \u2115\n\u22a2 (\u2191n).nadd a = a + \u2191n"}, {"line": "rw [nadd_comm, nadd_nat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNatOrdinal_natCast (n : \u2115) : toNatOrdinal n = n := by\n  rw [\u2190 toOrdinal_natCast n]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 toNatOrdinal \u2191n = \u2191n"}, {"line": "rw [\u2190 toOrdinal_natCast n]", "tactic_state": "n : \u2115\n\u22a2 toNatOrdinal (toOrdinal \u2191n) = \u2191n"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_nadd_self {a b} : a \u2264 b \u266f a := by simpa using nadd_le_nadd_right (Ordinal.zero_le b) a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a \u2264 b.nadd a"}, {"line": "simpa using nadd_le_nadd_right (Ordinal.zero_le b) a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_self_nadd {a b} : a \u2264 a \u266f b := by simpa using nadd_le_nadd_left (Ordinal.zero_le b) a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a \u2264 a.nadd b"}, {"line": "simpa using nadd_le_nadd_left (Ordinal.zero_le b) a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_def (a b : Ordinal) :\n    a \u2a33 b = sInf {c | \u2200 a' < a, \u2200 b' < b, a' \u2a33 b \u266f a \u2a33 b' < c \u266f a' \u2a33 b'} := by\n  rw [nmul]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a.nmul b = sInf {c | \u2200 a' < a, \u2200 b' < b, (a'.nmul b).nadd (a.nmul b') < c.nadd (a'.nmul b')}"}, {"line": "rw [nmul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_nadd_lt {a' b' : Ordinal} (ha : a' < a) (hb : b' < b) :\n    a' \u2a33 b \u266f a \u2a33 b' < a \u2a33 b \u266f a' \u2a33 b' := by\n  conv_rhs => rw [nmul]\n  exact csInf_mem (nmul_nonempty a b) a' ha b' hb\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b a' b' : Ordinal.{u}\nha : a' < a\nhb : b' < b\n\u22a2 (a'.nmul b).nadd (a.nmul b') < (a.nmul b).nadd (a'.nmul b')"}, {"line": "conv_rhs => rw [nmul]", "tactic_state": "a b a' b' : Ordinal.{u}\nha : a' < a\nhb : b' < b\n\u22a2 (a'.nmul b).nadd (a.nmul b') <\n    (sInf {c | \u2200 a' < a, \u2200 b' < b, (a'.nmul b).nadd (a.nmul b') < c.nadd (a'.nmul b')}).nadd (a'.nmul b')"}, {"line": "exact csInf_mem (nmul_nonempty a b) a' ha b' hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_zero (a) : a \u2a33 0 = 0 := by\n  rw [\u2190 Ordinal.le_zero, nmul_le_iff]\n  exact fun _ _ a ha => (Ordinal.not_lt_zero a ha).elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a.nmul 0 = 0"}, {"line": "rw [\u2190 Ordinal.le_zero, nmul_le_iff]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 \u2200 a' < a, \u2200 b' < 0, (a'.nmul 0).nadd (a.nmul b') < nadd 0 (a'.nmul b')"}, {"line": "exact fun _ _ a ha => (Ordinal.not_lt_zero a ha).elim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_nmul (a) : 0 \u2a33 a = 0 := by rw [nmul_comm, nmul_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 nmul 0 a = 0"}, {"line": "rw [nmul_comm, nmul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_one (a : Ordinal) : a \u2a33 1 = a := by\n  rw [nmul]\n  convert csInf_Ici\n  ext b\n  refine \u27e8fun H \u21a6 le_of_forall_lt (a := a) fun c hc \u21a6 ?_, fun ha c hc \u21a6 ?_\u27e9\n  -- Porting note: had to add arguments to `nmul_one` in the next two lines\n  -- for the termination checker.\n  \u00b7 simpa [nmul_one c] using H c hc\n  \u00b7 simpa [nmul_one c] using hc.trans_le ha", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 a.nmul 1 = a"}, {"line": "rw [nmul]", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 sInf {c | \u2200 a' < a, \u2200 b' < 1, (a'.nmul 1).nadd (a.nmul b') < c.nadd (a'.nmul b')} = a"}, {"line": "convert csInf_Ici", "tactic_state": "case h.e'_2.h.e'_3\na : Ordinal.{u_1}\n\u22a2 {c | \u2200 a' < a, \u2200 b' < 1, (a'.nmul 1).nadd (a.nmul b') < c.nadd (a'.nmul b')} = Ici a"}, {"line": "ext b", "tactic_state": "case h.e'_2.h.e'_3.h\na b : Ordinal.{u_1}\n\u22a2 b \u2208 {c | \u2200 a' < a, \u2200 b' < 1, (a'.nmul 1).nadd (a.nmul b') < c.nadd (a'.nmul b')} \u2194 b \u2208 Ici a"}, {"line": "refine \u27e8fun H \u21a6 le_of_forall_lt (a := a) fun c hc \u21a6 ?_, fun ha c hc \u21a6 ?_\u27e9", "tactic_state": "case h.e'_2.h.e'_3.h.refine_1\na b : Ordinal.{u_1}\nH : b \u2208 {c | \u2200 a' < a, \u2200 b' < 1, (a'.nmul 1).nadd (a.nmul b') < c.nadd (a'.nmul b')}\nc : Ordinal.{u_1}\nhc : c < a\n\u22a2 c < b\n---\ncase h.e'_2.h.e'_3.h.refine_2\na b : Ordinal.{u_1}\nha : b \u2208 Ici a\nc : Ordinal.{u_1}\nhc : c < a\n\u22a2 \u2200 b' < 1, (c.nmul 1).nadd (a.nmul b') < b.nadd (c.nmul b')"}, {"line": "\u00b7 simpa [nmul_one c] using H c hc", "tactic_state": "case h.e'_2.h.e'_3.h.refine_2\na b : Ordinal.{u_1}\nha : b \u2208 Ici a\nc : Ordinal.{u_1}\nhc : c < a\n\u22a2 \u2200 b' < 1, (c.nmul 1).nadd (a.nmul b') < b.nadd (c.nmul b')"}, {"line": "\u00b7 simpa [nmul_one c] using hc.trans_le ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_nmul (a) : 1 \u2a33 a = a := by rw [nmul_comm, nmul_one]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Ordinal.{u_1}\n\u22a2 nmul 1 a = a"}, {"line": "rw [nmul_comm, nmul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_le_nmul_left (h : a \u2264 b) (c) : c \u2a33 a \u2264 c \u2a33 b := by\n  rcases lt_or_eq_of_le h with (h\u2081 | rfl) <;> rcases (eq_zero_or_pos c).symm with (h\u2082 | rfl)\n  \u00b7 exact (nmul_lt_nmul_of_pos_left h\u2081 h\u2082).le\n  all_goals simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u}\nh : a \u2264 b\nc : Ordinal.{u}\n\u22a2 c.nmul a \u2264 c.nmul b"}, {"line": "rcases lt_or_eq_of_le h with (h\u2081 | rfl) <;> rcases (eq_zero_or_pos c).symm with (h\u2082 | rfl)", "tactic_state": "case inl.inl\na b : Ordinal.{u}\nh : a \u2264 b\nc : Ordinal.{u}\nh\u2081 : a < b\nh\u2082 : 0 < c\n\u22a2 c.nmul a \u2264 c.nmul b\n---\ncase inl.inr\na b : Ordinal.{u}\nh : a \u2264 b\nh\u2081 : a < b\n\u22a2 nmul 0 a \u2264 nmul 0 b\n---\ncase inr.inl\na c : Ordinal.{u}\nh : a \u2264 a\nh\u2082 : 0 < c\n\u22a2 c.nmul a \u2264 c.nmul a\n---\ncase inr.inr\na : Ordinal.{u}\nh : a \u2264 a\n\u22a2 nmul 0 a \u2264 nmul 0 a"}, {"line": "\u00b7 exact (nmul_lt_nmul_of_pos_left h\u2081 h\u2082).le", "tactic_state": "case inl.inr\na b : Ordinal.{u}\nh : a \u2264 b\nh\u2081 : a < b\n\u22a2 nmul 0 a \u2264 nmul 0 b\n---\ncase inr.inl\na c : Ordinal.{u}\nh : a \u2264 a\nh\u2082 : 0 < c\n\u22a2 c.nmul a \u2264 c.nmul a\n---\ncase inr.inr\na : Ordinal.{u}\nh : a \u2264 a\n\u22a2 nmul 0 a \u2264 nmul 0 a"}, {"line": "all_goals simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_le_nmul_right (h : a \u2264 b) (c) : a \u2a33 c \u2264 b \u2a33 c := by\n  rw [nmul_comm, nmul_comm b]\n  exact nmul_le_nmul_left h c\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u}\nh : a \u2264 b\nc : Ordinal.{u}\n\u22a2 a.nmul c \u2264 b.nmul c"}, {"line": "rw [nmul_comm, nmul_comm b]", "tactic_state": "a b : Ordinal.{u}\nh : a \u2264 b\nc : Ordinal.{u}\n\u22a2 c.nmul a \u2264 c.nmul b"}, {"line": "exact nmul_le_nmul_left h c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nadd_nmul (a b c) : (a \u266f b) \u2a33 c = a \u2a33 c \u266f b \u2a33 c := by\n  rw [nmul_comm, nmul_nadd, nmul_comm, nmul_comm c]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\n\u22a2 (a.nadd b).nmul c = (a.nmul c).nadd (b.nmul c)"}, {"line": "rw [nmul_comm, nmul_nadd, nmul_comm, nmul_comm c]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_nadd_lt\u2083 {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :\n    a' \u2a33 b \u2a33 c \u266f a \u2a33 b' \u2a33 c \u266f a \u2a33 b \u2a33 c' \u266f a' \u2a33 b' \u2a33 c' <\n      a \u2a33 b \u2a33 c \u266f a' \u2a33 b' \u2a33 c \u266f a' \u2a33 b \u2a33 c' \u266f a \u2a33 b' \u2a33 c' := by\n  simpa only [nadd_nmul, \u2190 nadd_assoc] using nmul_nadd_lt (nmul_nadd_lt ha hb) hc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c a' b' c' : Ordinal.{u}\nha : a' < a\nhb : b' < b\nhc : c' < c\n\u22a2 ((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c') <\n    ((((a.nmul b).nmul c).nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c')"}, {"line": "simpa only [nadd_nmul, \u2190 nadd_assoc] using nmul_nadd_lt (nmul_nadd_lt ha hb) hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_nadd_le\u2083 {a' b' c' : Ordinal} (ha : a' \u2264 a) (hb : b' \u2264 b) (hc : c' \u2264 c) :\n    a' \u2a33 b \u2a33 c \u266f a \u2a33 b' \u2a33 c \u266f a \u2a33 b \u2a33 c' \u266f a' \u2a33 b' \u2a33 c' \u2264\n      a \u2a33 b \u2a33 c \u266f a' \u2a33 b' \u2a33 c \u266f a' \u2a33 b \u2a33 c' \u266f a \u2a33 b' \u2a33 c' := by\n  simpa only [nadd_nmul, \u2190 nadd_assoc] using nmul_nadd_le (nmul_nadd_le ha hb) hc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c a' b' c' : Ordinal.{u}\nha : a' \u2264 a\nhb : b' \u2264 b\nhc : c' \u2264 c\n\u22a2 ((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c') \u2264\n    ((((a.nmul b).nmul c).nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c')"}, {"line": "simpa only [nadd_nmul, \u2190 nadd_assoc] using nmul_nadd_le (nmul_nadd_le ha hb) hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_le_iff\u2083 : a \u2a33 b \u2a33 c \u2264 d \u2194 \u2200 a' < a, \u2200 b' < b, \u2200 c' < c,\n    a' \u2a33 b \u2a33 c \u266f a \u2a33 b' \u2a33 c \u266f a \u2a33 b \u2a33 c' \u266f a' \u2a33 b' \u2a33 c' <\n      d \u266f a' \u2a33 b' \u2a33 c \u266f a' \u2a33 b \u2a33 c' \u266f a \u2a33 b' \u2a33 c' := by\n  simpa using lt_nmul_iff\u2083.not\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Ordinal.{u}\n\u22a2 (a.nmul b).nmul c \u2264 d \u2194\n    \u2200 a' < a,\n      \u2200 b' < b,\n        \u2200 c' < c,\n          ((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c') <\n            ((d.nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c')"}, {"line": "simpa using lt_nmul_iff\u2083.not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_nmul_iff\u2083' : d < a \u2a33 (b \u2a33 c) \u2194 \u2203 a' < a, \u2203 b' < b, \u2203 c' < c,\n    d \u266f a' \u2a33 (b' \u2a33 c) \u266f a' \u2a33 (b \u2a33 c') \u266f a \u2a33 (b' \u2a33 c') \u2264\n      a' \u2a33 (b \u2a33 c) \u266f a \u2a33 (b' \u2a33 c) \u266f a \u2a33 (b \u2a33 c') \u266f a' \u2a33 (b' \u2a33 c') := by\n  simpa using nmul_le_iff\u2083'.not\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Ordinal.{u}\n\u22a2 d < a.nmul (b.nmul c) \u2194\n    \u2203 a' < a,\n      \u2203 b' < b,\n        \u2203 c' < c,\n          ((d.nadd (a'.nmul (b'.nmul c))).nadd (a'.nmul (b.nmul c'))).nadd (a.nmul (b'.nmul c')) \u2264\n            (((a'.nmul (b.nmul c)).nadd (a.nmul (b'.nmul c))).nadd (a.nmul (b.nmul c'))).nadd (a'.nmul (b'.nmul c'))"}, {"line": "simpa using nmul_le_iff\u2083'.not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_succ (a b) : a \u2a33 succ b = a \u2a33 b \u266f a := by rw [\u2190 nadd_one, nmul_nadd_one]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps", "Ordinal"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 a.nmul (succ b) = (a.nmul b).nadd a"}, {"line": "rw [\u2190 nadd_one, nmul_nadd_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_nmul (a b) : succ a \u2a33 b = a \u2a33 b \u266f b := by rw [\u2190 nadd_one, nadd_one_nmul]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/NaturalOps.lean", "context": {"open": ["Function Order Set", "Ordinal", "NaturalOps", "Ordinal NaturalOps", "NatOrdinal", "NaturalOps", "Ordinal"], "variables": ["{a b c : Ordinal.{u}}", "(a b)", "{a b c d : Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\n\u22a2 (succ a).nmul b = (a.nmul b).nadd b"}, {"line": "rw [\u2190 nadd_one, nadd_one_nmul]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem enumOrd_nonempty (hs : \u00ac BddAbove s) (o : Ordinal) :\n    (s \u2229 { b | \u2200 c, c < o \u2192 enumOrd s c < b }).Nonempty := by\n  rw [not_bddAbove_iff] at hs\n  obtain \u27e8a, ha\u27e9 := bddAbove_of_small (enumOrd s '' Iio o)\n  obtain \u27e8b, hb, hba\u27e9 := hs a\n  exact \u27e8b, hb, fun c hc \u21a6 (ha (mem_image_of_mem _ hc)).trans_lt hba\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Enum.lean", "context": {"open": ["Order Set"], "variables": ["{o a b : Ordinal.{u}}", "{s : Set Ordinal.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set Ordinal.{u}\nx\u271d : Sort u_1\nenumOrd : x\u271d\nhs : \u00acBddAbove s\no : Ordinal.{u_2}\n\u22a2 (s \u2229 {b | \u2200 c < o, sorry < b}).Nonempty"}, {"line": "rw [not_bddAbove_iff] at hs", "tactic_state": "s : Set Ordinal.{u}\nx\u271d : Sort u_1\nenumOrd : x\u271d\nhs : \u2200 (x : Ordinal.{u}), \u2203 y \u2208 s, x < y\no : Ordinal.{u_2}\n\u22a2 (s \u2229 {b | \u2200 c < o, sorry < b}).Nonempty"}, {"line": "obtain \u27e8a, ha\u27e9 := bddAbove_of_small (enumOrd s '' Iio o)", "tactic_state": "case mk.mk\ns : Set Ordinal.{u}\nx\u271d\u00b9 : Sort u_1\nenumOrd : x\u271d\u00b9\nhs : \u2200 (x : Ordinal.{u}), \u2203 y \u2208 s, x < y\no : Ordinal.{u_2}\nx\u271d : Ordinal.{u}\na : Type u\nha : a \u2192 a \u2192 Prop\nwo\u271d : IsWellOrder a ha\n\u22a2 (s \u2229 {b | \u2200 c < o, Quot.mk \u21d1Ordinal.isEquivalent { \u03b1 := a, r := ha, wo := wo\u271d } < b}).Nonempty"}, {"line": "obtain \u27e8b, hb, hba\u27e9 := hs a", "tactic_state": "case mk.mk.intro.intro\ns : Set Ordinal.{u}\nx\u271d\u00b9 : Sort u_1\nenumOrd : x\u271d\u00b9\nhs : \u2200 (x : Ordinal.{u}), \u2203 y \u2208 s, x < y\no : Ordinal.{u_2}\nx\u271d : Ordinal.{u}\na : Type u\nha : a \u2192 a \u2192 Prop\nwo\u271d : IsWellOrder a ha\nb : Ordinal.{u}\nhb : b \u2208 s\nhba : sorry < b\n\u22a2 (s \u2229 {b | \u2200 c < o, Quot.mk \u21d1Ordinal.isEquivalent { \u03b1 := a, r := ha, wo := wo\u271d } < b}).Nonempty"}, {"line": "exact \u27e8b, hb, fun c hc \u21a6 (ha (mem_image_of_mem _ hc)).trans_lt hba\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem add_lt_add_iff_left' (a) {b c : Ordinal} : a + b < a + c \u2194 b < c := by\n  rw [\u2190 not_le, \u2190 not_le, add_le_add_iff_left]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_4}\n\u22a2 a + b < a + c \u2194 b < c"}, {"line": "rw [\u2190 not_le, \u2190 not_le, add_le_add_iff_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLimit.one_lt {o : Ordinal} (h : IsLimit o) : 1 < o := by\n  simpa only [succ_zero] using h.succ_lt h.pos\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\n\u22a2 1 < o"}, {"line": "simpa only [succ_zero] using h.succ_lt h.pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLimit.sSup_Iio {o : Ordinal} (h : IsLimit o) : sSup (Iio o) = o := by\n  apply (csSup_le' (fun a ha \u21a6 le_of_lt ha)).antisymm\n  apply le_of_forall_lt\n  intro a ha\n  exact (lt_succ a).trans_le (le_csSup bddAbove_Iio (h.succ_lt ha))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\n\u22a2 sSup (Iio o) = o"}, {"line": "apply (csSup_le' (fun a ha \u21a6 le_of_lt ha)).antisymm", "tactic_state": "x\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\n\u22a2 o \u2264 sSup fun a => Preorder.toLT.1 a o"}, {"line": "apply le_of_forall_lt", "tactic_state": "case H\nx\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\n\u22a2 \u2200 c < o, c < sSup fun a => Preorder.toLT.1 a o"}, {"line": "intro a ha", "tactic_state": "case H\nx\u271d : Sort u_1\nIsLimit : x\u271d\no : Ordinal.{u_2}\nh : sorry\na : Ordinal.{u_2}\nha : a < o\n\u22a2 a < sSup fun a => Preorder.toLT.1 a o"}, {"line": "exact (lt_succ a).trans_le (le_csSup bddAbove_Iio (h.succ_lt ha))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_sub_of_le {a b c : Ordinal} (h : b \u2264 a) : c \u2264 a - b \u2194 b + c \u2264 a := by\n  rw [\u2190 add_le_add_iff_left b, Ordinal.add_sub_cancel_of_le h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nh : b \u2264 a\n\u22a2 c \u2264 a - b \u2194 b + c \u2264 a"}, {"line": "rw [\u2190 add_le_add_iff_left b, Ordinal.add_sub_cancel_of_le h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_sub_of_add_le {a b c : Ordinal} (h : b + c \u2264 a) : c \u2264 a - b := by\n  rw [\u2190 add_le_add_iff_left b]\n  exact h.trans (le_add_sub a b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nh : b + c \u2264 a\n\u22a2 c \u2264 a - b"}, {"line": "rw [\u2190 add_le_add_iff_left b]", "tactic_state": "a b c : Ordinal.{u_1}\nh : b + c \u2264 a\n\u22a2 b + c \u2264 b + (a - b)"}, {"line": "exact h.trans (le_add_sub a b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_lt_of_lt_add {a b c : Ordinal} (h : a < b + c) (hc : 0 < c) : a - b < c := by\n  obtain hab | hba := lt_or_le a b\n  \u00b7 rwa [Ordinal.sub_eq_zero_iff_le.2 hab.le]\n  \u00b7 rwa [sub_lt_of_le hba]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nh : a < b + c\nhc : 0 < c\n\u22a2 a - b < c"}, {"line": "obtain hab | hba := lt_or_le a b", "tactic_state": "case inl\na b c : Ordinal.{u_1}\nh : a < b + c\nhc : 0 < c\nhab : a < b\n\u22a2 a - b < c\n---\ncase inr\na b c : Ordinal.{u_1}\nh : a < b + c\nhc : 0 < c\nhba : b \u2264 a\n\u22a2 a - b < c"}, {"line": "\u00b7 rwa [Ordinal.sub_eq_zero_iff_le.2 hab.le]", "tactic_state": "case inr\na b c : Ordinal.{u_1}\nh : a < b + c\nhc : 0 < c\nhba : b \u2264 a\n\u22a2 a - b < c"}, {"line": "\u00b7 rwa [sub_lt_of_le hba]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_add_iff {a b c : Ordinal} (hc : c \u2260 0) : a < b + c \u2194 \u2203 d < c, a \u2264 b + d := by\n  use fun h \u21a6 \u27e8_, sub_lt_of_lt_add h hc.bot_lt, le_add_sub a b\u27e9\n  rintro \u27e8d, hd, ha\u27e9\n  exact ha.trans_lt (add_lt_add_left hd b)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 a < b + c \u2194 \u2203 d < c, a \u2264 b + d"}, {"line": "use fun h \u21a6 \u27e8_, sub_lt_of_lt_add h hc.bot_lt, le_add_sub a b\u27e9", "tactic_state": "case mpr\na b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 (\u2203 d < c, a \u2264 b + d) \u2192 a < b + c\n---\ncase mp\na b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 a < b + c \u2192 \u2203 d < c, a \u2264 b + d"}, {"line": "rintro \u27e8d, hd, ha\u27e9", "tactic_state": "case mpr.intro.intro\na b c : Ordinal.{u_1}\nhc : c \u2260 0\nd : Ordinal.{u_1}\nhd : d < c\nha : a \u2264 b + d\n\u22a2 a < b + c\n---\ncase mp\na b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 a < b + c \u2192 \u2203 d < c, a \u2264 b + d"}, {"line": "exact ha.trans_lt (add_lt_add_left hd b)", "tactic_state": "case mp\na b c : Ordinal.{u_1}\nhc : c \u2260 0\n\u22a2 a < b + c \u2192 \u2203 d < c, a \u2264 b + d"}]}
{"declaration": "theorem lt_mul_div_add (a) {b : Ordinal} (h : b \u2260 0) : a < b * (a / b) + b := by\n  simpa only [mul_succ] using lt_mul_succ_div a h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nh : b \u2260 0\n\u22a2 a < b * (a / b) + b"}, {"line": "simpa only [mul_succ] using lt_mul_succ_div a h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mod_eq_zero_of_dvd {a b : Ordinal} (H : b \u2223 a) : a % b = 0 := by\n  rcases H with \u27e8c, rfl\u27e9\n  rcases eq_or_ne b 0 with (rfl | hb)\n  \u00b7 simp\n  \u00b7 simp [mod_def, hb]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Ordinal.{u_1}\nH : b \u2223 a\n\u22a2 a % b = 0"}, {"line": "rcases H with \u27e8c, rfl\u27e9", "tactic_state": "case intro\nb c : Ordinal.{u_1}\n\u22a2 b * c % b = 0"}, {"line": "rcases eq_or_ne b 0 with (rfl | hb)", "tactic_state": "case intro.inl\nc : Ordinal.{u_1}\n\u22a2 0 * c % 0 = 0\n---\ncase intro.inr\nb c : Ordinal.{u_1}\nhb : b \u2260 0\n\u22a2 b * c % b = 0"}, {"line": "\u00b7 simp", "tactic_state": "case intro.inr\nb c : Ordinal.{u_1}\nhb : b \u2260 0\n\u22a2 b * c % b = 0"}, {"line": "\u00b7 simp [mod_def, hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_add_mod_self (x y z : Ordinal) : (x * y + z) % x = z % x := by\n  rcases eq_or_ne x 0 with rfl | hx\n  \u00b7 simp\n  \u00b7 rwa [mod_def, mul_add_div, mul_add, \u2190 sub_sub, add_sub_cancel, mod_def]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : Ordinal.{u_1}\n\u22a2 (x * y + z) % x = z % x"}, {"line": "rcases eq_or_ne x 0 with rfl | hx", "tactic_state": "case inl\ny z : Ordinal.{u_1}\n\u22a2 (0 * y + z) % 0 = z % 0\n---\ncase inr\nx y z : Ordinal.{u_1}\nhx : x \u2260 0\n\u22a2 (x * y + z) % x = z % x"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nx y z : Ordinal.{u_1}\nhx : x \u2260 0\n\u22a2 (x * y + z) % x = z % x"}, {"line": "\u00b7 rwa [mod_def, mul_add_div, mul_add, \u2190 sub_sub, add_sub_cancel, mod_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_mod (x y : Ordinal) : x * y % x = 0 := by\n  simpa using mul_add_mod_self x y 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Ordinal.{u_1}\n\u22a2 x * y % x = 0"}, {"line": "simpa using mul_add_mod_self x y 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_add_natCast (m : \u2115) : 1 + (m : Ordinal) = succ m := by\n  rw [\u2190 Nat.cast_one, \u2190 Nat.cast_add, add_comm]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 1 + \u2191m = \u2191(succ m)"}, {"line": "rw [\u2190 Nat.cast_one, \u2190 Nat.cast_add, add_comm]", "tactic_state": "m : \u2115\n\u22a2 \u2191(m + 1) = \u2191(succ m)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_nat_or_omega0_le (o : Ordinal) : (\u2203 n : \u2115, o = n) \u2228 \u03c9 \u2264 o := by\n  obtain ho | ho := lt_or_le o \u03c9\n  \u00b7 exact Or.inl <| lt_omega0.1 ho\n  \u00b7 exact Or.inr ho\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Ordinal.{u_1}\n\u22a2 (\u2203 n, o = \u2191n) \u2228 Ordinal.omega0 \u2264 o"}, {"line": "obtain ho | ho := lt_or_le o \u03c9", "tactic_state": "case inl\no : Ordinal.{u_1}\nho : o < sorry\n\u22a2 (\u2203 n, o = \u2191n) \u2228 Ordinal.omega0 \u2264 o\n---\ncase inr\no : Ordinal.{u_1}\nho : sorry \u2264 o\n\u22a2 (\u2203 n, o = \u2191n) \u2228 Ordinal.omega0 \u2264 o"}, {"line": "\u00b7 exact Or.inl <| lt_omega0.1 ho", "tactic_state": "case inr\no : Ordinal.{u_1}\nho : sorry \u2264 o\n\u22a2 (\u2203 n, o = \u2191n) \u2228 Ordinal.omega0 \u2264 o"}, {"line": "\u00b7 exact Or.inr ho", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_omega0 : 1 < \u03c9 := by simpa only [Nat.cast_one] using nat_lt_omega0 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 < Ordinal.omega0"}, {"line": "simpa only [Nat.cast_one] using nat_lt_omega0 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_one_of_aleph0_le {c} (h : \u2135\u2080 \u2264 c) : c + 1 = c := by\n  rw [add_comm, \u2190 card_ord c, \u2190 card_one, \u2190 card_add, one_add_of_omega0_le]\n  rwa [\u2190 ord_aleph0, ord_le_ord]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal", "Classical in", "Ordinal", "Ordinal"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_4}\nh : aleph0 \u2264 c\n\u22a2 c + 1 = c"}, {"line": "rw [add_comm, \u2190 card_ord c, \u2190 card_one, \u2190 card_add, one_add_of_omega0_le]", "tactic_state": "c : Cardinal.{u_4}\nh : aleph0 \u2264 c\n\u22a2 omega0 \u2264 c.ord"}, {"line": "rwa [\u2190 ord_aleph0, ord_le_ord]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bsup_congr {o\u2081 o\u2082 : Ordinal.{u}} (f : \u2200 a < o\u2081, Ordinal.{max u v}) (ho : o\u2081 = o\u2082) :\n    bsup.{_, v} o\u2081 f = bsup.{_, v} o\u2082 fun a h => f a (h.trans_eq ho.symm) := by\n  subst ho\n  -- Porting note: `rfl` is required.\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Family.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nbsup : x\u271d\no\u2081 o\u2082 : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o\u2081 \u2192 Ordinal.{max u v}\nho : o\u2081 = o\u2082\n\u22a2 sorry = sorry"}, {"line": "subst ho", "tactic_state": "x\u271d : Sort u_4\nbsup : x\u271d\no\u2081 : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o\u2081 \u2192 Ordinal.{max u v}\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blsub_congr {o\u2081 o\u2082 : Ordinal.{u}} (f : \u2200 a < o\u2081, Ordinal.{max u v}) (ho : o\u2081 = o\u2082) :\n    blsub.{_, v} o\u2081 f = blsub.{_, v} o\u2082 fun a h => f a (h.trans_eq ho.symm) := by\n  subst ho\n  -- Porting note: `rfl` is required.\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/Family.lean", "context": {"open": ["Function Cardinal Set Equiv Order", "scoped Ordinal"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nblsub : x\u271d\no\u2081 o\u2082 : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o\u2081 \u2192 Ordinal.{max u v}\nho : o\u2081 = o\u2082\n\u22a2 sorry = sorry"}, {"line": "subst ho", "tactic_state": "x\u271d : Sort u_4\nblsub : x\u271d\no\u2081 : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o\u2081 \u2192 Ordinal.{max u v}\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_CNF {o : Ordinal} (ho : o \u2260 0) : CNF 0 o = [(0, o)] := by simp [CNF_ne_zero ho]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/CantorNormalForm.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCNF : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 sorry = [(0, o)]"}, {"line": "simp [CNF_ne_zero ho]", "tactic_state": "x\u271d : Sort u_1\nCNF : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 sorry () = [(0, o)]"}]}
{"declaration": "theorem one_CNF {o : Ordinal} (ho : o \u2260 0) : CNF 1 o = [(0, o)] := by simp [CNF_ne_zero ho]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Ordinal/CantorNormalForm.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCNF : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 sorry = [(0, o)]"}, {"line": "simp [CNF_ne_zero ho]", "tactic_state": "x\u271d : Sort u_1\nCNF : x\u271d\no : Ordinal.{u_2}\nho : o \u2260 0\n\u22a2 sorry () = [(0, o)]"}]}
{"declaration": "lemma mem_of_append {x y : List A} (h : x ++ y \u2208 T) : x \u2208 T := by\n  induction' y with y ys ih generalizing x\n  \u00b7 simpa using h\n  \u00b7 exact T.prop (ih (by simpa))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Descriptive/Tree.lean", "context": {"open": [], "variables": ["{A : Type*} {S T : tree A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "tree : ?m.832\nA\u271d : Type u_1\nS : sorry\nT : sorry\nA : Type u_1\nx y : List A\nh : sorry\n\u22a2 sorry"}, {"line": "induction' y with y ys ih generalizing x", "tactic_state": "case nil\ntree : ?m.832\nA\u271d : Type u_1\nS : sorry\nT : sorry\nA : Type u_1\nh : sorry\nx : List A\n\u22a2 sorry\n---\ncase cons\ntree : ?m.832\nA\u271d : Type u_1\nS : sorry\nT : sorry\nA : Type u_1\nh : sorry\ny : A\nys : List A\nih : \u2200 {x : List A}, sorry\nx : List A\n\u22a2 sorry"}, {"line": "\u00b7 simpa using h", "tactic_state": "case cons\ntree : ?m.832\nA\u271d : Type u_1\nS : sorry\nT : sorry\nA : Type u_1\nh : sorry\ny : A\nys : List A\nih : \u2200 {x : List A}, sorry\nx : List A\n\u22a2 sorry"}, {"line": "\u00b7 exact T.prop (ih (by simpa))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_add {x y : PGame} (hx : x.Numeric) (hy : y.Numeric) :\n    Surreal.mk (x + y) (hx.add hy) = Surreal.mk x hx + Surreal.mk y hy := by rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Basic.lean", "context": {"open": ["scoped PGame", "SetTheory PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : PGame\nhx : x.Numeric\nhy : y.Numeric\n\u22a2 Surreal.mk (x + y) \u22ef = Surreal.mk x hx + Surreal.mk y hy"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_sub {x y : PGame} (hx : x.Numeric) (hy : y.Numeric) :\n    Surreal.mk (x - y) (hx.sub hy) = Surreal.mk x hx - Surreal.mk y hy := by rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Basic.lean", "context": {"open": ["scoped PGame", "SetTheory PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : PGame\nhx : x.Numeric\nhy : y.Numeric\n\u22a2 Surreal.mk (x - y) \u22ef = Surreal.mk x hx - Surreal.mk y hy"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mulOption_lt_iff_P1 {i j k l} :\n    (\u27e6mulOption x y i k\u27e7 : Game) < -\u27e6mulOption x (-y) j l\u27e7 \u2194\n    P1 (x.moveLeft i) x (x.moveLeft j) y (y.moveLeft k) (-(-y).moveLeft l) := by\n  dsimp only [P1, mulOption, quot_sub, quot_add]\n  simp_rw [neg_sub', neg_add, quot_mul_neg, neg_neg]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Multiplication.lean", "context": {"open": ["SetTheory Game PGame WellFounded"], "variables": ["{x x\u2081 x\u2082 x\u2083 x' y y\u2081 y\u2082 y\u2083 y' : PGame.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : PGame\nx\u271d : Sort u_1\nP1 : x\u271d\ni j : x.LeftMoves\nk : y.LeftMoves\nl : (-y).LeftMoves\n\u22a2 \u27e6x.mulOption y i k\u27e7 < -\u27e6x.mulOption (-y) j l\u27e7 \u2194 sorry"}, {"line": "dsimp only [P1, mulOption, quot_sub, quot_add]", "tactic_state": "x y : PGame\nx\u271d : Sort u_1\nP1 : x\u271d\ni j : x.LeftMoves\nk : y.LeftMoves\nl : (-y).LeftMoves\n\u22a2 \u27e6x.moveLeft i * y\u27e7 + \u27e6x * y.moveLeft k\u27e7 - \u27e6x.moveLeft i * y.moveLeft k\u27e7 <\n      -(\u27e6x.moveLeft j * -y\u27e7 + \u27e6x * (-y).moveLeft l\u27e7 - \u27e6x.moveLeft j * (-y).moveLeft l\u27e7) \u2194\n    sorry"}, {"line": "simp_rw [neg_sub', neg_add, quot_mul_neg, neg_neg]", "tactic_state": "x y : PGame\nx\u271d : Sort u_1\nP1 : x\u271d\ni j : x.LeftMoves\nk : y.LeftMoves\nl : (-y).LeftMoves\n\u22a2 \u27e6x.moveLeft i * y\u27e7 + \u27e6x * y.moveLeft k\u27e7 - \u27e6x.moveLeft i * y.moveLeft k\u27e7 <\n      \u27e6x.moveLeft j * y\u27e7 + -\u27e6x * (-y).moveLeft l\u27e7 - -\u27e6x.moveLeft j * (-y).moveLeft l\u27e7 \u2194\n    sorry"}]}
{"declaration": "theorem Numeric.mul_pos (hx\u2081 : x\u2081.Numeric) (hx\u2082 : x\u2082.Numeric) (hp\u2081 : 0 < x\u2081) (hp\u2082 : 0 < x\u2082) :\n    0 < x\u2081 * x\u2082 := by\n  rw [lt_iff_game_lt]\n  have := P3_of_lt_of_lt numeric_zero hx\u2081 numeric_zero hx\u2082 hp\u2081 hp\u2082\n  simp_rw [P3, quot_zero_mul, quot_mul_zero, add_lt_add_iff_left] at this\n  exact this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/SetTheory/Surreal/Multiplication.lean", "context": {"open": ["SetTheory Game PGame WellFounded", "Relation", "Surreal.Multiplication", "Prod.GameAdd"], "variables": ["{x x\u2081 x\u2082 x\u2083 x' y y\u2081 y\u2082 y\u2083 y' : PGame.{u}}", "{x x\u2081 x\u2082 y y\u2081 y\u2082 : PGame.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u2081 x\u2082 : PGame\nhx\u2081 : x\u2081.Numeric\nhx\u2082 : x\u2082.Numeric\nhp\u2081 : 0 < x\u2081\nhp\u2082 : 0 < x\u2082\n\u22a2 0 < x\u2081 * x\u2082"}, {"line": "rw [lt_iff_game_lt]", "tactic_state": "x\u2081 x\u2082 : PGame\nhx\u2081 : x\u2081.Numeric\nhx\u2082 : x\u2082.Numeric\nhp\u2081 : 0 < x\u2081\nhp\u2082 : 0 < x\u2082\n\u22a2 \u27e60\u27e7 < \u27e6x\u2081 * x\u2082\u27e7"}, {"line": "have := P3_of_lt_of_lt numeric_zero hx\u2081 numeric_zero hx\u2082 hp\u2081 hp\u2082", "tactic_state": "x\u2081 x\u2082 : PGame\nhx\u2081 : x\u2081.Numeric\nhx\u2082 : x\u2082.Numeric\nhp\u2081 : 0 < x\u2081\nhp\u2082 : 0 < x\u2082\nthis : P3 0 x\u2081 0 x\u2082\n\u22a2 \u27e60\u27e7 < \u27e6x\u2081 * x\u2082\u27e7"}, {"line": "simp_rw [P3, quot_zero_mul, quot_mul_zero, add_lt_add_iff_left] at this", "tactic_state": "x\u2081 x\u2082 : PGame\nhx\u2081 : x\u2081.Numeric\nhx\u2082 : x\u2082.Numeric\nhp\u2081 : 0 < x\u2081\nhp\u2082 : 0 < x\u2082\nthis : 0 < \u27e6x\u2081 * x\u2082\u27e7\n\u22a2 \u27e60\u27e7 < \u27e6x\u2081 * x\u2082\u27e7"}, {"line": "exact this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orientation_map (e : Basis \u03b9 R M) (f : M \u2243\u2097[R] N) :\n    (e.map f).orientation = Orientation.map \u03b9 f e.orientation := by\n  simp_rw [Basis.orientation, Orientation.map_apply, Basis.det_map']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Orientation.lean", "context": {"open": [], "variables": ["(R : Type*) [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "(M : Type*) [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 \u03b9' : Type*)", "{R M}", "(R M) {\u03b9 \u03b9'}", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "{\u03b9 \u03b9' : Type*}", "[Fintype \u03b9] [DecidableEq \u03b9] [Fintype \u03b9'] [DecidableEq \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : IsStrictOrderedRing R\nM : Type u_7\nN : Type u_8\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R N\n\u03b9 : Type u_9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne : Basis \u03b9 R M\nf : M \u2243\u2097[R] N\n\u22a2 (e.map f).orientation = (Orientation.map \u03b9 f) e.orientation"}, {"line": "simp_rw [Basis.orientation, Orientation.map_apply, Basis.det_map']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orientation_isEmpty [IsEmpty \u03b9] (b : Basis \u03b9 R M) :\n    b.orientation = positiveOrientation := by\n  rw [Basis.orientation]\n  congr\n  exact b.det_isEmpty\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Orientation.lean", "context": {"open": [], "variables": ["(R : Type*) [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "(M : Type*) [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 \u03b9' : Type*)", "{R M}", "(R M) {\u03b9 \u03b9'}", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "{\u03b9 \u03b9' : Type*}", "[Fintype \u03b9] [DecidableEq \u03b9] [Fintype \u03b9'] [DecidableEq \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : IsStrictOrderedRing R\nM : Type u_7\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\n\u03b9 : Type u_9\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : IsEmpty \u03b9\nb : Basis \u03b9 R M\n\u22a2 b.orientation = positiveOrientation"}, {"line": "rw [Basis.orientation]", "tactic_state": "R : Type u_6\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : IsStrictOrderedRing R\nM : Type u_7\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\n\u03b9 : Type u_9\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : IsEmpty \u03b9\nb : Basis \u03b9 R M\n\u22a2 rayOfNeZero R b.det \u22ef = positiveOrientation"}, {"line": "congr", "tactic_state": "case e_v\nR : Type u_6\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : IsStrictOrderedRing R\nM : Type u_7\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\n\u03b9 : Type u_9\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : IsEmpty \u03b9\nb : Basis \u03b9 R M\n\u22a2 b.det = AlternatingMap.constLinearEquivOfIsEmpty 1"}, {"line": "exact b.det_isEmpty", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_basis_left {\u03b9 : Type*} (m : Basis \u03b9 R M)\n    (H : LinearMap.ker (mulLeftMap N m) = \u22a5) : M.LinearDisjoint N := by\n  -- need this instance otherwise `LinearMap.ker_eq_bot` does not work\n  letI : AddCommGroup (\u03b9 \u2192\u2080 N) := Finsupp.instAddCommGroup\n  exact of_basis_left' M N m (LinearMap.ker_eq_bot.1 H)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearDisjoint.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{R : Type u} {S : Type v}", "[CommSemiring R] [Semiring S] [Algebra R S]", "(M N : Submodule R S)", "{M N}", "(M N)", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "{M N : Submodule R S}", "[CommRing R] [Ring S] [Algebra R S]", "(M N : Submodule R S)", "{M N} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nmulLeftMap : x\u271d\n\u03b9 : Type u_1\nm : sorry\nH : LinearMap.ker sorry = \u22a5\n\u22a2 sorry"}, {"line": "letI : AddCommGroup (\u03b9 \u2192\u2080 N) := Finsupp.instAddCommGroup", "tactic_state": "x\u271d : Sort u_2\nmulLeftMap : x\u271d\n\u03b9 : Type u_1\nm : sorry\nH : LinearMap.ker sorry = \u22a5\nthis : AddCommGroup sorry := sorry\n\u22a2 sorry"}, {"line": "exact of_basis_left' M N m (LinearMap.ker_eq_bot.1 H)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_basis_right {\u03b9 : Type*} (n : Basis \u03b9 R N)\n    (H : LinearMap.ker (mulRightMap M n) = \u22a5) : M.LinearDisjoint N := by\n  -- need this instance otherwise `LinearMap.ker_eq_bot` does not work\n  letI : AddCommGroup (\u03b9 \u2192\u2080 M) := Finsupp.instAddCommGroup\n  exact of_basis_right' M N n (LinearMap.ker_eq_bot.1 H)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearDisjoint.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{R : Type u} {S : Type v}", "[CommSemiring R] [Semiring S] [Algebra R S]", "(M N : Submodule R S)", "{M N}", "(M N)", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "{M N : Submodule R S}", "[CommRing R] [Ring S] [Algebra R S]", "(M N : Submodule R S)", "{M N} in", "{M N} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nmulRightMap : x\u271d\n\u03b9 : Type u_1\nn : sorry\nH : LinearMap.ker sorry = \u22a5\n\u22a2 sorry"}, {"line": "letI : AddCommGroup (\u03b9 \u2192\u2080 M) := Finsupp.instAddCommGroup", "tactic_state": "x\u271d : Sort u_2\nmulRightMap : x\u271d\n\u03b9 : Type u_1\nn : sorry\nH : LinearMap.ker sorry = \u22a5\nthis : AddCommGroup sorry := sorry\n\u22a2 sorry"}, {"line": "exact of_basis_right' M N n (LinearMap.ker_eq_bot.1 H)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_of_mem_unitary {A : Matrix n n \u03b1} (hA : A \u2208 Matrix.unitaryGroup n \u03b1) :\n    A.det \u2208 unitary \u03b1 := by\n  constructor\n  \u00b7 simpa [star, det_transpose] using congr_arg det hA.1\n  \u00b7 simpa [star, det_transpose] using congr_arg det hA.2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/UnitaryGroup.lean", "context": {"open": ["LinearMap Matrix"], "variables": ["(n : Type u) [DecidableEq n] [Fintype n]", "(\u03b1 : Type v) [CommRing \u03b1] [StarRing \u03b1]", "{n : Type u} [DecidableEq n] [Fintype n]", "{\u03b1 : Type v} [CommRing \u03b1] [StarRing \u03b1] {A : Matrix n n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 A.det \u2208 unitary \u03b1"}, {"line": "constructor", "tactic_state": "case left\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 star A.det * A.det = 1\n---\ncase right\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 A.det * star A.det = 1"}, {"line": "\u00b7 simpa [star, det_transpose] using congr_arg det hA.1", "tactic_state": "case right\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 A.det * star A.det = 1"}, {"line": "\u00b7 simpa [star, det_transpose] using congr_arg det hA.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearProjOfIsCompl_apply_left (h : IsCompl p q) (x : p) :\n    linearProjOfIsCompl p q h x = x := by simp [linearProjOfIsCompl]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : \u21a5p\n\u22a2 (p.linearProjOfIsCompl q h) \u2191x = x"}, {"line": "simp [linearProjOfIsCompl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearProjOfIsCompl_apply_eq_zero_iff (h : IsCompl p q) {x : E} :\n    linearProjOfIsCompl p q h x = 0 \u2194 x \u2208 q := by simp [linearProjOfIsCompl]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : E\n\u22a2 (p.linearProjOfIsCompl q h) x = 0 \u2194 x \u2208 q"}, {"line": "simp [linearProjOfIsCompl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofIsCompl_left_apply (h : IsCompl p q) {\u03c6 : p \u2192\u2097[R] F} {\u03c8 : q \u2192\u2097[R] F} (u : p) :\n    ofIsCompl h \u03c6 \u03c8 (u : E) = \u03c6 u := by simp [ofIsCompl]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap", "Submodule"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Ring R\nE : Type u_2\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module R E\nF : Type u_3\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module R F\np q : Submodule R E\nh : IsCompl p q\n\u03c6 : \u21a5p \u2192\u2097[R] F\n\u03c8 : \u21a5q \u2192\u2097[R] F\nu : \u21a5p\n\u22a2 (ofIsCompl h \u03c6 \u03c8) \u2191u = \u03c6 u"}, {"line": "simp [ofIsCompl]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Ring R\nE : Type u_2\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module R E\nF : Type u_3\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module R F\np q : Submodule R E\nh : IsCompl p q\n\u03c6 : \u21a5p \u2192\u2097[R] F\n\u03c8 : \u21a5q \u2192\u2097[R] F\nu : \u21a5p\n\u22a2 \u03c6 u + \u03c8 0 = \u03c6 u"}]}
{"declaration": "theorem ofIsCompl_right_apply (h : IsCompl p q) {\u03c6 : p \u2192\u2097[R] F} {\u03c8 : q \u2192\u2097[R] F} (v : q) :\n    ofIsCompl h \u03c6 \u03c8 (v : E) = \u03c8 v := by simp [ofIsCompl]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap", "Submodule"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Ring R\nE : Type u_2\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module R E\nF : Type u_3\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module R F\np q : Submodule R E\nh : IsCompl p q\n\u03c6 : \u21a5p \u2192\u2097[R] F\n\u03c8 : \u21a5q \u2192\u2097[R] F\nv : \u21a5q\n\u22a2 (ofIsCompl h \u03c6 \u03c8) \u2191v = \u03c8 v"}, {"line": "simp [ofIsCompl]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Ring R\nE : Type u_2\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module R E\nF : Type u_3\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module R F\np q : Submodule R E\nh : IsCompl p q\n\u03c6 : \u21a5p \u2192\u2097[R] F\n\u03c8 : \u21a5q \u2192\u2097[R] F\nv : \u21a5q\n\u22a2 \u03c6 0 + \u03c8 v = \u03c8 v"}]}
{"declaration": "theorem IsProj.eq_conj_prodMap {f : E \u2192\u2097[R] E} (h : IsProj p f) :\n    f = (p.prodEquivOfIsCompl (ker f) h.isCompl).conj (prodMap id 0) := by\n  rw [LinearEquiv.conj_apply]\n  exact h.eq_conj_prod_map'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap", "Submodule", "LinearMap", "Submodule"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}", "{p q}", "{R\u2081 : Type*} [CommRing R\u2081] [Module R\u2081 E] [Module R\u2081 F]", "{p m}", "{R : Type*} [CommRing R] {E : Type*} [AddCommGroup E] [Module R E] {p : Submodule R E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_8\ninst\u271d\u00b2 : CommRing R\nE : Type u_9\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module R E\np : Submodule R E\nf : E \u2192\u2097[R] E\nh : IsProj p f\n\u22a2 f = (p.prodEquivOfIsCompl (ker f) \u22ef).conj (LinearMap.id.prodMap 0)"}, {"line": "rw [LinearEquiv.conj_apply]", "tactic_state": "R : Type u_8\ninst\u271d\u00b2 : CommRing R\nE : Type u_9\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module R E\np : Submodule R E\nf : E \u2192\u2097[R] E\nh : IsProj p f\n\u22a2 f = (\u2191(p.prodEquivOfIsCompl (ker f) \u22ef) \u2218\u2097 LinearMap.id.prodMap 0) \u2218\u2097 \u2191(p.prodEquivOfIsCompl (ker f) \u22ef).symm"}, {"line": "exact h.eq_conj_prod_map'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem BilinMap.isSymm_iff_eq_flip {N : Type*} [AddCommMonoid N] [Module R N]\n    {B : LinearMap.BilinMap R M N} : (\u2200 x y, B x y = B y x) \u2194 B = B.flip := by\n  simp [LinearMap.ext_iff\u2082]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SesquilinearForm.lean", "context": {"open": ["scoped Function in -- required for scoped `on` notation"], "variables": ["{R R\u2081 R\u2082 R\u2083 M M\u2081 M\u2082 M\u2083 M\u2097\u2081 M\u2097\u2081' M\u2097\u2082 M\u2097\u2082' K K\u2081 K\u2082 V V\u2081 V\u2082 n : Type*}", "[CommSemiring R] [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081] [CommSemiring R\u2082]", "[Field K] [AddCommGroup V] [Module K V] [Field K\u2081] [AddCommGroup V\u2081] [Module K\u2081 V\u2081]", "[CommSemiring R] [AddCommMonoid M] [Module R M] [CommSemiring R\u2081] [AddCommMonoid M\u2081]", "(H : B.IsRefl)", "[CommSemiring R] [AddCommMonoid M] [Module R M] {I : R \u2192+* R} {B : M \u2192\u209b\u2097[I] M \u2192\u2097[R] R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nM : Type u_3\ninst\u271d\u2078 inst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nN : Type u_1\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\nB : LinearMap.BilinMap R M N\n\u22a2 (\u2200 (x y : M), (B x) y = (B y) x) \u2194 B = LinearMap.flip B"}, {"line": "simp [LinearMap.ext_iff\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem basis_pair_right (hij : i \u2260 j) : Lagrange.basis {i, j} v j = basisDivisor (v j) (v i) := by\n  rw [pair_comm]\n  exact basis_pair_left hij.symm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Lagrange.lean", "context": {"open": ["Polynomial", "Function Fintype", "scoped Finset", "Finset", "Polynomial", "Finset"], "variables": ["{R : Type*} [CommRing R] [IsDomain R] {f g : R[X]}", "(s : Finset R)", "{\u03b9 : Type*} {v : \u03b9 \u2192 R} (s : Finset \u03b9)", "{F : Type*} [Field F]", "{x y : F}", "{F : Type*} [Field F] {\u03b9 : Type*} [DecidableEq \u03b9]", "{s : Finset \u03b9} {v : \u03b9 \u2192 F} {i j : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_4\ninst\u271d\u00b9 : Field F\n\u03b9 : Type u_5\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 F\ni j : \u03b9\nx\u271d : Sort u_6\nbasisDivisor : x\u271d\nhij : i \u2260 j\n\u22a2 Lagrange.basis {i, j} v j = sorry"}, {"line": "rw [pair_comm]", "tactic_state": "F : Type u_4\ninst\u271d\u00b9 : Field F\n\u03b9 : Type u_5\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 F\ni j : \u03b9\nx\u271d : Sort u_6\nbasisDivisor : x\u271d\nhij : i \u2260 j\n\u22a2 Lagrange.basis {j, i} v j = sorry"}, {"line": "exact basis_pair_left hij.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nodal_ne_zero [Nontrivial R] : nodal s v \u2260 0 := by", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Lagrange.lean", "context": {"open": ["Polynomial", "Function Fintype", "scoped Finset", "Finset", "Polynomial", "Finset", "Finset", "Finset Polynomial"], "variables": ["{R : Type*} [CommRing R] [IsDomain R] {f g : R[X]}", "(s : Finset R)", "{\u03b9 : Type*} {v : \u03b9 \u2192 R} (s : Finset \u03b9)", "{F : Type*} [Field F]", "{x y : F}", "{F : Type*} [Field F] {\u03b9 : Type*} [DecidableEq \u03b9]", "{s : Finset \u03b9} {v : \u03b9 \u2192 F} {i j : \u03b9}", "{F : Type*} [Field F] {\u03b9 : Type*} [DecidableEq \u03b9]", "{s t : Finset \u03b9} {i j : \u03b9} {v : \u03b9 \u2192 F} (r r' : \u03b9 \u2192 F)", "{R : Type*} [CommRing R] {\u03b9 : Type*}", "{s : Finset \u03b9} {v : \u03b9 \u2192 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_8\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_10\nnodal : x\u271d\ninst\u271d : Nontrivial R\n\u22a2 sorry \u2260 0"}]}
{"declaration": "lemma preReflection_apply :\n    preReflection x f y = y - (f y) \u2022 x := by\n  simp [preReflection]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Reflection.lean", "context": {"open": ["Function Set", "Module hiding Finite", "Submodule (span)"], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (x : M) (f : Dual R M) (y : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nf : Dual R M\ny : M\n\u22a2 (preReflection x f) y = y - f y \u2022 x"}, {"line": "simp [preReflection]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem map_add_smul_aux [DecidableEq \u03b9] (i : \u03b9) (x : \u03a0 i, s i) (u : s i \u2192\u2097[R] t i) :\n    (fun j \u21a6 update f i u j (x j)) = update (fun j \u21a6 (f j) (x j)) i (u (x i)) := by\n  ext j\n  exact apply_update (fun i F => F (x i)) f i u j\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/PiTensorProduct.lean", "context": {"open": ["Function", "TensorProduct", "MultilinearMap", "Function in"], "variables": ["{\u03b9 \u03b9\u2082 \u03b9\u2083 : Type*}", "{R : Type*} [CommSemiring R]", "{R\u2081 R\u2082 : Type*}", "{s : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (s i)] [\u2200 i, Module R (s i)]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{E : Type*} [AddCommMonoid E] [Module R E]", "{F : Type*} [AddCommMonoid F]", "(R) (s)", "(R) (s)", "{R}", "(R) {s}", "{R}", "[Monoid R\u2081] [DistribMulAction R\u2081 R] [SMulCommClass R\u2081 R R]", "[Monoid R\u2082] [DistribMulAction R\u2082 R] [SMulCommClass R\u2082 R R]", "(R) in", "{s}", "{\u03c6 : MultilinearMap R s E}", "{t t' : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (t i)] [\u2200 i, Module R (t i)]", "[\u2200 i, AddCommMonoid (t' i)] [\u2200 i, Module R (t' i)]", "(g : \u03a0 i, t i \u2192\u2097[R] t' i) (f : \u03a0 i, s i \u2192\u2097[R] t i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\nR : Type u_1\ninst\u271d\u2075 : CommSemiring R\ns : \u03b9 \u2192 Type u_4\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (s i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Module R (s i)\nt : \u03b9 \u2192 Type u_8\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (t i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (t i)\nf : (i : \u03b9) \u2192 s i \u2192\u2097[R] t i\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nx : (i : \u03b9) \u2192 s i\nu : s i \u2192\u2097[R] t i\n\u22a2 (fun j => (update f i u j) (x j)) = update (fun j => (f j) (x j)) i (u (x i))"}, {"line": "ext j", "tactic_state": "case h\n\u03b9 : Type u_10\nR : Type u_1\ninst\u271d\u2075 : CommSemiring R\ns : \u03b9 \u2192 Type u_4\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (s i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Module R (s i)\nt : \u03b9 \u2192 Type u_8\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (t i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (t i)\nf : (i : \u03b9) \u2192 s i \u2192\u2097[R] t i\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nx : (i : \u03b9) \u2192 s i\nu : s i \u2192\u2097[R] t i\nj : \u03b9\n\u22a2 (update f i u j) (x j) = update (fun j => (f j) (x j)) i (u (x i)) j"}, {"line": "exact apply_update (fun i F => F (x i)) f i u j", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tmulEquiv_symm_apply (a : \u03b9 \u2295 \u03b9\u2082 \u2192 M) :\n    (tmulEquiv R M).symm (\u2a02\u209c[R] i, a i) =\n      (\u2a02\u209c[R] i, a (Sum.inl i)) \u2297\u209c[R] \u2a02\u209c[R] i, a (Sum.inr i) := by\n  simp [tmulEquiv]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/PiTensorProduct.lean", "context": {"open": ["Function", "TensorProduct", "MultilinearMap", "Function in", "Function in", "Function in"], "variables": ["{\u03b9 \u03b9\u2082 \u03b9\u2083 : Type*}", "{R : Type*} [CommSemiring R]", "{R\u2081 R\u2082 : Type*}", "{s : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (s i)] [\u2200 i, Module R (s i)]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{E : Type*} [AddCommMonoid E] [Module R E]", "{F : Type*} [AddCommMonoid F]", "(R) (s)", "(R) (s)", "{R}", "(R) {s}", "{R}", "[Monoid R\u2081] [DistribMulAction R\u2081 R] [SMulCommClass R\u2081 R R]", "[Monoid R\u2082] [DistribMulAction R\u2082 R] [SMulCommClass R\u2082 R R]", "(R) in", "{s}", "{\u03c6 : MultilinearMap R s E}", "{t t' : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (t i)] [\u2200 i, Module R (t i)]", "[\u2200 i, AddCommMonoid (t' i)] [\u2200 i, Module R (t' i)]", "(g : \u03a0 i, t i \u2192\u2097[R] t' i) (f : \u03a0 i, s i \u2192\u2097[R] t i)", "(R s t)", "{R s t}", "(R M)", "(s) in", "{t : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (t i)] [\u2200 i, Module R (t i)]", "(\u03b9)", "{\u03b9}", "(R M)", "(N : \u03b9 \u2295 \u03b9\u2082 \u2192 Type*) [\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u2082 : Type u_13\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_12\nx\u271d : Sort u_11\ntmulEquiv : x\u271d\na : \u03b9 \u2295 \u03b9\u2082 \u2192 M\n\u22a2 sorry = ((PiTensorProduct.tprod R) fun i => a (Sum.inl i)) \u2297\u209c[R] (PiTensorProduct.tprod R) fun i => a (Sum.inr i)"}, {"line": "simp [tmulEquiv]", "tactic_state": "\u03b9\u2082 : Type u_13\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_12\nx\u271d : Sort u_11\ntmulEquiv : x\u271d\na : \u03b9 \u2295 \u03b9\u2082 \u2192 M\n\u22a2 sorry () = ((PiTensorProduct.tprod R) fun i => a (Sum.inl i)) \u2297\u209c[R] (PiTensorProduct.tprod R) fun i => a (Sum.inr i)"}]}
{"declaration": "theorem units_smul_of_pos (u : R\u02e3) (hu : 0 < (u : R)) (v : Module.Ray R M) : u \u2022 v = v := by\n  induction v using Module.Ray.ind\n  rw [smul_rayOfNeZero, ray_eq_iff]\n  exact SameRay.sameRay_pos_smul_left _ hu\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nu : R\u02e3\nhu : 0 < \u2191u\nv : Module.Ray R M\n\u22a2 u \u2022 v = v"}, {"line": "induction v using Module.Ray.ind", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nu : R\u02e3\nhu : 0 < \u2191u\nv\u271d : M\nhv\u271d : v\u271d \u2260 0\n\u22a2 u \u2022 rayOfNeZero R v\u271d hv\u271d = rayOfNeZero R v\u271d hv\u271d"}, {"line": "rw [smul_rayOfNeZero, ray_eq_iff]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nu : R\u02e3\nhu : 0 < \u2191u\nv\u271d : M\nhv\u271d : v\u271d \u2260 0\n\u22a2 SameRay R (u \u2022 v\u271d) v\u271d"}, {"line": "exact SameRay.sameRay_pos_smul_left _ hu", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_units_smul (u : R\u02e3) (v : Module.Ray R M) : -u \u2022 v = -(u \u2022 v) := by\n  induction v using Module.Ray.ind\n  simp only [smul_rayOfNeZero, Units.smul_def, Units.val_neg, neg_smul, neg_rayOfNeZero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_8\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 -u \u2022 v = -(u \u2022 v)"}, {"line": "induction v using Module.Ray.ind", "tactic_state": "case h\nR : Type u_7\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_8\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nu : R\u02e3\nv\u271d : M\nhv\u271d : v\u271d \u2260 0\n\u22a2 -u \u2022 rayOfNeZero R v\u271d hv\u271d = -(u \u2022 rayOfNeZero R v\u271d hv\u271d)"}, {"line": "simp only [smul_rayOfNeZero, Units.smul_def, Units.val_neg, neg_smul, neg_rayOfNeZero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_nonneg_left (h : SameRay R x y) (hx : x \u2260 0) : \u2203 r : R, 0 \u2264 r \u2227 r \u2022 x = y := by\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 exact \u27e80, le_rfl, zero_smul _ _\u27e9\n  \u00b7 exact (h.exists_pos_left hx hy).imp fun _ => And.imp_left le_of_lt\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "[NoZeroSMulDivisors R M]", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y v\u2081 v\u2082 : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nh : SameRay R x y\nhx : x \u2260 0\n\u22a2 \u2203 r, 0 \u2264 r \u2227 r \u2022 x = y"}, {"line": "obtain rfl | hy := eq_or_ne y 0", "tactic_state": "case inl\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nhx : x \u2260 0\nh : SameRay R x sorry\n\u22a2 \u2203 r, 0 \u2264 r \u2227 r \u2022 x = sorry\n---\ncase inr\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nh : SameRay R x y\nhx : x \u2260 0\nhy : y \u2260 sorry\n\u22a2 \u2203 r, 0 \u2264 r \u2227 r \u2022 x = y"}, {"line": "\u00b7 exact \u27e80, le_rfl, zero_smul _ _\u27e9", "tactic_state": "case inr\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nh : SameRay R x y\nhx : x \u2260 0\nhy : y \u2260 sorry\n\u22a2 \u2203 r, 0 \u2264 r \u2227 r \u2022 x = y"}, {"line": "\u00b7 exact (h.exists_pos_left hx hy).imp fun _ => And.imp_left le_of_lt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lsum_single [Semiring S] [Module S N] [SMulCommClass R S N] (F : \u2200 i, M i \u2192\u2097[R] N) (i)\n    (x : M i) : lsum S F (single i x) = F i x := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DFinsupp.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {R : Type*} {S : Type*} {M : \u03b9 \u2192 Type*} {N : Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "[AddCommMonoid N] [Module R N]", "[DecidableEq \u03b9]", "(S)", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\nM : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\nx\u271d : Sort u_6\nlsum : x\u271d\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S N\ninst\u271d : SMulCommClass R S N\nF : (i : \u03b9) \u2192 M i \u2192\u2097[R] N\ni : \u03b9\nx : M i\n\u22a2 sorry = (F i) x"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\nM : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\nx\u271d : Sort u_6\nlsum : x\u271d\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S N\ninst\u271d : SMulCommClass R S N\nF : (i : \u03b9) \u2192 M i \u2192\u2097[R] N\ni : \u03b9\nx : M i\n\u22a2 sorry () = (F i) x"}]}
{"declaration": "theorem sum_mapRange_index.linearMap [DecidableEq \u03b9] {f : \u2200 i, \u03b2\u2081 i \u2192\u2097[R] \u03b2\u2082 i}\n    {h : \u2200 i, \u03b2\u2082 i \u2192\u2097[R] N} {l : \u03a0\u2080 i, \u03b2\u2081 i} :\n    DFinsupp.lsum \u2115 h (mapRange.linearMap f l) = DFinsupp.lsum \u2115 (fun i => (h i).comp (f i)) l := by\n  classical simpa [DFinsupp.sumAddHom_apply] using sum_mapRange_index fun i => by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DFinsupp.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {R : Type*} {S : Type*} {M : \u03b9 \u2192 Type*} {N : Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "[AddCommMonoid N] [Module R N]", "[DecidableEq \u03b9]", "(S)", "[DecidableEq \u03b9]", "{\u03b2 \u03b2\u2081 \u03b2\u2082 : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 i, AddCommMonoid (\u03b2\u2081 i)] [\u2200 i, AddCommMonoid (\u03b2\u2082 i)]", "[\u2200 i, Module R (\u03b2 i)] [\u2200 i, Module R (\u03b2\u2081 i)] [\u2200 i, Module R (\u03b2\u2082 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nN : Type u_5\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid N\ninst\u271d\u2077 : Module R N\ninst\u271d\u2076 inst\u271d\u2075 : DecidableEq \u03b9\n\u03b2\u2081 : \u03b9 \u2192 Type u_7\n\u03b2\u2082 : \u03b9 \u2192 Type u_8\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (\u03b2\u2081 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03b2\u2082 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03b2\u2081 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03b2\u2082 i)\ninst\u271d : DecidableEq \u03b9\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192\u2097[R] \u03b2\u2082 i\nh : (i : \u03b9) \u2192 \u03b2\u2082 i \u2192\u2097[R] N\nl : \u03a0\u2080 (i : \u03b9), \u03b2\u2081 i\n\u22a2 ((DFinsupp.lsum \u2115) h) sorry = ((DFinsupp.lsum \u2115) fun i => h i \u2218\u2097 f i) l"}, {"line": "classical simpa [DFinsupp.sumAddHom_apply] using sum_mapRange_index fun i => by simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprodMap_apply_single (f : \u2200 i : \u03b9, M i \u2192\u2097[R] N) (i : \u03b9) (x : M i) :\n    coprodMap f (single i x) = f i x := by\n  simp [coprodMap]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DFinsupp.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {R : Type*} {S : Type*} {M : \u03b9 \u2192 Type*} {N : Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "[AddCommMonoid N] [Module R N]", "[DecidableEq \u03b9]", "(S)", "[DecidableEq \u03b9]", "{\u03b2 \u03b2\u2081 \u03b2\u2082 : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 i, AddCommMonoid (\u03b2\u2081 i)] [\u2200 i, AddCommMonoid (\u03b2\u2082 i)]", "[\u2200 i, Module R (\u03b2 i)] [\u2200 i, Module R (\u03b2\u2081 i)] [\u2200 i, Module R (\u03b2\u2082 i)]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_9\ncoprodMap : x\u271d\nf : (i : \u03b9) \u2192 M i \u2192\u2097[R] N\ni : \u03b9\nx : M i\n\u22a2 sorry = (f i) x"}, {"line": "simp [coprodMap]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_9\ncoprodMap : x\u271d\nf : (i : \u03b9) \u2192 M i \u2192\u2097[R] N\ni : \u03b9\nx : M i\n\u22a2 sorry () = (f i) x"}]}
{"declaration": "lemma vandermonde_eq_projVandermonde (v : Fin n \u2192 R) : vandermonde v = projVandermonde v 1 := by\n  simp [projVandermonde]\n  simp [rectVandermonde]\n  simp [vandermonde]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 vandermonde v = projVandermonde v 1"}, {"line": "simp [projVandermonde]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 vandermonde v = rectVandermonde v 1 n"}, {"line": "simp [rectVandermonde]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 vandermonde v = of fun i j => v i ^ \u2191j * 1 ^ (n - (\u2191j + 1))"}, {"line": "simp [vandermonde]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 (fun i j => v i ^ \u2191j) = fun i j => v i ^ \u2191j * 1 ^ (n - (\u2191j + 1))"}]}
{"declaration": "theorem vandermonde_cons (v0 : R) (v : Fin n \u2192 R) :\n    vandermonde (Fin.cons v0 v : Fin n.succ \u2192 R) =\n      Fin.cons (fun (j : Fin n.succ) => v0 ^ (j : \u2115)) fun i => Fin.cons 1\n      fun j => v i * vandermonde v i j := by\n  ext i j\n  refine Fin.cases (by simp) (fun i => ?_) i\n  refine Fin.cases (by simp) (fun j => ?_) j\n  simp [pow_succ']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv0 : R\nv : Fin n \u2192 R\n\u22a2 vandermonde (Fin.cons v0 v) = Fin.cons (fun j => v0 ^ \u2191j) fun i => Fin.cons 1 fun j => v i * vandermonde v i j"}, {"line": "ext i j", "tactic_state": "case a\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv0 : R\nv : Fin n \u2192 R\ni j : Fin (n + 1)\n\u22a2 vandermonde (Fin.cons v0 v) i j =\n    Fin.cons (fun j => v0 ^ \u2191j) (fun i => Fin.cons 1 fun j => v i * vandermonde v i j) i j"}, {"line": "refine Fin.cases (by simp) (fun i => ?_) i", "tactic_state": "case a\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv0 : R\nv : Fin n \u2192 R\ni\u271d j : Fin (n + 1)\ni : Fin n\n\u22a2 vandermonde (Fin.cons v0 v) i.succ j =\n    Fin.cons (fun j => v0 ^ \u2191j) (fun i => Fin.cons 1 fun j => v i * vandermonde v i j) i.succ j"}, {"line": "refine Fin.cases (by simp) (fun j => ?_) j", "tactic_state": "case a\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv0 : R\nv : Fin n \u2192 R\ni\u271d j\u271d : Fin (n + 1)\ni j : Fin n\n\u22a2 vandermonde (Fin.cons v0 v) i.succ j.succ =\n    Fin.cons (fun j => v0 ^ \u2191j) (fun i => Fin.cons 1 fun j => v i * vandermonde v i j) i.succ j.succ"}, {"line": "simp [pow_succ']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vandermonde_succ (v : Fin n.succ \u2192 R) :\n    vandermonde v = .of\n      Fin.cons (fun (j : Fin n.succ) => v 0 ^ (j : \u2115)) fun i =>\n        Fin.cons 1 fun j => v i.succ * vandermonde (Fin.tail v) i j := by\n  conv_lhs => rw [\u2190 Fin.cons_self_tail v, vandermonde_cons]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n.succ \u2192 R\n\u22a2 vandermonde v = of Fin.cons (fun j => v 0 ^ \u2191j) fun i => Fin.cons 1 fun j => v i.succ * vandermonde (tail v) i j"}, {"line": "conv_lhs => rw [\u2190 Fin.cons_self_tail v, vandermonde_cons]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n.succ \u2192 R\n\u22a2 (Fin.cons (fun j => v 0 ^ \u2191j) fun i => Fin.cons 1 fun j => tail v i * vandermonde (tail v) i j) =\n    of Fin.cons (fun j => v 0 ^ \u2191j) fun i => Fin.cons 1 fun j => v i.succ * vandermonde (tail v) i j"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vandermonde_mul_vandermonde_transpose (v w : Fin n \u2192 R) (i j) :\n    (vandermonde v * (vandermonde w)\u1d40) i j = \u2211 k : Fin n, (v i * w j) ^ (k : \u2115) := by\n  simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, mul_pow]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv w : Fin n \u2192 R\ni j : Fin n\n\u22a2 (vandermonde v * (vandermonde w).transpose) i j = \u2211 k, (v i * w j) ^ \u2191k"}, {"line": "simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, mul_pow]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv w : Fin n \u2192 R\ni j : Fin n\n\u22a2 \u2211 x, v i ^ \u2191x * w j ^ \u2191x = \u2211 k, (v i * w j) ^ \u2191k"}]}
{"declaration": "theorem vandermonde_transpose_mul_vandermonde (v : Fin n \u2192 R) (i j) :\n    ((vandermonde v)\u1d40 * vandermonde v) i j = \u2211 k : Fin n, v k ^ (i + j : \u2115) := by\n  simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, pow_add]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\ni j : Fin n\n\u22a2 ((vandermonde v).transpose * vandermonde v) i j = \u2211 k, v k ^ (\u2191i + \u2191j)"}, {"line": "simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, pow_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem projVandermonde_map {R' : Type*} [CommRing R'] (\u03c6 : R \u2192+* R') (v w : Fin n \u2192 R) :\n    projVandermonde (fun i \u21a6 \u03c6 (v i)) (fun i \u21a6 \u03c6 (w i)) = \u03c6.mapMatrix (projVandermonde v w) := by\n  ext i j\n  simp [projVandermonde_apply]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\nR' : Type u_3\ninst\u271d : CommRing R'\n\u03c6 : R \u2192+* R'\nv w : Fin n \u2192 R\n\u22a2 (projVandermonde (fun i => \u03c6 (v i)) fun i => \u03c6 (w i)) = \u03c6.mapMatrix (projVandermonde v w)"}, {"line": "ext i j", "tactic_state": "case a\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\nR' : Type u_3\ninst\u271d : CommRing R'\n\u03c6 : R \u2192+* R'\nv w : Fin n \u2192 R\ni j : Fin n\n\u22a2 projVandermonde (fun i => \u03c6 (v i)) (fun i => \u03c6 (w i)) i j = \u03c6.mapMatrix (projVandermonde v w) i j"}, {"line": "simp [projVandermonde_apply]", "tactic_state": "case a\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\nR' : Type u_3\ninst\u271d : CommRing R'\n\u03c6 : R \u2192+* R'\nv w : Fin n \u2192 R\ni j : Fin n\n\u22a2 \u03c6 (v i) ^ \u2191j * \u03c6 (w i) ^ (n - (\u2191j + 1)) = \u03c6 (v i ^ \u2191j) * \u03c6 (w i ^ (n - (\u2191j + 1)))"}]}
{"declaration": "theorem det_vandermonde (v : Fin n \u2192 R) :\n    det (vandermonde v) = \u220f i : Fin n, \u220f j \u2208 Ioi i, (v j - v i) := by\n  simp [vandermonde_eq_projVandermonde]\n  simp [det_projVandermonde]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 (vandermonde v).det = \u220f i, \u220f j \u2208 Ioi i, (v j - v i)"}, {"line": "simp [vandermonde_eq_projVandermonde]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 (projVandermonde v 1).det = \u220f i, \u220f j \u2208 Ioi i, (v j - v i)"}, {"line": "simp [det_projVandermonde]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 \u220f x, \u220f x_1 \u2208 Ioi x, (v x_1 * 1 - v x * 1) = \u220f i, \u220f j \u2208 Ioi i, (v j - v i)"}]}
{"declaration": "theorem det_vandermonde_ne_zero_iff [IsDomain R] {v : Fin n \u2192 R} :\n    det (vandermonde v) \u2260 0 \u2194 Function.Injective v := by\n  unfold Function.Injective\n  simp only [det_vandermonde_eq_zero_iff, Ne, not_exists, not_and, Classical.not_not]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : IsDomain R\nv : Fin n \u2192 R\n\u22a2 (vandermonde v).det \u2260 0 \u2194 Function.Injective v"}, {"line": "unfold Function.Injective", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : IsDomain R\nv : Fin n \u2192 R\n\u22a2 (vandermonde v).det \u2260 0 \u2194 \u2200 \u2983a\u2081 a\u2082 : Fin n\u2984, v a\u2081 = v a\u2082 \u2192 a\u2081 = a\u2082"}, {"line": "simp only [det_vandermonde_eq_zero_iff, Ne, not_exists, not_and, Classical.not_not]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : IsDomain R\nv : Fin n \u2192 R\n\u22a2 \u00ac(vandermonde v).det = 0 \u2194 \u2200 \u2983a\u2081 a\u2082 : Fin n\u2984, v a\u2081 = v a\u2082 \u2192 a\u2081 = a\u2082"}]}
{"declaration": "theorem det_vandermonde_add (v : Fin n \u2192 R) (a : R) :\n    (Matrix.vandermonde fun i \u21a6 v i + a).det = (Matrix.vandermonde v).det := by\n  simp [Matrix.det_vandermonde]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\na : R\n\u22a2 (vandermonde fun i => v i + a).det = (vandermonde v).det"}, {"line": "simp [Matrix.det_vandermonde]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iff {A : Matrix (l \u2295 l) (l \u2295 l) R} :\n    A \u2208 symplecticGroup l R \u2194 A * J l R * A\u1d40 = J l R := by simp [symplecticGroup]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SymplecticGroup.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l R : Type*}", "(l) [DecidableEq l] (R) [CommRing R]", "[Fintype l]", "[Fintype l]", "[DecidableEq l] [Fintype l] [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nR : Type u_2\ninst\u271d\u2076 : DecidableEq l\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 inst\u271d\u00b3 : Fintype l\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : Fintype l\ninst\u271d : CommRing R\nA : Matrix (l \u2295 l) (l \u2295 l) R\n\u22a2 A \u2208 symplecticGroup l R \u2194 A * J l R * A.transpose = J l R"}, {"line": "simp [symplecticGroup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_graph_snd_inj' (f : E \u2192\u2097.[R] F) {x y : E \u00d7 F} (hx : x \u2208 f.graph) (hy : y \u2208 f.graph)\n    (hxy : x.1 = y.1) : x.2 = y.2 := by\n  cases x\n  cases y\n  exact f.mem_graph_snd_inj hx hy hxy\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearPMap.lean", "context": {"open": ["Submodule"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E] {F : Type*}", "{M N : Type*} [Monoid M] [DistribMulAction M F] [SMulCommClass R M F]", "[Monoid N] [DistribMulAction N F] [SMulCommClass R N F]", "{K : Type*} [DivisionRing K] [Module K E] [Module K F]", "{M : Type*} [Monoid M] [DistribMulAction M F] [SMulCommClass R M F] (y : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : AddCommGroup E\nF : Type u_3\nf : sorry\nx y : E \u00d7 F\nhx : x \u2208 sorry\nhy : y \u2208 sorry\nhxy : x.1 = y.1\n\u22a2 x.2 = y.2"}, {"line": "cases x", "tactic_state": "case mk\nE : Type u_2\ninst\u271d : AddCommGroup E\nF : Type u_3\nf : sorry\ny : E \u00d7 F\nfst\u271d : E\nsnd\u271d : F\nhx : (fst\u271d, snd\u271d) \u2208 sorry\nhy : y \u2208 sorry\nhxy : (fst\u271d, snd\u271d).1 = y.1\n\u22a2 (fst\u271d, snd\u271d).2 = y.2"}, {"line": "cases y", "tactic_state": "case mk.mk\nE : Type u_2\ninst\u271d : AddCommGroup E\nF : Type u_3\nf : sorry\nfst\u271d\u00b9 : E\nsnd\u271d\u00b9 : F\nfst\u271d : E\nsnd\u271d : F\nhx : (fst\u271d\u00b9, snd\u271d\u00b9) \u2208 sorry\nhy : (fst\u271d, snd\u271d) \u2208 sorry\nhxy : (fst\u271d\u00b9, snd\u271d\u00b9).1 = (fst\u271d, snd\u271d).1\n\u22a2 (fst\u271d\u00b9, snd\u271d\u00b9).2 = (fst\u271d, snd\u271d).2"}, {"line": "exact f.mem_graph_snd_inj hx hy hxy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem detAux_def' (b : Basis \u03b9 A M) (f : M \u2192\u2097[A] M) :\n    LinearMap.detAux (Trunc.mk b) f = Matrix.det (LinearMap.toMatrix b b f) := by\n  rw [detAux]\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d\u2074 : AddCommGroup M\n\u03b9 : Type u_4\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : Fintype \u03b9\nA : Type u_8\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Module A M\nb : Basis \u03b9 A M\nf : M \u2192\u2097[A] M\n\u22a2 (detAux (Trunc.mk b)) f = ((toMatrix b b) f).det"}, {"line": "rw [detAux]", "tactic_state": "M : Type u_2\ninst\u271d\u2074 : AddCommGroup M\n\u03b9 : Type u_4\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : Fintype \u03b9\nA : Type u_8\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Module A M\nb : Basis \u03b9 A M\nf : M \u2192\u2097[A] M\n\u22a2 (Trunc.lift (fun b => detMonoidHom.comp \u2191(toMatrixAlgEquiv b)) \u22ef (Trunc.mk b)) f = ((toMatrix b b) f).det"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_toMatrix' {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (f : (\u03b9 \u2192 A) \u2192\u2097[A] \u03b9 \u2192 A) :\n    Matrix.det (LinearMap.toMatrix' f) = LinearMap.det f := by simp [\u2190 toMatrix_eq_toMatrix']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function", "scoped Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\n\u03b9 : Type u_6\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (\u03b9 \u2192 A) \u2192\u2097[A] \u03b9 \u2192 A\n\u22a2 (toMatrix' f).det = LinearMap.det f"}, {"line": "simp [\u2190 toMatrix_eq_toMatrix']", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\n\u03b9 : Type u_6\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (\u03b9 \u2192 A) \u2192\u2097[A] \u03b9 \u2192 A\n\u22a2 ((toMatrix (Pi.basisFun A \u03b9) (Pi.basisFun A \u03b9)) f).det = LinearMap.det f"}]}
{"declaration": "lemma det_mulLeft (a : R) : (mulLeft R a).det = a := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function", "scoped Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\na : R\n\u22a2 sorry = a"}, {"line": "simp", "tactic_state": "R : Type u_6\na : R\n\u22a2 sorry () = a"}]}
{"declaration": "lemma det_mulRight (a : R) : (mulRight R a).det = a := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function", "scoped Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\na : R\n\u22a2 sorry = a"}, {"line": "simp", "tactic_state": "R : Type u_6\na : R\n\u22a2 sorry () = a"}]}
{"declaration": "theorem bot : x \u2261 y [SMOD (\u22a5 : Submodule R M)] \u2194 x = y := by\n  rw [SModEq.def, Submodule.Quotient.eq, mem_bot, sub_eq_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\n\u22a2 x \u2261 y [SMOD \u22a5] \u2194 x = y"}, {"line": "rw [SModEq.def, Submodule.Quotient.eq, mem_bot, sub_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add (hxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD U]) (hxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD U]) : x\u2081 + x\u2082 \u2261 y\u2081 + y\u2082 [SMOD U] := by\n  rw [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2\n  simp_rw [Quotient.mk_add, hxy\u2081, hxy\u2082]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx\u2081 x\u2082 y\u2081 y\u2082 : M\nhxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD U]\nhxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD U]\n\u22a2 x\u2081 + x\u2082 \u2261 y\u2081 + y\u2082 [SMOD U]"}, {"line": "rw [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx\u2081 x\u2082 y\u2081 y\u2082 : M\nhxy\u2081 : Submodule.Quotient.mk x\u2081 = Submodule.Quotient.mk y\u2081\nhxy\u2082 : Submodule.Quotient.mk x\u2082 = Submodule.Quotient.mk y\u2082\n\u22a2 Submodule.Quotient.mk (x\u2081 + x\u2082) = Submodule.Quotient.mk (y\u2081 + y\u2082)"}, {"line": "simp_rw [Quotient.mk_add, hxy\u2081, hxy\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul {I : Ideal A} {x\u2081 x\u2082 y\u2081 y\u2082 : A} (hxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD I])\n    (hxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD I]) : x\u2081 * x\u2082 \u2261 y\u2081 * y\u2082 [SMOD I] := by\n  simp only [SModEq.def, Ideal.Quotient.mk_eq_mk, map_mul] at hxy\u2081 hxy\u2082 \u22a2\n  rw [hxy\u2081, hxy\u2082]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d : CommRing A\nI : Ideal A\nx\u2081 x\u2082 y\u2081 y\u2082 : A\nhxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD I]\nhxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD I]\n\u22a2 x\u2081 * x\u2082 \u2261 y\u2081 * y\u2082 [SMOD I]"}, {"line": "simp only [SModEq.def, Ideal.Quotient.mk_eq_mk, map_mul] at hxy\u2081 hxy\u2082 \u22a2", "tactic_state": "A : Type u_2\ninst\u271d : CommRing A\nI : Ideal A\nx\u2081 x\u2082 y\u2081 y\u2082 : A\nhxy\u2081 : (Ideal.Quotient.mk I) x\u2081 = (Ideal.Quotient.mk I) y\u2081\nhxy\u2082 : (Ideal.Quotient.mk I) x\u2082 = (Ideal.Quotient.mk I) y\u2082\n\u22a2 (Ideal.Quotient.mk I) x\u2081 * (Ideal.Quotient.mk I) x\u2082 = (Ideal.Quotient.mk I) y\u2081 * (Ideal.Quotient.mk I) y\u2082"}, {"line": "rw [hxy\u2081, hxy\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg (hxy : x \u2261 y [SMOD U]) : - x \u2261 - y [SMOD U] := by\n  simpa only [SModEq.def, Quotient.mk_neg, neg_inj]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx y : M\nhxy : x \u2261 y [SMOD U]\n\u22a2 -x \u2261 -y [SMOD U]"}, {"line": "simpa only [SModEq.def, Quotient.mk_neg, neg_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub (hxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD U]) (hxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD U]) : x\u2081 - x\u2082 \u2261 y\u2081 - y\u2082 [SMOD U] := by\n  rw [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2\n  simp_rw [Quotient.mk_sub, hxy\u2081, hxy\u2082]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx\u2081 x\u2082 y\u2081 y\u2082 : M\nhxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD U]\nhxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD U]\n\u22a2 x\u2081 - x\u2082 \u2261 y\u2081 - y\u2082 [SMOD U]"}, {"line": "rw [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx\u2081 x\u2082 y\u2081 y\u2082 : M\nhxy\u2081 : Submodule.Quotient.mk x\u2081 = Submodule.Quotient.mk y\u2081\nhxy\u2082 : Submodule.Quotient.mk x\u2082 = Submodule.Quotient.mk y\u2082\n\u22a2 Submodule.Quotient.mk (x\u2081 - x\u2082) = Submodule.Quotient.mk (y\u2081 - y\u2082)"}, {"line": "simp_rw [Quotient.mk_sub, hxy\u2081, hxy\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero : x \u2261 0 [SMOD U] \u2194 x \u2208 U := by rw [SModEq.def, Submodule.Quotient.eq, sub_zero]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx : M\n\u22a2 x \u2261 0 [SMOD U] \u2194 x \u2208 U"}, {"line": "rw [SModEq.def, Submodule.Quotient.eq, sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_comap_single_pi [DecidableEq \u03b9] (p : (i : \u03b9) \u2192 Submodule R (\u03c6 i)) {I i} :\n    p i \u2264 Submodule.comap (LinearMap.single R \u03c6 i : \u03c6 i \u2192\u2097[R] _) (Submodule.pi I p) := by\n  intro x hx\n  rw [Submodule.mem_comap, Submodule.mem_pi]\n  rintro j -\n  rcases eq_or_ne j i with rfl | hne <;> simp [*]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Pi.lean", "context": {"open": ["Function Submodule", "LinearMap"], "variables": ["{R : Type u} {K : Type u'} {M : Type v} {V : Type v'} {M\u2082 : Type w} {V\u2082 : Type w'}", "{M\u2083 : Type y} {V\u2083 : Type y'} {M\u2084 : Type z} {\u03b9 : Type x} {\u03b9' : Type x'}", "[Semiring R] [AddCommMonoid M\u2082] [Module R M\u2082] [AddCommMonoid M\u2083] [Module R M\u2083]", "(R \u03c6)", "[DecidableEq \u03b9]", "{R \u03c6}", "[Finite \u03b9] [AddCommMonoid M] [Module R M] {f g : ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] M}", "(R \u03c6)", "(R \u03c6)", "[Semiring R] {\u03c6 : \u03b9 \u2192 Type*} [(i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)] [(i : \u03b9) \u2192 Module R (\u03c6 i)]", "{I : Set \u03b9} {p q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)} {x : (i : \u03b9) \u2192 \u03c6 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type x\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nI : Set \u03b9\ni : \u03b9\n\u22a2 p i \u2264 comap (single R \u03c6 i) (Submodule.pi I p)"}, {"line": "intro x hx", "tactic_state": "R : Type u\n\u03b9 : Type x\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nI : Set \u03b9\ni : \u03b9\nx : \u03c6 i\nhx : x \u2208 p i\n\u22a2 x \u2208 comap (single R \u03c6 i) (Submodule.pi I p)"}, {"line": "rw [Submodule.mem_comap, Submodule.mem_pi]", "tactic_state": "R : Type u\n\u03b9 : Type x\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nI : Set \u03b9\ni : \u03b9\nx : \u03c6 i\nhx : x \u2208 p i\n\u22a2 \u2200 i_1 \u2208 I, (single R \u03c6 i) x i_1 \u2208 p i_1"}, {"line": "rintro j -", "tactic_state": "R : Type u\n\u03b9 : Type x\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nI : Set \u03b9\ni : \u03b9\nx : \u03c6 i\nhx : x \u2208 p i\nj : \u03b9\n\u22a2 (single R \u03c6 i) x j \u2208 p j"}, {"line": "rcases eq_or_ne j i with rfl | hne <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem basisFun_repr (x : \u03b7 \u2192 R) (i : \u03b7) : (Pi.basisFun R \u03b7).repr x i = x i := by simp [basisFun]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/StdBasis.lean", "context": {"open": ["Function Set Submodule", "LinearMap", "Set", "LinearEquiv"], "variables": ["{R : Type*}", "{\u03b7 : Type*} {\u03b9s : \u03b7 \u2192 Type*} {Ms : \u03b7 \u2192 Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (Ms i)] [\u2200 i, Module R (Ms i)]", "[Fintype \u03b7]", "[Finite \u03b7]", "(R \u03b7)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b7 : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Fintype \u03b7\ninst\u271d : Finite \u03b7\nx : \u03b7 \u2192 R\ni : \u03b7\n\u22a2 ((Pi.basisFun R \u03b7).repr x) i = x i"}, {"line": "simp [basisFun]", "tactic_state": "No Goals!"}]}
