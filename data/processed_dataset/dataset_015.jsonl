{"declaration": "theorem le_comap_single_pi [DecidableEq \u03b9] (p : (i : \u03b9) \u2192 Submodule R (\u03c6 i)) {I i} :\n    p i \u2264 Submodule.comap (LinearMap.single R \u03c6 i : \u03c6 i \u2192\u2097[R] _) (Submodule.pi I p) := by\n  intro x hx\n  rw [Submodule.mem_comap]\n  rw [Submodule.mem_pi]\n  rintro j -\n  rcases eq_or_ne j i with rfl | hne <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Pi.lean", "context": {"open": ["Function Submodule", "LinearMap"], "variables": ["{R : Type u} {K : Type u'} {M : Type v} {V : Type v'} {M\u2082 : Type w} {V\u2082 : Type w'}", "{M\u2083 : Type y} {V\u2083 : Type y'} {M\u2084 : Type z} {\u03b9 : Type x} {\u03b9' : Type x'}", "[Semiring R] [AddCommMonoid M\u2082] [Module R M\u2082] [AddCommMonoid M\u2083] [Module R M\u2083]", "(R \u03c6)", "[DecidableEq \u03b9]", "{R \u03c6}", "[Finite \u03b9] [AddCommMonoid M] [Module R M] {f g : ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] M}", "(R \u03c6)", "(R \u03c6)", "[Semiring R] {\u03c6 : \u03b9 \u2192 Type*} [(i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)] [(i : \u03b9) \u2192 Module R (\u03c6 i)]", "{I : Set \u03b9} {p q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)} {x : (i : \u03b9) \u2192 \u03c6 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type x\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nI : Set \u03b9\ni : \u03b9\n\u22a2 p i \u2264 comap (single R \u03c6 i) (Submodule.pi I p)"}, {"line": "intro x hx", "tactic_state": "R : Type u\n\u03b9 : Type x\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nI : Set \u03b9\ni : \u03b9\nx : \u03c6 i\nhx : x \u2208 p i\n\u22a2 x \u2208 comap (single R \u03c6 i) (Submodule.pi I p)"}, {"line": "rw [Submodule.mem_comap]", "tactic_state": "R : Type u\n\u03b9 : Type x\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nI : Set \u03b9\ni : \u03b9\nx : \u03c6 i\nhx : x \u2208 p i\n\u22a2 (single R \u03c6 i) x \u2208 Submodule.pi I p"}, {"line": "rw [Submodule.mem_pi]", "tactic_state": "R : Type u\n\u03b9 : Type x\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nI : Set \u03b9\ni : \u03b9\nx : \u03c6 i\nhx : x \u2208 p i\n\u22a2 \u2200 i_1 \u2208 I, (single R \u03c6 i) x i_1 \u2208 p i_1"}, {"line": "rintro j -", "tactic_state": "R : Type u\n\u03b9 : Type x\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nI : Set \u03b9\ni : \u03b9\nx : \u03c6 i\nhx : x \u2208 p i\nj : \u03b9\n\u22a2 (single R \u03c6 i) x j \u2208 p j"}, {"line": "rcases eq_or_ne j i with rfl | hne <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem map_add_smul_aux [DecidableEq \u03b9] (i : \u03b9) (x : \u03a0 i, s i) (u : s i \u2192\u2097[R] t i) :\n    (fun j \u21a6 update f i u j (x j)) = update (fun j \u21a6 (f j) (x j)) i (u (x i)) := by\n  ext j\n  exact apply_update (fun i F => F (x i)) f i u j\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/PiTensorProduct.lean", "context": {"open": ["Function", "TensorProduct", "MultilinearMap", "Function in"], "variables": ["{\u03b9 \u03b9\u2082 \u03b9\u2083 : Type*}", "{R : Type*} [CommSemiring R]", "{R\u2081 R\u2082 : Type*}", "{s : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (s i)] [\u2200 i, Module R (s i)]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{E : Type*} [AddCommMonoid E] [Module R E]", "{F : Type*} [AddCommMonoid F]", "(R) (s)", "(R) (s)", "{R}", "(R) {s}", "{R}", "[Monoid R\u2081] [DistribMulAction R\u2081 R] [SMulCommClass R\u2081 R R]", "[Monoid R\u2082] [DistribMulAction R\u2082 R] [SMulCommClass R\u2082 R R]", "(R) in", "{s}", "{\u03c6 : MultilinearMap R s E}", "{t t' : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (t i)] [\u2200 i, Module R (t i)]", "[\u2200 i, AddCommMonoid (t' i)] [\u2200 i, Module R (t' i)]", "(g : \u03a0 i, t i \u2192\u2097[R] t' i) (f : \u03a0 i, s i \u2192\u2097[R] t i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\nR : Type u_1\ninst\u271d\u2075 : CommSemiring R\ns : \u03b9 \u2192 Type u_4\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (s i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Module R (s i)\nt : \u03b9 \u2192 Type u_8\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (t i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (t i)\nf : (i : \u03b9) \u2192 s i \u2192\u2097[R] t i\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nx : (i : \u03b9) \u2192 s i\nu : s i \u2192\u2097[R] t i\n\u22a2 (fun j => (update f i u j) (x j)) = update (fun j => (f j) (x j)) i (u (x i))"}, {"line": "ext j", "tactic_state": "case h\n\u03b9 : Type u_10\nR : Type u_1\ninst\u271d\u2075 : CommSemiring R\ns : \u03b9 \u2192 Type u_4\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (s i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Module R (s i)\nt : \u03b9 \u2192 Type u_8\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (t i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (t i)\nf : (i : \u03b9) \u2192 s i \u2192\u2097[R] t i\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nx : (i : \u03b9) \u2192 s i\nu : s i \u2192\u2097[R] t i\nj : \u03b9\n\u22a2 (update f i u j) (x j) = update (fun j => (f j) (x j)) i (u (x i)) j"}, {"line": "exact apply_update (fun i F => F (x i)) f i u j", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tmulEquiv_symm_apply (a : \u03b9 \u2295 \u03b9\u2082 \u2192 M) :\n    (tmulEquiv R M).symm (\u2a02\u209c[R] i, a i) =\n      (\u2a02\u209c[R] i, a (Sum.inl i)) \u2297\u209c[R] \u2a02\u209c[R] i, a (Sum.inr i) := by\n  simp [tmulEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/PiTensorProduct.lean", "context": {"open": ["Function", "TensorProduct", "MultilinearMap", "Function in", "Function in", "Function in"], "variables": ["{\u03b9 \u03b9\u2082 \u03b9\u2083 : Type*}", "{R : Type*} [CommSemiring R]", "{R\u2081 R\u2082 : Type*}", "{s : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (s i)] [\u2200 i, Module R (s i)]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{E : Type*} [AddCommMonoid E] [Module R E]", "{F : Type*} [AddCommMonoid F]", "(R) (s)", "(R) (s)", "{R}", "(R) {s}", "{R}", "[Monoid R\u2081] [DistribMulAction R\u2081 R] [SMulCommClass R\u2081 R R]", "[Monoid R\u2082] [DistribMulAction R\u2082 R] [SMulCommClass R\u2082 R R]", "(R) in", "{s}", "{\u03c6 : MultilinearMap R s E}", "{t t' : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (t i)] [\u2200 i, Module R (t i)]", "[\u2200 i, AddCommMonoid (t' i)] [\u2200 i, Module R (t' i)]", "(g : \u03a0 i, t i \u2192\u2097[R] t' i) (f : \u03a0 i, s i \u2192\u2097[R] t i)", "(R s t)", "{R s t}", "(R M)", "(s) in", "{t : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (t i)] [\u2200 i, Module R (t i)]", "(\u03b9)", "{\u03b9}", "(R M)", "(N : \u03b9 \u2295 \u03b9\u2082 \u2192 Type*) [\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u2082 : Type u_13\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_12\nx\u271d : Sort u_11\ntmulEquiv : x\u271d\na : \u03b9 \u2295 \u03b9\u2082 \u2192 M\n\u22a2 sorry = ((PiTensorProduct.tprod R) fun i => a (Sum.inl i)) \u2297\u209c[R] (PiTensorProduct.tprod R) fun i => a (Sum.inr i)"}, {"line": "simp [tmulEquiv]", "tactic_state": "\u03b9\u2082 : Type u_13\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_12\nx\u271d : Sort u_11\ntmulEquiv : x\u271d\na : \u03b9 \u2295 \u03b9\u2082 \u2192 M\n\u22a2 sorry () = ((PiTensorProduct.tprod R) fun i => a (Sum.inl i)) \u2297\u209c[R] (PiTensorProduct.tprod R) fun i => a (Sum.inr i)"}]}
{"declaration": "theorem disjoint_inl_inr : Disjoint (range <| inl R M M\u2082) (range <| inr R M M\u2082) := by\n  simp +contextual [disjoint_def, @eq_comm M 0, @eq_comm M\u2082 0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Prod.lean", "context": {"open": ["Submodule"], "variables": ["{R : Type u} {K : Type u'} {M : Type v} {V : Type v'} {M\u2082 : Type w} {V\u2082 : Type w'}", "{M\u2083 : Type y} {V\u2083 : Type y'} {M\u2084 : Type z} {\u03b9 : Type x}", "{M\u2085 M\u2086 : Type*}", "(S : Type*) [Semiring R] [Semiring S]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083] [AddCommMonoid M\u2084]", "[AddCommMonoid M\u2085] [AddCommMonoid M\u2086]", "[Module R M] [Module R M\u2082] [Module R M\u2083] [Module R M\u2084]", "[Module R M\u2085] [Module R M\u2086]", "(f : M \u2192\u2097[R] M\u2082)", "(R M M\u2082)", "(R M M\u2082)", "(R M M\u2082 M\u2083 M\u2084)", "{R M M\u2082 M\u2083 M\u2084}", "{A : Type*} [NonUnitalNonAssocSemiring A] [Module R A]", "{B : Type*} [NonUnitalNonAssocSemiring B] [Module R B]", "(R M M\u2082)", "[CommSemiring R]", "[AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R M\u2082]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083] [AddCommMonoid M\u2084]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_6\nrange : x\u271d\n\u22a2 Disjoint sorry sorry"}, {"line": "simp +contextual [disjoint_def, @eq_comm M 0, @eq_comm M\u2082 0]", "tactic_state": "x\u271d : Sort u_6\nrange : x\u271d\n\u22a2 Disjoint (sorry ()) (sorry ())"}]}
{"declaration": "theorem ker_inl : ker (inl R M M\u2082) = \u22a5 := by rw [ker, \u2190 prod_bot, prod_comap_inl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Prod.lean", "context": {"open": ["Submodule", "LinearMap"], "variables": ["{R : Type u} {K : Type u'} {M : Type v} {V : Type v'} {M\u2082 : Type w} {V\u2082 : Type w'}", "{M\u2083 : Type y} {V\u2083 : Type y'} {M\u2084 : Type z} {\u03b9 : Type x}", "{M\u2085 M\u2086 : Type*}", "(S : Type*) [Semiring R] [Semiring S]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083] [AddCommMonoid M\u2084]", "[AddCommMonoid M\u2085] [AddCommMonoid M\u2086]", "[Module R M] [Module R M\u2082] [Module R M\u2083] [Module R M\u2084]", "[Module R M\u2085] [Module R M\u2086]", "(f : M \u2192\u2097[R] M\u2082)", "(R M M\u2082)", "(R M M\u2082)", "(R M M\u2082 M\u2083 M\u2084)", "{R M M\u2082 M\u2083 M\u2084}", "{A : Type*} [NonUnitalNonAssocSemiring A] [Module R A]", "{B : Type*} [NonUnitalNonAssocSemiring B] [Module R B]", "(R M M\u2082)", "[CommSemiring R]", "[AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R M\u2082]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083] [AddCommMonoid M\u2084]", "[Semiring R]", "[AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R M\u2082]", "(p : Submodule R M) (q : Submodule R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\nM\u2082 : Type w\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R M\u2082\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M\u2082\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\n\u22a2 ker (inl R M M\u2082) = \u22a5"}, {"line": "rw [ker, \u2190 prod_bot, prod_comap_inl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ker_inr : ker (inr R M M\u2082) = \u22a5 := by rw [ker, \u2190 prod_bot, prod_comap_inr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Prod.lean", "context": {"open": ["Submodule", "LinearMap"], "variables": ["{R : Type u} {K : Type u'} {M : Type v} {V : Type v'} {M\u2082 : Type w} {V\u2082 : Type w'}", "{M\u2083 : Type y} {V\u2083 : Type y'} {M\u2084 : Type z} {\u03b9 : Type x}", "{M\u2085 M\u2086 : Type*}", "(S : Type*) [Semiring R] [Semiring S]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083] [AddCommMonoid M\u2084]", "[AddCommMonoid M\u2085] [AddCommMonoid M\u2086]", "[Module R M] [Module R M\u2082] [Module R M\u2083] [Module R M\u2084]", "[Module R M\u2085] [Module R M\u2086]", "(f : M \u2192\u2097[R] M\u2082)", "(R M M\u2082)", "(R M M\u2082)", "(R M M\u2082 M\u2083 M\u2084)", "{R M M\u2082 M\u2083 M\u2084}", "{A : Type*} [NonUnitalNonAssocSemiring A] [Module R A]", "{B : Type*} [NonUnitalNonAssocSemiring B] [Module R B]", "(R M M\u2082)", "[CommSemiring R]", "[AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R M\u2082]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083] [AddCommMonoid M\u2084]", "[Semiring R]", "[AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R M\u2082]", "(p : Submodule R M) (q : Submodule R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\nM\u2082 : Type w\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R M\u2082\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M\u2082\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\n\u22a2 ker (inr R M M\u2082) = \u22a5"}, {"line": "rw [ker, \u2190 prod_bot, prod_comap_inr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_bot_iff {p\u2081 : Submodule R M} {p\u2082 : Submodule R M\u2082} :\n    p\u2081.prod p\u2082 = \u22a5 \u2194 p\u2081 = \u22a5 \u2227 p\u2082 = \u22a5 := by\n  simp only [eq_bot_iff]\n  simp only [prod_le_iff]\n  simp only [(gc_map_comap _).le_iff_le]\n  simp only [comap_bot]\n  simp only [ker_inl]\n  simp only [ker_inr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Prod.lean", "context": {"open": ["Submodule", "LinearMap"], "variables": ["{R : Type u} {K : Type u'} {M : Type v} {V : Type v'} {M\u2082 : Type w} {V\u2082 : Type w'}", "{M\u2083 : Type y} {V\u2083 : Type y'} {M\u2084 : Type z} {\u03b9 : Type x}", "{M\u2085 M\u2086 : Type*}", "(S : Type*) [Semiring R] [Semiring S]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083] [AddCommMonoid M\u2084]", "[AddCommMonoid M\u2085] [AddCommMonoid M\u2086]", "[Module R M] [Module R M\u2082] [Module R M\u2083] [Module R M\u2084]", "[Module R M\u2085] [Module R M\u2086]", "(f : M \u2192\u2097[R] M\u2082)", "(R M M\u2082)", "(R M M\u2082)", "(R M M\u2082 M\u2083 M\u2084)", "{R M M\u2082 M\u2083 M\u2084}", "{A : Type*} [NonUnitalNonAssocSemiring A] [Module R A]", "{B : Type*} [NonUnitalNonAssocSemiring B] [Module R B]", "(R M M\u2082)", "[CommSemiring R]", "[AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R M\u2082]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083] [AddCommMonoid M\u2084]", "[Semiring R]", "[AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R M\u2082]", "(p : Submodule R M) (q : Submodule R M\u2082)", "(R M M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\nM\u2082 : Type w\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R M\u2082\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M\u2082\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np\u2081 : Submodule R M\np\u2082 : Submodule R M\u2082\n\u22a2 p\u2081.prod p\u2082 = \u22a5 \u2194 p\u2081 = \u22a5 \u2227 p\u2082 = \u22a5"}, {"line": "simp only [eq_bot_iff]", "tactic_state": "R : Type u\nM : Type v\nM\u2082 : Type w\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R M\u2082\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M\u2082\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np\u2081 : Submodule R M\np\u2082 : Submodule R M\u2082\n\u22a2 p\u2081.prod p\u2082 \u2264 \u22a5 \u2194 p\u2081 \u2264 \u22a5 \u2227 p\u2082 \u2264 \u22a5"}, {"line": "simp only [prod_le_iff]", "tactic_state": "R : Type u\nM : Type v\nM\u2082 : Type w\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R M\u2082\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M\u2082\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np\u2081 : Submodule R M\np\u2082 : Submodule R M\u2082\n\u22a2 map (inl R M M\u2082) p\u2081 \u2264 \u22a5 \u2227 map (inr R M M\u2082) p\u2082 \u2264 \u22a5 \u2194 p\u2081 \u2264 \u22a5 \u2227 p\u2082 \u2264 \u22a5"}, {"line": "simp only [(gc_map_comap _).le_iff_le]", "tactic_state": "R : Type u\nM : Type v\nM\u2082 : Type w\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R M\u2082\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M\u2082\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np\u2081 : Submodule R M\np\u2082 : Submodule R M\u2082\n\u22a2 p\u2081 \u2264 comap (inl R M M\u2082) \u22a5 \u2227 p\u2082 \u2264 comap (inr R M M\u2082) \u22a5 \u2194 p\u2081 \u2264 \u22a5 \u2227 p\u2082 \u2264 \u22a5"}, {"line": "simp only [comap_bot]", "tactic_state": "R : Type u\nM : Type v\nM\u2082 : Type w\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R M\u2082\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M\u2082\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np\u2081 : Submodule R M\np\u2082 : Submodule R M\u2082\n\u22a2 p\u2081 \u2264 ker (inl R M M\u2082) \u2227 p\u2082 \u2264 ker (inr R M M\u2082) \u2194 p\u2081 \u2264 \u22a5 \u2227 p\u2082 \u2264 \u22a5"}, {"line": "simp only [ker_inl]", "tactic_state": "R : Type u\nM : Type v\nM\u2082 : Type w\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R M\u2082\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M\u2082\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np\u2081 : Submodule R M\np\u2082 : Submodule R M\u2082\n\u22a2 p\u2081 \u2264 \u22a5 \u2227 p\u2082 \u2264 ker (inr R M M\u2082) \u2194 p\u2081 \u2264 \u22a5 \u2227 p\u2082 \u2264 \u22a5"}, {"line": "simp only [ker_inr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearProjOfIsCompl_apply_left (h : IsCompl p q) (x : p) :\n    linearProjOfIsCompl p q h x = x := by simp [linearProjOfIsCompl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : \u21a5p\n\u22a2 (p.linearProjOfIsCompl q h) \u2191x = x"}, {"line": "simp [linearProjOfIsCompl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearProjOfIsCompl_apply_eq_zero_iff (h : IsCompl p q) {x : E} :\n    linearProjOfIsCompl p q h x = 0 \u2194 x \u2208 q := by simp [linearProjOfIsCompl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : E\n\u22a2 (p.linearProjOfIsCompl q h) x = 0 \u2194 x \u2208 q"}, {"line": "simp [linearProjOfIsCompl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofIsCompl_left_apply (h : IsCompl p q) {\u03c6 : p \u2192\u2097[R] F} {\u03c8 : q \u2192\u2097[R] F} (u : p) :\n    ofIsCompl h \u03c6 \u03c8 (u : E) = \u03c6 u := by simp [ofIsCompl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap", "Submodule"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Ring R\nE : Type u_2\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module R E\nF : Type u_3\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module R F\np q : Submodule R E\nh : IsCompl p q\n\u03c6 : \u21a5p \u2192\u2097[R] F\n\u03c8 : \u21a5q \u2192\u2097[R] F\nu : \u21a5p\n\u22a2 (ofIsCompl h \u03c6 \u03c8) \u2191u = \u03c6 u"}, {"line": "simp [ofIsCompl]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Ring R\nE : Type u_2\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module R E\nF : Type u_3\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module R F\np q : Submodule R E\nh : IsCompl p q\n\u03c6 : \u21a5p \u2192\u2097[R] F\n\u03c8 : \u21a5q \u2192\u2097[R] F\nu : \u21a5p\n\u22a2 \u03c6 u + \u03c8 0 = \u03c6 u"}]}
{"declaration": "theorem ofIsCompl_right_apply (h : IsCompl p q) {\u03c6 : p \u2192\u2097[R] F} {\u03c8 : q \u2192\u2097[R] F} (v : q) :\n    ofIsCompl h \u03c6 \u03c8 (v : E) = \u03c8 v := by simp [ofIsCompl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap", "Submodule"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Ring R\nE : Type u_2\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module R E\nF : Type u_3\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module R F\np q : Submodule R E\nh : IsCompl p q\n\u03c6 : \u21a5p \u2192\u2097[R] F\n\u03c8 : \u21a5q \u2192\u2097[R] F\nv : \u21a5q\n\u22a2 (ofIsCompl h \u03c6 \u03c8) \u2191v = \u03c8 v"}, {"line": "simp [ofIsCompl]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Ring R\nE : Type u_2\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module R E\nF : Type u_3\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module R F\np q : Submodule R E\nh : IsCompl p q\n\u03c6 : \u21a5p \u2192\u2097[R] F\n\u03c8 : \u21a5q \u2192\u2097[R] F\nv : \u21a5q\n\u22a2 \u03c6 0 + \u03c8 v = \u03c8 v"}]}
{"declaration": "theorem IsProj.eq_conj_prodMap {f : E \u2192\u2097[R] E} (h : IsProj p f) :\n    f = (p.prodEquivOfIsCompl (ker f) h.isCompl).conj (prodMap id 0) := by\n  rw [LinearEquiv.conj_apply]\n  exact h.eq_conj_prod_map'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Projection.lean", "context": {"open": ["Submodule", "LinearMap", "Submodule", "LinearMap", "Submodule"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E]", "{F : Type*} [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]", "(p q : Submodule R E)", "{S : Type*} [Semiring S] {M : Type*} [AddCommMonoid M] [Module S M] (m : Submodule S M)", "{p}", "{p q}", "{p q}", "{R\u2081 : Type*} [CommRing R\u2081] [Module R\u2081 E] [Module R\u2081 F]", "{p m}", "{R : Type*} [CommRing R] {E : Type*} [AddCommGroup E] [Module R E] {p : Submodule R E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_8\ninst\u271d\u00b2 : CommRing R\nE : Type u_9\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module R E\np : Submodule R E\nf : E \u2192\u2097[R] E\nh : IsProj p f\n\u22a2 f = (p.prodEquivOfIsCompl (ker f) \u22ef).conj (LinearMap.id.prodMap 0)"}, {"line": "rw [LinearEquiv.conj_apply]", "tactic_state": "R : Type u_8\ninst\u271d\u00b2 : CommRing R\nE : Type u_9\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module R E\np : Submodule R E\nf : E \u2192\u2097[R] E\nh : IsProj p f\n\u22a2 f = (\u2191(p.prodEquivOfIsCompl (ker f) \u22ef) \u2218\u2097 LinearMap.id.prodMap 0) \u2218\u2097 \u2191(p.prodEquivOfIsCompl (ker f) \u22ef).symm"}, {"line": "exact h.eq_conj_prod_map'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem units_smul_of_pos (u : R\u02e3) (hu : 0 < (u : R)) (v : Module.Ray R M) : u \u2022 v = v := by\n  induction v using Module.Ray.ind\n  rw [smul_rayOfNeZero]\n  rw [ray_eq_iff]\n  exact SameRay.sameRay_pos_smul_left _ hu\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nu : R\u02e3\nhu : 0 < \u2191u\nv : Module.Ray R M\n\u22a2 u \u2022 v = v"}, {"line": "induction v using Module.Ray.ind", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nu : R\u02e3\nhu : 0 < \u2191u\nv\u271d : M\nhv\u271d : v\u271d \u2260 0\n\u22a2 u \u2022 rayOfNeZero R v\u271d hv\u271d = rayOfNeZero R v\u271d hv\u271d"}, {"line": "rw [smul_rayOfNeZero]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nu : R\u02e3\nhu : 0 < \u2191u\nv\u271d : M\nhv\u271d : v\u271d \u2260 0\n\u22a2 rayOfNeZero R (u \u2022 v\u271d) \u22ef = rayOfNeZero R v\u271d hv\u271d"}, {"line": "rw [ray_eq_iff]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nu : R\u02e3\nhu : 0 < \u2191u\nv\u271d : M\nhv\u271d : v\u271d \u2260 0\n\u22a2 SameRay R (u \u2022 v\u271d) v\u271d"}, {"line": "exact SameRay.sameRay_pos_smul_left _ hu", "tactic_state": "No Goals!"}]}
{"declaration": "theorem units_inv_smul (u : R\u02e3) (v : Module.Ray R M) : u\u207b\u00b9 \u2022 v = u \u2022 v :=\n  have := mul_self_pos.2 u.ne_zero\n  calc\n    u\u207b\u00b9 \u2022 v = (u * u) \u2022 u\u207b\u00b9 \u2022 v := Eq.symm <| (u\u207b\u00b9 \u2022 v).units_smul_of_pos _ (by exact this)\n    _ = u \u2022 v := by rw [mul_smul, smul_inv_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nu : R\u02e3\nv : Module.Ray R M\nthis : 0 < \u2191u * \u2191u\n\u22a2 (u * u) \u2022 u\u207b\u00b9 \u2022 v = u \u2022 v"}, {"line": "rw [mul_smul, smul_inv_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem units_smul_eq_neg_iff {u : R\u02e3} {v : Module.Ray R M} : u \u2022 v = -v \u2194 u.1 < 0 := by\n  rw [\u2190 neg_inj]\n  rw [neg_neg]\n  rw [\u2190 Module.Ray.neg_units_smul]\n  rw [units_smul_eq_self_iff]\n  rw [Units.val_neg]\n  rw [neg_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "[NoZeroSMulDivisors R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 u \u2022 v = -v \u2194 \u2191u < 0"}, {"line": "rw [\u2190 neg_inj]", "tactic_state": "R : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 -(u \u2022 v) = - -v \u2194 \u2191u < 0"}, {"line": "rw [neg_neg]", "tactic_state": "R : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 -(u \u2022 v) = v \u2194 \u2191u < 0"}, {"line": "rw [\u2190 Module.Ray.neg_units_smul]", "tactic_state": "R : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 -u \u2022 v = v \u2194 \u2191u < 0"}, {"line": "rw [units_smul_eq_self_iff]", "tactic_state": "R : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 0 < \u2191(-u) \u2194 \u2191u < 0\n---\nR : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 NoZeroSMulDivisors R M"}, {"line": "rw [Units.val_neg]", "tactic_state": "R : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 0 < -\u2191u \u2194 \u2191u < 0\n---\nR : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 NoZeroSMulDivisors R M"}, {"line": "rw [neg_pos]", "tactic_state": "R : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 AddLeftStrictMono R\n---\nR : Type u_10\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : IsStrictOrderedRing R\nM : Type u_11\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nu : R\u02e3\nv : Module.Ray R M\n\u22a2 NoZeroSMulDivisors R M"}]}
{"declaration": "theorem exists_nonneg_left (h : SameRay R x y) (hx : x \u2260 0) : \u2203 r : R, 0 \u2264 r \u2227 r \u2022 x = y := by\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 exact \u27e80, le_rfl, zero_smul _ _\u27e9\n  \u00b7 exact (h.exists_pos_left hx hy).imp fun _ => And.imp_left le_of_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "[NoZeroSMulDivisors R M]", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y v\u2081 v\u2082 : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nh : SameRay R x y\nhx : x \u2260 0\n\u22a2 \u2203 r, 0 \u2264 r \u2227 r \u2022 x = y"}, {"line": "obtain rfl | hy := eq_or_ne y 0", "tactic_state": "case inl\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nhx : x \u2260 0\nh : SameRay R x sorry\n\u22a2 \u2203 r, 0 \u2264 r \u2227 r \u2022 x = sorry\n---\ncase inr\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nh : SameRay R x y\nhx : x \u2260 0\nhy : y \u2260 sorry\n\u22a2 \u2203 r, 0 \u2264 r \u2227 r \u2022 x = y"}, {"line": "\u00b7 exact \u27e80, le_rfl, zero_smul _ _\u27e9", "tactic_state": "case inr\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nh : SameRay R x y\nhx : x \u2260 0\nhy : y \u2260 sorry\n\u22a2 \u2203 r, 0 \u2264 r \u2227 r \u2022 x = y"}, {"line": "\u00b7 exact (h.exists_pos_left hx hy).imp fun _ => And.imp_left le_of_lt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_eq_smul_add (h : SameRay R v\u2081 v\u2082) :\n    \u2203 a b : R, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 v\u2081 = a \u2022 (v\u2081 + v\u2082) \u2227 v\u2082 = b \u2022 (v\u2081 + v\u2082) := by\n  rcases h with (rfl | rfl | \u27e8r\u2081, r\u2082, h\u2081, h\u2082, H\u27e9)\n  \u00b7 use 0, 1\n    simp\n  \u00b7 use 1, 0\n    simp\n  \u00b7 have h\u2081\u2082 : 0 < r\u2081 + r\u2082 := add_pos h\u2081 h\u2082\n    refine\n      \u27e8r\u2082 / (r\u2081 + r\u2082), r\u2081 / (r\u2081 + r\u2082), div_nonneg h\u2082.le h\u2081\u2082.le, div_nonneg h\u2081.le h\u2081\u2082.le, ?_, ?_, ?_\u27e9\n    \u00b7 rw [\u2190 add_div, add_comm, div_self h\u2081\u2082.ne']\n    \u00b7 rw [div_eq_inv_mul, mul_smul, smul_add, \u2190 H, \u2190 add_smul, add_comm r\u2082, inv_smul_smul\u2080 h\u2081\u2082.ne']\n    \u00b7 rw [div_eq_inv_mul, mul_smul, smul_add, H, \u2190 add_smul, add_comm r\u2082, inv_smul_smul\u2080 h\u2081\u2082.ne']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "[NoZeroSMulDivisors R M]", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y v\u2081 v\u2082 : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nv\u2081 v\u2082 : M\nh : SameRay R v\u2081 v\u2082\n\u22a2 \u2203 a b, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 v\u2081 = a \u2022 (v\u2081 + v\u2082) \u2227 v\u2082 = b \u2022 (v\u2081 + v\u2082)"}, {"line": "rcases h with (rfl | rfl | \u27e8r\u2081, r\u2082, h\u2081, h\u2082, H\u27e9)", "tactic_state": "case inl\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nv\u2082 : M\n\u22a2 \u2203 a b, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 0 = a \u2022 (0 + v\u2082) \u2227 v\u2082 = b \u2022 (0 + v\u2082)\n---\ncase inr.inl\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nv\u2081 : M\n\u22a2 \u2203 a b, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 v\u2081 = a \u2022 (v\u2081 + 0) \u2227 0 = b \u2022 (v\u2081 + 0)\n---\ncase inr.inr.intro.intro.intro.intro\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nv\u2081 v\u2082 : M\nr\u2081 r\u2082 : R\nh\u2081 : 0 < r\u2081\nh\u2082 : 0 < r\u2082\nH : r\u2081 \u2022 v\u2081 = r\u2082 \u2022 v\u2082\n\u22a2 \u2203 a b, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 v\u2081 = a \u2022 (v\u2081 + v\u2082) \u2227 v\u2082 = b \u2022 (v\u2081 + v\u2082)"}, {"line": "\u00b7 use 0, 1\n    simp", "tactic_state": "case inr.inl\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nv\u2081 : M\n\u22a2 \u2203 a b, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 v\u2081 = a \u2022 (v\u2081 + 0) \u2227 0 = b \u2022 (v\u2081 + 0)\n---\ncase inr.inr.intro.intro.intro.intro\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nv\u2081 v\u2082 : M\nr\u2081 r\u2082 : R\nh\u2081 : 0 < r\u2081\nh\u2082 : 0 < r\u2082\nH : r\u2081 \u2022 v\u2081 = r\u2082 \u2022 v\u2082\n\u22a2 \u2203 a b, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 v\u2081 = a \u2022 (v\u2081 + v\u2082) \u2227 v\u2082 = b \u2022 (v\u2081 + v\u2082)"}, {"line": "\u00b7 use 1, 0\n    simp", "tactic_state": "case inr.inr.intro.intro.intro.intro\nR : Type u_12\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_13\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nv\u2081 v\u2082 : M\nr\u2081 r\u2082 : R\nh\u2081 : 0 < r\u2081\nh\u2082 : 0 < r\u2082\nH : r\u2081 \u2022 v\u2081 = r\u2082 \u2022 v\u2082\n\u22a2 \u2203 a b, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 v\u2081 = a \u2022 (v\u2081 + v\u2082) \u2227 v\u2082 = b \u2022 (v\u2081 + v\u2082)"}, {"line": "\u00b7 have h\u2081\u2082 : 0 < r\u2081 + r\u2082 := add_pos h\u2081 h\u2082\n    refine\n      \u27e8r\u2082 / (r\u2081 + r\u2082), r\u2081 / (r\u2081 + r\u2082), div_nonneg h\u2082.le h\u2081\u2082.le, div_nonneg h\u2081.le h\u2081\u2082.le, ?_, ?_, ?_\u27e9\n    \u00b7 rw [\u2190 add_div, add_comm, div_self h\u2081\u2082.ne']\n    \u00b7 rw [div_eq_inv_mul, mul_smul, smul_add, \u2190 H, \u2190 add_smul, add_comm r\u2082, inv_smul_smul\u2080 h\u2081\u2082.ne']\n    \u00b7 rw [div_eq_inv_mul, mul_smul, smul_add, H, \u2190 add_smul, add_comm r\u2082, inv_smul_smul\u2080 h\u2081\u2082.ne']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_pos_left_iff_sameRay (hx : x \u2260 0) (hy : y \u2260 0) :\n    (\u2203 r : R, 0 < r \u2227 r \u2022 x = y) \u2194 SameRay R x y := by\n  refine \u27e8fun h => ?_, fun h => h.exists_pos_left hx hy\u27e9\n  rcases h with \u27e8r, hr, rfl\u27e9\n  exact SameRay.sameRay_pos_smul_right x hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "[NoZeroSMulDivisors R M]", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y v\u2081 v\u2082 : M}", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 < r \u2227 r \u2022 x = y) \u2194 SameRay R x y"}, {"line": "refine \u27e8fun h => ?_, fun h => h.exists_pos_left hx hy\u27e9", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2203 r, 0 < r \u2227 r \u2022 x = y\n\u22a2 SameRay R x y"}, {"line": "rcases h with \u27e8r, hr, rfl\u27e9", "tactic_state": "case intro.intro\nR : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nhx : x \u2260 0\nr : R\nhr : 0 < r\nhy : r \u2022 x \u2260 0\n\u22a2 SameRay R x (r \u2022 x)"}, {"line": "exact SameRay.sameRay_pos_smul_right x hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_nonneg_left_iff_sameRay (hx : x \u2260 0) :\n    (\u2203 r : R, 0 \u2264 r \u2227 r \u2022 x = y) \u2194 SameRay R x y := by\n  refine \u27e8fun h => ?_, fun h => h.exists_nonneg_left hx\u27e9\n  rcases h with \u27e8r, hr, rfl\u27e9\n  exact SameRay.sameRay_nonneg_smul_right x hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "[NoZeroSMulDivisors R M]", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y v\u2081 v\u2082 : M}", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhx : x \u2260 0\n\u22a2 (\u2203 r, 0 \u2264 r \u2227 r \u2022 x = y) \u2194 SameRay R x y"}, {"line": "refine \u27e8fun h => ?_, fun h => h.exists_nonneg_left hx\u27e9", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhx : x \u2260 0\nh : \u2203 r, 0 \u2264 r \u2227 r \u2022 x = y\n\u22a2 SameRay R x y"}, {"line": "rcases h with \u27e8r, hr, rfl\u27e9", "tactic_state": "case intro.intro\nR : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nhx : x \u2260 0\nr : R\nhr : 0 \u2264 r\n\u22a2 SameRay R x (r \u2022 x)"}, {"line": "exact SameRay.sameRay_nonneg_smul_right x hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_pos_right_iff_sameRay (hx : x \u2260 0) (hy : y \u2260 0) :\n    (\u2203 r : R, 0 < r \u2227 x = r \u2022 y) \u2194 SameRay R x y := by\n  rw [SameRay.sameRay_comm]\n  simp_rw [eq_comm (a := x)]\n  exact exists_pos_left_iff_sameRay hy hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "[NoZeroSMulDivisors R M]", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y v\u2081 v\u2082 : M}", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 < r \u2227 x = r \u2022 y) \u2194 SameRay R x y"}, {"line": "rw [SameRay.sameRay_comm]", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 < r \u2227 x = r \u2022 y) \u2194 SameRay R y x"}, {"line": "simp_rw [eq_comm (a := x)]", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 < r \u2227 r \u2022 y = x) \u2194 SameRay R y x"}, {"line": "exact exists_pos_left_iff_sameRay hy hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_pos_right_iff_sameRay_and_ne_zero (hy : y \u2260 0) :\n    (\u2203 r : R, 0 < r \u2227 x = r \u2022 y) \u2194 SameRay R x y \u2227 x \u2260 0 := by\n  rw [SameRay.sameRay_comm]\n  simp_rw [eq_comm (a := x)]\n  exact exists_pos_left_iff_sameRay_and_ne_zero hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "[NoZeroSMulDivisors R M]", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y v\u2081 v\u2082 : M}", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 < r \u2227 x = r \u2022 y) \u2194 SameRay R x y \u2227 x \u2260 0"}, {"line": "rw [SameRay.sameRay_comm]", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 < r \u2227 x = r \u2022 y) \u2194 SameRay R y x \u2227 x \u2260 0"}, {"line": "simp_rw [eq_comm (a := x)]", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 < r \u2227 r \u2022 y = x) \u2194 SameRay R y x \u2227 x \u2260 0"}, {"line": "exact exists_pos_left_iff_sameRay_and_ne_zero hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_nonneg_right_iff_sameRay (hy : y \u2260 0) :\n    (\u2203 r : R, 0 \u2264 r \u2227 x = r \u2022 y) \u2194 SameRay R x y := by\n  rw [SameRay.sameRay_comm]\n  simp_rw [eq_comm (a := x)]\n  exact exists_nonneg_left_iff_sameRay (R := R) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Ray.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{x y z : M}", "{S : Type*} [CommSemiring S] [PartialOrder S]", "(R M)", "{R M}", "(R)", "{R}", "{G : Type*} [Group G] [DistribMulAction G M]", "[SMulCommClass R G M]", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] {x y : M}", "(R)", "{R}", "{R : Type*} [CommRing R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "[NoZeroSMulDivisors R M]", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y v\u2081 v\u2082 : M}", "{R : Type*} [Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{M : Type*} [AddCommGroup M] [Module R M] {x y : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 \u2264 r \u2227 x = r \u2022 y) \u2194 SameRay R x y"}, {"line": "rw [SameRay.sameRay_comm]", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 \u2264 r \u2227 x = r \u2022 y) \u2194 SameRay R y x"}, {"line": "simp_rw [eq_comm (a := x)]", "tactic_state": "R : Type u_14\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_15\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nhy : y \u2260 0\n\u22a2 (\u2203 r, 0 \u2264 r \u2227 r \u2022 y = x) \u2194 SameRay R y x"}, {"line": "exact exists_nonneg_left_iff_sameRay (R := R) hy", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preReflection_apply :\n    preReflection x f y = y - (f y) \u2022 x := by\n  simp [preReflection]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Reflection.lean", "context": {"open": ["Function Set", "Module hiding Finite", "Submodule (span)"], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (x : M) (f : Dual R M) (y : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nf : Dual R M\ny : M\n\u22a2 (preReflection x f) y = y - f y \u2022 x"}, {"line": "simp [preReflection]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Submodule.mem_invtSubmodule_reflection_of_mem (h : f x = 2)\n    (p : Submodule R M) (hx : x \u2208 p) :\n    p \u2208 End.invtSubmodule (reflection h) := by\n  suffices \u2200 y \u2208 p, reflection h y \u2208 p from\n    (End.mem_invtSubmodule _).mpr fun y hy \u21a6 by simpa using this y hy\n  intro y hy\n  simpa only [reflection_apply,p.sub_mem_iff_right hy] using p.smul_mem (f y) hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Reflection.lean", "context": {"open": ["Function Set", "Module hiding Finite", "Submodule (span)"], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (x : M) (f : Dual R M) (y : M)", "{x f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nf : Dual R M\nh : f x = 2\np : Submodule R M\nhx : x \u2208 p\n\u22a2 p \u2208 End.invtSubmodule \u2191(reflection h)"}, {"line": "suffices \u2200 y \u2208 p, reflection h y \u2208 p from\n    (End.mem_invtSubmodule _).mpr fun y hy \u21a6 by simpa using this y hy", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nf : Dual R M\nh : f x = 2\np : Submodule R M\nhx : x \u2208 p\n\u22a2 \u2200 y \u2208 p, sorry \u2208 p"}, {"line": "intro y hy", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nf : Dual R M\nh : f x = 2\np : Submodule R M\nhx : x \u2208 p\ny : M\nhy : y \u2208 p\n\u22a2 sorry \u2208 p"}, {"line": "simpa only [reflection_apply,p.sub_mem_iff_right hy] using p.smul_mem (f y) hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma injOn_dualMap_subtype_span_range_range {\u03b9 : Type*} [NoZeroSMulDivisors \u2124 M]\n    {r : \u03b9 \u21aa M} {c : \u03b9 \u2192 Dual R M} (hfin : (range r).Finite)\n    (h_two : \u2200 i, c i (r i) = 2)\n    (h_mapsTo : \u2200 i, MapsTo (preReflection (r i) (c i)) (range r) (range r)) :\n    InjOn (span R (range r)).subtype.dualMap (range c) := by\n  rintro - \u27e8i, rfl\u27e9 - \u27e8j, rfl\u27e9 hij\n  congr\n  suffices \u2200 k, c i (r k) = c j (r k) by\n    rw [\u2190 EmbeddingLike.apply_eq_iff_eq r]\n    exact eq_of_mapsTo_reflection_of_mem (f := c i) (g := c j) hfin (h_two i) (h_two j)\n      (by rw [\u2190 this, h_two]) (by rw [this, h_two]) (h_mapsTo i) (h_mapsTo j) (mem_range_self j)\n  intro k\n  simpa using LinearMap.congr_fun hij \u27e8r k, Submodule.subset_span (mem_range_self k)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Reflection.lean", "context": {"open": ["Function Set", "Module hiding Finite", "Submodule (span)", "Int Polynomial.Chebyshev"], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (x : M) (f : Dual R M) (y : M)", "{x f}", "{x y : M} {f g : Dual R M} (hf : f x = 2) (hg : g y = 2)", "{y}", "{g : Dual R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_3\ninst\u271d : NoZeroSMulDivisors \u2124 M\nr : \u03b9 \u21aa M\nc : \u03b9 \u2192 Dual R M\nhfin : (Set.range \u21d1r).Finite\nh_two : \u2200 (i : \u03b9), (c i) (r i) = 2\nh_mapsTo : \u2200 (i : \u03b9), MapsTo (\u21d1(preReflection (r i) (c i))) (Set.range \u21d1r) (Set.range \u21d1r)\n\u22a2 InjOn (\u21d1(span R (Set.range \u21d1r)).subtype.dualMap) (Set.range c)"}, {"line": "rintro - \u27e8i, rfl\u27e9 - \u27e8j, rfl\u27e9 hij", "tactic_state": "case intro.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_3\ninst\u271d : NoZeroSMulDivisors \u2124 M\nr : \u03b9 \u21aa M\nc : \u03b9 \u2192 Dual R M\nhfin : (Set.range \u21d1r).Finite\nh_two : \u2200 (i : \u03b9), (c i) (r i) = 2\nh_mapsTo : \u2200 (i : \u03b9), MapsTo (\u21d1(preReflection (r i) (c i))) (Set.range \u21d1r) (Set.range \u21d1r)\ni j : \u03b9\nhij : (span R (Set.range \u21d1r)).subtype.dualMap (c i) = (span R (Set.range \u21d1r)).subtype.dualMap (c j)\n\u22a2 c i = c j"}, {"line": "congr", "tactic_state": "case intro.intro.e_a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_3\ninst\u271d : NoZeroSMulDivisors \u2124 M\nr : \u03b9 \u21aa M\nc : \u03b9 \u2192 Dual R M\nhfin : (Set.range \u21d1r).Finite\nh_two : \u2200 (i : \u03b9), (c i) (r i) = 2\nh_mapsTo : \u2200 (i : \u03b9), MapsTo (\u21d1(preReflection (r i) (c i))) (Set.range \u21d1r) (Set.range \u21d1r)\ni j : \u03b9\nhij : (span R (Set.range \u21d1r)).subtype.dualMap (c i) = (span R (Set.range \u21d1r)).subtype.dualMap (c j)\n\u22a2 i = j"}, {"line": "suffices \u2200 k, c i (r k) = c j (r k) by\n    rw [\u2190 EmbeddingLike.apply_eq_iff_eq r]\n    exact eq_of_mapsTo_reflection_of_mem (f := c i) (g := c j) hfin (h_two i) (h_two j)\n      (by rw [\u2190 this, h_two]) (by rw [this, h_two]) (h_mapsTo i) (h_mapsTo j) (mem_range_self j)", "tactic_state": "case intro.intro.e_a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_3\ninst\u271d : NoZeroSMulDivisors \u2124 M\nr : \u03b9 \u21aa M\nc : \u03b9 \u2192 Dual R M\nhfin : (Set.range \u21d1r).Finite\nh_two : \u2200 (i : \u03b9), (c i) (r i) = 2\nh_mapsTo : \u2200 (i : \u03b9), MapsTo (\u21d1(preReflection (r i) (c i))) (Set.range \u21d1r) (Set.range \u21d1r)\ni j : \u03b9\nhij : (span R (Set.range \u21d1r)).subtype.dualMap (c i) = (span R (Set.range \u21d1r)).subtype.dualMap (c j)\n\u22a2 \u2200 (k : \u03b9), (c i) (r k) = (c j) (r k)"}, {"line": "intro k", "tactic_state": "case intro.intro.e_a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_3\ninst\u271d : NoZeroSMulDivisors \u2124 M\nr : \u03b9 \u21aa M\nc : \u03b9 \u2192 Dual R M\nhfin : (Set.range \u21d1r).Finite\nh_two : \u2200 (i : \u03b9), (c i) (r i) = 2\nh_mapsTo : \u2200 (i : \u03b9), MapsTo (\u21d1(preReflection (r i) (c i))) (Set.range \u21d1r) (Set.range \u21d1r)\ni j : \u03b9\nhij : (span R (Set.range \u21d1r)).subtype.dualMap (c i) = (span R (Set.range \u21d1r)).subtype.dualMap (c j)\nk : \u03b9\n\u22a2 (c i) (r k) = (c j) (r k)"}, {"line": "simpa using LinearMap.congr_fun hij \u27e8r k, Submodule.subset_span (mem_range_self k)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsSemisimple_smul_iff {t : K} (ht : t \u2260 0) :\n    (t \u2022 f).IsSemisimple \u2194 f.IsSemisimple := by\n  simp [isSemisimple_iff, mem_invtSubmodule, Submodule.comap_smul f (h := ht)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Semisimple.lean", "context": {"open": ["Set Function Polynomial"], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M]", "(f : End R M)", "{f}", "(f) in", "{K : Type*} [Field K] [Module K M] {f g : End K M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "End : ?m.8650\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : sorry\nK : Type u_3\nt : K\nht : t \u2260 sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [isSemisimple_iff, mem_invtSubmodule, Submodule.comap_smul f (h := ht)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma linearIndependent_single_of_ne_zero {\u03b9 R M : Type*} [Ring R] [AddCommGroup M] [Module R M]\n    [NoZeroSMulDivisors R M] [DecidableEq \u03b9] {v : \u03b9 \u2192 M} (hv : \u2200 i, v i \u2260 0) :\n    LinearIndependent R fun i : \u03b9 \u21a6 Pi.single i (v i) := by\n  rw [\u2190 linearIndependent_equiv (Equiv.sigmaPUnit \u03b9)]\n  exact linearIndependent_single (fun i (_ : Unit) \u21a6 v i) <| by\n    simp +contextual [Fintype.linearIndependent_iff, hv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/StdBasis.lean", "context": {"open": ["Function Set Submodule", "LinearMap", "Set"], "variables": ["{R : Type*}", "{\u03b7 : Type*} {\u03b9s : \u03b7 \u2192 Type*} {Ms : \u03b7 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\nR : Type u_6\nM : Type u_7\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 M\nhv : \u2200 (i : \u03b9), v i \u2260 0\n\u22a2 LinearIndependent R fun i => Pi.single i (v i)"}, {"line": "rw [\u2190 linearIndependent_equiv (Equiv.sigmaPUnit \u03b9)]", "tactic_state": "\u03b9 : Type u_5\nR : Type u_6\nM : Type u_7\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 M\nhv : \u2200 (i : \u03b9), v i \u2260 0\n\u22a2 LinearIndependent R ((fun i => Pi.single i (v i)) \u2218 \u21d1(Equiv.sigmaPUnit \u03b9))"}, {"line": "exact linearIndependent_single (fun i (_ : Unit) \u21a6 v i) <| by\n    simp +contextual [Fintype.linearIndependent_iff, hv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem basisFun_repr (x : \u03b7 \u2192 R) (i : \u03b7) : (Pi.basisFun R \u03b7).repr x i = x i := by simp [basisFun]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/StdBasis.lean", "context": {"open": ["Function Set Submodule", "LinearMap", "Set", "LinearEquiv"], "variables": ["{R : Type*}", "{\u03b7 : Type*} {\u03b9s : \u03b7 \u2192 Type*} {Ms : \u03b7 \u2192 Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (Ms i)] [\u2200 i, Module R (Ms i)]", "[Fintype \u03b7]", "[Finite \u03b7]", "(R \u03b7)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b7 : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Fintype \u03b7\ninst\u271d : Finite \u03b7\nx : \u03b7 \u2192 R\ni : \u03b7\n\u22a2 ((Pi.basisFun R \u03b7).repr x) i = x i"}, {"line": "simp [basisFun]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_of_mem_unitary {A : Matrix n n \u03b1} (hA : A \u2208 Matrix.unitaryGroup n \u03b1) :\n    A.det \u2208 unitary \u03b1 := by\n  constructor\n  \u00b7 simpa [star, det_transpose] using congr_arg det hA.1\n  \u00b7 simpa [star, det_transpose] using congr_arg det hA.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/UnitaryGroup.lean", "context": {"open": ["LinearMap Matrix"], "variables": ["(n : Type u) [DecidableEq n] [Fintype n]", "(\u03b1 : Type v) [CommRing \u03b1] [StarRing \u03b1]", "{n : Type u} [DecidableEq n] [Fintype n]", "{\u03b1 : Type v} [CommRing \u03b1] [StarRing \u03b1] {A : Matrix n n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 A.det \u2208 unitary \u03b1"}, {"line": "constructor", "tactic_state": "case left\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 star A.det * A.det = 1\n---\ncase right\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 A.det * star A.det = 1"}, {"line": "\u00b7 simpa [star, det_transpose] using congr_arg det hA.1", "tactic_state": "case right\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 A.det * star A.det = 1"}, {"line": "\u00b7 simpa [star, det_transpose] using congr_arg det hA.2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma vandermonde_eq_projVandermonde (v : Fin n \u2192 R) : vandermonde v = projVandermonde v 1 := by\n  simp [projVandermonde, rectVandermonde, vandermonde]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 vandermonde v = projVandermonde v 1"}, {"line": "simp [projVandermonde, rectVandermonde, vandermonde]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 (fun i j => v i ^ \u2191j) = fun i j => v i ^ \u2191j * 1 ^ (n - (\u2191j + 1))"}]}
{"declaration": "theorem vandermonde_cons (v0 : R) (v : Fin n \u2192 R) :\n    vandermonde (Fin.cons v0 v : Fin n.succ \u2192 R) =\n      Fin.cons (fun (j : Fin n.succ) => v0 ^ (j : \u2115)) fun i => Fin.cons 1\n      fun j => v i * vandermonde v i j := by\n  ext i j\n  refine Fin.cases (by simp) (fun i => ?_) i\n  refine Fin.cases (by simp) (fun j => ?_) j\n  simp [pow_succ']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv0 : R\nv : Fin n \u2192 R\n\u22a2 vandermonde (Fin.cons v0 v) = Fin.cons (fun j => v0 ^ \u2191j) fun i => Fin.cons 1 fun j => v i * vandermonde v i j"}, {"line": "ext i j", "tactic_state": "case a\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv0 : R\nv : Fin n \u2192 R\ni j : Fin (n + 1)\n\u22a2 vandermonde (Fin.cons v0 v) i j =\n    Fin.cons (fun j => v0 ^ \u2191j) (fun i => Fin.cons 1 fun j => v i * vandermonde v i j) i j"}, {"line": "refine Fin.cases (by simp) (fun i => ?_) i", "tactic_state": "case a\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv0 : R\nv : Fin n \u2192 R\ni\u271d j : Fin (n + 1)\ni : Fin n\n\u22a2 vandermonde (Fin.cons v0 v) i.succ j =\n    Fin.cons (fun j => v0 ^ \u2191j) (fun i => Fin.cons 1 fun j => v i * vandermonde v i j) i.succ j"}, {"line": "refine Fin.cases (by simp) (fun j => ?_) j", "tactic_state": "case a\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv0 : R\nv : Fin n \u2192 R\ni\u271d j\u271d : Fin (n + 1)\ni j : Fin n\n\u22a2 vandermonde (Fin.cons v0 v) i.succ j.succ =\n    Fin.cons (fun j => v0 ^ \u2191j) (fun i => Fin.cons 1 fun j => v i * vandermonde v i j) i.succ j.succ"}, {"line": "simp [pow_succ']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vandermonde_succ (v : Fin n.succ \u2192 R) :\n    vandermonde v = .of\n      Fin.cons (fun (j : Fin n.succ) => v 0 ^ (j : \u2115)) fun i =>\n        Fin.cons 1 fun j => v i.succ * vandermonde (Fin.tail v) i j := by\n  conv_lhs => rw [\u2190 Fin.cons_self_tail v, vandermonde_cons]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n.succ \u2192 R\n\u22a2 vandermonde v = of Fin.cons (fun j => v 0 ^ \u2191j) fun i => Fin.cons 1 fun j => v i.succ * vandermonde (tail v) i j"}, {"line": "conv_lhs => rw [\u2190 Fin.cons_self_tail v, vandermonde_cons]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n.succ \u2192 R\n\u22a2 (Fin.cons (fun j => v 0 ^ \u2191j) fun i => Fin.cons 1 fun j => tail v i * vandermonde (tail v) i j) =\n    of Fin.cons (fun j => v 0 ^ \u2191j) fun i => Fin.cons 1 fun j => v i.succ * vandermonde (tail v) i j"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem projVandermonde_map {R' : Type*} [CommRing R'] (\u03c6 : R \u2192+* R') (v w : Fin n \u2192 R) :\n    projVandermonde (fun i \u21a6 \u03c6 (v i)) (fun i \u21a6 \u03c6 (w i)) = \u03c6.mapMatrix (projVandermonde v w) := by\n  ext i j\n  simp [projVandermonde_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\nR' : Type u_3\ninst\u271d : CommRing R'\n\u03c6 : R \u2192+* R'\nv w : Fin n \u2192 R\n\u22a2 (projVandermonde (fun i => \u03c6 (v i)) fun i => \u03c6 (w i)) = \u03c6.mapMatrix (projVandermonde v w)"}, {"line": "ext i j", "tactic_state": "case a\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\nR' : Type u_3\ninst\u271d : CommRing R'\n\u03c6 : R \u2192+* R'\nv w : Fin n \u2192 R\ni j : Fin n\n\u22a2 projVandermonde (fun i => \u03c6 (v i)) (fun i => \u03c6 (w i)) i j = \u03c6.mapMatrix (projVandermonde v w) i j"}, {"line": "simp [projVandermonde_apply]", "tactic_state": "case a\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\nR' : Type u_3\ninst\u271d : CommRing R'\n\u03c6 : R \u2192+* R'\nv w : Fin n \u2192 R\ni j : Fin n\n\u22a2 \u03c6 (v i) ^ \u2191j * \u03c6 (w i) ^ (n - (\u2191j + 1)) = \u03c6 (v i ^ \u2191j) * \u03c6 (w i ^ (n - (\u2191j + 1)))"}]}
{"declaration": "theorem det_vandermonde (v : Fin n \u2192 R) :\n    det (vandermonde v) = \u220f i : Fin n, \u220f j \u2208 Ioi i, (v j - v i) := by\n  simp [vandermonde_eq_projVandermonde, det_projVandermonde]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 (vandermonde v).det = \u220f i, \u220f j \u2208 Ioi i, (v j - v i)"}, {"line": "simp [vandermonde_eq_projVandermonde, det_projVandermonde]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 \u220f x, \u220f x_1 \u2208 Ioi x, (v x_1 * 1 - v x * 1) = \u220f i, \u220f j \u2208 Ioi i, (v j - v i)"}]}
{"declaration": "theorem det_vandermonde_add (v : Fin n \u2192 R) (a : R) :\n    (Matrix.vandermonde fun i \u21a6 v i + a).det = (Matrix.vandermonde v).det := by\n  simp [Matrix.det_vandermonde]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Vandermonde.lean", "context": {"open": ["Equiv Finset", "Matrix Fin"], "variables": ["{R K : Type*} [CommRing R] [Field K] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nv : Fin n \u2192 R\na : R\n\u22a2 (vandermonde fun i => v i + a).det = (vandermonde v).det"}, {"line": "simp [Matrix.det_vandermonde]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AffineIndependent.card_le_finrank_succ [Fintype \u03b9] {p : \u03b9 \u2192 P} (hp : AffineIndependent k p) :\n    Fintype.card \u03b9 \u2264 Module.finrank k (vectorSpan k (Set.range p)) + 1 := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 simp [Fintype.card_eq_zero]\n  rw [\u2190 tsub_le_iff_right]\n  exact (affineIndependent_iff_le_finrank_vectorSpan _ _\n    (tsub_add_cancel_of_le <| Nat.one_le_iff_ne_zero.2 Fintype.card_ne_zero).symm).1 hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "context": {"open": ["Affine", "scoped Finset", "AffineSubspace Module"], "variables": ["(k : Type*) {V : Type*} {P : Type*}", "{\u03b9 : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "{k}", "(k)", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\n\u03b9 : Type u_4\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\ninst\u271d : Fintype \u03b9\np : \u03b9 \u2192 P\nhp : AffineIndependent k p\n\u22a2 Fintype.card \u03b9 \u2264 finrank k \u21a5(vectorSpan k (Set.range p)) + 1"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\nk : Type u_1\nV : Type u_2\nP : Type u_3\n\u03b9 : Type u_4\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\ninst\u271d : Fintype \u03b9\np : \u03b9 \u2192 P\nhp : AffineIndependent k p\nh\u271d : IsEmpty \u03b9\n\u22a2 Fintype.card \u03b9 \u2264 finrank k \u21a5(vectorSpan k (Set.range p)) + 1\n---\ncase inr\nk : Type u_1\nV : Type u_2\nP : Type u_3\n\u03b9 : Type u_4\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\ninst\u271d : Fintype \u03b9\np : \u03b9 \u2192 P\nhp : AffineIndependent k p\nh\u271d : Nonempty \u03b9\n\u22a2 Fintype.card \u03b9 \u2264 finrank k \u21a5(vectorSpan k (Set.range p)) + 1"}, {"line": "\u00b7 simp [Fintype.card_eq_zero]", "tactic_state": "case inr\nk : Type u_1\nV : Type u_2\nP : Type u_3\n\u03b9 : Type u_4\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\ninst\u271d : Fintype \u03b9\np : \u03b9 \u2192 P\nhp : AffineIndependent k p\nh\u271d : Nonempty \u03b9\n\u22a2 Fintype.card \u03b9 \u2264 finrank k \u21a5(vectorSpan k (Set.range p)) + 1"}, {"line": "rw [\u2190 tsub_le_iff_right]", "tactic_state": "case inr\nk : Type u_1\nV : Type u_2\nP : Type u_3\n\u03b9 : Type u_4\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\ninst\u271d : Fintype \u03b9\np : \u03b9 \u2192 P\nhp : AffineIndependent k p\nh\u271d : Nonempty \u03b9\n\u22a2 Fintype.card \u03b9 - 1 \u2264 finrank k \u21a5(vectorSpan k (Set.range p))"}, {"line": "exact (affineIndependent_iff_le_finrank_vectorSpan _ _\n    (tsub_add_cancel_of_le <| Nat.one_le_iff_ne_zero.2 Fintype.card_ne_zero).symm).1 hp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne\u2081\u2082_of_not_collinear {p\u2081 p\u2082 p\u2083 : P} (h : \u00acCollinear k ({p\u2081, p\u2082, p\u2083} : Set P)) :\n    p\u2081 \u2260 p\u2082 := by\n  rintro rfl\n  simp [collinear_pair] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "context": {"open": ["Affine", "scoped Finset", "AffineSubspace Module", "Finset in", "Finset in"], "variables": ["(k : Type*) {V : Type*} {P : Type*}", "{\u03b9 : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "{k}", "(k)", "{k}", "(k)", "{k}", "(k P)", "{P}", "{k}", "(k) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\np\u2081 p\u2082 p\u2083 : P\nh : \u00acsorry\n\u22a2 p\u2081 \u2260 p\u2082"}, {"line": "rintro rfl", "tactic_state": "P : Type u_2\np\u2081 p\u2083 : P\nh : \u00acsorry\n\u22a2 False"}, {"line": "simp [collinear_pair] at h", "tactic_state": "P : Type u_2\np\u2081 p\u2083 : P\nh : \u00acsorry ()\n\u22a2 False"}]}
{"declaration": "theorem ne\u2081\u2083_of_not_collinear {p\u2081 p\u2082 p\u2083 : P} (h : \u00acCollinear k ({p\u2081, p\u2082, p\u2083} : Set P)) :\n    p\u2081 \u2260 p\u2083 := by\n  rintro rfl\n  simp [collinear_pair] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "context": {"open": ["Affine", "scoped Finset", "AffineSubspace Module", "Finset in", "Finset in"], "variables": ["(k : Type*) {V : Type*} {P : Type*}", "{\u03b9 : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "{k}", "(k)", "{k}", "(k)", "{k}", "(k P)", "{P}", "{k}", "(k) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\np\u2081 p\u2082 p\u2083 : P\nh : \u00acsorry\n\u22a2 p\u2081 \u2260 p\u2083"}, {"line": "rintro rfl", "tactic_state": "P : Type u_2\np\u2081 p\u2082 : P\nh : \u00acsorry\n\u22a2 False"}, {"line": "simp [collinear_pair] at h", "tactic_state": "P : Type u_2\np\u2081 p\u2082 : P\nh : \u00acsorry ()\n\u22a2 False"}]}
{"declaration": "theorem ne\u2082\u2083_of_not_collinear {p\u2081 p\u2082 p\u2083 : P} (h : \u00acCollinear k ({p\u2081, p\u2082, p\u2083} : Set P)) :\n    p\u2082 \u2260 p\u2083 := by\n  rintro rfl\n  simp [collinear_pair] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "context": {"open": ["Affine", "scoped Finset", "AffineSubspace Module", "Finset in", "Finset in"], "variables": ["(k : Type*) {V : Type*} {P : Type*}", "{\u03b9 : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "{k}", "(k)", "{k}", "(k)", "{k}", "(k P)", "{P}", "{k}", "(k) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\np\u2081 p\u2082 p\u2083 : P\nh : \u00acsorry\n\u22a2 p\u2082 \u2260 p\u2083"}, {"line": "rintro rfl", "tactic_state": "P : Type u_2\np\u2081 p\u2082 : P\nh : \u00acsorry\n\u22a2 False"}, {"line": "simp [collinear_pair] at h", "tactic_state": "P : Type u_2\np\u2081 p\u2082 : P\nh : \u00acsorry ()\n\u22a2 False"}]}
{"declaration": "theorem finrank_vectorSpan_insert_le_set (s : Set P) (p : P) :\n    finrank k (vectorSpan k (insert p s)) \u2264 finrank k (vectorSpan k s) + 1 := by\n  rw [\u2190 direction_affineSpan]\n  rw [\u2190 affineSpan_insert_affineSpan]\n  rw [direction_affineSpan]\n  refine (finrank_vectorSpan_insert_le _ _).trans (add_le_add_right ?_ _)\n  rw [direction_affineSpan]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "context": {"open": ["Affine", "scoped Finset", "AffineSubspace Module", "Finset in", "Finset in", "AffineSubspace Module Module"], "variables": ["(k : Type*) {V : Type*} {P : Type*}", "{\u03b9 : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "{k}", "(k)", "{k}", "(k)", "{k}", "(k P)", "{P}", "{k}", "(k) in", "(k) in", "(k) (P)", "{P}", "{k}", "{k : Type*} {V : Type*} {P : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "(k) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\np : P\n\u22a2 finrank k \u21a5(vectorSpan k (insert p s)) \u2264 finrank k \u21a5(vectorSpan k s) + 1"}, {"line": "rw [\u2190 direction_affineSpan]", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\np : P\n\u22a2 finrank k \u21a5(affineSpan k (insert p s)).direction \u2264 finrank k \u21a5(vectorSpan k s) + 1"}, {"line": "rw [\u2190 affineSpan_insert_affineSpan]", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\np : P\n\u22a2 finrank k \u21a5(affineSpan k (insert p \u2191(affineSpan k s))).direction \u2264 finrank k \u21a5(vectorSpan k s) + 1"}, {"line": "rw [direction_affineSpan]", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\np : P\n\u22a2 finrank k \u21a5(vectorSpan k (insert p \u2191(affineSpan k s))) \u2264 finrank k \u21a5(vectorSpan k s) + 1"}, {"line": "refine (finrank_vectorSpan_insert_le _ _).trans (add_le_add_right ?_ _)", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\np : P\n\u22a2 finrank k \u21a5(affineSpan k s).direction \u2264 finrank k \u21a5(vectorSpan k s)"}, {"line": "rw [direction_affineSpan]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Collinear.coplanar_insert {s : Set P} (h : Collinear k s) (p : P) :\n    Coplanar k (insert p s) := by\n  have : FiniteDimensional k { x // x \u2208 vectorSpan k s } := h.finiteDimensional_vectorSpan\n  rw [coplanar_iff_finrank_le_two]\n  exact (finrank_vectorSpan_insert_le_set k s p).trans (add_le_add_right h.finrank_le_one _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "context": {"open": ["Affine", "scoped Finset", "AffineSubspace Module", "Finset in", "Finset in", "AffineSubspace Module Module"], "variables": ["(k : Type*) {V : Type*} {P : Type*}", "{\u03b9 : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "{k}", "(k)", "{k}", "(k)", "{k}", "(k P)", "{P}", "{k}", "(k) in", "(k) in", "(k) (P)", "{P}", "{k}", "{k : Type*} {V : Type*} {P : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "(k) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : Collinear k s\np : P\n\u22a2 Coplanar k (insert p s)"}, {"line": "have : FiniteDimensional k { x // x \u2208 vectorSpan k s } := h.finiteDimensional_vectorSpan", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : Collinear k s\np : P\nthis : sorry\n\u22a2 Coplanar k (insert p s)"}, {"line": "rw [coplanar_iff_finrank_le_two]", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : Collinear k s\np : P\nthis : sorry\n\u22a2 finrank k \u21a5(vectorSpan k (insert p s)) \u2264 2\n---\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : Collinear k s\np : P\nthis : sorry\n\u22a2 FiniteDimensional k \u21a5(vectorSpan k (insert p s))"}, {"line": "exact (finrank_vectorSpan_insert_le_set k s p).trans (add_le_add_right h.finrank_le_one _)", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : Collinear k s\np : P\nthis : sorry\n\u22a2 FiniteDimensional k \u21a5(vectorSpan k (insert p s))"}]}
{"declaration": "theorem coplanar_of_finrank_eq_two (s : Set P) (h : finrank k V = 2) : Coplanar k s := by\n  have : FiniteDimensional k V := .of_finrank_eq_succ h\n  rw [coplanar_iff_finrank_le_two]\n  rw [\u2190 h]\n  exact Submodule.finrank_le _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "context": {"open": ["Affine", "scoped Finset", "AffineSubspace Module", "Finset in", "Finset in", "AffineSubspace Module Module"], "variables": ["(k : Type*) {V : Type*} {P : Type*}", "{\u03b9 : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "{k}", "(k)", "{k}", "(k)", "{k}", "(k P)", "{P}", "{k}", "(k) in", "(k) in", "(k) (P)", "{P}", "{k}", "{k : Type*} {V : Type*} {P : Type*}", "[DivisionRing k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "(k) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : finrank k V = 2\n\u22a2 Coplanar k s"}, {"line": "have : FiniteDimensional k V := .of_finrank_eq_succ h", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : finrank k V = 2\nthis : sorry\n\u22a2 Coplanar k s"}, {"line": "rw [coplanar_iff_finrank_le_two]", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : finrank k V = 2\nthis : sorry\n\u22a2 finrank k \u21a5(vectorSpan k s) \u2264 2\n---\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : finrank k V = 2\nthis : sorry\n\u22a2 FiniteDimensional k \u21a5(vectorSpan k s)"}, {"line": "rw [\u2190 h]", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : finrank k V = 2\nthis : sorry\n\u22a2 finrank k \u21a5(vectorSpan k s) \u2264 finrank k V\n---\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : finrank k V = 2\nthis : sorry\n\u22a2 FiniteDimensional k \u21a5(vectorSpan k s)"}, {"line": "exact Submodule.finrank_le _", "tactic_state": "k : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : Set P\nh : finrank k V = 2\nthis : sorry\n\u22a2 FiniteDimensional k \u21a5(vectorSpan k s)"}]}
{"declaration": "theorem toMatrix_row_sum_one [Fintype \u03b9] (q : \u03b9' \u2192 P) (i : \u03b9') : \u2211 j, b.toMatrix q i j = 1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Matrix.lean", "context": {"open": ["Affine Matrix", "Set"], "variables": ["{\u03b9 : Type u\u2081} {k : Type u\u2082} {V : Type u\u2083} {P : Type u\u2084}", "[AddCommGroup V] [AffineSpace V P]", "[Ring k] [Module k V] (b : AffineBasis \u03b9 k P)", "{\u03b9' : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\u2081\nk : Type u\u2082\nV : Type u\u2083\nP : Type u\u2084\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\n\u03b9' : Type u_1\ninst\u271d : Fintype \u03b9\nq : \u03b9' \u2192 P\ni : \u03b9'\n\u22a2 \u2211 j, b.toMatrix q i j = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_smul_slope_vadd (f : k \u2192 PE) (a b : k) : (b - a) \u2022 slope f a b +\u1d65 f a = f b := by\n  rw [sub_smul_slope]\n  rw [vsub_vadd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Slope.lean", "context": {"open": ["AffineMap"], "variables": ["{k E PE : Type*} [Field k] [AddCommGroup E] [Module k E] [AddTorsor E PE]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 PE\na b : k\n\u22a2 (b - a) \u2022 slope f a b +\u1d65 f a = f b"}, {"line": "rw [sub_smul_slope]", "tactic_state": "k : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 PE\na b : k\n\u22a2 (f b -\u1d65 f a) +\u1d65 f a = f b"}, {"line": "rw [vsub_vadd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem slope_vadd_const (f : k \u2192 E) (c : PE) : (slope fun x => f x +\u1d65 c) = slope f := by\n  ext a b\n  simp only [slope]\n  simp only [vadd_vsub_vadd_cancel_right]\n  simp only [vsub_eq_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Slope.lean", "context": {"open": ["AffineMap"], "variables": ["{k E PE : Type*} [Field k] [AddCommGroup E] [Module k E] [AddTorsor E PE]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 E\nc : PE\n\u22a2 (slope fun x => f x +\u1d65 c) = slope f"}, {"line": "ext a b", "tactic_state": "case h.h\nk : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 E\nc : PE\na b : k\n\u22a2 slope (fun x => f x +\u1d65 c) a b = slope f a b"}, {"line": "simp only [slope]", "tactic_state": "case h.h\nk : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 E\nc : PE\na b : k\n\u22a2 (b - a)\u207b\u00b9 \u2022 ((f b +\u1d65 c) -\u1d65 (f a +\u1d65 c)) = (b - a)\u207b\u00b9 \u2022 (f b -\u1d65 f a)"}, {"line": "simp only [vadd_vsub_vadd_cancel_right]", "tactic_state": "case h.h\nk : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 E\nc : PE\na b : k\n\u22a2 (b - a)\u207b\u00b9 \u2022 (f b - f a) = (b - a)\u207b\u00b9 \u2022 (f b -\u1d65 f a)"}, {"line": "simp only [vsub_eq_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem slope_sub_smul (f : k \u2192 E) {a b : k} (h : a \u2260 b) :\n    slope (fun x => (x - a) \u2022 f x) a b = f b := by\n  simp [slope, inv_smul_smul\u2080 (sub_ne_zero.2 h.symm)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Slope.lean", "context": {"open": ["AffineMap"], "variables": ["{k E PE : Type*} [Field k] [AddCommGroup E] [Module k E] [AddTorsor E PE]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : Field k\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module k E\nf : k \u2192 E\na b : k\nh : a \u2260 b\n\u22a2 slope (fun x => (x - a) \u2022 f x) a b = f b"}, {"line": "simp [slope, inv_smul_smul\u2080 (sub_ne_zero.2 h.symm)]", "tactic_state": "k : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : Field k\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module k E\nf : k \u2192 E\na b : k\nh : a \u2260 b\n\u22a2 (b - a)\u207b\u00b9 \u2022 ((b - a) \u2022 f b - 0 \u2022 f a) = f b"}]}
{"declaration": "theorem lineMap_slope_slope_sub_div_sub (f : k \u2192 PE) (a b c : k) (h : a \u2260 c) :\n    lineMap (slope f a b) (slope f b c) ((c - b) / (c - a)) = slope f a c := by\n  field_simp [sub_ne_zero.2 h.symm, \u2190 sub_div_sub_smul_slope_add_sub_div_sub_smul_slope f a b c,\n    lineMap_apply_module]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Slope.lean", "context": {"open": ["AffineMap"], "variables": ["{k E PE : Type*} [Field k] [AddCommGroup E] [Module k E] [AddTorsor E PE]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 PE\na b c : k\nh : a \u2260 c\n\u22a2 (lineMap (slope f a b) (slope f b c)) ((c - b) / (c - a)) = slope f a c"}, {"line": "field_simp [sub_ne_zero.2 h.symm, \u2190 sub_div_sub_smul_slope_add_sub_div_sub_smul_slope f a b c,\n    lineMap_apply_module]", "tactic_state": "k : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 PE\na b c : k\nh : a \u2260 c\n\u22a2 ((1 * (c - a) - (c - b)) / (c - a)) \u2022 slope f a b + ((c - b) / (c - a)) \u2022 slope f b c = slope f a c"}]}
{"declaration": "theorem apply_eq_iff_eq (e : P\u2081 \u2243\u1d43[k] P\u2082) {p\u2081 p\u2082 : P\u2081} : e p\u2081 = e p\u2082 \u2194 p\u2081 = p\u2082 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "context": {"open": ["Function Set", "Affine"], "variables": ["{k P\u2081 P\u2082 P\u2083 P\u2084 V\u2081 V\u2082 V\u2083 V\u2084 : Type*} [Ring k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P\u2081 : Type u_2\ne : sorry\np\u2081 p\u2082 : P\u2081\n\u22a2 sorry = sorry \u2194 p\u2081 = p\u2082"}, {"line": "simp", "tactic_state": "P\u2081 : Type u_2\ne : sorry\np\u2081 p\u2082 : P\u2081\n\u22a2 sorry () = sorry () \u2194 p\u2081 = p\u2082"}]}
{"declaration": "theorem homothety_neg_one_apply (c p : P\u2081) : homothety c (-1 : R') p = pointReflection R' c p := by\n  simp [homothety_apply, Equiv.pointReflection_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "context": {"open": ["Function Set", "Affine", "Function", "AffineEquiv"], "variables": ["{k P\u2081 P\u2082 P\u2083 P\u2084 V\u2081 V\u2082 V\u2083 V\u2084 : Type*} [Ring k]", "(k P\u2081)", "{k P\u2081}", "(k)", "(P\u2081)", "{R V P : Type*} [CommRing R] [AddCommGroup V] [Module R V] [AffineSpace V P]", "{P\u2081}", "{R' : Type*} [CommRing R'] [Module R' V\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P\u2081 : Type u_2\nx\u271d : Sort u_13\nhomothety : x\u271d\nR' : Type u_14\nc p : P\u2081\n\u22a2 sorry = sorry"}, {"line": "simp [homothety_apply, Equiv.pointReflection_apply]", "tactic_state": "P\u2081 : Type u_2\nx\u271d : Sort u_13\nhomothety : x\u271d\nR' : Type u_14\nc p : P\u2081\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem lineMap_same_apply (p : P1) (c : k) : lineMap p p c = p := by\n  simp [lineMap_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V\u2081 : Type*} {V\u2082 : Type*} [Ring k] [AddCommGroup V\u2081] [Module k V\u2081]", "{k : Type*} {V1 : Type*} {P1 : Type*} {V2 : Type*} {P2 : Type*} {V3 : Type*}", "(k P1)", "{k P1}", "{R : Type*} [Monoid R] [DistribMulAction R V2] [SMulCommClass k R V2]", "(k P1)", "{P1}", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_4\nP1 : Type u_6\nx\u271d : Sort u_10\nlineMap : x\u271d\np : P1\nc : k\n\u22a2 sorry = p"}, {"line": "simp [lineMap_apply]", "tactic_state": "k : Type u_4\nP1 : Type u_6\nx\u271d : Sort u_10\nlineMap : x\u271d\np : P1\nc : k\n\u22a2 sorry () = p"}]}
{"declaration": "theorem lineMap_apply_zero (p\u2080 p\u2081 : P1) : lineMap p\u2080 p\u2081 (0 : k) = p\u2080 := by\n  simp [lineMap_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V\u2081 : Type*} {V\u2082 : Type*} [Ring k] [AddCommGroup V\u2081] [Module k V\u2081]", "{k : Type*} {V1 : Type*} {P1 : Type*} {V2 : Type*} {P2 : Type*} {V3 : Type*}", "(k P1)", "{k P1}", "{R : Type*} [Monoid R] [DistribMulAction R V2] [SMulCommClass k R V2]", "(k P1)", "{P1}", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P1 : Type u_6\nx\u271d : Sort u_10\nlineMap : x\u271d\np\u2080 p\u2081 : P1\n\u22a2 sorry = p\u2080"}, {"line": "simp [lineMap_apply]", "tactic_state": "P1 : Type u_6\nx\u271d : Sort u_10\nlineMap : x\u271d\np\u2080 p\u2081 : P1\n\u22a2 sorry () = p\u2080"}]}
{"declaration": "theorem lineMap_apply_one (p\u2080 p\u2081 : P1) : lineMap p\u2080 p\u2081 (1 : k) = p\u2081 := by\n  simp [lineMap_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V\u2081 : Type*} {V\u2082 : Type*} [Ring k] [AddCommGroup V\u2081] [Module k V\u2081]", "{k : Type*} {V1 : Type*} {P1 : Type*} {V2 : Type*} {P2 : Type*} {V3 : Type*}", "(k P1)", "{k P1}", "{R : Type*} [Monoid R] [DistribMulAction R V2] [SMulCommClass k R V2]", "(k P1)", "{P1}", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P1 : Type u_6\nx\u271d : Sort u_10\nlineMap : x\u271d\np\u2080 p\u2081 : P1\n\u22a2 sorry = p\u2081"}, {"line": "simp [lineMap_apply]", "tactic_state": "P1 : Type u_6\nx\u271d : Sort u_10\nlineMap : x\u271d\np\u2080 p\u2081 : P1\n\u22a2 sorry () = p\u2081"}]}
{"declaration": "theorem apply_lineMap (f : P1 \u2192\u1d43[k] P2) (p\u2080 p\u2081 : P1) (c : k) :\n    f (lineMap p\u2080 p\u2081 c) = lineMap (f p\u2080) (f p\u2081) c := by\n  simp [lineMap_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V\u2081 : Type*} {V\u2082 : Type*} [Ring k] [AddCommGroup V\u2081] [Module k V\u2081]", "{k : Type*} {V1 : Type*} {P1 : Type*} {V2 : Type*} {P2 : Type*} {V3 : Type*}", "(k P1)", "{k P1}", "{R : Type*} [Monoid R] [DistribMulAction R V2] [SMulCommClass k R V2]", "(k P1)", "{P1}", "{k}", "(k) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_4\nP1 : Type u_6\nx\u271d : Sort u_10\nlineMap : x\u271d\nf : sorry\np\u2080 p\u2081 : P1\nc : k\n\u22a2 sorry = sorry"}, {"line": "simp [lineMap_apply]", "tactic_state": "k : Type u_4\nP1 : Type u_6\nx\u271d : Sort u_10\nlineMap : x\u271d\nf : sorry\np\u2080 p\u2081 : P1\nc : k\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem basisOf_apply (i : \u03b9) (j : { j : \u03b9 // j \u2260 i }) : b.basisOf i j = b \u2191j -\u1d65 b i := by\n  simp [basisOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "context": {"open": ["Affine Set", "scoped Pointwise"], "variables": ["{\u03b9 \u03b9' G G' k V P : Type*} [AddCommGroup V] [AffineSpace V P]", "[Ring k] [Module k V] (b : AffineBasis \u03b9 k P) {s : Finset \u03b9} {i j : \u03b9} (e : \u03b9 \u2243 \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 : Ring k\ninst\u271d : Module k V\nb : AffineBasis \u03b9 k P\ni : \u03b9\nj : { j // j \u2260 i }\n\u22a2 (b.basisOf i) j = b \u2191j -\u1d65 b i"}, {"line": "simp [basisOf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coord_apply [DecidableEq \u03b9] (i j : \u03b9) : b.coord i (b j) = if i = j then 1 else 0 := by\n  rcases eq_or_ne i j with h | h <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "context": {"open": ["Affine Set", "scoped Pointwise"], "variables": ["{\u03b9 \u03b9' G G' k V P : Type*} [AddCommGroup V] [AffineSpace V P]", "[Ring k] [Module k V] (b : AffineBasis \u03b9 k P) {s : Finset \u03b9} {i j : \u03b9} (e : \u03b9 \u2243 \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\n\u22a2 (b.coord i) (b j) = if i = j then 1 else 0"}, {"line": "rcases eq_or_ne i j with h | h <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univ_fin2 : (univ : Finset (Fin 2)) = {0, 1} := by\n  ext x\n  fin_cases x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "univ : Finset (Fin 2)\n\u22a2 univ = {0, 1}"}, {"line": "ext x", "tactic_state": "case h\nuniv : Finset (Fin 2)\nx : Fin 2\n\u22a2 x \u2208 univ \u2194 x \u2208 {0, 1}"}, {"line": "fin_cases x <;> simp", "tactic_state": "case h.\u00ab0\u00bb\nuniv : Finset (Fin 2)\n\u22a2 0 \u2208 univ\n---\ncase h.\u00ab1\u00bb\nuniv : Finset (Fin 2)\n\u22a2 1 \u2208 univ"}]}
{"declaration": "theorem weightedVSubOfPoint_apply (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (b : P) :\n    s.weightedVSubOfPoint p b w = \u2211 i \u2208 s, w i \u2022 (p i -\u1d65 b) := by\n  simp [weightedVSubOfPoint, LinearMap.sum_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\nw : \u03b9 \u2192 k\np : \u03b9 \u2192 P\nb : P\n\u22a2 (s.weightedVSubOfPoint p b) w = \u2211 i \u2208 s, w i \u2022 (p i -\u1d65 b)"}, {"line": "simp [weightedVSubOfPoint, LinearMap.sum_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma weightedVSubOfPoint_vadd (s : Finset \u03b9) (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (b : P) (v : V) :\n    s.weightedVSubOfPoint (v +\u1d65 p) b w = s.weightedVSubOfPoint p (-v +\u1d65 b) w := by\n  simp [vadd_vsub_assoc, vsub_vadd_eq_vsub_sub, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\nw : \u03b9 \u2192 k\np : \u03b9 \u2192 P\nb : P\nv : V\n\u22a2 (s.weightedVSubOfPoint (v +\u1d65 p) b) w = (s.weightedVSubOfPoint p (-v +\u1d65 b)) w"}, {"line": "simp [vadd_vsub_assoc, vsub_vadd_eq_vsub_sub, add_comm]", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\nw : \u03b9 \u2192 k\np : \u03b9 \u2192 P\nb : P\nv : V\n\u22a2 \u2211 x \u2208 s, w x \u2022 (v + (p x -\u1d65 b)) = \u2211 x \u2208 s, (w x \u2022 (p x -\u1d65 b) + w x \u2022 v)"}]}
{"declaration": "lemma weightedVSubOfPoint_smul {G : Type*} [Group G] [DistribMulAction G V] [SMulCommClass G k V]\n    (s : Finset \u03b9) (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 V) (b : V) (a : G) :\n    s.weightedVSubOfPoint (a \u2022 p) b w = a \u2022 s.weightedVSubOfPoint p (a\u207b\u00b9 \u2022 b) w := by\n  simp [smul_sum, smul_sub, smul_comm a (w _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\ninst\u271d\u2075 : Ring k\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module k V\n\u03b9 : Type u_4\nG : Type u_6\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G V\ninst\u271d : SMulCommClass G k V\ns : Finset \u03b9\nw : \u03b9 \u2192 k\np : \u03b9 \u2192 V\nb : V\na : G\n\u22a2 (s.weightedVSubOfPoint (a \u2022 p) b) w = a \u2022 (s.weightedVSubOfPoint p (a\u207b\u00b9 \u2022 b)) w"}, {"line": "simp [smul_sum, smul_sub, smul_comm a (w _)]", "tactic_state": "k : Type u_1\nV : Type u_2\ninst\u271d\u2075 : Ring k\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module k V\n\u03b9 : Type u_4\nG : Type u_6\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G V\ninst\u271d : SMulCommClass G k V\ns : Finset \u03b9\nw : \u03b9 \u2192 k\np : \u03b9 \u2192 V\nb : V\na : G\n\u22a2 \u2211 x \u2208 s, (w x \u2022 a \u2022 p x - w x \u2022 b) = a \u2022 \u2211 x \u2208 s, (w x \u2022 p x - w x \u2022 a\u207b\u00b9 \u2022 b)"}]}
{"declaration": "theorem weightedVSubOfPoint_eq_of_weights_eq (p : \u03b9 \u2192 P) (j : \u03b9) (w\u2081 w\u2082 : \u03b9 \u2192 k)\n    (hw : \u2200 i, i \u2260 j \u2192 w\u2081 i = w\u2082 i) :\n    s.weightedVSubOfPoint p (p j) w\u2081 = s.weightedVSubOfPoint p (p j) w\u2082 := by\n  simp only [Finset.weightedVSubOfPoint_apply]\n  congr\n  ext i\n  rcases eq_or_ne i j with h | h\n  \u00b7 simp [h]\n  \u00b7 simp [hw i h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\np : \u03b9 \u2192 P\nj : \u03b9\nw\u2081 w\u2082 : \u03b9 \u2192 k\nhw : \u2200 (i : \u03b9), i \u2260 j \u2192 w\u2081 i = w\u2082 i\n\u22a2 (s.weightedVSubOfPoint p (p j)) w\u2081 = (s.weightedVSubOfPoint p (p j)) w\u2082"}, {"line": "simp only [Finset.weightedVSubOfPoint_apply]", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\np : \u03b9 \u2192 P\nj : \u03b9\nw\u2081 w\u2082 : \u03b9 \u2192 k\nhw : \u2200 (i : \u03b9), i \u2260 j \u2192 w\u2081 i = w\u2082 i\n\u22a2 \u2211 i \u2208 s, w\u2081 i \u2022 (p i -\u1d65 p j) = \u2211 i \u2208 s, w\u2082 i \u2022 (p i -\u1d65 p j)"}, {"line": "congr", "tactic_state": "case e_f\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\np : \u03b9 \u2192 P\nj : \u03b9\nw\u2081 w\u2082 : \u03b9 \u2192 k\nhw : \u2200 (i : \u03b9), i \u2260 j \u2192 w\u2081 i = w\u2082 i\n\u22a2 (fun i => w\u2081 i \u2022 (p i -\u1d65 p j)) = fun i => w\u2082 i \u2022 (p i -\u1d65 p j)"}, {"line": "ext i", "tactic_state": "case e_f.h\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\np : \u03b9 \u2192 P\nj : \u03b9\nw\u2081 w\u2082 : \u03b9 \u2192 k\nhw : \u2200 (i : \u03b9), i \u2260 j \u2192 w\u2081 i = w\u2082 i\ni : \u03b9\n\u22a2 w\u2081 i \u2022 (p i -\u1d65 p j) = w\u2082 i \u2022 (p i -\u1d65 p j)"}, {"line": "rcases eq_or_ne i j with h | h", "tactic_state": "case e_f.h.inl\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\np : \u03b9 \u2192 P\nj : \u03b9\nw\u2081 w\u2082 : \u03b9 \u2192 k\nhw : \u2200 (i : \u03b9), i \u2260 j \u2192 w\u2081 i = w\u2082 i\ni : \u03b9\nh : i = j\n\u22a2 w\u2081 i \u2022 (p i -\u1d65 p j) = w\u2082 i \u2022 (p i -\u1d65 p j)\n---\ncase e_f.h.inr\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\np : \u03b9 \u2192 P\nj : \u03b9\nw\u2081 w\u2082 : \u03b9 \u2192 k\nhw : \u2200 (i : \u03b9), i \u2260 j \u2192 w\u2081 i = w\u2082 i\ni : \u03b9\nh : i \u2260 j\n\u22a2 w\u2081 i \u2022 (p i -\u1d65 p j) = w\u2082 i \u2022 (p i -\u1d65 p j)"}, {"line": "\u00b7 simp [h]", "tactic_state": "case e_f.h.inr\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\ns : Finset \u03b9\np : \u03b9 \u2192 P\nj : \u03b9\nw\u2081 w\u2082 : \u03b9 \u2192 k\nhw : \u2200 (i : \u03b9), i \u2260 j \u2192 w\u2081 i = w\u2082 i\ni : \u03b9\nh : i \u2260 j\n\u22a2 w\u2081 i \u2022 (p i -\u1d65 p j) = w\u2082 i \u2022 (p i -\u1d65 p j)"}, {"line": "\u00b7 simp [hw i h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem weightedVSub_empty (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) : (\u2205 : Finset \u03b9).weightedVSub p w = (0 : V) := by\n  simp [weightedVSub_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AddTorsor V P\n\u03b9 : Type u_4\nw : \u03b9 \u2192 k\np : \u03b9 \u2192 P\n\u22a2 (\u2205.weightedVSub p) w = 0"}, {"line": "simp [weightedVSub_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem weightedVSub_eq_linear_combination {\u03b9} (s : Finset \u03b9) {w : \u03b9 \u2192 k} {p : \u03b9 \u2192 V}\n    (hw : s.sum w = 0) : s.weightedVSub p w = \u2211 i \u2208 s, w i \u2022 p i := by\n  simp [s.weightedVSub_apply, vsub_eq_sub, smul_sub, \u2190 Finset.sum_smul, hw]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\n\u03b9 : Type u_6\ns : Finset \u03b9\nw : \u03b9 \u2192 k\np : \u03b9 \u2192 V\nhw : s.sum w = 0\n\u22a2 (s.weightedVSub p) w = \u2211 i \u2208 s, w i \u2022 p i"}, {"line": "simp [s.weightedVSub_apply, vsub_eq_sub, smul_sub, \u2190 Finset.sum_smul, hw]", "tactic_state": "k : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\n\u03b9 : Type u_6\ns : Finset \u03b9\nw : \u03b9 \u2192 k\np : \u03b9 \u2192 V\nhw : s.sum w = 0\n\u22a2 \u2211 x \u2208 s, (w x \u2022 p x - w x \u2022 Classical.choice \u22ef) = \u2211 i \u2208 s, w i \u2022 p i"}]}
{"declaration": "theorem weightedVSubVSubWeights_self [DecidableEq \u03b9] (i : \u03b9) :\n    weightedVSubVSubWeights k i i = 0 := by simp [weightedVSubVSubWeights]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nx\u271d : Sort u_6\nweightedVSubVSubWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\n\u22a2 sorry = 0"}, {"line": "simp [weightedVSubVSubWeights]", "tactic_state": "\u03b9 : Type u_4\nx\u271d : Sort u_6\nweightedVSubVSubWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem weightedVSubVSubWeights_apply_left [DecidableEq \u03b9] {i j : \u03b9} (h : i \u2260 j) :\n    weightedVSubVSubWeights k i j i = 1 := by simp [weightedVSubVSubWeights, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nx\u271d : Sort u_6\nweightedVSubVSubWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : i \u2260 j\n\u22a2 sorry = 1"}, {"line": "simp [weightedVSubVSubWeights, h]", "tactic_state": "\u03b9 : Type u_4\nx\u271d : Sort u_6\nweightedVSubVSubWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : i \u2260 j\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem weightedVSubVSubWeights_apply_right [DecidableEq \u03b9] {i j : \u03b9} (h : i \u2260 j) :\n    weightedVSubVSubWeights k i j j = -1 := by simp [weightedVSubVSubWeights, h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nx\u271d : Sort u_6\nweightedVSubVSubWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : i \u2260 j\n\u22a2 sorry = -1"}, {"line": "simp [weightedVSubVSubWeights, h.symm]", "tactic_state": "\u03b9 : Type u_4\nx\u271d : Sort u_6\nweightedVSubVSubWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : i \u2260 j\n\u22a2 sorry () = -1"}]}
{"declaration": "theorem weightedVSubVSubWeights_apply_of_ne [DecidableEq \u03b9] {i j t : \u03b9} (hi : t \u2260 i) (hj : t \u2260 j) :\n    weightedVSubVSubWeights k i j t = 0 := by simp [weightedVSubVSubWeights, hi, hj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nx\u271d : Sort u_6\nweightedVSubVSubWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j t : \u03b9\nhi : t \u2260 i\nhj : t \u2260 j\n\u22a2 sorry = 0"}, {"line": "simp [weightedVSubVSubWeights, hi, hj]", "tactic_state": "\u03b9 : Type u_4\nx\u271d : Sort u_6\nweightedVSubVSubWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j t : \u03b9\nhi : t \u2260 i\nhj : t \u2260 j\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem affineCombinationLineMapWeights_apply_left [DecidableEq \u03b9] {i j : \u03b9} (h : i \u2260 j) (c : k) :\n    affineCombinationLineMapWeights i j c i = 1 - c := by\n  simp [affineCombinationLineMapWeights, h.symm, sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Ring k\n\u03b9 : Type u_4\nx\u271d : Sort u_6\naffineCombinationLineMapWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : i \u2260 j\nc : k\n\u22a2 sorry = 1 - c"}, {"line": "simp [affineCombinationLineMapWeights, h.symm, sub_eq_neg_add]", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Ring k\n\u03b9 : Type u_4\nx\u271d : Sort u_6\naffineCombinationLineMapWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : i \u2260 j\nc : k\n\u22a2 sorry () = 1 - c"}]}
{"declaration": "theorem affineCombinationLineMapWeights_apply_right [DecidableEq \u03b9] {i j : \u03b9} (h : i \u2260 j) (c : k) :\n    affineCombinationLineMapWeights i j c j = c := by\n  simp [affineCombinationLineMapWeights, h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Ring k\n\u03b9 : Type u_4\nx\u271d : Sort u_6\naffineCombinationLineMapWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : i \u2260 j\nc : k\n\u22a2 sorry = c"}, {"line": "simp [affineCombinationLineMapWeights, h.symm]", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Ring k\n\u03b9 : Type u_4\nx\u271d : Sort u_6\naffineCombinationLineMapWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : i \u2260 j\nc : k\n\u22a2 sorry () = c"}]}
{"declaration": "theorem affineCombinationLineMapWeights_apply_of_ne [DecidableEq \u03b9] {i j t : \u03b9} (hi : t \u2260 i)\n    (hj : t \u2260 j) (c : k) : affineCombinationLineMapWeights i j c t = 0 := by\n  simp [affineCombinationLineMapWeights, hi, hj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Ring k\n\u03b9 : Type u_4\nx\u271d : Sort u_6\naffineCombinationLineMapWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j t : \u03b9\nhi : t \u2260 i\nhj : t \u2260 j\nc : k\n\u22a2 sorry = 0"}, {"line": "simp [affineCombinationLineMapWeights, hi, hj]", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Ring k\n\u03b9 : Type u_4\nx\u271d : Sort u_6\naffineCombinationLineMapWeights : x\u271d\ninst\u271d : DecidableEq \u03b9\ni j t : \u03b9\nhi : t \u2260 i\nhj : t \u2260 j\nc : k\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem centroid_singleton (p : \u03b9 \u2192 P) (i : \u03b9) : ({i} : Finset \u03b9).centroid k p = p i := by\n  simp [centroid_def, affineCombination_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)", "{k}", "(k)", "{k}", "(k : Type*) {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*} (s : Finset \u03b9) {\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "{k} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_6\nV : Type u_7\nP : Type u_8\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_9\np : \u03b9 \u2192 P\ni : \u03b9\n\u22a2 Finset.centroid k {i} p = p i"}, {"line": "simp [centroid_def, affineCombination_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem weightedVSub_mem_vectorSpan {s : Finset \u03b9} {w : \u03b9 \u2192 k} (h : \u2211 i \u2208 s, w i = 0)\n    (p : \u03b9 \u2192 P) : s.weightedVSub p w \u2208 vectorSpan k (Set.range p) := by\n  classical\n    rcases isEmpty_or_nonempty \u03b9 with (h\u03b9 | \u27e8\u27e8i0\u27e9\u27e9)\n    \u00b7 simp [Finset.eq_empty_of_isEmpty s]\n    \u00b7 rw [vectorSpan_range_eq_span_range_vsub_right k p i0, \u2190 Set.image_univ,\n        Finsupp.mem_span_image_iff_linearCombination,\n        Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s w p h (p i0),\n        Finset.weightedVSubOfPoint_apply]\n      let w' := Set.indicator (\u2191s) w\n      have hwx : \u2200 i, w' i \u2260 0 \u2192 i \u2208 s := fun i => Set.mem_of_indicator_ne_zero\n      use Finsupp.onFinset s w' hwx, Set.subset_univ _\n      rw [Finsupp.linearCombination_apply]\n      rw [Finsupp.onFinset_sum hwx]\n      \u00b7 apply Finset.sum_congr rfl\n        intro i hi\n        simp [w', Set.indicator_apply, if_pos hi]\n      \u00b7 exact fun _ => zero_smul k _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)", "{k}", "(k)", "{k}", "(k : Type*) {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*} (s : Finset \u03b9) {\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "{k} in", "{\u03b9 k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_6\nV : Type u_7\nP : Type u_8\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_9\ns : Finset \u03b9\nw : \u03b9 \u2192 k\nh : \u2211 i \u2208 s, w i = 0\np : \u03b9 \u2192 P\n\u22a2 (s.weightedVSub p) w \u2208 vectorSpan k (Set.range p)"}, {"line": "classical\n    rcases isEmpty_or_nonempty \u03b9 with (h\u03b9 | \u27e8\u27e8i0\u27e9\u27e9)\n    \u00b7 simp [Finset.eq_empty_of_isEmpty s]\n    \u00b7 rw [vectorSpan_range_eq_span_range_vsub_right k p i0, \u2190 Set.image_univ,\n        Finsupp.mem_span_image_iff_linearCombination,\n        Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s w p h (p i0),\n        Finset.weightedVSubOfPoint_apply]\n      let w' := Set.indicator (\u2191s) w\n      have hwx : \u2200 i, w' i \u2260 0 \u2192 i \u2208 s := fun i => Set.mem_of_indicator_ne_zero\n      use Finsupp.onFinset s w' hwx, Set.subset_univ _\n      rw [Finsupp.linearCombination_apply]\n      rw [Finsupp.onFinset_sum hwx]\n      \u00b7 apply Finset.sum_congr rfl\n        intro i hi\n        simp [w', Set.indicator_apply, if_pos hi]\n      \u00b7 exact fun _ => zero_smul k _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_vectorSpan_iff_eq_weightedVSub {v : V} {p : \u03b9 \u2192 P} :\n    v \u2208 vectorSpan k (Set.range p) \u2194\n      \u2203 (s : Finset \u03b9) (w : \u03b9 \u2192 k), \u2211 i \u2208 s, w i = 0 \u2227 v = s.weightedVSub p w := by\n  classical\n    constructor\n    \u00b7 rcases isEmpty_or_nonempty \u03b9 with (h\u03b9 | \u27e8\u27e8i0\u27e9\u27e9)\n      swap\n      \u00b7 rw [vectorSpan_range_eq_span_range_vsub_right k p i0, \u2190 Set.image_univ,\n          Finsupp.mem_span_image_iff_linearCombination]\n        rintro \u27e8l, _, hv\u27e9\n        use insert i0 l.support\n        set w :=\n          (l : \u03b9 \u2192 k) - Function.update (Function.const \u03b9 0 : \u03b9 \u2192 k) i0 (\u2211 i \u2208 l.support, l i) with\n          hwdef\n        use w\n        have hw : \u2211 i \u2208 insert i0 l.support, w i = 0 := by\n          rw [hwdef]\n          simp_rw [Pi.sub_apply, Finset.sum_sub_distrib,\n            Finset.sum_update_of_mem (Finset.mem_insert_self _ _),\n            Finset.sum_insert_of_eq_zero_if_not_mem Finsupp.not_mem_support_iff.1]\n          simp only [Finsupp.mem_support_iff]\n          simp only [ne_eq]\n          simp only [Finset.mem_insert]\n          simp only [true_or]\n          simp only [not_true]\n          simp only [Function.const_apply]\n          simp only [Finset.sum_const_zero]\n          simp only [add_zero]\n          simp only [sub_self]\n        use hw\n        have hz : w i0 \u2022 (p i0 -\u1d65 p i0 : V) = 0 := (vsub_self (p i0)).symm \u25b8 smul_zero _\n        change (fun i => w i \u2022 (p i -\u1d65 p i0 : V)) i0 = 0 at hz\n        rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero _ w p hw (p i0)]\n        rw [Finset.weightedVSubOfPoint_apply]\n        rw [\u2190 hv]\n        rw [Finsupp.linearCombination_apply]\n        rw [@Finset.sum_insert_zero _ _ l.support i0 _ _ _ hz]\n        change (\u2211 i \u2208 l.support, l i \u2022 _) = _\n        congr with i\n        by_cases h : i = i0\n        \u00b7 simp [h]\n        \u00b7 simp [hwdef, h]\n      \u00b7 rw [Set.range_eq_empty, vectorSpan_empty, Submodule.mem_bot]\n        rintro rfl\n        use \u2205\n        simp\n    \u00b7 rintro \u27e8s, w, hw, rfl\u27e9\n      exact weightedVSub_mem_vectorSpan hw p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)", "{k}", "(k)", "{k}", "(k : Type*) {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*} (s : Finset \u03b9) {\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "{k} in", "{\u03b9 k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "(k) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_6\nV : Type u_7\nP : Type u_8\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_9\nv : V\np : \u03b9 \u2192 P\n\u22a2 v \u2208 vectorSpan k (Set.range p) \u2194 \u2203 s w, \u2211 i \u2208 s, w i = 0 \u2227 v = (s.weightedVSub p) w"}, {"line": "classical\n    constructor\n    \u00b7 rcases isEmpty_or_nonempty \u03b9 with (h\u03b9 | \u27e8\u27e8i0\u27e9\u27e9)\n      swap\n      \u00b7 rw [vectorSpan_range_eq_span_range_vsub_right k p i0, \u2190 Set.image_univ,\n          Finsupp.mem_span_image_iff_linearCombination]\n        rintro \u27e8l, _, hv\u27e9\n        use insert i0 l.support\n        set w :=\n          (l : \u03b9 \u2192 k) - Function.update (Function.const \u03b9 0 : \u03b9 \u2192 k) i0 (\u2211 i \u2208 l.support, l i) with\n          hwdef\n        use w\n        have hw : \u2211 i \u2208 insert i0 l.support, w i = 0 := by\n          rw [hwdef]\n          simp_rw [Pi.sub_apply, Finset.sum_sub_distrib,\n            Finset.sum_update_of_mem (Finset.mem_insert_self _ _),\n            Finset.sum_insert_of_eq_zero_if_not_mem Finsupp.not_mem_support_iff.1]\n          simp only [Finsupp.mem_support_iff]\n          simp only [ne_eq]\n          simp only [Finset.mem_insert]\n          simp only [true_or]\n          simp only [not_true]\n          simp only [Function.const_apply]\n          simp only [Finset.sum_const_zero]\n          simp only [add_zero]\n          simp only [sub_self]\n        use hw\n        have hz : w i0 \u2022 (p i0 -\u1d65 p i0 : V) = 0 := (vsub_self (p i0)).symm \u25b8 smul_zero _\n        change (fun i => w i \u2022 (p i -\u1d65 p i0 : V)) i0 = 0 at hz\n        rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero _ w p hw (p i0)]\n        rw [Finset.weightedVSubOfPoint_apply]\n        rw [\u2190 hv]\n        rw [Finsupp.linearCombination_apply]\n        rw [@Finset.sum_insert_zero _ _ l.support i0 _ _ _ hz]\n        change (\u2211 i \u2208 l.support, l i \u2022 _) = _\n        congr with i\n        by_cases h : i = i0\n        \u00b7 simp [h]\n        \u00b7 simp [hwdef, h]\n      \u00b7 rw [Set.range_eq_empty, vectorSpan_empty, Submodule.mem_bot]\n        rintro rfl\n        use \u2205\n        simp\n    \u00b7 rintro \u27e8s, w, hw, rfl\u27e9\n      exact weightedVSub_mem_vectorSpan hw p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_affineSpan_iff_eq_affineCombination [Nontrivial k] {p1 : P} {p : \u03b9 \u2192 P} :\n    p1 \u2208 affineSpan k (Set.range p) \u2194\n      \u2203 (s : Finset \u03b9) (w : \u03b9 \u2192 k), \u2211 i \u2208 s, w i = 1 \u2227 p1 = s.affineCombination k p w := by\n  constructor\n  \u00b7 exact eq_affineCombination_of_mem_affineSpan\n  \u00b7 rintro \u27e8s, w, hw, rfl\u27e9\n    exact affineCombination_mem_affineSpan hw p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "context": {"open": ["Affine"], "variables": ["{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[S : AffineSpace V P]", "{\u03b9 : Type*} (s : Finset \u03b9)", "{\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "(k)", "{k}", "(k)", "(V)", "{k V}", "(k)", "{k}", "(k)", "{k}", "(k : Type*) {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*} (s : Finset \u03b9) {\u03b9\u2082 : Type*} (s\u2082 : Finset \u03b9\u2082)", "{k} in", "{\u03b9 k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]", "(k) in", "(k V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_6\nV : Type u_7\nP : Type u_8\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_9\ninst\u271d : Nontrivial k\np1 : P\np : \u03b9 \u2192 P\n\u22a2 p1 \u2208 affineSpan k (Set.range p) \u2194 \u2203 s w, \u2211 i \u2208 s, w i = 1 \u2227 p1 = (Finset.affineCombination k s p) w"}, {"line": "constructor", "tactic_state": "case mp\nk : Type u_6\nV : Type u_7\nP : Type u_8\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_9\ninst\u271d : Nontrivial k\np1 : P\np : \u03b9 \u2192 P\n\u22a2 p1 \u2208 affineSpan k (Set.range p) \u2192 \u2203 s w, \u2211 i \u2208 s, w i = 1 \u2227 p1 = (Finset.affineCombination k s p) w\n---\ncase mpr\nk : Type u_6\nV : Type u_7\nP : Type u_8\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_9\ninst\u271d : Nontrivial k\np1 : P\np : \u03b9 \u2192 P\n\u22a2 (\u2203 s w, \u2211 i \u2208 s, w i = 1 \u2227 p1 = (Finset.affineCombination k s p) w) \u2192 p1 \u2208 affineSpan k (Set.range p)"}, {"line": "\u00b7 exact eq_affineCombination_of_mem_affineSpan", "tactic_state": "case mpr\nk : Type u_6\nV : Type u_7\nP : Type u_8\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_9\ninst\u271d : Nontrivial k\np1 : P\np : \u03b9 \u2192 P\n\u22a2 (\u2203 s w, \u2211 i \u2208 s, w i = 1 \u2227 p1 = (Finset.affineCombination k s p) w) \u2192 p1 \u2208 affineSpan k (Set.range p)"}, {"line": "\u00b7 rintro \u27e8s, w, hw, rfl\u27e9\n    exact affineCombination_mem_affineSpan hw p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem affineIndependent_iff_linearIndependent_vsub (p : \u03b9 \u2192 P) (i1 : \u03b9) :\n    AffineIndependent k p \u2194 LinearIndependent k fun i : { x // x \u2260 i1 } => (p i -\u1d65 p i1 : V) := by\n  classical\n    constructor\n    \u00b7 intro h\n      rw [linearIndependent_iff']\n      intro s g hg i hi\n      set f : \u03b9 \u2192 k := fun x => if hx : x = i1 then -\u2211 y \u2208 s, g y else g \u27e8x, hx\u27e9 with hfdef\n      let s2 : Finset \u03b9 := insert i1 (s.map (Embedding.subtype _))\n      have hfg : \u2200 x : { x // x \u2260 i1 }, g x = f x := by\n        intro x\n        rw [hfdef]\n        dsimp only\n        rw [dif_neg x.property]\n        rw [Subtype.coe_eta]\n      rw [hfg]\n      have hf : \u2211 \u03b9 \u2208 s2, f \u03b9 = 0 := by\n        rw [Finset.sum_insert             (Finset.not_mem_map_subtype_of_not_property s (Classical.not_not.2 rfl))]\n        rw [Finset.sum_subtype_map_embedding fun x _ => (hfg x).symm]\n        rw [hfdef]\n        dsimp only\n        rw [dif_pos rfl]\n        exact neg_add_cancel _\n      have hs2 : s2.weightedVSub p f = (0 : V) := by\n        set f2 : \u03b9 \u2192 V := fun x => f x \u2022 (p x -\u1d65 p i1) with hf2def\n        set g2 : { x // x \u2260 i1 } \u2192 V := fun x => g x \u2022 (p x -\u1d65 p i1)\n        have hf2g2 : \u2200 x : { x // x \u2260 i1 }, f2 x = g2 x := by\n          simp only [g2]\n          simp only [hf2def]\n          refine fun x => ?_\n          rw [hfg]\n        rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s2 f p hf (p i1)]\n        rw [Finset.weightedVSubOfPoint_insert]\n        rw [Finset.weightedVSubOfPoint_apply]\n        rw [Finset.sum_subtype_map_embedding fun x _ => hf2g2 x]\n        exact hg\n      exact h s2 f hf hs2 i (Finset.mem_insert_of_mem (Finset.mem_map.2 \u27e8i, hi, rfl\u27e9))\n    \u00b7 intro h\n      rw [linearIndependent_iff'] at h\n      intro s w hw hs i hi\n      rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s w p hw (p i1)] at hs\n      rw [\u2190         s.weightedVSubOfPoint_erase w p i1] at hs\n      rw [Finset.weightedVSubOfPoint_apply] at hs\n      let f : \u03b9 \u2192 V := fun i => w i \u2022 (p i -\u1d65 p i1)\n      have hs2 : (\u2211 i \u2208 (s.erase i1).subtype fun i => i \u2260 i1, f i) = 0 := by\n        rw [\u2190 hs]\n        convert Finset.sum_subtype_of_mem f fun x => Finset.ne_of_mem_erase\n      have h2 := h ((s.erase i1).subtype fun i => i \u2260 i1) (fun x => w x) hs2\n      simp_rw [Finset.mem_subtype] at h2\n      have h2b : \u2200 i \u2208 s, i \u2260 i1 \u2192 w i = 0 := fun i his hi =>\n        h2 \u27e8i, hi\u27e9 (Finset.mem_erase_of_ne_of_mem hi his)\n      exact Finset.eq_zero_of_sum_eq_zero hw h2b i hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "context": {"open": ["Finset Function", "scoped Affine"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\ni1 : \u03b9\n\u22a2 AffineIndependent k p \u2194 LinearIndependent k fun i => p \u2191i -\u1d65 p i1"}, {"line": "classical\n    constructor\n    \u00b7 intro h\n      rw [linearIndependent_iff']\n      intro s g hg i hi\n      set f : \u03b9 \u2192 k := fun x => if hx : x = i1 then -\u2211 y \u2208 s, g y else g \u27e8x, hx\u27e9 with hfdef\n      let s2 : Finset \u03b9 := insert i1 (s.map (Embedding.subtype _))\n      have hfg : \u2200 x : { x // x \u2260 i1 }, g x = f x := by\n        intro x\n        rw [hfdef]\n        dsimp only\n        rw [dif_neg x.property]\n        rw [Subtype.coe_eta]\n      rw [hfg]\n      have hf : \u2211 \u03b9 \u2208 s2, f \u03b9 = 0 := by\n        rw [Finset.sum_insert             (Finset.not_mem_map_subtype_of_not_property s (Classical.not_not.2 rfl))]\n        rw [Finset.sum_subtype_map_embedding fun x _ => (hfg x).symm]\n        rw [hfdef]\n        dsimp only\n        rw [dif_pos rfl]\n        exact neg_add_cancel _\n      have hs2 : s2.weightedVSub p f = (0 : V) := by\n        set f2 : \u03b9 \u2192 V := fun x => f x \u2022 (p x -\u1d65 p i1) with hf2def\n        set g2 : { x // x \u2260 i1 } \u2192 V := fun x => g x \u2022 (p x -\u1d65 p i1)\n        have hf2g2 : \u2200 x : { x // x \u2260 i1 }, f2 x = g2 x := by\n          simp only [g2]\n          simp only [hf2def]\n          refine fun x => ?_\n          rw [hfg]\n        rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s2 f p hf (p i1)]\n        rw [Finset.weightedVSubOfPoint_insert]\n        rw [Finset.weightedVSubOfPoint_apply]\n        rw [Finset.sum_subtype_map_embedding fun x _ => hf2g2 x]\n        exact hg\n      exact h s2 f hf hs2 i (Finset.mem_insert_of_mem (Finset.mem_map.2 \u27e8i, hi, rfl\u27e9))\n    \u00b7 intro h\n      rw [linearIndependent_iff'] at h\n      intro s w hw hs i hi\n      rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s w p hw (p i1)] at hs\n      rw [\u2190         s.weightedVSubOfPoint_erase w p i1] at hs\n      rw [Finset.weightedVSubOfPoint_apply] at hs\n      let f : \u03b9 \u2192 V := fun i => w i \u2022 (p i -\u1d65 p i1)\n      have hs2 : (\u2211 i \u2208 (s.erase i1).subtype fun i => i \u2260 i1, f i) = 0 := by\n        rw [\u2190 hs]\n        convert Finset.sum_subtype_of_mem f fun x => Finset.ne_of_mem_erase\n      have h2 := h ((s.erase i1).subtype fun i => i \u2260 i1) (fun x => w x) hs2\n      simp_rw [Finset.mem_subtype] at h2\n      have h2b : \u2200 i \u2208 s, i \u2260 i1 \u2192 w i = 0 := fun i his hi =>\n        h2 \u27e8i, hi\u27e9 (Finset.mem_erase_of_ne_of_mem hi his)\n      exact Finset.eq_zero_of_sum_eq_zero hw h2b i hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem affineIndependent_iff_indicator_eq_of_affineCombination_eq (p : \u03b9 \u2192 P) :\n    AffineIndependent k p \u2194\n      \u2200 (s1 s2 : Finset \u03b9) (w1 w2 : \u03b9 \u2192 k),\n        \u2211 i \u2208 s1, w1 i = 1 \u2192\n          \u2211 i \u2208 s2, w2 i = 1 \u2192\n            s1.affineCombination k p w1 = s2.affineCombination k p w2 \u2192\n              Set.indicator (\u2191s1) w1 = Set.indicator (\u2191s2) w2 := by\n  classical\n    constructor\n    \u00b7 intro ha s1 s2 w1 w2 hw1 hw2 heq\n      ext i\n      by_cases hi : i \u2208 s1 \u222a s2\n      \u00b7 rw [\u2190 sub_eq_zero]\n        rw [\u2190 Finset.sum_indicator_subset w1 (s1.subset_union_left (s\u2082 := s2))] at hw1\n        rw [\u2190 Finset.sum_indicator_subset w2 (s1.subset_union_right)] at hw2\n        have hws : (\u2211 i \u2208 s1 \u222a s2, (Set.indicator (\u2191s1) w1 - Set.indicator (\u2191s2) w2) i) = 0 := by\n          simp [hw1, hw2]\n        rw [Finset.affineCombination_indicator_subset w1 p (s1.subset_union_left (s\u2082 := s2))] at heq\n        rw [Finset.affineCombination_indicator_subset w2 p s1.subset_union_right] at heq\n        rw [\u2190 @vsub_eq_zero_iff_eq V] at heq\n        rw [Finset.affineCombination_vsub] at heq\n        exact ha (s1 \u222a s2) (Set.indicator (\u2191s1) w1 - Set.indicator (\u2191s2) w2) hws heq i hi\n      \u00b7 rw [\u2190 Finset.mem_coe, Finset.coe_union] at hi\n        have h\u2081 : Set.indicator (\u2191s1) w1 i = 0 := by\n          simp only [Set.indicator]\n          simp only [Finset.mem_coe]\n          simp only [ite_eq_right_iff]\n          intro h\n          by_contra\n          exact (mt (@Set.mem_union_left _ i \u2191s1 \u2191s2) hi) h\n        have h\u2082 : Set.indicator (\u2191s2) w2 i = 0 := by\n          simp only [Set.indicator]\n          simp only [Finset.mem_coe]\n          simp only [ite_eq_right_iff]\n          intro h\n          by_contra\n          exact (mt (@Set.mem_union_right _ i \u2191s2 \u2191s1) hi) h\n        simp [h\u2081, h\u2082]\n    \u00b7 intro ha s w hw hs i0 hi0\n      let w1 : \u03b9 \u2192 k := Function.update (Function.const \u03b9 0) i0 1\n      have hw1 : \u2211 i \u2208 s, w1 i = 1 := by\n        rw [Finset.sum_update_of_mem hi0]\n        simp only [Finset.sum_const_zero]\n        simp only [add_zero]\n        simp only [const_apply]\n      have hw1s : s.affineCombination k p w1 = p i0 :=\n        s.affineCombination_of_eq_one_of_eq_zero w1 p hi0 (Function.update_self ..)\n          fun _ _ hne => Function.update_of_ne hne ..\n      let w2 := w + w1\n      have hw2 : \u2211 i \u2208 s, w2 i = 1 := by\n        simp_all only [w2, Pi.add_apply, Finset.sum_add_distrib, zero_add]\n      have hw2s : s.affineCombination k p w2 = p i0 := by\n        simp_all only [w2, \u2190 Finset.weightedVSub_vadd_affineCombination, zero_vadd]\n      replace ha := ha s s w2 w1 hw2 hw1 (hw1s.symm \u25b8 hw2s)\n      have hws : w2 i0 - w1 i0 = 0 := by\n        rw [\u2190 Finset.mem_coe] at hi0\n        rw [\u2190 Set.indicator_of_mem hi0 w2]\n        rw [\u2190 Set.indicator_of_mem hi0 w1]\n        rw [ha]\n        rw [sub_self]\n      simpa [w2] using hws\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "context": {"open": ["Finset Function", "scoped Affine"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\n\u22a2 AffineIndependent k p \u2194\n    \u2200 (s1 s2 : Finset \u03b9) (w1 w2 : \u03b9 \u2192 k),\n      \u2211 i \u2208 s1, w1 i = 1 \u2192\n        \u2211 i \u2208 s2, w2 i = 1 \u2192\n          (affineCombination k s1 p) w1 = (affineCombination k s2 p) w2 \u2192 (\u2191s1).indicator w1 = (\u2191s2).indicator w2"}, {"line": "classical\n    constructor\n    \u00b7 intro ha s1 s2 w1 w2 hw1 hw2 heq\n      ext i\n      by_cases hi : i \u2208 s1 \u222a s2\n      \u00b7 rw [\u2190 sub_eq_zero]\n        rw [\u2190 Finset.sum_indicator_subset w1 (s1.subset_union_left (s\u2082 := s2))] at hw1\n        rw [\u2190 Finset.sum_indicator_subset w2 (s1.subset_union_right)] at hw2\n        have hws : (\u2211 i \u2208 s1 \u222a s2, (Set.indicator (\u2191s1) w1 - Set.indicator (\u2191s2) w2) i) = 0 := by\n          simp [hw1, hw2]\n        rw [Finset.affineCombination_indicator_subset w1 p (s1.subset_union_left (s\u2082 := s2))] at heq\n        rw [Finset.affineCombination_indicator_subset w2 p s1.subset_union_right] at heq\n        rw [\u2190 @vsub_eq_zero_iff_eq V] at heq\n        rw [Finset.affineCombination_vsub] at heq\n        exact ha (s1 \u222a s2) (Set.indicator (\u2191s1) w1 - Set.indicator (\u2191s2) w2) hws heq i hi\n      \u00b7 rw [\u2190 Finset.mem_coe, Finset.coe_union] at hi\n        have h\u2081 : Set.indicator (\u2191s1) w1 i = 0 := by\n          simp only [Set.indicator]\n          simp only [Finset.mem_coe]\n          simp only [ite_eq_right_iff]\n          intro h\n          by_contra\n          exact (mt (@Set.mem_union_left _ i \u2191s1 \u2191s2) hi) h\n        have h\u2082 : Set.indicator (\u2191s2) w2 i = 0 := by\n          simp only [Set.indicator]\n          simp only [Finset.mem_coe]\n          simp only [ite_eq_right_iff]\n          intro h\n          by_contra\n          exact (mt (@Set.mem_union_right _ i \u2191s2 \u2191s1) hi) h\n        simp [h\u2081, h\u2082]\n    \u00b7 intro ha s w hw hs i0 hi0\n      let w1 : \u03b9 \u2192 k := Function.update (Function.const \u03b9 0) i0 1\n      have hw1 : \u2211 i \u2208 s, w1 i = 1 := by\n        rw [Finset.sum_update_of_mem hi0]\n        simp only [Finset.sum_const_zero]\n        simp only [add_zero]\n        simp only [const_apply]\n      have hw1s : s.affineCombination k p w1 = p i0 :=\n        s.affineCombination_of_eq_one_of_eq_zero w1 p hi0 (Function.update_self ..)\n          fun _ _ hne => Function.update_of_ne hne ..\n      let w2 := w + w1\n      have hw2 : \u2211 i \u2208 s, w2 i = 1 := by\n        simp_all only [w2, Pi.add_apply, Finset.sum_add_distrib, zero_add]\n      have hw2s : s.affineCombination k p w2 = p i0 := by\n        simp_all only [w2, \u2190 Finset.weightedVSub_vadd_affineCombination, zero_vadd]\n      replace ha := ha s s w2 w1 hw2 hw1 (hw1s.symm \u25b8 hw2s)\n      have hws : w2 i0 - w1 i0 = 0 := by\n        rw [\u2190 Finset.mem_coe] at hi0\n        rw [\u2190 Set.indicator_of_mem hi0 w2]\n        rw [\u2190 Set.indicator_of_mem hi0 w1]\n        rw [ha]\n        rw [sub_self]\n      simpa [w2] using hws", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem AffineIndependent.injective [Nontrivial k] {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k p) : Function.Injective p := by\n  intro i j hij\n  rw [affineIndependent_iff_linearIndependent_vsub _ _ j] at ha\n  by_contra hij'\n  refine ha.ne_zero \u27e8i, hij'\u27e9 (vsub_eq_zero_iff_eq.mpr ?_)\n  simp_all only [ne_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "context": {"open": ["Finset Function", "scoped Affine"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Ring k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_4\ninst\u271d : Nontrivial k\np : \u03b9 \u2192 P\nha : AffineIndependent k p\n\u22a2 Injective p"}, {"line": "intro i j hij", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Ring k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_4\ninst\u271d : Nontrivial k\np : \u03b9 \u2192 P\nha : AffineIndependent k p\ni j : \u03b9\nhij : p i = p j\n\u22a2 i = j"}, {"line": "rw [affineIndependent_iff_linearIndependent_vsub _ _ j] at ha", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Ring k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_4\ninst\u271d : Nontrivial k\np : \u03b9 \u2192 P\ni j : \u03b9\nha : LinearIndependent k fun i => p \u2191i -\u1d65 p j\nhij : p i = p j\n\u22a2 i = j"}, {"line": "by_contra hij'", "tactic_state": "case refine_1\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Ring k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_4\ninst\u271d : Nontrivial k\np : \u03b9 \u2192 P\ni j : \u03b9\nha : LinearIndependent k fun i => p \u2191i -\u1d65 p j\nhij : p i = p j\n\u22a2 Decidable (i = j)\n---\ncase refine_2\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Ring k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_4\ninst\u271d : Nontrivial k\np : \u03b9 \u2192 P\ni j : \u03b9\nha : LinearIndependent k fun i => p \u2191i -\u1d65 p j\nhij : p i = p j\nhij' : \u00aci = j\n\u22a2 False"}, {"line": "refine ha.ne_zero \u27e8i, hij'\u27e9 (vsub_eq_zero_iff_eq.mpr ?_)", "tactic_state": "case refine_2\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Ring k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_4\ninst\u271d : Nontrivial k\np : \u03b9 \u2192 P\ni j : \u03b9\nha : LinearIndependent k fun i => p \u2191i -\u1d65 p j\nhij : p i = p j\nhij' : \u00aci = j\n\u22a2 False"}, {"line": "simp_all only [ne_eq]", "tactic_state": "case refine_2\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Ring k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AddTorsor V P\n\u03b9 : Type u_4\ninst\u271d : Nontrivial k\np : \u03b9 \u2192 P\ni j : \u03b9\nha : LinearIndependent k fun i => p \u2191i -\u1d65 p j\nhij : p i = p j\nhij' : \u00aci = j\n\u22a2 False"}]}
{"declaration": "protected theorem AffineIndependent.range {p : \u03b9 \u2192 P} (ha : AffineIndependent k p) :\n    AffineIndependent k (fun x => x : Set.range p \u2192 P) := by\n  let f : Set.range p \u2192 \u03b9 := fun x => x.property.choose\n  have hf : \u2200 x, p (f x) = x := fun x => x.property.choose_spec\n  let fe : Set.range p \u21aa \u03b9 := \u27e8f, fun x\u2081 x\u2082 he => Subtype.ext (hf x\u2081 \u25b8 hf x\u2082 \u25b8 he \u25b8 rfl)\u27e9\n  convert ha.comp_embedding fe\n  ext\n  simp [fe, hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "context": {"open": ["Finset Function", "scoped Affine"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\nha : AffineIndependent k p\n\u22a2 AffineIndependent k fun x => \u2191x"}, {"line": "let f : Set.range p \u2192 \u03b9 := fun x => x.property.choose", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\nha : AffineIndependent k p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\n\u22a2 AffineIndependent k fun x => \u2191x"}, {"line": "have hf : \u2200 x, p (f x) = x := fun x => x.property.choose_spec", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\nha : AffineIndependent k p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\n\u22a2 AffineIndependent k fun x => \u2191x"}, {"line": "let fe : Set.range p \u21aa \u03b9 := \u27e8f, fun x\u2081 x\u2082 he => Subtype.ext (hf x\u2081 \u25b8 hf x\u2082 \u25b8 he \u25b8 rfl)\u27e9", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\nha : AffineIndependent k p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\nfe : \u2191(Set.range p) \u21aa \u03b9 := { toFun := f, inj' := \u22ef }\n\u22a2 AffineIndependent k fun x => \u2191x"}, {"line": "convert ha.comp_embedding fe", "tactic_state": "case h.e'_9.h.h.e\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\nha : AffineIndependent k p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\nfe : \u2191(Set.range p) \u21aa \u03b9 := { toFun := f, inj' := \u22ef }\nx\u271d : \u2191(Set.range p)\n\u22a2 Subtype.val = p \u2218 \u21d1fe"}, {"line": "ext", "tactic_state": "case h.e'_9.h.h.e.h\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\nha : AffineIndependent k p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\nfe : \u2191(Set.range p) \u21aa \u03b9 := { toFun := f, inj' := \u22ef }\nx\u271d\u00b9 : \u2191(Set.range p)\nx\u271d : { x // x \u2208 Set.range p }\n\u22a2 \u2191x\u271d = (p \u2218 \u21d1fe) x\u271d"}, {"line": "simp [fe, hf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem affineIndependent_equiv {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') {p : \u03b9' \u2192 P} :\n    AffineIndependent k (p \u2218 e) \u2194 AffineIndependent k p := by\n  refine \u27e8?_, AffineIndependent.comp_embedding e.toEmbedding\u27e9\n  intro h\n  have : p = p \u2218 e \u2218 e.symm.toEmbedding := by\n    ext\n    simp\n  rw [this]\n  exact h.comp_embedding e.symm.toEmbedding\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "context": {"open": ["Finset Function", "scoped Affine"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ne : \u03b9 \u2243 \u03b9'\np : \u03b9' \u2192 P\n\u22a2 AffineIndependent k (p \u2218 \u21d1e) \u2194 AffineIndependent k p"}, {"line": "refine \u27e8?_, AffineIndependent.comp_embedding e.toEmbedding\u27e9", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ne : \u03b9 \u2243 \u03b9'\np : \u03b9' \u2192 P\n\u22a2 AffineIndependent k (p \u2218 \u21d1e) \u2192 AffineIndependent k p"}, {"line": "intro h", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ne : \u03b9 \u2243 \u03b9'\np : \u03b9' \u2192 P\nh : AffineIndependent k (p \u2218 \u21d1e)\n\u22a2 AffineIndependent k p"}, {"line": "have : p = p \u2218 e \u2218 e.symm.toEmbedding := by\n    ext\n    simp", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ne : \u03b9 \u2243 \u03b9'\np : \u03b9' \u2192 P\nh : AffineIndependent k (p \u2218 \u21d1e)\nthis : p = p \u2218 \u21d1e \u2218 \u21d1e.symm.toEmbedding\n\u22a2 AffineIndependent k p"}, {"line": "rw [this]", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ne : \u03b9 \u2243 \u03b9'\np : \u03b9' \u2192 P\nh : AffineIndependent k (p \u2218 \u21d1e)\nthis : p = p \u2218 \u21d1e \u2218 \u21d1e.symm.toEmbedding\n\u22a2 AffineIndependent k (p \u2218 \u21d1e \u2218 \u21d1e.symm.toEmbedding)"}, {"line": "exact h.comp_embedding e.symm.toEmbedding", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AffineIndependent.eq_zero_of_sum_eq_zero_subtype {s : Finset V}\n    (hp : AffineIndependent k ((\u2191) : s \u2192 V)) {w : V \u2192 k} (hw\u2080 : \u2211 x \u2208 s, w x = 0)\n    (hw\u2081 : \u2211 x \u2208 s, w x \u2022 x = 0) : \u2200 x \u2208 s, w x = 0 := by\n  rw [\u2190 sum_attach] at hw\u2080 hw\u2081\n  exact fun x hx \u21a6 hp.eq_zero_of_sum_eq_zero hw\u2080 hw\u2081 \u27e8x, hx\u27e9 (mem_univ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "context": {"open": ["Finset Function", "scoped Affine"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "{k}", "{V\u2082 P\u2082 : Type*} [AddCommGroup V\u2082] [Module k V\u2082] [AffineSpace V\u2082 P\u2082]", "{s : Finset \u03b9} {w w\u2081 w\u2082 : \u03b9 \u2192 k} {p : \u03b9 \u2192 V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\ns : Finset V\nhp : AffineIndependent k Subtype.val\nw : V \u2192 k\nhw\u2080 : \u2211 x \u2208 s, w x = 0\nhw\u2081 : \u2211 x \u2208 s, w x \u2022 x = 0\n\u22a2 \u2200 x \u2208 s, w x = 0"}, {"line": "rw [\u2190 sum_attach] at hw\u2080 hw\u2081", "tactic_state": "k : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\ns : Finset V\nhp : AffineIndependent k Subtype.val\nw : V \u2192 k\nhw\u2080 : \u2211 x \u2208 s.attach, w \u2191x = 0\nhw\u2081 : \u2211 x \u2208 s.attach, w \u2191x \u2022 \u2191x = 0\n\u22a2 \u2200 x \u2208 s, w x = 0"}, {"line": "exact fun x hx \u21a6 hp.eq_zero_of_sum_eq_zero hw\u2080 hw\u2081 \u27e8x, hx\u27e9 (mem_univ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AffineIndependent.affineIndependent_of_not_mem_span {p : \u03b9 \u2192 P} {i : \u03b9}\n    (ha : AffineIndependent k fun x : { y // y \u2260 i } => p x)\n    (hi : p i \u2209 affineSpan k (p '' { x | x \u2260 i })) : AffineIndependent k p := by\n  classical\n    intro s w hw hs\n    let s' : Finset { y // y \u2260 i } := s.subtype (\u00b7 \u2260 i)\n    let p' : { y // y \u2260 i } \u2192 P := fun x => p x\n    by_cases his : i \u2208 s \u2227 w i \u2260 0\n    \u00b7 refine False.elim (hi ?_)\n      let wm : \u03b9 \u2192 k := -(w i)\u207b\u00b9 \u2022 w\n      have hms : s.weightedVSub p wm = (0 : V) := by simp [wm, hs]\n      have hwm : \u2211 i \u2208 s, wm i = 0 := by simp [wm, \u2190 Finset.mul_sum, hw]\n      have hwmi : wm i = -1 := by simp [wm, his.2]\n      let w' : { y // y \u2260 i } \u2192 k := fun x => wm x\n      have hw' : \u2211 x \u2208 s', w' x = 1 := by\n        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]\n        rw [\u2190 s.sum_filter_add_sum_filter_not (\u00b7 \u2260 i)] at hwm\n        simpa only [not_not,Finset.filter_eq' _ i,if_pos his.1,sum_singleton,hwmi,add_neg_eq_zero] using hwm\n      rw [\u2190 s.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one hms his.1 hwmi]\n      rw [\u2190         (Subtype.range_coe : _ = { x | x \u2260 i })]\n      rw [\u2190 Set.range_comp]\n      rw [\u2190         s.affineCombination_subtype_eq_filter]\n      exact affineCombination_mem_affineSpan hw' p'\n    \u00b7 rw [not_and_or, Classical.not_not] at his\n      let w' : { y // y \u2260 i } \u2192 k := fun x => w x\n      have hw' : \u2211 x \u2208 s', w' x = 0 := by\n        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]\n        rw [Finset.sum_filter_of_ne]\n        rw [hw]\n        rintro x hxs hwx rfl\n        exact hwx (his.neg_resolve_left hxs)\n      have hs' : s'.weightedVSub p' w' = (0 : V) := by\n        simp_rw [w', s', p', Finset.weightedVSub_subtype_eq_filter]\n        rw [Finset.weightedVSub_filter_of_ne]\n        rw [hs]\n        rintro x hxs hwx rfl\n        exact hwx (his.neg_resolve_left hxs)\n      intro j hj\n      by_cases hji : j = i\n      \u00b7 rw [hji] at hj\n        exact hji.symm \u25b8 his.neg_resolve_left hj\n      \u00b7 exact ha s' w' hw' hs' \u27e8j, hji\u27e9 (Finset.mem_subtype.2 hj)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "context": {"open": ["Finset Function", "scoped Affine"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "{k}", "{V\u2082 P\u2082 : Type*} [AddCommGroup V\u2082] [Module k V\u2082] [AffineSpace V\u2082 P\u2082]", "{s : Finset \u03b9} {w w\u2081 w\u2082 : \u03b9 \u2192 k} {p : \u03b9 \u2192 V}", "{k : Type*} {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "(k V)", "{V}", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u03b9 : Type u_10\np : \u03b9 \u2192 P\ni : \u03b9\nha : AffineIndependent k fun x => p \u2191x\nhi : p i \u2209 affineSpan k (p '' {x | x \u2260 i})\n\u22a2 AffineIndependent k p"}, {"line": "classical\n    intro s w hw hs\n    let s' : Finset { y // y \u2260 i } := s.subtype (\u00b7 \u2260 i)\n    let p' : { y // y \u2260 i } \u2192 P := fun x => p x\n    by_cases his : i \u2208 s \u2227 w i \u2260 0\n    \u00b7 refine False.elim (hi ?_)\n      let wm : \u03b9 \u2192 k := -(w i)\u207b\u00b9 \u2022 w\n      have hms : s.weightedVSub p wm = (0 : V) := by simp [wm, hs]\n      have hwm : \u2211 i \u2208 s, wm i = 0 := by simp [wm, \u2190 Finset.mul_sum, hw]\n      have hwmi : wm i = -1 := by simp [wm, his.2]\n      let w' : { y // y \u2260 i } \u2192 k := fun x => wm x\n      have hw' : \u2211 x \u2208 s', w' x = 1 := by\n        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]\n        rw [\u2190 s.sum_filter_add_sum_filter_not (\u00b7 \u2260 i)] at hwm\n        simpa only [not_not,Finset.filter_eq' _ i,if_pos his.1,sum_singleton,hwmi,add_neg_eq_zero] using hwm\n      rw [\u2190 s.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one hms his.1 hwmi]\n      rw [\u2190         (Subtype.range_coe : _ = { x | x \u2260 i })]\n      rw [\u2190 Set.range_comp]\n      rw [\u2190         s.affineCombination_subtype_eq_filter]\n      exact affineCombination_mem_affineSpan hw' p'\n    \u00b7 rw [not_and_or, Classical.not_not] at his\n      let w' : { y // y \u2260 i } \u2192 k := fun x => w x\n      have hw' : \u2211 x \u2208 s', w' x = 0 := by\n        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]\n        rw [Finset.sum_filter_of_ne]\n        rw [hw]\n        rintro x hxs hwx rfl\n        exact hwx (his.neg_resolve_left hxs)\n      have hs' : s'.weightedVSub p' w' = (0 : V) := by\n        simp_rw [w', s', p', Finset.weightedVSub_subtype_eq_filter]\n        rw [Finset.weightedVSub_filter_of_ne]\n        rw [hs]\n        rintro x hxs hwx rfl\n        exact hwx (his.neg_resolve_left hxs)\n      intro j hj\n      by_cases hji : j = i\n      \u00b7 rw [hji] at hj\n        exact hji.symm \u25b8 his.neg_resolve_left hj\n      \u00b7 exact ha s' w' hw' hs' \u27e8j, hji\u27e9 (Finset.mem_subtype.2 hj)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem affineIndependent_of_ne_of_mem_of_not_mem_of_mem {s : AffineSubspace k P} {p\u2081 p\u2082 p\u2083 : P}\n    (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : p\u2082 \u2209 s) (hp\u2083 : p\u2083 \u2208 s) :\n    AffineIndependent k ![p\u2081, p\u2082, p\u2083] := by\n  rw [\u2190 affineIndependent_equiv (Equiv.swap (1 : Fin 3) 2)]\n  convert affineIndependent_of_ne_of_mem_of_mem_of_not_mem hp\u2081p\u2083 hp\u2081 hp\u2083 hp\u2082 using 1\n  ext x\n  fin_cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "context": {"open": ["Finset Function", "scoped Affine"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "{k}", "{V\u2082 P\u2082 : Type*} [AddCommGroup V\u2082] [Module k V\u2082] [AffineSpace V\u2082 P\u2082]", "{s : Finset \u03b9} {w w\u2081 w\u2082 : \u03b9 \u2192 k} {p : \u03b9 \u2192 V}", "{k : Type*} {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "(k V)", "{V}", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2083 : p\u2081 \u2260 p\u2083\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2209 s\nhp\u2083 : p\u2083 \u2208 s\n\u22a2 AffineIndependent k ![p\u2081, p\u2082, p\u2083]"}, {"line": "rw [\u2190 affineIndependent_equiv (Equiv.swap (1 : Fin 3) 2)]", "tactic_state": "k : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2083 : p\u2081 \u2260 p\u2083\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2209 s\nhp\u2083 : p\u2083 \u2208 s\n\u22a2 AffineIndependent k (![p\u2081, p\u2082, p\u2083] \u2218 \u21d1(Equiv.swap 1 2))"}, {"line": "convert affineIndependent_of_ne_of_mem_of_mem_of_not_mem hp\u2081p\u2083 hp\u2081 hp\u2083 hp\u2082 using 1", "tactic_state": "case h.e'_9\nk : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2083 : p\u2081 \u2260 p\u2083\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2209 s\nhp\u2083 : p\u2083 \u2208 s\n\u22a2 ![p\u2081, p\u2082, p\u2083] \u2218 \u21d1(Equiv.swap 1 2) = ![p\u2081, p\u2083, p\u2082]"}, {"line": "ext x", "tactic_state": "case h.e'_9.h\nk : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2083 : p\u2081 \u2260 p\u2083\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2209 s\nhp\u2083 : p\u2083 \u2208 s\nx : Fin 3\n\u22a2 (![p\u2081, p\u2082, p\u2083] \u2218 \u21d1(Equiv.swap 1 2)) x = ![p\u2081, p\u2083, p\u2082] x"}, {"line": "fin_cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem affineIndependent_of_ne_of_not_mem_of_mem_of_mem {s : AffineSubspace k P} {p\u2081 p\u2082 p\u2083 : P}\n    (hp\u2082p\u2083 : p\u2082 \u2260 p\u2083) (hp\u2081 : p\u2081 \u2209 s) (hp\u2082 : p\u2082 \u2208 s) (hp\u2083 : p\u2083 \u2208 s) :\n    AffineIndependent k ![p\u2081, p\u2082, p\u2083] := by\n  rw [\u2190 affineIndependent_equiv (Equiv.swap (0 : Fin 3) 2)]\n  convert affineIndependent_of_ne_of_mem_of_mem_of_not_mem hp\u2082p\u2083.symm hp\u2083 hp\u2082 hp\u2081 using 1\n  ext x\n  fin_cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "context": {"open": ["Finset Function", "scoped Affine"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "{k}", "{V\u2082 P\u2082 : Type*} [AddCommGroup V\u2082] [Module k V\u2082] [AffineSpace V\u2082 P\u2082]", "{s : Finset \u03b9} {w w\u2081 w\u2082 : \u03b9 \u2192 k} {p : \u03b9 \u2192 V}", "{k : Type*} {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]", "[AffineSpace V P] {\u03b9 : Type*}", "(k V)", "{V}", "{k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2082p\u2083 : p\u2082 \u2260 p\u2083\nhp\u2081 : p\u2081 \u2209 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2208 s\n\u22a2 AffineIndependent k ![p\u2081, p\u2082, p\u2083]"}, {"line": "rw [\u2190 affineIndependent_equiv (Equiv.swap (0 : Fin 3) 2)]", "tactic_state": "k : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2082p\u2083 : p\u2082 \u2260 p\u2083\nhp\u2081 : p\u2081 \u2209 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2208 s\n\u22a2 AffineIndependent k (![p\u2081, p\u2082, p\u2083] \u2218 \u21d1(Equiv.swap 0 2))"}, {"line": "convert affineIndependent_of_ne_of_mem_of_mem_of_not_mem hp\u2082p\u2083.symm hp\u2083 hp\u2082 hp\u2081 using 1", "tactic_state": "case h.e'_9\nk : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2082p\u2083 : p\u2082 \u2260 p\u2083\nhp\u2081 : p\u2081 \u2209 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2208 s\n\u22a2 ![p\u2081, p\u2082, p\u2083] \u2218 \u21d1(Equiv.swap 0 2) = ![p\u2083, p\u2082, p\u2081]"}, {"line": "ext x", "tactic_state": "case h.e'_9.h\nk : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2082p\u2083 : p\u2082 \u2260 p\u2083\nhp\u2081 : p\u2081 \u2209 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2208 s\nx : Fin 3\n\u22a2 (![p\u2081, p\u2082, p\u2083] \u2218 \u21d1(Equiv.swap 0 2)) x = ![p\u2083, p\u2082, p\u2081] x"}, {"line": "fin_cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AffineMap.lineMap_mem {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {Q : AffineSubspace k P} {p\u2080 p\u2081 : P} (c : k) (h\u2080 : p\u2080 \u2208 Q) (h\u2081 : p\u2081 \u2208 Q) :\n    AffineMap.lineMap p\u2080 p\u2081 c \u2208 Q := by\n  rw [AffineMap.lineMap_apply]\n  exact Q.smul_vsub_vadd_mem c h\u2081 h\u2080 h\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\nQ : AffineSubspace k P\np\u2080 p\u2081 : P\nc : k\nh\u2080 : p\u2080 \u2208 Q\nh\u2081 : p\u2081 \u2208 Q\n\u22a2 (lineMap p\u2080 p\u2081) c \u2208 Q"}, {"line": "rw [AffineMap.lineMap_apply]", "tactic_state": "k : Type u_7\nV : Type u_8\nP : Type u_9\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\nQ : AffineSubspace k P\np\u2080 p\u2081 : P\nc : k\nh\u2080 : p\u2080 \u2208 Q\nh\u2081 : p\u2081 \u2208 Q\n\u22a2 c \u2022 (p\u2081 -\u1d65 p\u2080) +\u1d65 p\u2080 \u2208 Q"}, {"line": "exact Q.smul_vsub_vadd_mem c h\u2081 h\u2080 h\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AffineMap.vectorSpan_image_eq_submodule_map {s : Set P\u2081} :\n    Submodule.map f.linear (vectorSpan k s) = vectorSpan k (f '' s) := by\n  simp [vectorSpan_def, f.image_vsub_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u2081 : Type u_19\nP\u2081 : Type u_17\nV\u2082 : Type u_18\nP\u2082 : Type u_20\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\n\u22a2 Submodule.map f.linear (vectorSpan k s) = vectorSpan k (\u21d1f '' s)"}, {"line": "simp [vectorSpan_def, f.image_vsub_image]", "tactic_state": "V\u2081 : Type u_19\nP\u2081 : Type u_17\nV\u2082 : Type u_18\nP\u2082 : Type u_20\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\n\u22a2 Submodule.map f.linear (Submodule.span k (s -\u1d65 s)) = Submodule.span k (\u21d1f '' s -\u1d65 \u21d1f '' s)"}]}
{"declaration": "theorem map_eq_bot_iff {s : AffineSubspace k P\u2081} : s.map f = \u22a5 \u2194 s = \u22a5 := by\n  refine \u27e8fun h => ?_, fun h => ?_\u27e9\n  \u00b7 rwa [\u2190 coe_eq_bot_iff, coe_map, image_eq_empty, coe_eq_bot_iff] at h\n  \u00b7 rw [h, map_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u2081 : Type u_17\nP\u2081 : Type u_18\nV\u2082 : Type u_20\nP\u2082 : Type u_19\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : AffineSubspace k P\u2081\n\u22a2 map f s = \u22a5 \u2194 s = \u22a5"}, {"line": "refine \u27e8fun h => ?_, fun h => ?_\u27e9", "tactic_state": "case refine_1\nV\u2081 : Type u_17\nP\u2081 : Type u_18\nV\u2082 : Type u_20\nP\u2082 : Type u_19\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : AffineSubspace k P\u2081\nh : map f s = \u22a5\n\u22a2 s = \u22a5\n---\ncase refine_2\nV\u2081 : Type u_17\nP\u2081 : Type u_18\nV\u2082 : Type u_20\nP\u2082 : Type u_19\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : AffineSubspace k P\u2081\nh : s = \u22a5\n\u22a2 map f s = \u22a5"}, {"line": "\u00b7 rwa [\u2190 coe_eq_bot_iff, coe_map, image_eq_empty, coe_eq_bot_iff] at h", "tactic_state": "case refine_2\nV\u2081 : Type u_17\nP\u2081 : Type u_18\nV\u2082 : Type u_20\nP\u2082 : Type u_19\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : AffineSubspace k P\u2081\nh : s = \u22a5\n\u22a2 map f s = \u22a5"}, {"line": "\u00b7 rw [h, map_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_direction (s : AffineSubspace k P\u2081) :\n    (s.map f).direction = s.direction.map f.linear := by\n  simp [direction_eq_vectorSpan, AffineMap.vectorSpan_image_eq_submodule_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u2081 : Type u_17\nP\u2081 : Type u_18\nV\u2082 : Type u_19\nP\u2082 : Type u_20\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : AffineSubspace k P\u2081\n\u22a2 (map f s).direction = Submodule.map f.linear s.direction"}, {"line": "simp [direction_eq_vectorSpan, AffineMap.vectorSpan_image_eq_submodule_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_top_of_surjective (hf : Function.Surjective f) : AffineSubspace.map f \u22a4 = \u22a4 := by\n  rw [AffineSubspace.ext_iff]\n  exact image_univ_of_surjective hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)", "{S\u2081 S\u2082 : AffineSubspace k P\u2081} [Nonempty S\u2081] [Nonempty S\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u2081 : Type u_19\nP\u2081 : Type u_17\nV\u2082 : Type u_20\nP\u2082 : Type u_18\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\nhf : Function.Surjective \u21d1f\n\u22a2 map f \u22a4 = \u22a4"}, {"line": "rw [AffineSubspace.ext_iff]", "tactic_state": "V\u2081 : Type u_19\nP\u2081 : Type u_17\nV\u2082 : Type u_20\nP\u2082 : Type u_18\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\nhf : Function.Surjective \u21d1f\n\u22a2 \u2191(map f \u22a4) = \u2191\u22a4"}, {"line": "exact image_univ_of_surjective hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem span_eq_top_iff {s : Set P\u2081} (e : P\u2081 \u2243\u1d43[k] P\u2082) :\n    affineSpan k s = \u22a4 \u2194 affineSpan k (e '' s) = \u22a4 := by\n  refine \u27e8(e : P\u2081 \u2192\u1d43[k] P\u2082).span_eq_top_of_surjective e.surjective, ?_\u27e9\n  intro h\n  have : s = e.symm '' (e '' s) := by rw [\u2190 image_comp]; simp\n  rw [this]\n  exact (e.symm : P\u2082 \u2192\u1d43[k] P\u2081).span_eq_top_of_surjective e.symm.surjective h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)", "{S\u2081 S\u2082 : AffineSubspace k P\u2081} [Nonempty S\u2081] [Nonempty S\u2082]", "(S\u2081 S\u2082 : AffineSubspace k P\u2081) [Nonempty S\u2081] [Nonempty S\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u2081 : Type u_19\nP\u2081 : Type u_17\nV\u2082 : Type u_20\nP\u2082 : Type u_18\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\n\u22a2 affineSpan k s = \u22a4 \u2194 affineSpan k (\u21d1e '' s) = \u22a4"}, {"line": "refine \u27e8(e : P\u2081 \u2192\u1d43[k] P\u2082).span_eq_top_of_surjective e.surjective, ?_\u27e9", "tactic_state": "V\u2081 : Type u_19\nP\u2081 : Type u_17\nV\u2082 : Type u_20\nP\u2082 : Type u_18\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\n\u22a2 affineSpan k (\u21d1e '' s) = \u22a4 \u2192 affineSpan k s = \u22a4"}, {"line": "intro h", "tactic_state": "V\u2081 : Type u_19\nP\u2081 : Type u_17\nV\u2082 : Type u_20\nP\u2082 : Type u_18\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\n\u22a2 affineSpan k s = \u22a4"}, {"line": "have : s = e.symm '' (e '' s) := by rw [\u2190 image_comp]; simp", "tactic_state": "V\u2081 : Type u_19\nP\u2081 : Type u_17\nV\u2082 : Type u_20\nP\u2082 : Type u_18\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\nthis : s = sorry '' (\u21d1e '' s)\n\u22a2 affineSpan k s = \u22a4"}, {"line": "rw [this]", "tactic_state": "V\u2081 : Type u_19\nP\u2081 : Type u_17\nV\u2082 : Type u_20\nP\u2082 : Type u_18\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\nthis : s = sorry '' (\u21d1e '' s)\n\u22a2 affineSpan k (sorry '' (\u21d1e '' s)) = \u22a4"}, {"line": "exact (e.symm : P\u2082 \u2192\u1d43[k] P\u2081).span_eq_top_of_surjective e.symm.surjective h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_top {f : P\u2081 \u2192\u1d43[k] P\u2082} : (\u22a4 : AffineSubspace k P\u2082).comap f = \u22a4 := by\n  rw [AffineSubspace.ext_iff]\n  exact preimage_univ (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)", "{S\u2081 S\u2082 : AffineSubspace k P\u2081} [Nonempty S\u2081] [Nonempty S\u2082]", "(S\u2081 S\u2082 : AffineSubspace k P\u2081) [Nonempty S\u2081] [Nonempty S\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V\u2081 : Type u_17\nP\u2081 : Type u_18\nV\u2082 : Type u_19\nP\u2082 : Type u_20\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\n\u22a2 comap f \u22a4 = \u22a4"}, {"line": "rw [AffineSubspace.ext_iff]", "tactic_state": "V\u2081 : Type u_17\nP\u2081 : Type u_18\nV\u2082 : Type u_19\nP\u2082 : Type u_20\nk : Type u_14\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\u2081\ninst\u271d\u2074 : Module k V\u2081\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AddTorsor V\u2082 P\u2082\nf : P\u2081 \u2192\u1d43[k] P\u2082\n\u22a2 \u2191(comap f \u22a4) = \u2191\u22a4"}, {"line": "exact preimage_univ (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Parallel.trans {s\u2081 s\u2082 s\u2083 : AffineSubspace k P} (h\u2081\u2082 : s\u2081 \u2225 s\u2082) (h\u2082\u2083 : s\u2082 \u2225 s\u2083) :\n    s\u2081 \u2225 s\u2083 := by\n  rcases h\u2081\u2082 with \u27e8v\u2081\u2082, rfl\u27e9\n  rcases h\u2082\u2083 with \u27e8v\u2082\u2083, rfl\u27e9\n  refine \u27e8v\u2082\u2083 + v\u2081\u2082, ?_\u27e9\n  rw [map_map]\n  rw [\u2190 coe_trans_to_affineMap]\n  rw [\u2190 constVAdd_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set", "AffineEquiv"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)", "{S\u2081 S\u2082 : AffineSubspace k P\u2081} [Nonempty S\u2081] [Nonempty S\u2082]", "(S\u2081 S\u2082 : AffineSubspace k P\u2081) [Nonempty S\u2081] [Nonempty S\u2082]", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 s\u2082 s\u2083 : AffineSubspace k P\nh\u2081\u2082 : s\u2081.Parallel s\u2082\nh\u2082\u2083 : s\u2082.Parallel s\u2083\n\u22a2 s\u2081.Parallel s\u2083"}, {"line": "rcases h\u2081\u2082 with \u27e8v\u2081\u2082, rfl\u27e9", "tactic_state": "case intro\nk : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 s\u2083 : AffineSubspace k P\nv\u2081\u2082 : V\nh\u2082\u2083 : (map (\u2191(constVAdd k P v\u2081\u2082)) s\u2081).Parallel s\u2083\n\u22a2 s\u2081.Parallel s\u2083"}, {"line": "rcases h\u2082\u2083 with \u27e8v\u2082\u2083, rfl\u27e9", "tactic_state": "case intro.intro\nk : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 : AffineSubspace k P\nv\u2081\u2082 v\u2082\u2083 : V\n\u22a2 s\u2081.Parallel (map (\u2191(constVAdd k P v\u2082\u2083)) (map (\u2191(constVAdd k P v\u2081\u2082)) s\u2081))"}, {"line": "refine \u27e8v\u2082\u2083 + v\u2081\u2082, ?_\u27e9", "tactic_state": "case intro.intro\nk : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 : AffineSubspace k P\nv\u2081\u2082 v\u2082\u2083 : V\n\u22a2 map (\u2191(constVAdd k P v\u2082\u2083)) (map (\u2191(constVAdd k P v\u2081\u2082)) s\u2081) = map (\u2191(constVAdd k P sorry)) s\u2081"}, {"line": "rw [map_map]", "tactic_state": "case intro.intro\nk : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 : AffineSubspace k P\nv\u2081\u2082 v\u2082\u2083 : V\n\u22a2 map ((\u2191(constVAdd k P v\u2082\u2083)).comp \u2191(constVAdd k P v\u2081\u2082)) s\u2081 = map (\u2191(constVAdd k P sorry)) s\u2081"}, {"line": "rw [\u2190 coe_trans_to_affineMap]", "tactic_state": "case intro.intro\nk : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 : AffineSubspace k P\nv\u2081\u2082 v\u2082\u2083 : V\n\u22a2 map (\u2191((constVAdd k P v\u2081\u2082).trans (constVAdd k P v\u2082\u2083))) s\u2081 = map (\u2191(constVAdd k P sorry)) s\u2081"}, {"line": "rw [\u2190 constVAdd_add]", "tactic_state": "case intro.intro\nk : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 : AffineSubspace k P\nv\u2081\u2082 v\u2082\u2083 : V\n\u22a2 map (\u2191(constVAdd k P (v\u2082\u2083 + v\u2081\u2082))) s\u2081 = map (\u2191(constVAdd k P sorry)) s\u2081"}]}
{"declaration": "theorem Parallel.direction_eq {s\u2081 s\u2082 : AffineSubspace k P} (h : s\u2081 \u2225 s\u2082) :\n    s\u2081.direction = s\u2082.direction := by\n  rcases h with \u27e8v, rfl\u27e9\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set", "AffineEquiv"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)", "{S\u2081 S\u2082 : AffineSubspace k P\u2081} [Nonempty S\u2081] [Nonempty S\u2082]", "(S\u2081 S\u2082 : AffineSubspace k P\u2081) [Nonempty S\u2081] [Nonempty S\u2082]", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 s\u2082 : AffineSubspace k P\nh : s\u2081.Parallel s\u2082\n\u22a2 s\u2081.direction = s\u2082.direction"}, {"line": "rcases h with \u27e8v, rfl\u27e9", "tactic_state": "case intro\nk : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 : AffineSubspace k P\nv : V\n\u22a2 s\u2081.direction = (map (\u2191(constVAdd k P v)) s\u2081).direction"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bot_parallel_iff_eq_bot {s : AffineSubspace k P} : \u22a5 \u2225 s \u2194 s = \u22a5 := by\n  rw [parallel_comm]\n  rw [parallel_bot_iff_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set", "AffineEquiv"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)", "{S\u2081 S\u2082 : AffineSubspace k P\u2081} [Nonempty S\u2081] [Nonempty S\u2082]", "(S\u2081 S\u2082 : AffineSubspace k P\u2081) [Nonempty S\u2081] [Nonempty S\u2082]", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\n\u22a2 \u22a5.Parallel s \u2194 s = \u22a5"}, {"line": "rw [parallel_comm]", "tactic_state": "k : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns : AffineSubspace k P\n\u22a2 s.Parallel \u22a5 \u2194 s = \u22a5"}, {"line": "rw [parallel_bot_iff_eq_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Parallel.vectorSpan_eq {s\u2081 s\u2082 : Set P} (h : affineSpan k s\u2081 \u2225 affineSpan k s\u2082) :\n    vectorSpan k s\u2081 = vectorSpan k s\u2082 := by\n  simp_rw [\u2190 direction_affineSpan]\n  exact h.direction_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set", "AffineEquiv"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)", "{S\u2081 S\u2082 : AffineSubspace k P\u2081} [Nonempty S\u2081] [Nonempty S\u2082]", "(S\u2081 S\u2082 : AffineSubspace k P\u2081) [Nonempty S\u2081] [Nonempty S\u2082]", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 s\u2082 : Set P\nh : (affineSpan k s\u2081).Parallel (affineSpan k s\u2082)\n\u22a2 vectorSpan k s\u2081 = vectorSpan k s\u2082"}, {"line": "simp_rw [\u2190 direction_affineSpan]", "tactic_state": "k : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\ns\u2081 s\u2082 : Set P\nh : (affineSpan k s\u2081).Parallel (affineSpan k s\u2082)\n\u22a2 (affineSpan k s\u2081).direction = (affineSpan k s\u2082).direction"}, {"line": "exact h.direction_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem affineSpan_pair_parallel_iff_vectorSpan_eq {p\u2081 p\u2082 p\u2083 p\u2084 : P} :\n    line[k, p\u2081, p\u2082] \u2225 line[k, p\u2083, p\u2084] \u2194\n      vectorSpan k ({p\u2081, p\u2082} : Set P) = vectorSpan k ({p\u2083, p\u2084} : Set P) := by\n  simp [affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty, \u2190\n    not_nonempty_iff_eq_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Basic.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise", "AffineSubspace Set", "AffineEquiv"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k V) {p\u2081 p\u2082 : P}", "(P)", "{k V P}", "(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "{\u03b9 : Type*}", "{k}", "(k)", "{k}", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k) in", "{k V\u2081 P\u2081 V\u2082 P\u2082 V\u2083 P\u2083 : Type*} [Ring k]", "[AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]", "[AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]", "[AddCommGroup V\u2083] [Module k V\u2083] [AddTorsor V\u2083 P\u2083]", "(f : P\u2081 \u2192\u1d43[k] P\u2082)", "{S\u2081 S\u2082 : AffineSubspace k P\u2081} [Nonempty S\u2081] [Nonempty S\u2082]", "(S\u2081 S\u2082 : AffineSubspace k P\u2081) [Nonempty S\u2081] [Nonempty S\u2082]", "{k : Type*} {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_17\nV : Type u_18\nP : Type u_19\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 (affineSpan k {p\u2081, p\u2082}).Parallel (affineSpan k {p\u2083, p\u2084}) \u2194 vectorSpan k {p\u2081, p\u2082} = vectorSpan k {p\u2083, p\u2084}"}, {"line": "simp [affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty, \u2190\n    not_nonempty_iff_eq_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vectorSpan_empty : vectorSpan k (\u2205 : Set P) = (\u22a5 : Submodule k V) := by\n  rw [vectorSpan_def]\n  rw [vsub_empty]\n  rw [Submodule.span_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Defs.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(P) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u22a2 vectorSpan k \u2205 = \u22a5"}, {"line": "rw [vectorSpan_def]", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u22a2 Submodule.span k (\u2205 -\u1d65 \u2205) = \u22a5"}, {"line": "rw [vsub_empty]", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\n\u22a2 Submodule.span k \u2205 = \u22a5"}, {"line": "rw [Submodule.span_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vectorSpan_singleton (p : P) : vectorSpan k ({p} : Set P) = \u22a5 := by simp [vectorSpan_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Defs.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(P) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AddTorsor V P\np : P\n\u22a2 vectorSpan k {p} = \u22a5"}, {"line": "simp [vectorSpan_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_coe (p : P) (s : AffineSubspace k P) : p \u2208 (s : Set P) \u2194 p \u2208 s := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Defs.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(P) in", "{k V : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_6\np : P\ns : sorry\n\u22a2 p \u2208 sorry \u2194 sorry"}, {"line": "simp", "tactic_state": "P : Type u_6\np : P\ns : sorry\n\u22a2 p \u2208 sorry () \u2194 sorry ()"}]}
{"declaration": "theorem self_mem_mk' (p : P) (direction : Submodule k V) : p \u2208 mk' p direction := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace/Defs.lean", "context": {"open": ["Affine", "Set", "scoped Pointwise"], "variables": ["(k : Type*) {V : Type*} {P : Type*} [Ring k] [AddCommGroup V] [Module k V]", "[AffineSpace V P]", "(P) in", "{k V : Type*} [Ring k] [AddCommGroup V] [Module k V]", "(k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V] [Module k V]", "{k P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_4\nV : Type u_5\nP : Type u_6\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nx\u271d : Sort u_7\nmk' : x\u271d\np : P\ndirection : Submodule k V\n\u22a2 p \u2208 sorry"}, {"line": "simp", "tactic_state": "k : Type u_4\nV : Type u_5\nP : Type u_6\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nx\u271d : Sort u_7\nmk' : x\u271d\np : P\ndirection : Submodule k V\n\u22a2 p \u2208 sorry ()"}]}
{"declaration": "theorem coe_multilinearMap_mk (f : (\u03b9 \u2192 M) \u2192 N) (h\u2081 h\u2082 h\u2083) :\n    ((\u27e8\u27e8f, h\u2081, h\u2082\u27e9, h\u2083\u27e9 : M [\u22c0^\u03b9]\u2192\u2097[R] N) : MultilinearMap R (fun _ : \u03b9 => M) N) =\n      \u27e8f, @h\u2081, @h\u2082\u27e9 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Alternating/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} [Semiring R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "{P : Type*} [AddCommMonoid P] [Module R P]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{N' : Type*} [AddCommGroup N'] [Module R N']", "{\u03b9 \u03b9' \u03b9'' : Type*}", "(R M N \u03b9)", "(f f' : M [\u22c0^\u03b9]\u2192\u2097[R] N)", "(g g\u2082 : M [\u22c0^\u03b9]\u2192\u2097[R] N')", "(g' : M' [\u22c0^\u03b9]\u2192\u2097[R] N')", "(v : \u03b9 \u2192 M) (v' : \u03b9 \u2192 M')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\nM : Type u_2\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nN : Type u_3\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\n\u03b9 : Type u_7\nf : (\u03b9 \u2192 M) \u2192 N\nh\u2081 :\n  \u2200 [inst : DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) (x y : M), f (update m i (x + y)) = f (update m i x) + f (update m i y)\nh\u2082 : \u2200 [inst : DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) (c : R) (x : M), f (update m i (c \u2022 x)) = c \u2022 f (update m i x)\nh\u2083 :\n  \u2200 (v : \u03b9 \u2192 M) (i j : \u03b9), v i = v j \u2192 i \u2260 j \u2192 { toFun := f, map_update_add' := \u22ef, map_update_smul' := \u22ef }.toFun v = 0\n\u22a2 \u2191{ toFun := f, map_update_add' := \u22ef, map_update_smul' := \u22ef, map_eq_zero_of_eq' := h\u2083 } =\n    { toFun := f, map_update_add' := h\u2081, map_update_smul' := h\u2082 }"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_eq_zero_of_not_injective (v : \u03b9 \u2192 M) (hv : \u00acFunction.Injective v) : f v = 0 := by\n  rw [Function.Injective] at hv\n  push_neg at hv\n  rcases hv with \u27e8i\u2081, i\u2082, heq, hne\u27e9\n  exact f.map_eq_zero_of_eq v heq hne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Alternating/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} [Semiring R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "{P : Type*} [AddCommMonoid P] [Module R P]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{N' : Type*} [AddCommGroup N'] [Module R N']", "{\u03b9 \u03b9' \u03b9'' : Type*}", "(R M N \u03b9)", "(f f' : M [\u22c0^\u03b9]\u2192\u2097[R] N)", "(g g\u2082 : M [\u22c0^\u03b9]\u2192\u2097[R] N')", "(g' : M' [\u22c0^\u03b9]\u2192\u2097[R] N')", "(v : \u03b9 \u2192 M) (v' : \u03b9 \u2192 M')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\nM : Type u_2\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nN : Type u_3\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\n\u03b9 : Type u_7\nf : M [\u22c0^\u03b9]\u2192\u2097[R] N\nv : \u03b9 \u2192 M\nhv : \u00acInjective v\n\u22a2 f v = 0"}, {"line": "rw [Function.Injective] at hv", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\nM : Type u_2\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nN : Type u_3\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\n\u03b9 : Type u_7\nf : M [\u22c0^\u03b9]\u2192\u2097[R] N\nv : \u03b9 \u2192 M\nhv : \u00ac\u2200 \u2983a\u2081 a\u2082 : \u03b9\u2984, v a\u2081 = v a\u2082 \u2192 a\u2081 = a\u2082\n\u22a2 f v = 0"}, {"line": "push_neg at hv", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\nM : Type u_2\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nN : Type u_3\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\n\u03b9 : Type u_7\nf : M [\u22c0^\u03b9]\u2192\u2097[R] N\nv : \u03b9 \u2192 M\nhv : \u2203 a\u2081 a\u2082, v a\u2081 = v a\u2082 \u2227 a\u2081 \u2260 a\u2082\n\u22a2 f v = 0"}, {"line": "rcases hv with \u27e8i\u2081, i\u2082, heq, hne\u27e9", "tactic_state": "case intro.intro.intro\nR : Type u_1\ninst\u271d\u2074 : Semiring R\nM : Type u_2\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nN : Type u_3\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\n\u03b9 : Type u_7\nf : M [\u22c0^\u03b9]\u2192\u2097[R] N\nv : \u03b9 \u2192 M\ni\u2081 i\u2082 : \u03b9\nheq : v i\u2081 = v i\u2082\nhne : i\u2081 \u2260 i\u2082\n\u22a2 f v = 0"}, {"line": "exact f.map_eq_zero_of_eq v heq hne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_add_swap [DecidableEq \u03b9] {i j : \u03b9} (hij : i \u2260 j) :\n    f v + f (v \u2218 Equiv.swap i j) = 0 := by\n  rw [add_comm]\n  exact f.map_swap_add v hij\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Alternating/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{R : Type*} [Semiring R]", "{M : Type*} [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "{P : Type*} [AddCommMonoid P] [Module R P]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{N' : Type*} [AddCommGroup N'] [Module R N']", "{\u03b9 \u03b9' \u03b9'' : Type*}", "(R M N \u03b9)", "(f f' : M [\u22c0^\u03b9]\u2192\u2097[R] N)", "(g g\u2082 : M [\u22c0^\u03b9]\u2192\u2097[R] N')", "(g' : M' [\u22c0^\u03b9]\u2192\u2097[R] N')", "(v : \u03b9 \u2192 M) (v' : \u03b9 \u2192 M')", "{S : Type*} [Monoid S] [DistribMulAction S N] [SMulCommClass R S N]", "{S : Type*} [Monoid S] [DistribMulAction S N] [SMulCommClass R S N]", "{S : Type*} [Semiring S] [Module S N] [SMulCommClass R S N]", "(R M N)", "(\u03b9) {N}", "{S : Type*} {N\u2082 : Type*} [AddCommMonoid N\u2082] [Module R N\u2082]", "(S) in", "{M\u2082 : Type*} [AddCommMonoid M\u2082] [Module R M\u2082]", "{M\u2083 : Type*} [AddCommMonoid M\u2083] [Module R M\u2083]", "(\u03b9 R N)", "(S : Type*) [Semiring S] [Module S N] [SMulCommClass R S N]", "(f f' : M [\u22c0^\u03b9]\u2192\u2097[R] N)", "(g g\u2082 : M [\u22c0^\u03b9]\u2192\u2097[R] N')", "(g' : M' [\u22c0^\u03b9]\u2192\u2097[R] N')", "(v : \u03b9 \u2192 M) (v' : \u03b9 \u2192 M')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Semiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_7\nf : M [\u22c0^\u03b9]\u2192\u2097[R] N\nv : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 f v + f (v \u2218 \u21d1(Equiv.swap i j)) = 0"}, {"line": "rw [add_comm]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Semiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_7\nf : M [\u22c0^\u03b9]\u2192\u2097[R] N\nv : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 f (v \u2218 \u21d1(Equiv.swap i j)) + f v = 0"}, {"line": "exact f.map_swap_add v hij", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finTwoProd_zero (R : Type*) [Semiring R] : Basis.finTwoProd R 0 = (1, 0) := by\n  simp [Basis.finTwoProd, LinearEquiv.finTwoArrow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Fin.lean", "context": {"open": ["Function Set Submodule Finsupp", "LinearMap"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {M : Type*} {M' : Type*}", "{v : \u03b9 \u2192 M}", "[Ring R] [CommRing R\u2082] [AddCommGroup M]", "[Module R M] [Module R\u2082 M]", "{x y : M}", "(b : Basis \u03b9 R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\ninst\u271d : Semiring R\n\u22a2 (Basis.finTwoProd R) 0 = (1, 0)"}, {"line": "simp [Basis.finTwoProd, LinearEquiv.finTwoArrow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finTwoProd_one (R : Type*) [Semiring R] : Basis.finTwoProd R 1 = (0, 1) := by\n  simp [Basis.finTwoProd, LinearEquiv.finTwoArrow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Fin.lean", "context": {"open": ["Function Set Submodule Finsupp", "LinearMap"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {M : Type*} {M' : Type*}", "{v : \u03b9 \u2192 M}", "[Ring R] [CommRing R\u2082] [AddCommGroup M]", "[Module R M] [Module R\u2082 M]", "{x y : M}", "(b : Basis \u03b9 R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\ninst\u271d : Semiring R\n\u22a2 (Basis.finTwoProd R) 1 = (0, 1)"}, {"line": "simp [Basis.finTwoProd, LinearEquiv.finTwoArrow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem flag_zero (b : Basis (Fin n) R M) : b.flag 0 = \u22a5 := by simp [flag]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Flag.lean", "context": {"open": ["Set Submodule"], "variables": ["{R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] {n : \u2115} {b : Basis (Fin n) R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nb : Basis (Fin n) R M\n\u22a2 b.flag 0 = \u22a5"}, {"line": "simp [flag]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem flag_last (b : Basis (Fin n) R M) : b.flag (.last n) = \u22a4 := by\n  simp [flag]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Flag.lean", "context": {"open": ["Set Submodule"], "variables": ["{R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] {n : \u2115} {b : Basis (Fin n) R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nb : Basis (Fin n) R M\n\u22a2 b.flag (Fin.last n) = \u22a4"}, {"line": "simp [flag]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem flag_le_ker_coord (b : Basis (Fin n) R M) {k : Fin (n + 1)} {l : Fin n}\n    (h : k \u2264 l.castSucc) : b.flag k \u2264 LinearMap.ker (b.coord l) := by\n  nontriviality R\n  exact b.flag_le_ker_coord_iff.2 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Flag.lean", "context": {"open": ["Set Submodule"], "variables": ["{R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] {n : \u2115} {b : Basis (Fin n) R M}", "{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nM : Type u_4\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nb : Basis (Fin n) R M\nk : Fin (n + 1)\nl : Fin n\nh : k \u2264 l.castSucc\n\u22a2 b.flag k \u2264 LinearMap.ker (b.coord l)"}, {"line": "nontriviality R", "tactic_state": "R : Type u_3\nM : Type u_4\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nb : Basis (Fin n) R M\nk : Fin (n + 1)\nl : Fin n\nh : k \u2264 l.castSucc\na\u271d : Nontrivial R\n\u22a2 b.flag k \u2264 LinearMap.ker (b.coord l)"}, {"line": "exact b.flag_le_ker_coord_iff.2 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem repr_range : LinearMap.range (b.repr : M \u2192\u2097[R] \u03b9 \u2192\u2080 R) = Finsupp.supported R R univ := by\n  rw [LinearEquiv.range]\n  rw [Finsupp.supported_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Basic.lean", "context": {"open": ["Function Set Submodule Finsupp"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {M : Type*} {M' : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(b : Basis \u03b9 R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\n\u22a2 LinearMap.range \u2191b.repr = supported R R univ"}, {"line": "rw [LinearEquiv.range]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\n\u22a2 \u22a4 = supported R R univ"}, {"line": "rw [Finsupp.supported_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem index_nonempty (b : Basis \u03b9 R M) [Nontrivial M] : Nonempty \u03b9 := by\n  obtain \u27e8x, y, ne\u27e9 : \u2203 x y : M, x \u2260 y := Nontrivial.exists_pair_ne\n  obtain \u27e8i, _\u27e9 := not_forall.mp (mt b.ext_elem_iff.2 ne)\n  exact \u27e8i\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Basic.lean", "context": {"open": ["Function Set Submodule Finsupp"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {M : Type*} {M' : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(b : Basis \u03b9 R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nM : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nb : Basis \u03b9 R M\ninst\u271d : Nontrivial M\n\u22a2 Nonempty \u03b9"}, {"line": "obtain \u27e8x, y, ne\u27e9 : \u2203 x y : M, x \u2260 y := Nontrivial.exists_pair_ne", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\nR : Type u_3\nM : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nb : Basis \u03b9 R M\ninst\u271d : Nontrivial M\nx y : M\nne : x \u2260 y\n\u22a2 Nonempty \u03b9"}, {"line": "obtain \u27e8i, _\u27e9 := not_forall.mp (mt b.ext_elem_iff.2 ne)", "tactic_state": "case intro.intro.intro\n\u03b9 : Type u_1\nR : Type u_3\nM : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nb : Basis \u03b9 R M\ninst\u271d : Nontrivial M\nx y : M\nne : x \u2260 y\ni : ?m.1507\nh\u271d : \u00ac?m.1508 i\n\u22a2 Nonempty \u03b9"}, {"line": "exact \u27e8i\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_coord_apply [DecidableEq \u03b9] {i j : \u03b9} :\n    (Basis.mk hli hsp).coord i (v j) = if j = i then 1 else 0 := by\n  rcases eq_or_ne j i with h | h\n  \u00b7 simp only [h, if_true, eq_self_iff_true, mk_coord_apply_eq i]\n  \u00b7 simp only [h, if_false, mk_coord_apply_ne h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Basic.lean", "context": {"open": ["Function Set Submodule Finsupp"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {M : Type*} {M' : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(b : Basis \u03b9 R M)", "{v : \u03b9 \u2192 M} {x y : M}", "(hli : LinearIndependent R v) (hsp : \u22a4 \u2264 span R (range v))", "(hli : LinearIndependent R v) (hsp : \u22a4 \u2264 span R (range v))", "{hli hsp}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nM : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhsp : \u22a4 \u2264 span R (range v)\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\n\u22a2 ((Basis.mk hli hsp).coord i) (v j) = if j = i then 1 else 0"}, {"line": "rcases eq_or_ne j i with h | h", "tactic_state": "case inl\n\u03b9 : Type u_1\nR : Type u_3\nM : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhsp : \u22a4 \u2264 span R (range v)\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : j = i\n\u22a2 ((Basis.mk hli hsp).coord i) (v j) = if j = i then 1 else 0\n---\ncase inr\n\u03b9 : Type u_1\nR : Type u_3\nM : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhsp : \u22a4 \u2264 span R (range v)\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : j \u2260 i\n\u22a2 ((Basis.mk hli hsp).coord i) (v j) = if j = i then 1 else 0"}, {"line": "\u00b7 simp only [h, if_true, eq_self_iff_true, mk_coord_apply_eq i]", "tactic_state": "case inr\n\u03b9 : Type u_1\nR : Type u_3\nM : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhsp : \u22a4 \u2264 span R (range v)\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nh : j \u2260 i\n\u22a2 ((Basis.mk hli hsp).coord i) (v j) = if j = i then 1 else 0"}, {"line": "\u00b7 simp only [h, if_false, mk_coord_apply_ne h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_repr (\u03b9 R : Type*) [Unique \u03b9] [Semiring R] (x i) :\n    (Basis.singleton \u03b9 R).repr x i = x := by simp [Basis.singleton, Unique.eq_default i]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Basic.lean", "context": {"open": ["Function Set Submodule Finsupp"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {M : Type*} {M' : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(b : Basis \u03b9 R M)", "{v : \u03b9 \u2192 M} {x y : M}", "(hli : LinearIndependent R v) (hsp : \u22a4 \u2264 span R (range v))", "(hli : LinearIndependent R v) (hsp : \u22a4 \u2264 span R (range v))", "{hli hsp}", "(hli : LinearIndependent R v)", "(b : Basis \u03b9 R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : Unique \u03b9\ninst\u271d : Semiring R\nx : R\ni : \u03b9\n\u22a2 ((Basis.singleton \u03b9 R).repr x) i = x"}, {"line": "simp [Basis.singleton, Unique.eq_default i]", "tactic_state": "\u03b9 : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : Unique \u03b9\ninst\u271d : Semiring R\nx : R\ni : \u03b9\n\u22a2 (fun\u2080 | default => x) i = x"}]}
{"declaration": "theorem reindex_refl : b.reindex (Equiv.refl \u03b9) = b := by\n  simp [reindex]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nM : Type u_6\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\n\u22a2 b.reindex (Equiv.refl \u03b9) = b"}, {"line": "simp [reindex]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_reindex : Set.range (b.reindex e) = Set.range b := by\n  simp [coe_reindex, range_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nM : Type u_6\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ne : \u03b9 \u2243 \u03b9'\n\u22a2 range \u21d1(b.reindex e) = range \u21d1b"}, {"line": "simp [coe_reindex, range_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Basis.equivFun_symm_apply [Fintype \u03b9] (b : Basis \u03b9 R M) (x : \u03b9 \u2192 R) :\n    b.equivFun.symm x = \u2211 i, x i \u2022 b i := by\n  simp [Basis.equivFun, Finsupp.linearCombination_apply, sum_fintype, equivFunOnFinite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nM : Type u_6\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nx : \u03b9 \u2192 R\n\u22a2 b.equivFun.symm x = \u2211 i, x i \u2022 b i"}, {"line": "simp [Basis.equivFun, Finsupp.linearCombination_apply, sum_fintype, equivFunOnFinite]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nM : Type u_6\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nx : \u03b9 \u2192 R\n\u22a2 ({ support := \u22ef.toFinset, toFun := x, mem_support_toFun := \u22ef }.sum fun i a => a \u2022 b i) = \u2211 i, x i \u2022 b i"}]}
{"declaration": "theorem ext_elem_iff {x y : M} : x = y \u2194 \u2200 i, b.repr x i = b.repr y i := by\n  simp only [\u2190 DFunLike.ext_iff]\n  simp only [EmbeddingLike.apply_eq_iff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\nx y : M\n\u22a2 x = y \u2194 \u2200 (i : \u03b9), (b.repr x) i = (b.repr y) i"}, {"line": "simp only [\u2190 DFunLike.ext_iff]", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\nx y : M\n\u22a2 x = y \u2194 b.repr x = b.repr y"}, {"line": "simp only [EmbeddingLike.apply_eq_iff_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reindexRange_self (i : \u03b9) (h := Set.mem_range_self i) : b.reindexRange \u27e8b i, h\u27e9 = b i := by\n  by_cases htr : Nontrivial R\n  \u00b7 letI := htr\n    simp [htr, reindexRange, reindex_apply, Equiv.apply_ofInjective_symm b.injective,\n      Subtype.coe_mk]\n  \u00b7 letI : Subsingleton R := not_nontrivial_iff_subsingleton.mp htr\n    letI := Module.subsingleton R M\n    simp [reindexRange, eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R' : Type*} [Semiring R'] [Module R' M] (f : R \u2243+* R')", "(h : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ni : \u03b9\nh : optParam (b i \u2208 range \u21d1b) \u22ef\n\u22a2 b.reindexRange \u27e8b i, h\u27e9 = b i"}, {"line": "by_cases htr : Nontrivial R", "tactic_state": "case pos\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ni : \u03b9\nh : optParam (b i \u2208 range \u21d1b) \u22ef\nhtr : Nontrivial R\n\u22a2 b.reindexRange \u27e8b i, h\u27e9 = b i\n---\ncase neg\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ni : \u03b9\nh : optParam (b i \u2208 range \u21d1b) \u22ef\nhtr : \u00acNontrivial R\n\u22a2 b.reindexRange \u27e8b i, h\u27e9 = b i"}, {"line": "\u00b7 letI := htr\n    simp [htr, reindexRange, reindex_apply, Equiv.apply_ofInjective_symm b.injective,\n      Subtype.coe_mk]", "tactic_state": "case neg\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ni : \u03b9\nh : optParam (b i \u2208 range \u21d1b) \u22ef\nhtr : \u00acNontrivial R\n\u22a2 b.reindexRange \u27e8b i, h\u27e9 = b i"}, {"line": "\u00b7 letI : Subsingleton R := not_nontrivial_iff_subsingleton.mp htr\n    letI := Module.subsingleton R M\n    simp [reindexRange, eq_iff_true_of_subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reindexRange_apply (x : range b) : b.reindexRange x = x := by\n  rcases x with \u27e8bi, \u27e8i, rfl\u27e9\u27e9\n  exact b.reindexRange_self i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R' : Type*} [Semiring R'] [Module R' M] (f : R \u2243+* R')", "(h : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\nx : \u2191(range \u21d1b)\n\u22a2 b.reindexRange x = \u2191x"}, {"line": "rcases x with \u27e8bi, \u27e8i, rfl\u27e9\u27e9", "tactic_state": "case mk.intro\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ni : \u03b9\n\u22a2 b.reindexRange \u27e8b i, \u22ef\u27e9 = \u2191\u27e8b i, \u22ef\u27e9"}, {"line": "exact b.reindexRange_self i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reindexFinsetRange_self (i : \u03b9) (h := Finset.mem_image_of_mem b (Finset.mem_univ i)) :\n    b.reindexFinsetRange \u27e8b i, h\u27e9 = b i := by\n  rw [reindexFinsetRange]\n  rw [reindex_apply]\n  rw [reindexRange_apply]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R' : Type*} [Semiring R'] [Module R' M] (f : R \u2243+* R')", "(h : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x)", "[Fintype \u03b9] [DecidableEq M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\ni : \u03b9\nh : optParam (b i \u2208 Finset.image (\u21d1b) Finset.univ) \u22ef\n\u22a2 b.reindexFinsetRange \u27e8b i, h\u27e9 = b i"}, {"line": "rw [reindexFinsetRange]", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\ni : \u03b9\nh : optParam (b i \u2208 Finset.image (\u21d1b) Finset.univ) \u22ef\n\u22a2 (b.reindexRange.reindex ((Equiv.refl M).subtypeEquiv \u22ef)) \u27e8b i, h\u27e9 = b i"}, {"line": "rw [reindex_apply]", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\ni : \u03b9\nh : optParam (b i \u2208 Finset.image (\u21d1b) Finset.univ) \u22ef\n\u22a2 b.reindexRange (((Equiv.refl M).subtypeEquiv \u22ef).symm \u27e8b i, h\u27e9) = b i"}, {"line": "rw [reindexRange_apply]", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\ni : \u03b9\nh : optParam (b i \u2208 Finset.image (\u21d1b) Finset.univ) \u22ef\n\u22a2 \u2191(((Equiv.refl M).subtypeEquiv \u22ef).symm \u27e8b i, h\u27e9) = b i"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reindexFinsetRange_apply (x : Finset.univ.image b) : b.reindexFinsetRange x = x := by\n  rcases x with \u27e8bi, hbi\u27e9\n  rcases Finset.mem_image.mp hbi with \u27e8i, -, rfl\u27e9\n  exact b.reindexFinsetRange_self i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R' : Type*} [Semiring R'] [Module R' M] (f : R \u2243+* R')", "(h : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x)", "[Fintype \u03b9] [DecidableEq M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\nx : { x // x \u2208 Finset.image (\u21d1b) Finset.univ }\n\u22a2 b.reindexFinsetRange x = \u2191x"}, {"line": "rcases x with \u27e8bi, hbi\u27e9", "tactic_state": "case mk\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\nbi : M\nhbi : bi \u2208 Finset.image (\u21d1b) Finset.univ\n\u22a2 b.reindexFinsetRange \u27e8bi, hbi\u27e9 = \u2191\u27e8bi, hbi\u27e9"}, {"line": "rcases Finset.mem_image.mp hbi with \u27e8i, -, rfl\u27e9", "tactic_state": "case mk.intro.intro\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\ni : \u03b9\nhbi : b i \u2208 Finset.image (\u21d1b) Finset.univ\n\u22a2 b.reindexFinsetRange \u27e8b i, hbi\u27e9 = \u2191\u27e8b i, hbi\u27e9"}, {"line": "exact b.reindexFinsetRange_self i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reindexFinsetRange_repr (x : M) (i : \u03b9)\n    (h := Finset.mem_image_of_mem b (Finset.mem_univ i)) :\n    b.reindexFinsetRange.repr x \u27e8b i, h\u27e9 = b.repr x i := by simp [reindexFinsetRange]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R' : Type*} [Semiring R'] [Module R' M] (f : R \u2243+* R')", "(h : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x)", "[Fintype \u03b9] [DecidableEq M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\nx : M\ni : \u03b9\nh : optParam (b i \u2208 Finset.image (\u21d1b) Finset.univ) \u22ef\n\u22a2 (b.reindexFinsetRange.repr x) \u27e8b i, h\u27e9 = (b.repr x) i"}, {"line": "simp [reindexFinsetRange]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem constr_basis (f : \u03b9 \u2192 M') (i : \u03b9) : (constr (M' := M') b S f : M \u2192 M') (b i) = f i := by\n  simp [Basis.constr_apply, b.repr_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R' : Type*} [Semiring R'] [Module R' M] (f : R \u2243+* R')", "(h : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x)", "[Fintype \u03b9] [DecidableEq M]", "[Module R M']", "(S : Type*) [Semiring S] [Module S M']", "[SMulCommClass R S M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M' : Type u_7\ninst\u271d\u2079 : AddCommMonoid M'\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u2075 : Fintype \u03b9\ninst\u271d\u2074 : DecidableEq M\ninst\u271d\u00b3 : Module R M'\nS : Type u_16\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M'\ninst\u271d : SMulCommClass R S M'\nf : \u03b9 \u2192 M'\ni : \u03b9\n\u22a2 ((b.constr S) f) (b i) = f i"}, {"line": "simp [Basis.constr_apply, b.repr_self]", "tactic_state": "M' : Type u_7\ninst\u271d\u2079 : AddCommMonoid M'\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u2075 : Fintype \u03b9\ninst\u271d\u2074 : DecidableEq M\ninst\u271d\u00b3 : Module R M'\nS : Type u_16\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M'\ninst\u271d : SMulCommClass R S M'\nf : \u03b9 \u2192 M'\ni : \u03b9\n\u22a2 ((fun\u2080 | i => 1).sum fun b a => a \u2022 f b) = f i"}]}
{"declaration": "theorem constr_apply_fintype [Fintype \u03b9] (b : Basis \u03b9 R M) (f : \u03b9 \u2192 M') (x : M) :\n    (constr (M' := M') b S f : M \u2192 M') x = \u2211 i, b.equivFun x i \u2022 f i := by\n  simp [b.constr_apply, b.equivFun_apply, Finsupp.sum_fintype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R' : Type*} [Semiring R'] [Module R' M] (f : R \u2243+* R')", "(h : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x)", "[Fintype \u03b9] [DecidableEq M]", "[Module R M']", "(S : Type*) [Semiring S] [Module S M']", "[SMulCommClass R S M']", "(S : Type*) [Semiring S] [Module S M']", "[SMulCommClass R S M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M' : Type u_7\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : DecidableEq M\ninst\u271d\u2074 : Module R M'\nS : Type u_17\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Module S M'\ninst\u271d\u00b9 : SMulCommClass R S M'\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nf : \u03b9 \u2192 M'\nx : M\n\u22a2 ((b.constr S) f) x = \u2211 i, b.equivFun x i \u2022 f i"}, {"line": "simp [b.constr_apply, b.equivFun_apply, Finsupp.sum_fintype]", "tactic_state": "M' : Type u_7\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : DecidableEq M\ninst\u271d\u2074 : Module R M'\nS : Type u_17\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Module S M'\ninst\u271d\u00b9 : SMulCommClass R S M'\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nf : \u03b9 \u2192 M'\nx : M\n\u22a2 ((b.constr S) f) x = \u2211 x_1, (b.repr x) x_1 \u2022 f x_1"}]}
{"declaration": "theorem equiv_apply : b.equiv b' e (b i) = b' (e i) := by simp [Basis.equiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R' : Type*} [Semiring R'] [Module R' M] (f : R \u2243+* R')", "(h : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x)", "[Fintype \u03b9] [DecidableEq M]", "[Module R M']", "(S : Type*) [Semiring S] [Module S M']", "[SMulCommClass R S M']", "(S : Type*) [Semiring S] [Module S M']", "[SMulCommClass R S M']", "(i : \u03b9)", "{M'' : Type*} (b' : Basis \u03b9' R M') (e : \u03b9 \u2243 \u03b9')", "[AddCommMonoid M''] [Module R M'']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9' : Type u_2\nM' : Type u_7\ninst\u271d\u2076 : AddCommMonoid M'\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Module R M'\ni : \u03b9\nb' : Basis \u03b9' R M'\ne : \u03b9 \u2243 \u03b9'\n\u22a2 (b.equiv b' e) (b i) = b' (e i)"}, {"line": "simp [Basis.equiv]", "tactic_state": "\u03b9' : Type u_2\nM' : Type u_7\ninst\u271d\u2076 : AddCommMonoid M'\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Module R M'\ni : \u03b9\nb' : Basis \u03b9' R M'\ne : \u03b9 \u2243 \u03b9'\n\u22a2 1 \u2022 b' (e i) = b' (e i)"}]}
{"declaration": "theorem coord_repr_symm (b : Basis \u03b9 R M) (i : \u03b9) (f : \u03b9 \u2192\u2080 R) :\n    b.coord i (b.repr.symm f) = f i := by\n  simp only [repr_symm_apply]\n  simp only [coord_apply]\n  simp only [repr_linearCombination]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Basis/Defs.lean", "context": {"open": ["Function Set Submodule Finsupp", "Basis", "Fintype"], "variables": ["{\u03b9 : Type*} {\u03b9' : Type*} {R : Type*} {R\u2082 : Type*} {K : Type*}", "{M : Type*} {M' M'' : Type*} {V : Type u} {V' : Type*}", "[Semiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(\u03b9 R M)", "(b b\u2081 : Basis \u03b9 R M) (i : \u03b9) (c : R) (x : M)", "(f : M \u2243\u2097[R] M')", "(b' : Basis \u03b9' R M')", "(e : \u03b9 \u2243 \u03b9')", "{\u03b9 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(b : Basis \u03b9 R M)", "{R\u2081 : Type*} [Semiring R\u2081] {\u03c3 : R \u2192+* R\u2081} {\u03c3' : R\u2081 \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "{M\u2081 : Type*} [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R' : Type*} [Semiring R'] [Module R' M] (f : R \u2243+* R')", "(h : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x)", "[Fintype \u03b9] [DecidableEq M]", "[Module R M']", "(S : Type*) [Semiring S] [Module S M']", "[SMulCommClass R S M']", "(S : Type*) [Semiring S] [Module S M']", "[SMulCommClass R S M']", "(i : \u03b9)", "{M'' : Type*} (b' : Basis \u03b9' R M') (e : \u03b9 \u2243 \u03b9')", "[AddCommMonoid M''] [Module R M'']", "{R M M' : Type*} [CommSemiring R]", "[AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(b : Basis \u03b9 R M) (b' : Basis \u03b9' R M')", "[SMulCommClass R R M']", "(i : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\ninst\u271d\u00b3 : Fintype \u03b9\nR : Type u_19\nM : Type u_20\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 (b.coord i) (b.repr.symm f) = f i"}, {"line": "simp only [repr_symm_apply]", "tactic_state": "\u03b9 : Type u_10\ninst\u271d\u00b3 : Fintype \u03b9\nR : Type u_19\nM : Type u_20\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 (b.coord i) ((linearCombination R \u21d1b) f) = f i"}, {"line": "simp only [coord_apply]", "tactic_state": "\u03b9 : Type u_10\ninst\u271d\u00b3 : Fintype \u03b9\nR : Type u_19\nM : Type u_20\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ni : \u03b9\nf : \u03b9 \u2192\u2080 R\n\u22a2 (b.repr ((linearCombination R \u21d1b) f)) i = f i"}, {"line": "simp only [repr_linearCombination]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_inj (B\u2081 B\u2082 : BilinForm R M') {l r : M \u2192\u2097[R] M'} (h\u2097 : Function.Surjective l)\n    (h\u1d63 : Function.Surjective r) : B\u2081.comp l r = B\u2082.comp l r \u2194 B\u2081 = B\u2082 := by\n  constructor <;> intro h\n  \u00b7 -- B\u2081.comp l r = B\u2082.comp l r \u2192 B\u2081 = B\u2082\n    ext x y\n    obtain \u27e8x', hx\u27e9 := h\u2097 x\n    subst hx\n    obtain \u27e8y', hy\u27e9 := h\u1d63 y\n    subst hy\n    rw [\u2190 comp_apply]\n    rw [\u2190 comp_apply]\n    rw [h]\n  \u00b7 -- B\u2081 = B\u2082 \u2192 B\u2081.comp l r = B\u2082.comp l r\n    rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/BilinearForm/Hom.lean", "context": {"open": ["LinearMap (BilinForm)", "LinearMap (BilinMap)"], "variables": ["{R : Type*} {M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2081 : Type*} {M\u2081 : Type*} [CommRing R\u2081] [AddCommGroup M\u2081] [Module R\u2081 M\u2081]", "{V : Type*} {K : Type*} [Field K] [AddCommGroup V] [Module K V]", "{B : BilinForm R M} {B\u2081 : BilinForm R\u2081 M\u2081}", "(B)", "(w : M)", "{B}", "{R' : Type*} [CommSemiring R'] [Algebra R' R] [Module R' M] [IsScalarTower R' R M]", "{M' : Type w} [AddCommMonoid M'] [Module R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type w\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB\u2081 B\u2082 : BilinForm R M'\nl r : M \u2192\u2097[R] M'\nh\u2097 : Function.Surjective \u21d1l\nh\u1d63 : Function.Surjective \u21d1r\n\u22a2 B\u2081.comp l r = B\u2082.comp l r \u2194 B\u2081 = B\u2082"}, {"line": "constructor <;> intro h", "tactic_state": "case mp\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type w\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB\u2081 B\u2082 : BilinForm R M'\nl r : M \u2192\u2097[R] M'\nh\u2097 : Function.Surjective \u21d1l\nh\u1d63 : Function.Surjective \u21d1r\nh : B\u2081.comp l r = B\u2082.comp l r\n\u22a2 B\u2081 = B\u2082\n---\ncase mpr\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type w\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB\u2081 B\u2082 : BilinForm R M'\nl r : M \u2192\u2097[R] M'\nh\u2097 : Function.Surjective \u21d1l\nh\u1d63 : Function.Surjective \u21d1r\nh : B\u2081 = B\u2082\n\u22a2 B\u2081.comp l r = B\u2082.comp l r"}, {"line": "\u00b7 -- B\u2081.comp l r = B\u2082.comp l r \u2192 B\u2081 = B\u2082\n    ext x y\n    obtain \u27e8x', hx\u27e9 := h\u2097 x\n    subst hx\n    obtain \u27e8y', hy\u27e9 := h\u1d63 y\n    subst hy\n    rw [\u2190 comp_apply]\n    rw [\u2190 comp_apply]\n    rw [h]", "tactic_state": "case mpr\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type w\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB\u2081 B\u2082 : BilinForm R M'\nl r : M \u2192\u2097[R] M'\nh\u2097 : Function.Surjective \u21d1l\nh\u1d63 : Function.Surjective \u21d1r\nh : B\u2081 = B\u2082\n\u22a2 B\u2081.comp l r = B\u2082.comp l r"}, {"line": "\u00b7 -- B\u2081 = B\u2082 \u2192 B\u2081.comp l r = B\u2082.comp l r\n    rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma orthogonal_eq_bot_iff\n    (b\u2081 : B.IsRefl) (b\u2082 : (B.restrict W).Nondegenerate) (b\u2083 : B.Nondegenerate) :\n    B.orthogonal W = \u22a5 \u2194 W = \u22a4 := by\n  refine \u27e8eq_top_of_restrict_nondegenerate_of_orthogonal_eq_bot b\u2081 b\u2082, fun h \u21a6 ?_\u27e9\n  rw [h]\n  rw [eq_bot_iff]\n  exact fun x hx \u21a6 b\u2083 x fun y \u21a6 b\u2081 y x <| by simpa using hx y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/BilinearForm/Orthogonal.lean", "context": {"open": ["LinearMap (BilinForm)", "Module Submodule"], "variables": ["{R : Type*} {M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2081 : Type*} {M\u2081 : Type*} [CommRing R\u2081] [AddCommGroup M\u2081] [Module R\u2081 M\u2081]", "{V : Type*} {K : Type*} [Field K] [AddCommGroup V] [Module K V]", "{B : BilinForm R M} {B\u2081 : BilinForm R\u2081 M\u2081}", "{R\u2084 M\u2084 : Type*} [CommRing R\u2084] [IsDomain R\u2084]", "[AddCommGroup M\u2084] [Module R\u2084 M\u2084] {G : BilinForm R\u2084 M\u2084}", "{N L : Submodule R M}", "{M\u2082' : Type*}", "[AddCommMonoid M\u2082'] [Module R M\u2082']", "[FiniteDimensional K V]", "{B : BilinForm K V}", "{W : Submodule K V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_5\nK : Type u_6\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nB : BilinForm K V\nW : Submodule K V\nb\u2081 : B.IsRefl\nb\u2082 : (B.restrict W).Nondegenerate\nb\u2083 : B.Nondegenerate\n\u22a2 B.orthogonal W = \u22a5 \u2194 W = \u22a4"}, {"line": "refine \u27e8eq_top_of_restrict_nondegenerate_of_orthogonal_eq_bot b\u2081 b\u2082, fun h \u21a6 ?_\u27e9", "tactic_state": "V : Type u_5\nK : Type u_6\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nB : BilinForm K V\nW : Submodule K V\nb\u2081 : B.IsRefl\nb\u2082 : (B.restrict W).Nondegenerate\nb\u2083 : B.Nondegenerate\nh : W = \u22a4\n\u22a2 B.orthogonal W = \u22a5"}, {"line": "rw [h]", "tactic_state": "V : Type u_5\nK : Type u_6\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nB : BilinForm K V\nW : Submodule K V\nb\u2081 : B.IsRefl\nb\u2082 : (B.restrict W).Nondegenerate\nb\u2083 : B.Nondegenerate\nh : W = \u22a4\n\u22a2 B.orthogonal \u22a4 = \u22a5"}, {"line": "rw [eq_bot_iff]", "tactic_state": "V : Type u_5\nK : Type u_6\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nB : BilinForm K V\nW : Submodule K V\nb\u2081 : B.IsRefl\nb\u2082 : (B.restrict W).Nondegenerate\nb\u2083 : B.Nondegenerate\nh : W = \u22a4\n\u22a2 B.orthogonal \u22a4 \u2264 \u22a5"}, {"line": "exact fun x hx \u21a6 b\u2083 x fun y \u21a6 b\u2081 y x <| by simpa using hx y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nondegenerate_iff_ker_eq_bot {B : BilinForm R M} :\n    B.Nondegenerate \u2194 LinearMap.ker B = \u22a5 := by\n  rw [LinearMap.ker_eq_bot']\n  simp [Nondegenerate, LinearMap.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/BilinearForm/Properties.lean", "context": {"open": ["LinearMap (BilinForm)"], "variables": ["{R : Type*} {M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2081 : Type*} {M\u2081 : Type*} [CommRing R\u2081] [AddCommGroup M\u2081] [Module R\u2081 M\u2081]", "{V : Type*} {K : Type*} [Field K] [AddCommGroup V] [Module K V]", "{M' : Type*} [AddCommMonoid M'] [Module R M']", "{B : BilinForm R M} {B\u2081 : BilinForm R\u2081 M\u2081}", "(R M)", "{M' : Type*}", "[AddCommMonoid M'] [Module R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nB : BilinForm R M\n\u22a2 B.Nondegenerate \u2194 LinearMap.ker B = \u22a5"}, {"line": "rw [LinearMap.ker_eq_bot']", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nB : BilinForm R M\n\u22a2 B.Nondegenerate \u2194 \u2200 (m : M), B m = 0 \u2192 m = 0"}, {"line": "simp [Nondegenerate, LinearMap.ext_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nB : BilinForm R M\n\u22a2 B.Nondegenerate \u2194 \u2200 (m : M), (\u2200 (x : M), (B m) x = 0) \u2192 m = 0"}]}
{"declaration": "theorem changeForm_one : changeForm h (1 : CliffordAlgebra Q) = 1 := by\n  simpa using changeForm_algebraMap h (1 : R)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CliffordAlgebra/Contraction.lean", "context": {"open": ["LinearMap (BilinMap BilinForm)"], "variables": ["{R : Type u1} [CommRing R]", "{M : Type u2} [AddCommGroup M] [Module R M]", "(Q : QuadraticForm R M)", "(d d' : Module.Dual R M)", "{Q}", "(Q)", "{Q}", "{Q}", "{Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M}", "(h : B.toQuadraticMap = Q' - Q) (h' : B'.toQuadraticMap = Q'' - Q')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nchangeForm : x\u271d\n\u22a2 sorry = 1"}, {"line": "simpa using changeForm_algebraMap h (1 : R)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star_mem_iff {x : CliffordAlgebra Q} : star x \u2208 pinGroup Q \u2194 x \u2208 pinGroup Q := by\n  refine \u27e8?_, star_mem\u27e9\n  intro hx\n  convert star_mem hx\n  exact (star_star x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CliffordAlgebra/SpinGroup.lean", "context": {"open": ["CliffordAlgebra MulAction", "scoped Pointwise"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{Q : QuadraticForm R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n\u22a2 star x \u2208 pinGroup Q \u2194 x \u2208 pinGroup Q"}, {"line": "refine \u27e8?_, star_mem\u27e9", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n\u22a2 star x \u2208 pinGroup Q \u2192 x \u2208 pinGroup Q"}, {"line": "intro hx", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 pinGroup Q\n\u22a2 x \u2208 pinGroup Q"}, {"line": "convert star_mem hx", "tactic_state": "case h.e'_5\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 pinGroup Q\n\u22a2 x = star (star x)\n---\ncase convert_1\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 pinGroup Q\n\u22a2 Star (CliffordAlgebra Q)\n---\ncase convert_2\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 pinGroup Q\n\u22a2 StarMemClass (Submonoid (CliffordAlgebra Q)) (CliffordAlgebra Q)"}, {"line": "exact (star_star x).symm", "tactic_state": "case convert_2\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 pinGroup Q\n\u22a2 StarMemClass (Submonoid (CliffordAlgebra Q)) (CliffordAlgebra Q)"}]}
{"declaration": "theorem star_mem_iff {x : CliffordAlgebra Q} : star x \u2208 spinGroup Q \u2194 x \u2208 spinGroup Q := by\n  refine \u27e8?_, star_mem\u27e9\n  intro hx\n  convert star_mem hx\n  exact (star_star x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CliffordAlgebra/SpinGroup.lean", "context": {"open": ["CliffordAlgebra MulAction", "scoped Pointwise", "CliffordAlgebra MulAction", "scoped Pointwise"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{Q : QuadraticForm R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n\u22a2 star x \u2208 spinGroup Q \u2194 x \u2208 spinGroup Q"}, {"line": "refine \u27e8?_, star_mem\u27e9", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n\u22a2 star x \u2208 spinGroup Q \u2192 x \u2208 spinGroup Q"}, {"line": "intro hx", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 spinGroup Q\n\u22a2 x \u2208 spinGroup Q"}, {"line": "convert star_mem hx", "tactic_state": "case h.e'_5\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 spinGroup Q\n\u22a2 x = star (star x)\n---\ncase convert_1\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 spinGroup Q\n\u22a2 Star (CliffordAlgebra Q)\n---\ncase convert_2\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 spinGroup Q\n\u22a2 StarMemClass (Submonoid (CliffordAlgebra Q)) (CliffordAlgebra Q)"}, {"line": "exact (star_star x).symm", "tactic_state": "case convert_2\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : star x \u2208 spinGroup Q\n\u22a2 StarMemClass (Submonoid (CliffordAlgebra Q)) (CliffordAlgebra Q)"}]}
{"declaration": "theorem neg_v_mul_e0 (m : M) : -(v Q m * e0 Q) = e0 Q * v Q m := by\n  rw [neg_eq_iff_eq_neg]\n  exact (neg_e0_mul_v _ m).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CliffordAlgebra/EvenEquiv.lean", "context": {"open": [], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M]", "(Q : QuadraticForm R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : AddCommGroup M\nx\u271d\u00b9 : Sort u_3\nv : x\u271d\u00b9\nx\u271d : Sort u_4\ne0 : x\u271d\nm : M\n\u22a2 -(sorry * sorry) = sorry * sorry"}, {"line": "rw [neg_eq_iff_eq_neg]", "tactic_state": "M : Type u_2\ninst\u271d : AddCommGroup M\nx\u271d\u00b9 : Sort u_3\nv : x\u271d\u00b9\nx\u271d : Sort u_4\ne0 : x\u271d\nm : M\n\u22a2 sorry * sorry = -(sorry * sorry)"}, {"line": "exact (neg_e0_mul_v _ m).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_mul_map_eq_neg_of_isOrtho_of_mem_evenOdd_one\n    (hm\u2081 : m\u2081 \u2208 evenOdd Q\u2081 1) (hm\u2082 : m\u2082 \u2208 evenOdd Q\u2082 1) :\n    map f\u2081 m\u2081 * map f\u2082 m\u2082 = - map f\u2082 m\u2082 * map f\u2081 m\u2081 := by\n  simp [map_mul_map_of_isOrtho_of_mem_evenOdd _ _ hf _ _ hm\u2081 hm\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CliffordAlgebra/Prod.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{R M\u2081 M\u2082 N : Type*}", "[CommRing R] [AddCommGroup M\u2081] [AddCommGroup M\u2082] [AddCommGroup N]", "[Module R M\u2081] [Module R M\u2082] [Module R N]", "(Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) (Q\u2099 : QuadraticForm R N)", "{Q\u2081 Q\u2082 Q\u2099}", "(f\u2081 : Q\u2081 \u2192q\u1d62 Q\u2099) (f\u2082 : Q\u2082 \u2192q\u1d62 Q\u2099) (hf : \u2200 x y, Q\u2099.IsOrtho (f\u2081 x) (f\u2082 y))", "(m\u2081 : CliffordAlgebra Q\u2081) (m\u2082 : CliffordAlgebra Q\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM\u2081 : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\u2081\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nQ\u2081 : QuadraticForm R M\u2081\nQ\u2082 : QuadraticForm R M\u2082\nm\u2081 : CliffordAlgebra Q\u2081\nm\u2082 : CliffordAlgebra Q\u2082\nx\u271d\u00b9 : Sort u_5\nevenOdd : x\u271d\u00b9\nx\u271d : Sort u_6\nmap : x\u271d\nhm\u2081 : m\u2081 \u2208 sorry\nhm\u2082 : m\u2082 \u2208 sorry\n\u22a2 sorry * sorry = -sorry * sorry"}, {"line": "simp [map_mul_map_of_isOrtho_of_mem_evenOdd _ _ hf _ _ hm\u2081 hm\u2082]", "tactic_state": "R : Type u_1\nM\u2081 : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\u2081\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nQ\u2081 : QuadraticForm R M\u2081\nQ\u2082 : QuadraticForm R M\u2082\nm\u2081 : CliffordAlgebra Q\u2081\nm\u2082 : CliffordAlgebra Q\u2082\nx\u271d\u00b9 : Sort u_5\nevenOdd : x\u271d\u00b9\nx\u271d : Sort u_6\nmap : x\u271d\nhm\u2081 : m\u2081 \u2208 sorry\nhm\u2082 : m\u2082 \u2208 sorry\n\u22a2 sorry () * sorry () = -(sorry () * sorry ())"}]}
{"declaration": "theorem finrank_eq_of_rank_eq {n : \u2115} (h : Module.rank R M = \u2191n) : finrank R M = n := by\n  simp [finrank, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "context": {"open": ["Cardinal Submodule Module Function"], "variables": ["{R : Type u} {M : Type v} {N : Type w}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nh : Module.rank R M = \u2191n\n\u22a2 finrank R M = n"}, {"line": "simp [finrank, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_le_of_rank_le {n : \u2115} (h : Module.rank R M \u2264 \u2191n) : finrank R M \u2264 n := by\n  rwa [\u2190 Cardinal.toNat_le_iff_le_of_lt_aleph0, toNat_natCast] at h\n  \u00b7 exact h.trans_lt (nat_lt_aleph0 n)\n  \u00b7 exact nat_lt_aleph0 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "context": {"open": ["Cardinal Submodule Module Function"], "variables": ["{R : Type u} {M : Type v} {N : Type w}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nh : Module.rank R M \u2264 \u2191n\n\u22a2 finrank R M \u2264 n"}, {"line": "rwa [\u2190 Cardinal.toNat_le_iff_le_of_lt_aleph0, toNat_natCast] at h", "tactic_state": "case hc\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nh : Module.rank R M \u2264 \u2191n\n\u22a2 Module.rank R M < aleph0\n---\ncase hd\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nh : Module.rank R M \u2264 \u2191n\n\u22a2 \u2191n < aleph0"}, {"line": "\u00b7 exact h.trans_lt (nat_lt_aleph0 n)", "tactic_state": "case hd\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nh : Module.rank R M \u2264 \u2191n\n\u22a2 \u2191n < aleph0"}, {"line": "\u00b7 exact nat_lt_aleph0 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_lt_of_rank_lt {n : \u2115} (h : Module.rank R M < \u2191n) : finrank R M < n := by\n  rwa [\u2190 Cardinal.toNat_lt_iff_lt_of_lt_aleph0, toNat_natCast] at h\n  \u00b7 exact h.trans (nat_lt_aleph0 n)\n  \u00b7 exact nat_lt_aleph0 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "context": {"open": ["Cardinal Submodule Module Function"], "variables": ["{R : Type u} {M : Type v} {N : Type w}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nh : Module.rank R M < \u2191n\n\u22a2 finrank R M < n"}, {"line": "rwa [\u2190 Cardinal.toNat_lt_iff_lt_of_lt_aleph0, toNat_natCast] at h", "tactic_state": "case hc\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nh : Module.rank R M < \u2191n\n\u22a2 Module.rank R M < aleph0\n---\ncase hd\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nh : Module.rank R M < \u2191n\n\u22a2 \u2191n < aleph0"}, {"line": "\u00b7 exact h.trans (nat_lt_aleph0 n)", "tactic_state": "case hd\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nn : \u2115\nh : Module.rank R M < \u2191n\n\u22a2 \u2191n < aleph0"}, {"line": "\u00b7 exact nat_lt_aleph0 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_rank_of_one_lt_finrank (h : 1 < finrank R M) : 1 < Module.rank R M := by\n  simpa using lt_rank_of_lt_finrank h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "context": {"open": ["Cardinal Submodule Module Function"], "variables": ["{R : Type u} {M : Type v} {N : Type w}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nh : 1 < finrank R M\n\u22a2 1 < Module.rank R M"}, {"line": "simpa using lt_rank_of_lt_finrank h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_le_finrank_of_rank_le_rank\n    (h : lift.{w} (Module.rank R M) \u2264 Cardinal.lift.{v} (Module.rank R N))\n    (h' : Module.rank R N < \u2135\u2080) : finrank R M \u2264 finrank R N := by\n  simpa only [toNat_lift] using toNat_le_toNat h (lift_lt_aleph0.mpr h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "context": {"open": ["Cardinal Submodule Module Function"], "variables": ["{R : Type u} {M : Type v} {N : Type w}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\nN : Type w\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\nh : lift.{w, v} (Module.rank R M) \u2264 lift.{v, w} (Module.rank R N)\nh' : Module.rank R N < aleph0\n\u22a2 finrank R M \u2264 finrank R N"}, {"line": "simpa only [toNat_lift] using toNat_le_toNat h (lift_lt_aleph0.mpr h')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_top : finrank R (\u22a4 : Submodule R M) = finrank R M := by\n  unfold finrank\n  simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "context": {"open": ["Cardinal Submodule Module Function", "Module"], "variables": ["{R : Type u} {M : Type v} {N : Type w}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "(R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 finrank R \u21a5\u22a4 = finrank R M"}, {"line": "unfold finrank", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 Cardinal.toNat (Module.rank R \u21a5\u22a4) = Cardinal.toNat (Module.rank R M)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinal_lift_le_rank {\u03b9 : Type w} {v : \u03b9 \u2192 M}\n    (hv : LinearIndependent R v) :\n    Cardinal.lift.{v} #\u03b9 \u2264 Cardinal.lift.{w} (Module.rank R M) := by\n  rw [Module.rank]\n  refine le_trans ?_ (lift_le.mpr <| le_ciSup (bddAbove_range _) \u27e8_, hv.linearIndepOn_id\u27e9)\n  exact lift_mk_le'.mpr \u27e8(Equiv.ofInjective _ hv.injective).toEmbedding\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Basic.lean", "context": {"open": ["Cardinal Submodule Function Set"], "variables": ["{R : Type u} {R' : Type u'} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(R M)", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\n\u03b9 : Type w\nv : \u03b9 \u2192 M\nhv : LinearIndependent R v\n\u22a2 lift.{v, w} (Cardinal.mk \u03b9) \u2264 lift.{w, v} (Module.rank R M)"}, {"line": "rw [Module.rank]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\n\u03b9 : Type w\nv : \u03b9 \u2192 M\nhv : LinearIndependent R v\n\u22a2 lift.{v, w} (Cardinal.mk \u03b9) \u2264 lift.{w, v} (\u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9)"}, {"line": "refine le_trans ?_ (lift_le.mpr <| le_ciSup (bddAbove_range _) \u27e8_, hv.linearIndepOn_id\u27e9)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\n\u03b9 : Type w\nv : \u03b9 \u2192 M\nhv : LinearIndependent R v\n\u22a2 lift.{v, w} (Cardinal.mk \u03b9) \u2264 lift.{w, v} (Cardinal.mk \u2191\u2191\u27e8range v, \u22ef\u27e9)"}, {"line": "exact lift_mk_le'.mpr \u27e8(Equiv.ofInjective _ hv.injective).toEmbedding\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinal_le_rank {\u03b9 : Type v} {v : \u03b9 \u2192 M}\n    (hv : LinearIndependent R v) : #\u03b9 \u2264 Module.rank R M := by\n  simpa using hv.cardinal_lift_le_rank\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Basic.lean", "context": {"open": ["Cardinal Submodule Function Set"], "variables": ["{R : Type u} {R' : Type u'} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(R M)", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\n\u03b9 : Type v\nv : \u03b9 \u2192 M\nhv : LinearIndependent R v\n\u22a2 Cardinal.mk \u03b9 \u2264 Module.rank R M"}, {"line": "simpa using hv.cardinal_lift_le_rank", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_rank_le_of_injective_injective\u209b (i : R' \u2192 R) (j : M \u2192+ M')\n    (hi : Injective i) (hj : Injective j)\n    (hc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m) :\n    lift.{v'} (Module.rank R M) \u2264 lift.{v} (Module.rank R' M') := by\n  simp_rw [Module.rank, lift_iSup (bddAbove_range _)]\n  exact ciSup_mono' (bddAbove_range _) fun \u27e8s, h\u27e9 \u21a6 \u27e8\u27e8j '' s,\n    LinearIndepOn.id_image (h.linearIndependent.map_of_injective_injective\u209b i j hi hj hc)\u27e9,\n    lift_mk_le'.mpr \u27e8(Equiv.Set.image j s hj).toEmbedding\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Basic.lean", "context": {"open": ["Cardinal Submodule Function Set"], "variables": ["{R : Type u} {R' : Type u'} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(R M)", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Nontrivial R]", "[Semiring R] [AddCommMonoid M] [Module R M] [Semiring R']", "[AddCommMonoid M'] [Module R' M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nR' : Type u'\nM : Type v\nM' : Type v'\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ni : R' \u2192 R\nj : M \u2192+ M'\nhi : Injective i\nhj : Injective \u21d1j\nhc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m\n\u22a2 lift.{v', v} (Module.rank R M) \u2264 lift.{v, v'} (Module.rank R' M')"}, {"line": "simp_rw [Module.rank, lift_iSup (bddAbove_range _)]", "tactic_state": "R : Type u\nR' : Type u'\nM : Type v\nM' : Type v'\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ni : R' \u2192 R\nj : M \u2192+ M'\nhi : Injective i\nhj : Injective \u21d1j\nhc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m\n\u22a2 \u2a06 i, lift.{v', v} (Cardinal.mk \u2191\u2191i) \u2264 \u2a06 i, lift.{v, v'} (Cardinal.mk \u2191\u2191i)"}, {"line": "exact ciSup_mono' (bddAbove_range _) fun \u27e8s, h\u27e9 \u21a6 \u27e8\u27e8j '' s,\n    LinearIndepOn.id_image (h.linearIndependent.map_of_injective_injective\u209b i j hi hj hc)\u27e9,\n    lift_mk_le'.mpr \u27e8(Equiv.Set.image j s hj).toEmbedding\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_le_of_injective_injective\u209b (i : R' \u2192 R) (j : M \u2192+ M\u2081)\n    (hi : Injective i) (hj : Injective j)\n    (hc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m) :\n    Module.rank R M \u2264 Module.rank R' M\u2081 := by\n  simpa only [lift_id] using lift_rank_le_of_injective_injective\u209b i j hi hj hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Basic.lean", "context": {"open": ["Cardinal Submodule Function Set"], "variables": ["{R : Type u} {R' : Type u'} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(R M)", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Nontrivial R]", "[Semiring R] [AddCommMonoid M] [Module R M] [Semiring R']", "[AddCommMonoid M'] [Module R' M']", "[AddCommMonoid M\u2081] [Module R' M\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nR' : Type u'\nM M\u2081 : Type v\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R'\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R' M\u2081\ni : R' \u2192 R\nj : M \u2192+ M\u2081\nhi : Injective i\nhj : Injective \u21d1j\nhc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m\n\u22a2 Module.rank R M \u2264 Module.rank R' M\u2081"}, {"line": "simpa only [lift_id] using lift_rank_le_of_injective_injective\u209b i j hi hj hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_le_of_surjective_injective (i : R \u2192 R') (j : M \u2192+ M\u2081)\n    (hi : Surjective i) (hj : Injective j)\n    (hc : \u2200 (r : R) (m : M), j (r \u2022 m) = i r \u2022 j m) :\n    Module.rank R M \u2264 Module.rank R' M\u2081 := by\n  simpa only [lift_id] using lift_rank_le_of_surjective_injective i j hi hj hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Basic.lean", "context": {"open": ["Cardinal Submodule Function Set"], "variables": ["{R : Type u} {R' : Type u'} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(R M)", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Nontrivial R]", "[Semiring R] [AddCommMonoid M] [Module R M] [Semiring R']", "[AddCommMonoid M'] [Module R' M']", "[AddCommMonoid M\u2081] [Module R' M\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nR' : Type u'\nM M\u2081 : Type v\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R'\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R' M\u2081\ni : R \u2192 R'\nj : M \u2192+ M\u2081\nhi : Surjective i\nhj : Injective \u21d1j\nhc : \u2200 (r : R) (m : M), j (r \u2022 m) = i r \u2022 j m\n\u22a2 Module.rank R M \u2264 Module.rank R' M\u2081"}, {"line": "simpa only [lift_id] using lift_rank_le_of_surjective_injective i j hi hj hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_eq_of_equiv_equiv (i : R \u2192 R') (j : M \u2243+ M\u2081)\n    (hi : Bijective i) (hc : \u2200 (r : R) (m : M), j (r \u2022 m) = i r \u2022 j m) :\n    Module.rank R M = Module.rank R' M\u2081 := by\n  simpa only [lift_id] using lift_rank_eq_of_equiv_equiv i j hi hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Basic.lean", "context": {"open": ["Cardinal Submodule Function Set"], "variables": ["{R : Type u} {R' : Type u'} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(R M)", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Nontrivial R]", "[Semiring R] [AddCommMonoid M] [Module R M] [Semiring R']", "[AddCommMonoid M'] [Module R' M']", "[AddCommMonoid M\u2081] [Module R' M\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nR' : Type u'\nM M\u2081 : Type v\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R'\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R' M\u2081\ni : R \u2192 R'\nj : M \u2243+ M\u2081\nhi : Bijective i\nhc : \u2200 (r : R) (m : M), j (r \u2022 m) = i r \u2022 j m\n\u22a2 Module.rank R M = Module.rank R' M\u2081"}, {"line": "simpa only [lift_id] using lift_rank_eq_of_equiv_equiv i j hi hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_rank_le_of_injective_injective [AddCommGroup M'] [Module R' M']\n    (i : R' \u2192 R) (j : M \u2192+ M') (hi : \u2200 r, i r = 0 \u2192 r = 0) (hj : Injective j)\n    (hc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m) :\n    lift.{v'} (Module.rank R M) \u2264 lift.{v} (Module.rank R' M') := by\n  simp_rw [Module.rank, lift_iSup (bddAbove_range _)]\n  exact ciSup_mono' (bddAbove_range _) fun \u27e8s, h\u27e9 \u21a6\n    \u27e8\u27e8j '' s, LinearIndepOn.id_image <| h.linearIndependent.map_of_injective_injective i j hi\n      (fun _ _ \u21a6 hj <| by rwa [j.map_zero]) hc\u27e9,\n    lift_mk_le'.mpr \u27e8(Equiv.Set.image j s hj).toEmbedding\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Basic.lean", "context": {"open": ["Cardinal Submodule Function Set"], "variables": ["{R : Type u} {R' : Type u'} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(R M)", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Nontrivial R]", "[Semiring R] [AddCommMonoid M] [Module R M] [Semiring R']", "[AddCommMonoid M'] [Module R' M']", "[AddCommMonoid M\u2081] [Module R' M\u2081]", "[Ring R] [AddCommGroup M] [Module R M] [Ring R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nR' : Type u'\nM : Type v\nM' : Type v'\ninst\u271d\u00b9\u2078 : Semiring R\ninst\u271d\u00b9\u2077 : AddCommMonoid M\ninst\u271d\u00b9\u2076 : Module R M\ninst\u271d\u00b9\u2075 : Semiring R\ninst\u271d\u00b9\u2074 : AddCommMonoid M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Nontrivial R\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Semiring R'\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R' M'\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Ring R'\ninst\u271d\u00b9 : AddCommGroup M'\ninst\u271d : Module R' M'\ni : R' \u2192 R\nj : M \u2192+ M'\nhi : \u2200 (r : R'), i r = 0 \u2192 r = 0\nhj : Injective \u21d1j\nhc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m\n\u22a2 lift.{v', v} (Module.rank R M) \u2264 lift.{v, v'} (Module.rank R' M')"}, {"line": "simp_rw [Module.rank, lift_iSup (bddAbove_range _)]", "tactic_state": "R : Type u\nR' : Type u'\nM : Type v\nM' : Type v'\ninst\u271d\u00b9\u2078 : Semiring R\ninst\u271d\u00b9\u2077 : AddCommMonoid M\ninst\u271d\u00b9\u2076 : Module R M\ninst\u271d\u00b9\u2075 : Semiring R\ninst\u271d\u00b9\u2074 : AddCommMonoid M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Nontrivial R\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Semiring R'\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R' M'\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Ring R'\ninst\u271d\u00b9 : AddCommGroup M'\ninst\u271d : Module R' M'\ni : R' \u2192 R\nj : M \u2192+ M'\nhi : \u2200 (r : R'), i r = 0 \u2192 r = 0\nhj : Injective \u21d1j\nhc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m\n\u22a2 \u2a06 i, lift.{v', v} (Cardinal.mk \u2191\u2191i) \u2264 \u2a06 i, lift.{v, v'} (Cardinal.mk \u2191\u2191i)"}, {"line": "exact ciSup_mono' (bddAbove_range _) fun \u27e8s, h\u27e9 \u21a6\n    \u27e8\u27e8j '' s, LinearIndepOn.id_image <| h.linearIndependent.map_of_injective_injective i j hi\n      (fun _ _ \u21a6 hj <| by rwa [j.map_zero]) hc\u27e9,\n    lift_mk_le'.mpr \u27e8(Equiv.Set.image j s hj).toEmbedding\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearEquiv.lift_rank_eq (f : M \u2243\u2097[R] M') :\n    Cardinal.lift.{v'} (Module.rank R M) = Cardinal.lift.{v} (Module.rank R M') := by\n  apply le_antisymm\n  \u00b7 exact f.toLinearMap.lift_rank_le_of_injective f.injective\n  \u00b7 exact f.symm.toLinearMap.lift_rank_le_of_injective f.symm.injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Basic.lean", "context": {"open": ["Cardinal Submodule Function Set"], "variables": ["{R : Type u} {R' : Type u'} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(R M)", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Nontrivial R]", "[Semiring R] [AddCommMonoid M] [Module R M] [Semiring R']", "[AddCommMonoid M'] [Module R' M']", "[AddCommMonoid M\u2081] [Module R' M\u2081]", "[Ring R] [AddCommGroup M] [Module R M] [Ring R']", "{R : Type w} {S : Type v} [CommSemiring R] [Semiring S] [Algebra R S]", "{S' : Type v} [Semiring S'] [Algebra R' S']", "[Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type v\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommGroup M\nR : Type w\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : sorry\n\u22a2 lift.{v', v} (Module.rank R M) = lift.{v, v'} sorry"}, {"line": "apply le_antisymm", "tactic_state": "case a\nM : Type v\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommGroup M\nR : Type w\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : sorry\n\u22a2 lift.{v', v} (Module.rank R M) \u2264 lift.{v, v'} sorry\n---\ncase a\nM : Type v\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommGroup M\nR : Type w\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : sorry\n\u22a2 lift.{v, v'} sorry \u2264 lift.{v', v} (Module.rank R M)"}, {"line": "\u00b7 exact f.toLinearMap.lift_rank_le_of_injective f.injective", "tactic_state": "case a\nM : Type v\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommGroup M\nR : Type w\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : sorry\n\u22a2 lift.{v, v'} sorry \u2264 lift.{v', v} (Module.rank R M)"}, {"line": "\u00b7 exact f.symm.toLinearMap.lift_rank_le_of_injective f.symm.injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIndepOn.quotient_iff_union {s t : Set \u03b9} {f : \u03b9 \u2192 M} (hs : LinearIndepOn R f s)\n    (hst : Disjoint s t) :\n    LinearIndepOn R (mkQ (span R (f '' s)) \u2218 f) t \u2194 LinearIndepOn R f (s \u222a t) := by\n  rw [linearIndepOn_union_iff_quotient hst]\n  rw [and_iff_right hs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\n\u03b9 : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\ns t : Set \u03b9\nf : \u03b9 \u2192 M\nhs : LinearIndepOn R f s\nhst : Disjoint s t\n\u22a2 LinearIndepOn R (\u21d1(span R (f '' s)).mkQ \u2218 f) t \u2194 LinearIndepOn R f (s \u222a t)"}, {"line": "rw [linearIndepOn_union_iff_quotient hst]", "tactic_state": "R : Type u\nM : Type v\n\u03b9 : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\ns t : Set \u03b9\nf : \u03b9 \u2192 M\nhs : LinearIndepOn R f s\nhst : Disjoint s t\n\u22a2 LinearIndepOn R (\u21d1(span R (f '' s)).mkQ \u2218 f) t \u2194 LinearIndepOn R f s \u2227 LinearIndepOn R (\u21d1(span R (f '' s)).mkQ \u2218 f) t"}, {"line": "rw [and_iff_right hs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_ulift : finrank R (ULift M) = finrank R M := by\n  simp_rw [finrank, rank_ulift, toNat_lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 finrank R (ULift.{u_2, v} M) = finrank R M"}, {"line": "simp_rw [finrank, rank_ulift, toNat_lift]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_rank_add_lift_rank_le_rank_prod [Nontrivial R] :\n    lift.{v'} (Module.rank R M) + lift.{v} (Module.rank R M') \u2264 Module.rank R (M \u00d7 M') := by\n  rw [\u2190 rank_ulift]\n  rw [\u2190 rank_ulift]\n  exact (rank_add_rank_le_rank_prod R _).trans_eq\n    (ULift.moduleEquiv.prodCongr ULift.moduleEquiv).rank_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\nM' : Type v'\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup M'\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Nontrivial R\n\u22a2 lift.{v', v} (Module.rank R M) + lift.{v, v'} (Module.rank R M') \u2264 Module.rank R (M \u00d7 M')"}, {"line": "rw [\u2190 rank_ulift]", "tactic_state": "R : Type u\nM : Type v\nM' : Type v'\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup M'\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Nontrivial R\n\u22a2 Module.rank R (ULift.{v', v} M) + lift.{v, v'} (Module.rank R M') \u2264 Module.rank R (M \u00d7 M')"}, {"line": "rw [\u2190 rank_ulift]", "tactic_state": "R : Type u\nM : Type v\nM' : Type v'\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup M'\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Nontrivial R\n\u22a2 Module.rank R (ULift.{v', v} M) + Module.rank R (ULift.{v, v'} M') \u2264 Module.rank R (M \u00d7 M')"}, {"line": "exact (rank_add_rank_le_rank_prod R _).trans_eq\n    (ULift.moduleEquiv.prodCongr ULift.moduleEquiv).rank_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_prod : Module.rank R (M \u00d7 M') =\n    Cardinal.lift.{v'} (Module.rank R M) + Cardinal.lift.{v, v'} (Module.rank R M') := by\n  simpa [rank_eq_card_chooseBasisIndex R M, rank_eq_card_chooseBasisIndex R M', lift_umax]\n    using ((chooseBasis R M).prod (chooseBasis R M')).mk_eq_rank.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\nM' : Type v'\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M'\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R M'\ninst\u271d\u00b2 : StrongRankCondition R\ninst\u271d\u00b9 : Free R M\ninst\u271d : Free R M'\n\u22a2 Module.rank R (M \u00d7 M') = lift.{v', v} (Module.rank R M) + lift.{v, v'} (Module.rank R M')"}, {"line": "simpa [rank_eq_card_chooseBasisIndex R M, rank_eq_card_chooseBasisIndex R M', lift_umax]\n    using ((chooseBasis R M).prod (chooseBasis R M')).mk_eq_rank.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Module.finrank_prod [Module.Finite R M] [Module.Finite R M'] :\n    finrank R (M \u00d7 M') = finrank R M + finrank R M' := by\n  simp [finrank, rank_lt_aleph0 R M, rank_lt_aleph0 R M']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\nM' : Type v'\ninst\u271d\u00b9\u00b3 : Ring R\ninst\u271d\u00b9\u00b2 : AddCommGroup M\ninst\u271d\u00b9\u00b9 : AddCommGroup M'\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Free R M\ninst\u271d\u00b2 : Free R M'\ninst\u271d\u00b9 : Module.Finite R M\ninst\u271d : Module.Finite R M'\n\u22a2 finrank R (M \u00d7 M') = finrank R M + finrank R M'"}, {"line": "simp [finrank, rank_lt_aleph0 R M, rank_lt_aleph0 R M']", "tactic_state": "R : Type u\nM : Type v\nM' : Type v'\ninst\u271d\u00b9\u00b3 : Ring R\ninst\u271d\u00b9\u00b2 : AddCommGroup M\ninst\u271d\u00b9\u00b9 : AddCommGroup M'\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Free R M\ninst\u271d\u00b2 : Free R M'\ninst\u271d\u00b9 : Module.Finite R M\ninst\u271d : Module.Finite R M'\n\u22a2 Cardinal.toNat (Module.rank R (M \u00d7 M')) = Cardinal.toNat (Module.rank R M) + Cardinal.toNat (Module.rank R M')"}]}
{"declaration": "theorem rank_finsupp' (\u03b9 : Type v) : Module.rank R (\u03b9 \u2192\u2080 M) = #\u03b9 * Module.rank R M := by\n  simp [rank_finsupp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Free R M\n\u03b9 : Type v\n\u22a2 sorry = Cardinal.mk \u03b9 * Module.rank R M"}, {"line": "simp [rank_finsupp]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Free R M\n\u03b9 : Type v\n\u22a2 sorry () = Cardinal.mk \u03b9 * Module.rank R M"}]}
{"declaration": "theorem rank_finsupp_self (\u03b9 : Type w) : Module.rank R (\u03b9 \u2192\u2080 R) = Cardinal.lift.{u} #\u03b9 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type w\n\u22a2 sorry = lift.{u, w} (Cardinal.mk \u03b9)"}, {"line": "simp", "tactic_state": "\u03b9 : Type w\n\u22a2 sorry () = lift.{u, w} (Cardinal.mk \u03b9)"}]}
{"declaration": "theorem rank_finsupp_self' {\u03b9 : Type u} : Module.rank R (\u03b9 \u2192\u2080 R) = #\u03b9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u22a2 sorry = Cardinal.mk \u03b9"}, {"line": "simp", "tactic_state": "\u03b9 : Type u\n\u22a2 sorry () = Cardinal.mk \u03b9"}]}
{"declaration": "theorem rank_matrix'' (m n : Type u) [Finite m] [Finite n] :\n    Module.rank R (Matrix m n R) = #m * #n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : Type u\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\n\u22a2 sorry = Cardinal.mk m * Cardinal.mk n"}, {"line": "simp", "tactic_state": "m n : Type u\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\n\u22a2 sorry () = Cardinal.mk m * Cardinal.mk n"}]}
{"declaration": "theorem finrank_matrix (m n : Type*) [Fintype m] [Fintype n] :\n    finrank R (Matrix m n M) = card m * card n * finrank R M := by simp [finrank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\nm : Type u_2\nn : Type u_3\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\n\u22a2 finrank R (Matrix m n M) = card m * card n * finrank R M"}, {"line": "simp [finrank]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\nm : Type u_2\nn : Type u_3\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\n\u22a2 Cardinal.toNat (Module.rank R (Matrix m n M)) = card m * card n * Cardinal.toNat (Module.rank R M)"}]}
{"declaration": "theorem Module.finrank_pi {\u03b9 : Type v} [Fintype \u03b9] :\n    finrank R (\u03b9 \u2192 R) = Fintype.card \u03b9 := by\n  simp [finrank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype", "Module.Free", "LinearMap"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']", "[StrongRankCondition R] [Module.Free R M]", "[\u2200 i, AddCommMonoid (\u03c6 i)] [\u2200 i, Module R (\u03c6 i)] [\u2200 i, Module.Free R (\u03c6 i)]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type v\ninst\u271d : Fintype \u03b9\n\u22a2 sorry = card \u03b9"}, {"line": "simp [finrank]", "tactic_state": "\u03b9 : Type v\ninst\u271d : Fintype \u03b9\n\u22a2 sorry () = card \u03b9"}]}
{"declaration": "theorem rank_fin_fun (n : \u2115) : Module.rank R (Fin n \u2192 R) = n := by simp [rank_fun']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype", "Module.Free", "LinearMap"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']", "[StrongRankCondition R] [Module.Free R M]", "[\u2200 i, AddCommMonoid (\u03c6 i)] [\u2200 i, Module R (\u03c6 i)] [\u2200 i, Module.Free R (\u03c6 i)]", "(R)", "{R}", "[Fintype \u03b7]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry = n"}, {"line": "simp [rank_fun']", "tactic_state": "n : \u2115\n\u22a2 sorry () = n"}]}
{"declaration": "theorem Module.finrank_fin_fun {n : \u2115} : finrank R (Fin n \u2192 R) = n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype", "Module.Free", "LinearMap"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']", "[StrongRankCondition R] [Module.Free R M]", "[\u2200 i, AddCommMonoid (\u03c6 i)] [\u2200 i, Module R (\u03c6 i)] [\u2200 i, Module.Free R (\u03c6 i)]", "(R)", "{R}", "[Fintype \u03b7]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry = n"}, {"line": "simp", "tactic_state": "n : \u2115\n\u22a2 sorry () = n"}]}
{"declaration": "theorem Module.rank_baseChange :\n    Module.rank R (R \u2297[S] M') = Cardinal.lift.{u} (Module.rank S M') := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype", "Module.Free", "LinearMap", "TensorProduct", "Module.Free"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']", "[StrongRankCondition R] [Module.Free R M]", "[\u2200 i, AddCommMonoid (\u03c6 i)] [\u2200 i, Module R (\u03c6 i)] [\u2200 i, Module.Free R (\u03c6 i)]", "(R)", "{R}", "[Fintype \u03b7]", "(R)", "{R}", "[StrongRankCondition R] [StrongRankCondition S]", "[Module S M] [Module S M'] [Module.Free S M']", "[Module S M\u2081] [Module.Free S M\u2081]", "[Algebra S R] [IsScalarTower S R M] [Module.Free R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u'\nM' : Type v'\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : CommSemiring S\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : StrongRankCondition S\ninst\u271d\u00b9 : Module S M'\ninst\u271d : Free S M'\n\u22a2 sorry = Cardinal.lift.{u, v'} (Module.rank S M')"}, {"line": "simp", "tactic_state": "S : Type u'\nM' : Type v'\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : CommSemiring S\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : StrongRankCondition S\ninst\u271d\u00b9 : Module S M'\ninst\u271d : Free S M'\n\u22a2 sorry () = Cardinal.lift.{u, v'} (Module.rank S M')"}]}
{"declaration": "theorem Module.finrank_tensorProduct :\n    finrank R (M \u2297[S] M') = finrank R M * finrank S M' := by simp [finrank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype", "Module.Free", "LinearMap", "TensorProduct", "Module.Free"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']", "[StrongRankCondition R] [Module.Free R M]", "[\u2200 i, AddCommMonoid (\u03c6 i)] [\u2200 i, Module R (\u03c6 i)] [\u2200 i, Module.Free R (\u03c6 i)]", "(R)", "{R}", "[Fintype \u03b7]", "(R)", "{R}", "[StrongRankCondition R] [StrongRankCondition S]", "[Module S M] [Module S M'] [Module.Free S M']", "[Module S M\u2081] [Module.Free S M\u2081]", "[Algebra S R] [IsScalarTower S R M] [Module.Free R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type u'\nM : Type v\nM' : Type v'\ninst\u271d\u00b2\u2077 : Ring R\ninst\u271d\u00b2\u2076 : CommRing S\ninst\u271d\u00b2\u2075 : AddCommGroup M\ninst\u271d\u00b2\u2074 : AddCommGroup M'\ninst\u271d\u00b2\u00b3 : Module R M\ninst\u271d\u00b2\u00b2 : Semiring R\ninst\u271d\u00b2\u00b9 : CommSemiring S\ninst\u271d\u00b2\u2070 : AddCommMonoid M\ninst\u271d\u00b9\u2079 : AddCommMonoid M'\ninst\u271d\u00b9\u2078 : Module R M\ninst\u271d\u00b9\u2077 : Module R M'\ninst\u271d\u00b9\u2076 : StrongRankCondition R\ninst\u271d\u00b9\u2075 : Free R M\ninst\u271d\u00b9\u2074 : Free R M'\ninst\u271d\u00b9\u00b3 : StrongRankCondition R\ninst\u271d\u00b9\u00b2 : Free R M\ninst\u271d\u00b9\u00b9 : Module R M'\ninst\u271d\u00b9\u2070 : Free R M'\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : StrongRankCondition S\ninst\u271d\u2075 : Module S M\ninst\u271d\u2074 : Module S M'\ninst\u271d\u00b3 : Free S M'\ninst\u271d\u00b2 : Algebra S R\ninst\u271d\u00b9 : IsScalarTower S R M\ninst\u271d : Free R M\n\u22a2 finrank R (TensorProduct S M M') = finrank R M * finrank S M'"}, {"line": "simp [finrank]", "tactic_state": "R : Type u\nS : Type u'\nM : Type v\nM' : Type v'\ninst\u271d\u00b2\u2077 : Ring R\ninst\u271d\u00b2\u2076 : CommRing S\ninst\u271d\u00b2\u2075 : AddCommGroup M\ninst\u271d\u00b2\u2074 : AddCommGroup M'\ninst\u271d\u00b2\u00b3 : Module R M\ninst\u271d\u00b2\u00b2 : Semiring R\ninst\u271d\u00b2\u00b9 : CommSemiring S\ninst\u271d\u00b2\u2070 : AddCommMonoid M\ninst\u271d\u00b9\u2079 : AddCommMonoid M'\ninst\u271d\u00b9\u2078 : Module R M\ninst\u271d\u00b9\u2077 : Module R M'\ninst\u271d\u00b9\u2076 : StrongRankCondition R\ninst\u271d\u00b9\u2075 : Free R M\ninst\u271d\u00b9\u2074 : Free R M'\ninst\u271d\u00b9\u00b3 : StrongRankCondition R\ninst\u271d\u00b9\u00b2 : Free R M\ninst\u271d\u00b9\u00b9 : Module R M'\ninst\u271d\u00b9\u2070 : Free R M'\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : StrongRankCondition S\ninst\u271d\u2075 : Module S M\ninst\u271d\u2074 : Module S M'\ninst\u271d\u00b3 : Free S M'\ninst\u271d\u00b2 : Algebra S R\ninst\u271d\u00b9 : IsScalarTower S R M\ninst\u271d : Free R M\n\u22a2 Cardinal.toNat (Module.rank R (TensorProduct S M M')) =\n    Cardinal.toNat (Module.rank R M) * Cardinal.toNat (Module.rank S M')"}]}
{"declaration": "theorem Module.finrank_baseChange : finrank R (R \u2297[S] M') = finrank S M' := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype", "Module.Free", "LinearMap", "TensorProduct", "Module.Free"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']", "[StrongRankCondition R] [Module.Free R M]", "[\u2200 i, AddCommMonoid (\u03c6 i)] [\u2200 i, Module R (\u03c6 i)] [\u2200 i, Module.Free R (\u03c6 i)]", "(R)", "{R}", "[Fintype \u03b7]", "(R)", "{R}", "[StrongRankCondition R] [StrongRankCondition S]", "[Module S M] [Module S M'] [Module.Free S M']", "[Module S M\u2081] [Module.Free S M\u2081]", "[Algebra S R] [IsScalarTower S R M] [Module.Free R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u'\nM' : Type v'\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : CommSemiring S\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : StrongRankCondition S\ninst\u271d\u00b9 : Module S M'\ninst\u271d : Free S M'\n\u22a2 sorry = finrank S M'"}, {"line": "simp", "tactic_state": "S : Type u'\nM' : Type v'\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : CommSemiring S\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : StrongRankCondition S\ninst\u271d\u00b9 : Module S M'\ninst\u271d : Free S M'\n\u22a2 sorry () = finrank S M'"}]}
{"declaration": "theorem rank_span_finset_le (s : Finset M) : Module.rank R (span R (s : Set M)) \u2264 s.card := by\n  simpa using rank_span_le s.toSet\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype", "Module.Free", "LinearMap", "TensorProduct", "Module.Free", "Module"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']", "[StrongRankCondition R] [Module.Free R M]", "[\u2200 i, AddCommMonoid (\u03c6 i)] [\u2200 i, Module R (\u03c6 i)] [\u2200 i, Module.Free R (\u03c6 i)]", "(R)", "{R}", "[Fintype \u03b7]", "(R)", "{R}", "[StrongRankCondition R] [StrongRankCondition S]", "[Module S M] [Module S M'] [Module.Free S M']", "[Module S M\u2081] [Module.Free S M\u2081]", "[Algebra S R] [IsScalarTower S R M] [Module.Free R M]", "[StrongRankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Free R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\ns : Finset M\n\u22a2 Module.rank R \u21a5(span R \u2191s) \u2264 \u2191s.card"}, {"line": "simpa using rank_span_le s.toSet", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_span_finset_le_card (s : Finset M) : (s : Set M).finrank R \u2264 s.card :=\n  calc\n    (s : Set M).finrank R \u2264 (s : Set M).toFinset.card := finrank_span_le_card (M := M) s\n    _ = s.card := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype", "Module.Free", "LinearMap", "TensorProduct", "Module.Free", "Module", "Submodule Module"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']", "[StrongRankCondition R] [Module.Free R M]", "[\u2200 i, AddCommMonoid (\u03c6 i)] [\u2200 i, Module R (\u03c6 i)] [\u2200 i, Module.Free R (\u03c6 i)]", "(R)", "{R}", "[Fintype \u03b7]", "(R)", "{R}", "[StrongRankCondition R] [StrongRankCondition S]", "[Module S M] [Module S M'] [Module.Free S M']", "[Module S M\u2081] [Module.Free S M\u2081]", "[Algebra S R] [IsScalarTower S R M] [Module.Free R M]", "[StrongRankCondition R]", "[StrongRankCondition R]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Free R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\ns : Finset M\n\u22a2 (\u2191s).toFinset.card = s.card"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_span_finset_eq_card {s : Finset M} (hs : LinearIndepOn R id (s : Set M)) :\n    finrank R (span R (s : Set M)) = s.card := by\n  convert finrank_span_set_eq_card (s := (s : Set M)) hs\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "context": {"open": ["Basis Cardinal DirectSum Function Module Set Submodule", "Module.Free", "Module.Free", "Fintype", "Module.Free", "LinearMap", "TensorProduct", "Module.Free", "Module", "Submodule Module"], "variables": ["{R : Type u} {S : Type u'} {M : Type v} {M' : Type v'} {M\u2081 : Type v}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[Ring R] [CommRing S] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M]", "[Semiring R] [CommSemiring S] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M\u2081]", "[Module R M]", "(R M M')", "[Module R M\u2081] [Module R M']", "{R M M'}", "[StrongRankCondition R] [Module.Free R M] [Module.Free R M'] [Module.Free R M\u2081]", "(R M M')", "[StrongRankCondition R] [Module.Free R M] [Module R M'] [Module.Free R M']", "[StrongRankCondition R] [Module.Free R M]", "[\u2200 i, AddCommMonoid (\u03c6 i)] [\u2200 i, Module R (\u03c6 i)] [\u2200 i, Module.Free R (\u03c6 i)]", "(R)", "{R}", "[Fintype \u03b7]", "(R)", "{R}", "[StrongRankCondition R] [StrongRankCondition S]", "[Module S M] [Module S M'] [Module.Free S M']", "[Module S M\u2081] [Module.Free S M\u2081]", "[Algebra S R] [IsScalarTower S R M] [Module.Free R M]", "[StrongRankCondition R]", "[StrongRankCondition R]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Free R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\ns : Finset M\nhs : LinearIndepOn R _root_.id \u2191s\n\u22a2 finrank R \u21a5(span R \u2191s) = s.card"}, {"line": "convert finrank_span_set_eq_card (s := (s : Set M)) hs", "tactic_state": "case h.e'_3.h.e'_2\nR : Type u\nM : Type v\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Free R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\ns : Finset M\nhs : LinearIndepOn R _root_.id \u2191s\n\u22a2 s = (\u2191s).toFinset\n---\nR : Type u\nM : Type v\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Free R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\ns : Finset M\nhs : LinearIndepOn R _root_.id \u2191s\n\u22a2 StrongRankCondition R"}, {"line": "ext", "tactic_state": "case h.e'_3.h.e'_2.h\nR : Type u\nM : Type v\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Free R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\ns : Finset M\nhs : LinearIndepOn R _root_.id \u2191s\na\u271d : M\n\u22a2 a\u271d \u2208 s \u2194 a\u271d \u2208 (\u2191s).toFinset\n---\nR : Type u\nM : Type v\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Free R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\ns : Finset M\nhs : LinearIndepOn R _root_.id \u2191s\n\u22a2 StrongRankCondition R"}, {"line": "simp", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Free R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Free R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Free R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\ns : Finset M\nhs : LinearIndepOn R _root_.id \u2191s\n\u22a2 StrongRankCondition R"}]}
{"declaration": "theorem linearIndependent_iff_card_le_finrank_span {\u03b9 : Type*} [Fintype \u03b9] {b : \u03b9 \u2192 V} :\n    LinearIndependent K b \u2194 Fintype.card \u03b9 \u2264 (Set.range b).finrank K := by\n  rw [linearIndependent_iff_card_eq_finrank_span]\n  rw [(finrank_range_le_card _).le_iff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/DivisionRing.lean", "context": {"open": ["Cardinal Basis Submodule Function Set", "LinearMap", "Module"], "variables": ["{K R : Type u} {V V\u2081 V\u2082 V\u2083 : Type v} {V' V'\u2081 : Type v'} {V'' : Type v''}", "{\u03b9 : Type w} {\u03b9' : Type w'} {\u03b7 : Type u\u2081'} {\u03c6 : \u03b7 \u2192 Type*}", "[DivisionRing K]", "[AddCommGroup V] [Module K V]", "[AddCommGroup V'] [Module K V']", "[AddCommGroup V\u2081] [Module K V\u2081]", "[AddCommGroup V\u2082] [Module K V\u2082]", "[AddCommGroup V\u2083] [Module K V\u2083]", "[DivisionRing K] [AddCommGroup V] [Module K V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\nV : Type v\ninst\u271d\u2076 : DivisionRing K\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module K V\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\nb : \u03b9 \u2192 V\n\u22a2 LinearIndependent K b \u2194 Fintype.card \u03b9 \u2264 Set.finrank K (Set.range b)"}, {"line": "rw [linearIndependent_iff_card_eq_finrank_span]", "tactic_state": "K : Type u\nV : Type v\ninst\u271d\u2076 : DivisionRing K\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module K V\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\nb : \u03b9 \u2192 V\n\u22a2 Fintype.card \u03b9 = Set.finrank K (Set.range b) \u2194 Fintype.card \u03b9 \u2264 Set.finrank K (Set.range b)\n---\nK : Type u\nV : Type v\ninst\u271d\u2076 : DivisionRing K\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module K V\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\nb : \u03b9 \u2192 V\n\u22a2 Fintype \u03b9"}, {"line": "rw [(finrank_range_le_card _).le_iff_eq]", "tactic_state": "K : Type u\nV : Type v\ninst\u271d\u2076 : DivisionRing K\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module K V\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\nb : \u03b9 \u2192 V\n\u22a2 StrongRankCondition K"}]}
{"declaration": "theorem linearIndependent_bounded_of_finset_linearIndependent_bounded {n : \u2115}\n    (H : \u2200 s : Finset M, (LinearIndependent R fun i : s => (i : M)) \u2192 s.card \u2264 n) :\n    \u2200 s : Set M, LinearIndependent R ((\u2191) : s \u2192 M) \u2192 #s \u2264 n := by\n  intro s li\n  apply Cardinal.card_le_of\n  intro t\n  rw [\u2190 Finset.card_map (Embedding.subtype s)]\n  apply H\n  apply linearIndependent_finset_map_embedding_subtype _ li\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\n\u22a2 \u2200 (s : Set M), LinearIndependent R Subtype.val \u2192 Cardinal.mk \u2191s \u2264 \u2191n"}, {"line": "intro s li", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set M\nli : LinearIndependent R Subtype.val\n\u22a2 Cardinal.mk \u2191s \u2264 \u2191n"}, {"line": "apply Cardinal.card_le_of", "tactic_state": "case H\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set M\nli : LinearIndependent R Subtype.val\n\u22a2 \u2200 (s_1 : Finset \u2191s), s_1.card \u2264 n"}, {"line": "intro t", "tactic_state": "case H\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\n\u22a2 t.card \u2264 n"}, {"line": "rw [\u2190 Finset.card_map (Embedding.subtype s)]", "tactic_state": "case H\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\n\u22a2 (Finset.map (Embedding.subtype s) t).card \u2264 n"}, {"line": "apply H", "tactic_state": "case H.a\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\n\u22a2 LinearIndependent R fun i => \u2191i"}, {"line": "apply linearIndependent_finset_map_embedding_subtype _ li", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_le {n : \u2115}\n    (H : \u2200 s : Finset M, (LinearIndependent R fun i : s => (i : M)) \u2192 s.card \u2264 n) :\n    Module.rank R M \u2264 n := by\n  rw [Module.rank_def]\n  apply ciSup_le'\n  rintro \u27e8s, li\u27e9\n  exact linearIndependent_bounded_of_finset_linearIndependent_bounded H _ li\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\n\u22a2 Module.rank R M \u2264 \u2191n"}, {"line": "rw [Module.rank_def]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\n\u22a2 \u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9 \u2264 \u2191n"}, {"line": "apply ciSup_le'", "tactic_state": "case h\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\n\u22a2 \u2200 (i : { s // LinearIndepOn R id s }), Cardinal.mk \u2191\u2191i \u2264 \u2191n"}, {"line": "rintro \u27e8s, li\u27e9", "tactic_state": "case h.mk\nR : Type u\nM : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nn : \u2115\nH : \u2200 (s : Finset M), (LinearIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set M\nli : LinearIndepOn R id s\n\u22a2 Cardinal.mk \u2191\u2191\u27e8s, li\u27e9 \u2264 \u2191n"}, {"line": "exact linearIndependent_bounded_of_finset_linearIndependent_bounded H _ li", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Module.finite_of_rank_eq_zero [NoZeroSMulDivisors R M]\n    (h : Module.rank R M = 0) :\n    Module.Finite R M := by\n  nontriviality R\n  rw [rank_zero_iff] at h\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : NoZeroSMulDivisors R M\nh : Module.rank R M = 0\n\u22a2 Module.Finite R M"}, {"line": "nontriviality R", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : NoZeroSMulDivisors R M\nh : Module.rank R M = 0\ninst\u271d : Nontrivial R\n\u22a2 Module.Finite R M"}, {"line": "rw [rank_zero_iff] at h", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : NoZeroSMulDivisors R M\nh : Subsingleton M\ninst\u271d : Nontrivial R\n\u22a2 Module.Finite R M\n---\nR : Type u\nM : Type v\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : NoZeroSMulDivisors R M\nh : Module.rank R M = 0\ninst\u271d : Nontrivial R\n\u22a2 NoZeroSMulDivisors R M"}, {"line": "infer_instance", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : NoZeroSMulDivisors R M\nh : Module.rank R M = 0\ninst\u271d : Nontrivial R\n\u22a2 NoZeroSMulDivisors R M"}]}
{"declaration": "theorem fintype_card_le_finrank [Module.Finite R M]\n    {\u03b9 : Type*} [Fintype \u03b9] {b : \u03b9 \u2192 M} (h : LinearIndependent R b) :\n    Fintype.card \u03b9 \u2264 finrank R M := by\n  simpa using h.cardinalMk_le_finrank\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : NoZeroSMulDivisors R M\ninst\u271d\u00b3 inst\u271d\u00b2 : StrongRankCondition R\ninst\u271d\u00b9 : Module.Finite R M\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nb : \u03b9 \u2192 M\nh : LinearIndependent R b\n\u22a2 Fintype.card \u03b9 \u2264 finrank R M"}, {"line": "simpa using h.cardinalMk_le_finrank", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finset_card_le_finrank [Module.Finite R M]\n    {b : Finset M} (h : LinearIndependent R (fun x => x : b \u2192 M)) :\n    b.card \u2264 finrank R M := by\n  rw [\u2190 Fintype.card_coe]\n  exact h.fintype_card_le_finrank\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b2 inst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nb : Finset M\nh : LinearIndependent R fun x => \u2191x\n\u22a2 b.card \u2264 finrank R M"}, {"line": "rw [\u2190 Fintype.card_coe]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b2 inst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nb : Finset M\nh : LinearIndependent R fun x => \u2191x\n\u22a2 Fintype.card { x // x \u2208 b } \u2264 finrank R M"}, {"line": "exact h.fintype_card_le_finrank", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_set_linearIndependent_of_lt_rank {n : Cardinal} (hn : n < Module.rank R M) :\n    \u2203 s : Set M, #s = n \u2227 LinearIndepOn R id s := by\n  obtain \u27e8\u27e8s, hs\u27e9, hs'\u27e9 := exists_lt_of_lt_ciSup' (hn.trans_eq (Module.rank_def R M))\n  obtain \u27e8t, ht, ht'\u27e9 := le_mk_iff_exists_subset.mp hs'.le\n  exact \u27e8t, ht', hs.mono ht\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\nn : Cardinal.{v}\nhn : n < Module.rank R M\n\u22a2 \u2203 s, Cardinal.mk \u2191s = n \u2227 LinearIndepOn R id s"}, {"line": "obtain \u27e8\u27e8s, hs\u27e9, hs'\u27e9 := exists_lt_of_lt_ciSup' (hn.trans_eq (Module.rank_def R M))", "tactic_state": "case intro.mk\nR : Type u\nM : Type v\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\nn : Cardinal.{v}\nhn : n < Module.rank R M\ns : Set M\nhs : LinearIndepOn R id s\nhs' : n < Cardinal.mk \u2191\u2191\u27e8s, hs\u27e9\n\u22a2 \u2203 s, Cardinal.mk \u2191s = n \u2227 LinearIndepOn R id s"}, {"line": "obtain \u27e8t, ht, ht'\u27e9 := le_mk_iff_exists_subset.mp hs'.le", "tactic_state": "case intro.mk.intro.intro\nR : Type u\nM : Type v\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\nn : Cardinal.{v}\nhn : n < Module.rank R M\ns : Set M\nhs : LinearIndepOn R id s\nhs' : n < Cardinal.mk \u2191\u2191\u27e8s, hs\u27e9\nt : Set M\nht : t \u2286 \u2191\u27e8s, hs\u27e9\nht' : Cardinal.mk \u2191t = n\n\u22a2 \u2203 s, Cardinal.mk \u2191s = n \u2227 LinearIndepOn R id s"}, {"line": "exact \u27e8t, ht', hs.mono ht\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSupIndep.subtype_ne_bot_le_rank [Nontrivial R]\n    {V : \u03b9 \u2192 Submodule R M} (hV : iSupIndep V) :\n    Cardinal.lift.{v} #{ i : \u03b9 // V i \u2260 \u22a5 } \u2264 Cardinal.lift.{w} (Module.rank R M) := by\n  set I := { i : \u03b9 // V i \u2260 \u22a5 }\n  have hI : \u2200 i : I, \u2203 v \u2208 V i, v \u2260 (0 : M) := by\n    intro i\n    rw [\u2190 Submodule.ne_bot_iff]\n    exact i.prop\n  choose v hvV hv using hI\n  have : LinearIndependent R v := (hV.comp Subtype.coe_injective).linearIndependent _ hvV hv\n  exact this.cardinal_lift_le_rank\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R] in", "[NoZeroSMulDivisors R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\n\u03b9 : Type w\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b2 inst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Nontrivial R\nV : \u03b9 \u2192 Submodule R M\nhV : iSupIndep V\n\u22a2 lift.{v, w} (Cardinal.mk { i // V i \u2260 \u22a5 }) \u2264 lift.{w, v} (Module.rank R M)"}, {"line": "set I := { i : \u03b9 // V i \u2260 \u22a5 }", "tactic_state": "R : Type u\nM : Type v\n\u03b9 : Type w\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b2 inst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Nontrivial R\nV : \u03b9 \u2192 Submodule R M\nhV : iSupIndep V\nI : Type w := { i // V i \u2260 \u22a5 }\n\u22a2 lift.{v, w} (Cardinal.mk I) \u2264 lift.{w, v} (Module.rank R M)"}, {"line": "have hI : \u2200 i : I, \u2203 v \u2208 V i, v \u2260 (0 : M) := sorry", "tactic_state": "R : Type u\nM : Type v\n\u03b9 : Type w\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b2 inst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Nontrivial R\nV : \u03b9 \u2192 Submodule R M\nhV : iSupIndep V\nI : Type w := { i // V i \u2260 \u22a5 }\nhI : \u2200 (i : I), \u2203 v \u2208 V \u2191i, v \u2260 sorry\n\u22a2 lift.{v, w} (Cardinal.mk I) \u2264 lift.{w, v} (Module.rank R M)"}, {"line": "choose v hvV hv using hI", "tactic_state": "R : Type u\nM : Type v\n\u03b9 : Type w\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b2 inst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Nontrivial R\nV : \u03b9 \u2192 Submodule R M\nhV : iSupIndep V\nI : Type w := { i // V i \u2260 \u22a5 }\nv : I \u2192 M\nhvV : \u2200 (i : I), v i \u2208 V \u2191i\nhv : \u2200 (i : I), v i \u2260 sorry\n\u22a2 lift.{v, w} (Cardinal.mk I) \u2264 lift.{w, v} (Module.rank R M)"}, {"line": "have : LinearIndependent R v := (hV.comp Subtype.coe_injective).linearIndependent _ hvV hv", "tactic_state": "R : Type u\nM : Type v\n\u03b9 : Type w\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b2 inst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Nontrivial R\nV : \u03b9 \u2192 Submodule R M\nhV : iSupIndep V\nI : Type w := { i // V i \u2260 \u22a5 }\nv : I \u2192 M\nhvV : \u2200 (i : I), v i \u2208 V \u2191i\nhv : \u2200 (i : I), v i \u2260 sorry\nthis : sorry\n\u22a2 lift.{v, w} (Cardinal.mk I) \u2264 lift.{w, v} (Module.rank R M)"}, {"line": "exact this.cardinal_lift_le_rank", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSupIndep.subtype_ne_bot_le_finrank\n    {p : \u03b9 \u2192 Submodule R M} (hp : iSupIndep p) [Fintype { i // p i \u2260 \u22a5 }] :\n    Fintype.card { i // p i \u2260 \u22a5 } \u2264 finrank R M := by simpa using hp.subtype_ne_bot_le_finrank_aux\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R] in", "[NoZeroSMulDivisors R M]", "[Module.Finite R M] [StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\n\u03b9 : Type w\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : NoZeroSMulDivisors R M\ninst\u271d\u2074 inst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Module.Finite R M\ninst\u271d\u00b9 : StrongRankCondition R\np : \u03b9 \u2192 Submodule R M\nhp : iSupIndep p\ninst\u271d : Fintype { i // p i \u2260 \u22a5 }\n\u22a2 Fintype.card { i // p i \u2260 \u22a5 } \u2264 finrank R M"}, {"line": "simpa using hp.subtype_ne_bot_le_finrank_aux", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Module.finrank_eq_zero_of_rank_eq_zero (h : Module.rank R M = 0) :\n    finrank R M = 0 := by\n  delta finrank\n  rw [h]\n  rw [zero_toNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule", "Finset"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R] in", "[NoZeroSMulDivisors R M]", "[Module.Finite R M] [StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "[StrongRankCondition R] [Module.Finite R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2074 : Ring R\ninst\u271d\u00b9\u00b3 : AddCommGroup M\ninst\u271d\u00b9\u00b2 : Module R M\ninst\u271d\u00b9\u00b9 : Nontrivial R\ninst\u271d\u00b9\u2070 : NoZeroSMulDivisors R M\ninst\u271d\u2079 inst\u271d\u2078 : StrongRankCondition R\ninst\u271d\u2077 : Module.Finite R M\ninst\u271d\u2076 : StrongRankCondition R\ninst\u271d\u2075 : Module.Finite R M\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nh : Module.rank R M = 0\n\u22a2 finrank R M = 0"}, {"line": "delta finrank", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2074 : Ring R\ninst\u271d\u00b9\u00b3 : AddCommGroup M\ninst\u271d\u00b9\u00b2 : Module R M\ninst\u271d\u00b9\u00b9 : Nontrivial R\ninst\u271d\u00b9\u2070 : NoZeroSMulDivisors R M\ninst\u271d\u2079 inst\u271d\u2078 : StrongRankCondition R\ninst\u271d\u2077 : Module.Finite R M\ninst\u271d\u2076 : StrongRankCondition R\ninst\u271d\u2075 : Module.Finite R M\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nh : Module.rank R M = 0\n\u22a2 Cardinal.toNat (Module.rank R M) = 0"}, {"line": "rw [h]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2074 : Ring R\ninst\u271d\u00b9\u00b3 : AddCommGroup M\ninst\u271d\u00b9\u00b2 : Module R M\ninst\u271d\u00b9\u00b9 : Nontrivial R\ninst\u271d\u00b9\u2070 : NoZeroSMulDivisors R M\ninst\u271d\u2079 inst\u271d\u2078 : StrongRankCondition R\ninst\u271d\u2077 : Module.Finite R M\ninst\u271d\u2076 : StrongRankCondition R\ninst\u271d\u2075 : Module.Finite R M\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nh : Module.rank R M = 0\n\u22a2 Cardinal.toNat 0 = 0"}, {"line": "rw [zero_toNat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Submodule.bot_eq_top_of_rank_eq_zero [NoZeroSMulDivisors R M] (h : Module.rank R M = 0) :\n    (\u22a5 : Submodule R M) = \u22a4 := by\n  nontriviality R\n  rw [rank_zero_iff] at h\n  subsingleton\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule", "Finset"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R] in", "[NoZeroSMulDivisors R M]", "[Module.Finite R M] [StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "[StrongRankCondition R] [Module.Finite R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Nontrivial R\ninst\u271d\u00b9\u00b9 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Finite R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Module.Finite R M\ninst\u271d\u2075 : StrongRankCondition R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b2 : StrongRankCondition R\ninst\u271d\u00b9 : Module.Finite R M\ninst\u271d : NoZeroSMulDivisors R M\nh : Module.rank R M = 0\n\u22a2 \u22a5 = \u22a4"}, {"line": "nontriviality R", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2076 : Ring R\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Nontrivial R\ninst\u271d\u00b9\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : StrongRankCondition R\ninst\u271d\u2079 : Module.Finite R M\ninst\u271d\u2078 : StrongRankCondition R\ninst\u271d\u2077 : Module.Finite R M\ninst\u271d\u2076 : StrongRankCondition R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : NoZeroSMulDivisors R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Module.Finite R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\nh : Module.rank R M = 0\ninst\u271d : Nontrivial R\n\u22a2 \u22a5 = \u22a4"}, {"line": "rw [rank_zero_iff] at h", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2076 : Ring R\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Nontrivial R\ninst\u271d\u00b9\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : StrongRankCondition R\ninst\u271d\u2079 : Module.Finite R M\ninst\u271d\u2078 : StrongRankCondition R\ninst\u271d\u2077 : Module.Finite R M\ninst\u271d\u2076 : StrongRankCondition R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : NoZeroSMulDivisors R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Module.Finite R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\nh : Subsingleton M\ninst\u271d : Nontrivial R\n\u22a2 \u22a5 = \u22a4\n---\nR : Type u\nM : Type v\ninst\u271d\u00b9\u2076 : Ring R\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Nontrivial R\ninst\u271d\u00b9\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : StrongRankCondition R\ninst\u271d\u2079 : Module.Finite R M\ninst\u271d\u2078 : StrongRankCondition R\ninst\u271d\u2077 : Module.Finite R M\ninst\u271d\u2076 : StrongRankCondition R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : NoZeroSMulDivisors R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Module.Finite R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\nh : Module.rank R M = 0\ninst\u271d : Nontrivial R\n\u22a2 NoZeroSMulDivisors R M"}, {"line": "subsingleton", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2076 : Ring R\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Nontrivial R\ninst\u271d\u00b9\u00b2 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : StrongRankCondition R\ninst\u271d\u2079 : Module.Finite R M\ninst\u271d\u2078 : StrongRankCondition R\ninst\u271d\u2077 : Module.Finite R M\ninst\u271d\u2076 : StrongRankCondition R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : NoZeroSMulDivisors R M\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Module.Finite R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\nh : Module.rank R M = 0\ninst\u271d : Nontrivial R\n\u22a2 NoZeroSMulDivisors R M"}]}
{"declaration": "theorem finrank_le_one (v : M) (h : \u2200 w : M, \u2203 c : R, c \u2022 v = w) : finrank R M \u2264 1 := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rcases eq_or_ne v 0 with (rfl | hn)\n  \u00b7 haveI :=\n      _root_.subsingleton_of_forall_eq (0 : M) fun w => by\n        obtain \u27e8c, rfl\u27e9 := h w\n        simp\n    rw [finrank_zero_of_subsingleton]\n    exact zero_le_one\n  \u00b7 exact (finrank_eq_one v hn h).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule", "Finset"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R] in", "[NoZeroSMulDivisors R M]", "[Module.Finite R M] [StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "[StrongRankCondition R] [Module.Finite R M]", "[Module.Free R M]", "[NoZeroSMulDivisors R M] [StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2077 : Ring R\ninst\u271d\u00b9\u2076 : AddCommGroup M\ninst\u271d\u00b9\u2075 : Module R M\ninst\u271d\u00b9\u2074 : Nontrivial R\ninst\u271d\u00b9\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : StrongRankCondition R\ninst\u271d\u00b9\u2070 : Module.Finite R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Finite R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : NoZeroSMulDivisors R M\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Finite R M\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : StrongRankCondition R\nv : M\nh : \u2200 (w : M), \u2203 c, c \u2022 v = w\n\u22a2 finrank R M \u2264 1"}, {"line": "haveI := nontrivial_of_invariantBasisNumber R", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b9\u2077 : Ring R\ninst\u271d\u00b9\u2076 : AddCommGroup M\ninst\u271d\u00b9\u2075 : Module R M\ninst\u271d\u00b9\u2074 : Nontrivial R\ninst\u271d\u00b9\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : StrongRankCondition R\ninst\u271d\u00b9\u2070 : Module.Finite R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Finite R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : NoZeroSMulDivisors R M\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Finite R M\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : StrongRankCondition R\nv : M\nh : \u2200 (w : M), \u2203 c, c \u2022 v = w\nthis : Nontrivial R\n\u22a2 finrank R M \u2264 1"}, {"line": "rcases eq_or_ne v 0 with (rfl | hn)", "tactic_state": "case inl\nR : Type u\nM : Type v\ninst\u271d\u00b9\u2077 : Ring R\ninst\u271d\u00b9\u2076 : AddCommGroup M\ninst\u271d\u00b9\u2075 : Module R M\ninst\u271d\u00b9\u2074 : Nontrivial R\ninst\u271d\u00b9\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : StrongRankCondition R\ninst\u271d\u00b9\u2070 : Module.Finite R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Finite R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : NoZeroSMulDivisors R M\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Finite R M\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : StrongRankCondition R\nthis : Nontrivial R\nh : \u2200 (w : M), \u2203 c, c \u2022 sorry = w\n\u22a2 finrank R M \u2264 1\n---\ncase inr\nR : Type u\nM : Type v\ninst\u271d\u00b9\u2077 : Ring R\ninst\u271d\u00b9\u2076 : AddCommGroup M\ninst\u271d\u00b9\u2075 : Module R M\ninst\u271d\u00b9\u2074 : Nontrivial R\ninst\u271d\u00b9\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : StrongRankCondition R\ninst\u271d\u00b9\u2070 : Module.Finite R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Finite R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : NoZeroSMulDivisors R M\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Finite R M\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : StrongRankCondition R\nv : M\nh : \u2200 (w : M), \u2203 c, c \u2022 v = w\nthis : Nontrivial R\nhn : v \u2260 sorry\n\u22a2 finrank R M \u2264 1"}, {"line": "\u00b7 haveI :=\n      _root_.subsingleton_of_forall_eq (0 : M) fun w => by\n        obtain \u27e8c, rfl\u27e9 := h w\n        simp\n    rw [finrank_zero_of_subsingleton]\n    exact zero_le_one", "tactic_state": "case inr\nR : Type u\nM : Type v\ninst\u271d\u00b9\u2077 : Ring R\ninst\u271d\u00b9\u2076 : AddCommGroup M\ninst\u271d\u00b9\u2075 : Module R M\ninst\u271d\u00b9\u2074 : Nontrivial R\ninst\u271d\u00b9\u00b3 : NoZeroSMulDivisors R M\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : StrongRankCondition R\ninst\u271d\u00b9\u2070 : Module.Finite R M\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Finite R M\ninst\u271d\u2077 : StrongRankCondition R\ninst\u271d\u2076 : Nontrivial R\ninst\u271d\u2075 : NoZeroSMulDivisors R M\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Finite R M\ninst\u271d\u00b2 : Free R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : StrongRankCondition R\nv : M\nh : \u2200 (w : M), \u2203 c, c \u2022 v = w\nthis : Nontrivial R\nhn : v \u2260 sorry\n\u22a2 finrank R M \u2264 1"}, {"line": "\u00b7 exact (finrank_eq_one v hn h).le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finite_finsupp_self_iff : Module.Finite R (\u03b9 \u2192\u2080 R) \u2194 Subsingleton R \u2228 Finite \u03b9 := by\n  simp only [finite_finsupp_iff]\n  simp only [Finite.self]\n  simp only [true_and]\n  simp only [or_iff_right_iff_imp]\n  exact fun _ \u21a6 .inr inferInstance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Finite.lean", "context": {"open": ["Basis Cardinal Function Module Set Submodule", "Finset"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R] in", "[NoZeroSMulDivisors R M]", "[Module.Finite R M] [StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "[StrongRankCondition R] [Module.Finite R M]", "[Module.Free R M]", "[NoZeroSMulDivisors R M] [StrongRankCondition R]", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : Nontrivial R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\n\u03b9 : Type u_1\n\u22a2 Module.Finite R (\u03b9 \u2192\u2080 R) \u2194 Subsingleton R \u2228 Finite \u03b9"}, {"line": "simp only [finite_finsupp_iff]", "tactic_state": "R : Type u\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : Nontrivial R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\n\u03b9 : Type u_1\n\u22a2 IsEmpty \u03b9 \u2228 Subsingleton R \u2228 Module.Finite R R \u2227 Finite \u03b9 \u2194 Subsingleton R \u2228 Finite \u03b9"}, {"line": "simp only [Finite.self]", "tactic_state": "R : Type u\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : Nontrivial R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\n\u03b9 : Type u_1\n\u22a2 IsEmpty \u03b9 \u2228 Subsingleton R \u2228 True \u2227 Finite \u03b9 \u2194 Subsingleton R \u2228 Finite \u03b9"}, {"line": "simp only [true_and]", "tactic_state": "R : Type u\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : Nontrivial R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\n\u03b9 : Type u_1\n\u22a2 IsEmpty \u03b9 \u2228 Subsingleton R \u2228 Finite \u03b9 \u2194 Subsingleton R \u2228 Finite \u03b9"}, {"line": "simp only [or_iff_right_iff_imp]", "tactic_state": "R : Type u\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : Nontrivial R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : StrongRankCondition R\n\u03b9 : Type u_1\n\u22a2 IsEmpty \u03b9 \u2192 Subsingleton R \u2228 Finite \u03b9"}, {"line": "exact fun _ \u21a6 .inr inferInstance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_of_not_finite (h : \u00acModule.Finite R M) : finrank R M = 0 := by\n  rw [finrank]\n  rw [toNat_eq_zero]\n  rw [\u2190 not_lt]\n  rw [Module.rank_lt_aleph0_iff]\n  exact .inr h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Free.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Module.Free", "Cardinal"], "variables": ["(F : Type u) (K : Type v) (A : Type w)", "[Semiring F] [Semiring K] [AddCommMonoid A]", "[Module F K] [Module K A] [Module F A] [IsScalarTower F K A]", "[StrongRankCondition F] [StrongRankCondition K] [Module.Free F K] [Module.Free K A]", "{R : Type u} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [StrongRankCondition R]", "[AddCommMonoid M] [Module R M] [Module.Free R M]", "[AddCommMonoid M'] [Module R M'] [Module.Free R M']", "[AddCommMonoid M\u2081] [Module R M\u2081] [Module.Free R M\u2081]", "(R M)", "(M M' M\u2081)", "(M M')", "{M M'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 finrank R M = 0"}, {"line": "rw [finrank]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 Cardinal.toNat (Module.rank R M) = 0"}, {"line": "rw [toNat_eq_zero]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 Module.rank R M = 0 \u2228 aleph0 \u2264 Module.rank R M"}, {"line": "rw [\u2190 not_lt]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 Module.rank R M = 0 \u2228 \u00acModule.rank R M < aleph0"}, {"line": "rw [Module.rank_lt_aleph0_iff]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 Module.rank R M = 0 \u2228 \u00acModule.Finite R M\n---\nR : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 StrongRankCondition R\n---\nR : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 Free R M"}, {"line": "exact .inr h", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 StrongRankCondition R\n---\nR : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 Free R M"}]}
{"declaration": "theorem finite_of_finrank_pos (h : 0 < finrank R M) : Module.Finite R M := by\n  contrapose h\n  simp [finrank_of_not_finite h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Free.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Module.Free", "Cardinal"], "variables": ["(F : Type u) (K : Type v) (A : Type w)", "[Semiring F] [Semiring K] [AddCommMonoid A]", "[Module F K] [Module K A] [Module F A] [IsScalarTower F K A]", "[StrongRankCondition F] [StrongRankCondition K] [Module.Free F K] [Module.Free K A]", "{R : Type u} {M M\u2081 : Type v} {M' : Type v'}", "[Semiring R] [StrongRankCondition R]", "[AddCommMonoid M] [Module R M] [Module.Free R M]", "[AddCommMonoid M'] [Module R M'] [Module.Free R M']", "[AddCommMonoid M\u2081] [Module R M\u2081] [Module.Free R M\u2081]", "(R M)", "(M M' M\u2081)", "(M M')", "{M M'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : 0 < finrank R M\n\u22a2 Module.Finite R M"}, {"line": "contrapose h", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 \u00ac0 < finrank R M"}, {"line": "simp [finrank_of_not_finite h]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : StrongRankCondition R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Free R M\nh : \u00acModule.Finite R M\n\u22a2 finrank R M = 0"}]}
{"declaration": "theorem finrank_eq_one_iff' [Module.Free K V] :\n    finrank K V = 1 \u2194 \u2203 v \u2260 0, \u2200 w : V, \u2203 c : K, c \u2022 v = w := by\n  rw [\u2190 rank_eq_one_iff]\n  exact toNat_eq_iff one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/FreeAndStrongRankCondition.lean", "context": {"open": ["Cardinal Module Module Set Submodule"], "variables": ["{K : Type u} {V : Type v} [Ring K] [StrongRankCondition K] [AddCommGroup V] [Module K V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\nV : Type v\ninst\u271d\u2074 : Ring K\ninst\u271d\u00b3 : StrongRankCondition K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : Free K V\n\u22a2 finrank K V = 1 \u2194 \u2203 v, v \u2260 0 \u2227 \u2200 (w : V), \u2203 c, c \u2022 v = w"}, {"line": "rw [\u2190 rank_eq_one_iff]", "tactic_state": "K : Type u\nV : Type v\ninst\u271d\u2074 : Ring K\ninst\u271d\u00b3 : StrongRankCondition K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : Free K V\n\u22a2 finrank K V = 1 \u2194 Module.rank K V = 1\n---\nK : Type u\nV : Type v\ninst\u271d\u2074 : Ring K\ninst\u271d\u00b3 : StrongRankCondition K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : Free K V\n\u22a2 StrongRankCondition K\n---\nK : Type u\nV : Type v\ninst\u271d\u2074 : Ring K\ninst\u271d\u00b3 : StrongRankCondition K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : Free K V\n\u22a2 Free K V"}, {"line": "exact toNat_eq_iff one_ne_zero", "tactic_state": "K : Type u\nV : Type v\ninst\u271d\u2074 : Ring K\ninst\u271d\u00b3 : StrongRankCondition K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : Free K V\n\u22a2 StrongRankCondition K\n---\nK : Type u\nV : Type v\ninst\u271d\u2074 : Ring K\ninst\u271d\u00b3 : StrongRankCondition K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : Free K V\n\u22a2 Free K V"}]}
{"declaration": "theorem cardinalMk_eq_cardinalMk_field_pow_rank (K V : Type u) [Ring K] [StrongRankCondition K]\n    [AddCommGroup V] [Module K V] [Module.Free K V] [Module.Finite K V] :\n    #V = #K ^ Module.rank K V := by\n  simpa using lift_cardinalMk_eq_lift_cardinalMk_field_pow_lift_rank K V\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/FreeAndStrongRankCondition.lean", "context": {"open": ["Cardinal Module Module Set Submodule"], "variables": ["{K : Type u} {V : Type v} [Ring K] [StrongRankCondition K] [AddCommGroup V] [Module K V]", "(K V) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K V : Type u\ninst\u271d\u2075 : Ring K\ninst\u271d\u2074 : StrongRankCondition K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : Free K V\ninst\u271d : Module.Finite K V\n\u22a2 Cardinal.mk V = Cardinal.mk K ^ Module.rank K V"}, {"line": "simpa using lift_cardinalMk_eq_lift_cardinalMk_field_pow_lift_rank K V", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLocalizedModule.lift_rank_eq :\n    Cardinal.lift.{uM} (Module.rank R N) = Cardinal.lift.{uN} (Module.rank R M) := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 simp only [rank_subsingleton, lift_one]\n  apply le_antisymm <;>\n    rw [Module.rank_def] <;>\n    rw [lift_iSup (bddAbove_range _)] <;>\n    apply ciSup_le' <;>\n    intro \u27e8s, hs\u27e9\n  exacts [(IsLocalizedModule.linearIndependent_lift p f hs).choose_spec.cardinal_lift_le_rank,\n    hs.of_isLocalizedModule_of_isRegular p f (le_nonZeroDivisors_iff_isRegular.mp hp)\n      |>.cardinal_lift_le_rank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Localization.lean", "context": {"open": ["Cardinal Module nonZeroDivisors"], "variables": ["{R : Type uR} (S : Type uS) {M : Type uM} {N : Type uN}", "[CommRing R] [CommRing S] [AddCommGroup M] [AddCommGroup N]", "[Module R M] [Module R N] [Algebra R S] [Module S N] [IsScalarTower R S N]", "(p : Submonoid R) [IsLocalization p S] (f : M \u2192\u2097[R] N) [IsLocalizedModule p f]", "(hp : p \u2264 R\u2070)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\nM : Type uM\nN : Type uN\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\n\u22a2 Cardinal.lift.{uM, uN} (Module.rank R N) = Cardinal.lift.{uN, uM} (Module.rank R M)"}, {"line": "cases subsingleton_or_nontrivial R", "tactic_state": "case inl\nR : Type uR\nM : Type uM\nN : Type uN\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nh\u271d : Subsingleton R\n\u22a2 Cardinal.lift.{uM, uN} (Module.rank R N) = Cardinal.lift.{uN, uM} (Module.rank R M)\n---\ncase inr\nR : Type uR\nM : Type uM\nN : Type uN\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nh\u271d : Nontrivial R\n\u22a2 Cardinal.lift.{uM, uN} (Module.rank R N) = Cardinal.lift.{uN, uM} (Module.rank R M)"}, {"line": "\u00b7 simp only [rank_subsingleton, lift_one]", "tactic_state": "case inr\nR : Type uR\nM : Type uM\nN : Type uN\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nh\u271d : Nontrivial R\n\u22a2 Cardinal.lift.{uM, uN} (Module.rank R N) = Cardinal.lift.{uN, uM} (Module.rank R M)"}, {"line": "apply le_antisymm <;>\n    rw [Module.rank_def] <;>\n    rw [lift_iSup (bddAbove_range _)] <;>\n    apply ciSup_le' <;>\n    intro \u27e8s, hs\u27e9", "tactic_state": "case inr.a.h\nR : Type uR\nM : Type uM\nN : Type uN\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nh\u271d : Nontrivial R\ns : Set N\nhs : LinearIndepOn R id s\n\u22a2 Cardinal.lift.{uM, uN} (Cardinal.mk \u2191\u2191\u27e8s, hs\u27e9) \u2264 Cardinal.lift.{uN, uM} (Module.rank R M)\n---\ncase inr.a.h\nR : Type uR\nM : Type uM\nN : Type uN\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nh\u271d : Nontrivial R\ns : Set M\nhs : LinearIndepOn R id s\n\u22a2 Cardinal.lift.{uN, uM} (Cardinal.mk \u2191\u2191\u27e8s, hs\u27e9) \u2264 Cardinal.lift.{uM, uN} (Module.rank R N)"}, {"line": "exacts [(IsLocalizedModule.linearIndependent_lift p f hs).choose_spec.cardinal_lift_le_rank,\n    hs.of_isLocalizedModule_of_isRegular p f (le_nonZeroDivisors_iff_isRegular.mp hp)\n      |>.cardinal_lift_le_rank]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLocalizedModule.finrank_eq : finrank R N = finrank R M := by\n  simpa using congr_arg toNat (lift_rank_eq p f hp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Localization.lean", "context": {"open": ["Cardinal Module nonZeroDivisors"], "variables": ["{R : Type uR} (S : Type uS) {M : Type uM} {N : Type uN}", "[CommRing R] [CommRing S] [AddCommGroup M] [AddCommGroup N]", "[Module R M] [Module R N] [Algebra R S] [Module S N] [IsScalarTower R S N]", "(p : Submonoid R) [IsLocalization p S] (f : M \u2192\u2097[R] N) [IsLocalizedModule p f]", "(hp : p \u2264 R\u2070)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\nM : Type uM\nN : Type uN\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\n\u22a2 finrank R N = finrank R M"}, {"line": "simpa using congr_arg toNat (lift_rank_eq p f hp)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLocalizedModule.rank_eq {N : Type uM} [AddCommGroup N] [Module R N] (f : M \u2192\u2097[R] N)\n    [IsLocalizedModule p f] : Module.rank R N = Module.rank R M := by\n  simpa using lift_rank_eq p f hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Localization.lean", "context": {"open": ["Cardinal Module nonZeroDivisors"], "variables": ["{R : Type uR} (S : Type uS) {M : Type uM} {N : Type uN}", "[CommRing R] [CommRing S] [AddCommGroup M] [AddCommGroup N]", "[Module R M] [Module R N] [Algebra R S] [Module S N] [IsScalarTower R S N]", "(p : Submonoid R) [IsLocalization p S] (f : M \u2192\u2097[R] N) [IsLocalizedModule p f]", "(hp : p \u2264 R\u2070)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\np : Submonoid R\nN : Type uM\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : M \u2192\u2097[R] N\ninst\u271d : IsLocalizedModule p f\n\u22a2 Module.rank R N = Module.rank R M"}, {"line": "simpa using lift_rank_eq p f hp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_eq {P : Type uM} [AddCommGroup P] [Module R P] [Module T P] [IsScalarTower R T P]\n    {g : M \u2192\u2097[R] P} (bc : IsBaseChange T g) : Module.rank T P = Module.rank R M := by\n  simpa using bc.lift_rank_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/Localization.lean", "context": {"open": ["Cardinal Module nonZeroDivisors", "Cardinal TensorProduct"], "variables": ["{R : Type uR} (S : Type uS) {M : Type uM} {N : Type uN}", "[CommRing R] [CommRing S] [AddCommGroup M] [AddCommGroup N]", "[Module R M] [Module R N] [Algebra R S] [Module S N] [IsScalarTower R S N]", "(p : Submonoid R) [IsLocalization p S] (f : M \u2192\u2097[R] N) [IsLocalizedModule p f]", "(hp : p \u2264 R\u2070)", "(R M) in", "{p} [Free S N] [StrongRankCondition S] {T : Type uT} [CommRing T] [Algebra R T]", "{p} {T : Type uT} [CommRing T] [NoZeroDivisors T] [Algebra R T] [FaithfulSMul R T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\nM : Type uM\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\nT : Type uT\ninst\u271d\u2077 : CommRing T\ninst\u271d\u2076 : NoZeroDivisors T\ninst\u271d\u2075 : Algebra R T\ninst\u271d\u2074 : FaithfulSMul R T\nP : Type uM\ninst\u271d\u00b3 : AddCommGroup P\ninst\u271d\u00b2 : Module R P\ninst\u271d\u00b9 : Module T P\ninst\u271d : IsScalarTower R T P\ng : M \u2192\u2097[R] P\nbc : IsBaseChange T g\n\u22a2 Module.rank T P = Module.rank R M"}, {"line": "simpa using bc.lift_rank_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nontrivial_of_hasRankNullity : Nontrivial R := by\n  refine (subsingleton_or_nontrivial R).resolve_left fun H \u21a6 ?_\n  have := rank_quotient_add_rank (R := R) (M := PUnit) \u22a5\n  simp [one_add_one_eq_two] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/RankNullity.lean", "context": {"open": ["Function Set Cardinal Submodule LinearMap"], "variables": ["{R} {M M\u2081 M\u2082 M\u2083 : Type u} {M' : Type v} [Ring R]", "[AddCommGroup M] [AddCommGroup M\u2081] [AddCommGroup M\u2082] [AddCommGroup M\u2083] [AddCommGroup M']", "[Module R M] [Module R M\u2081] [Module R M\u2082] [Module R M\u2083] [Module R M']", "[HasRankNullity.{u} R]", "(R M) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : HasRankNullity.{u, u_1} R\n\u22a2 Nontrivial R"}, {"line": "refine (subsingleton_or_nontrivial R).resolve_left fun H \u21a6 ?_", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : HasRankNullity.{u, u_1} R\nH : Subsingleton R\n\u22a2 False"}, {"line": "have := rank_quotient_add_rank (R := R) (M := PUnit) \u22a5", "tactic_state": "case refine_2\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : HasRankNullity.{u, u_1} R\nH : Subsingleton R\nthis : Module.rank R (PUnit.{?u.13966 + 1} \u29f8 \u22a5) + Module.rank R \u21a5\u22a5 = Module.rank R PUnit.{?u.13966 + 1}\n\u22a2 False\n---\ncase refine_1\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : HasRankNullity.{u, u_1} R\nH : Subsingleton R\n\u22a2 Ring R"}, {"line": "simp [one_add_one_eq_two] at this", "tactic_state": "case refine_1\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : HasRankNullity.{u, u_1} R\nH : Subsingleton R\n\u22a2 Ring R"}]}
{"declaration": "theorem Submodule.rank_add_le_rank_add_rank (s t : Submodule R M) :\n    Module.rank R (s \u2294 t : Submodule R M) \u2264 Module.rank R s + Module.rank R t := by\n  rw [\u2190 Submodule.rank_sup_add_rank_inf_eq]\n  exact self_le_add_right _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/RankNullity.lean", "context": {"open": ["Function Set Cardinal Submodule LinearMap", "Cardinal Basis Submodule Function Set LinearMap"], "variables": ["{R} {M M\u2081 M\u2082 M\u2083 : Type u} {M' : Type v} [Ring R]", "[AddCommGroup M] [AddCommGroup M\u2081] [AddCommGroup M\u2082] [AddCommGroup M\u2083] [AddCommGroup M']", "[Module R M] [Module R M\u2081] [Module R M\u2082] [Module R M\u2083] [Module R M']", "[HasRankNullity.{u} R]", "(R M) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : HasRankNullity.{u, u_1} R\ns t : Submodule R M\n\u22a2 Module.rank R \u21a5(s \u2294 t) \u2264 Module.rank R \u21a5s + Module.rank R \u21a5t"}, {"line": "rw [\u2190 Submodule.rank_sup_add_rank_inf_eq]", "tactic_state": "R : Type u_1\nM : Type u\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : HasRankNullity.{u, u_1} R\ns t : Submodule R M\n\u22a2 Module.rank R \u21a5(s \u2294 t) \u2264 Module.rank R \u21a5(s \u2294 t) + Module.rank R \u21a5(s \u2293 t)\n---\nR : Type u_1\nM : Type u\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : HasRankNullity.{u, u_1} R\ns t : Submodule R M\n\u22a2 HasRankNullity.{u, u_1} R"}, {"line": "exact self_le_add_right _ _", "tactic_state": "R : Type u_1\nM : Type u\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : HasRankNullity.{u, u_1} R\ns t : Submodule R M\n\u22a2 HasRankNullity.{u, u_1} R"}]}
{"declaration": "theorem basis_le_span' {\u03b9 : Type*} (b : Basis \u03b9 R M) {w : Set M} [Fintype w] (s : span R w = \u22a4) :\n    #\u03b9 \u2264 Fintype.card w := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  haveI := basis_finite_of_finite_spans w.toFinite s b\n  cases nonempty_fintype \u03b9\n  rw [Cardinal.mk_fintype \u03b9]\n  simp only [Nat.cast_le]\n  exact Basis.le_span'' b s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module"], "variables": ["{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 : Type w} {\u03b9' : Type w'}", "[InvariantBasisNumber R]", "[RankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\n\u03b9 : Type u_1\nb : Basis \u03b9 R M\nw : Set M\ninst\u271d : Fintype \u2191w\ns : span R w = \u22a4\n\u22a2 Cardinal.mk \u03b9 \u2264 \u2191(Fintype.card \u2191w)"}, {"line": "haveI := nontrivial_of_invariantBasisNumber R", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\n\u03b9 : Type u_1\nb : Basis \u03b9 R M\nw : Set M\ninst\u271d : Fintype \u2191w\ns : span R w = \u22a4\nthis : Nontrivial R\n\u22a2 Cardinal.mk \u03b9 \u2264 \u2191(Fintype.card \u2191w)"}, {"line": "haveI := basis_finite_of_finite_spans w.toFinite s b", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\n\u03b9 : Type u_1\nb : Basis \u03b9 R M\nw : Set M\ninst\u271d : Fintype \u2191w\ns : span R w = \u22a4\nthis\u271d : Nontrivial R\nthis : Finite \u03b9\n\u22a2 Cardinal.mk \u03b9 \u2264 \u2191(Fintype.card \u2191w)"}, {"line": "cases nonempty_fintype \u03b9", "tactic_state": "case intro\nR : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\n\u03b9 : Type u_1\nb : Basis \u03b9 R M\nw : Set M\ninst\u271d : Fintype \u2191w\ns : span R w = \u22a4\nthis\u271d : Nontrivial R\nthis : Finite \u03b9\nval\u271d : Fintype \u03b9\n\u22a2 Cardinal.mk \u03b9 \u2264 \u2191(Fintype.card \u2191w)"}, {"line": "rw [Cardinal.mk_fintype \u03b9]", "tactic_state": "case intro\nR : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\n\u03b9 : Type u_1\nb : Basis \u03b9 R M\nw : Set M\ninst\u271d : Fintype \u2191w\ns : span R w = \u22a4\nthis\u271d : Nontrivial R\nthis : Finite \u03b9\nval\u271d : Fintype \u03b9\n\u22a2 \u2191(Fintype.card \u03b9) \u2264 \u2191(Fintype.card \u2191w)"}, {"line": "simp only [Nat.cast_le]", "tactic_state": "case intro\nR : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\n\u03b9 : Type u_1\nb : Basis \u03b9 R M\nw : Set M\ninst\u271d : Fintype \u2191w\ns : span R w = \u22a4\nthis\u271d : Nontrivial R\nthis : Finite \u03b9\nval\u271d : Fintype \u03b9\n\u22a2 Fintype.card \u03b9 \u2264 Fintype.card \u2191w"}, {"line": "exact Basis.le_span'' b s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearIndependent_le_span' {\u03b9 : Type*} (v : \u03b9 \u2192 M) (i : LinearIndependent R v) (w : Set M)\n    [Fintype w] (s : range v \u2264 span R w) : #\u03b9 \u2264 Fintype.card w := by\n  haveI : Finite \u03b9 := i.finite_of_le_span_finite v w s\n  letI := Fintype.ofFinite \u03b9\n  rw [Cardinal.mk_fintype]\n  simp only [Nat.cast_le]\n  exact linearIndependent_le_span_aux' v i w s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Submodule Finsupp"], "variables": ["{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 : Type w} {\u03b9' : Type w'}", "[InvariantBasisNumber R]", "[RankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\n\u03b9 : Type u_1\nv : \u03b9 \u2192 M\ni : LinearIndependent R v\nw : Set M\ninst\u271d : Fintype \u2191w\ns : range v \u2264 \u2191(span R w)\n\u22a2 Cardinal.mk \u03b9 \u2264 \u2191(Fintype.card \u2191w)"}, {"line": "haveI : Finite \u03b9 := i.finite_of_le_span_finite v w s", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\n\u03b9 : Type u_1\nv : \u03b9 \u2192 M\ni : LinearIndependent R v\nw : Set M\ninst\u271d : Fintype \u2191w\ns : range v \u2264 \u2191(span R w)\nthis : Finite \u03b9\n\u22a2 Cardinal.mk \u03b9 \u2264 \u2191(Fintype.card \u2191w)"}, {"line": "letI := Fintype.ofFinite \u03b9", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\n\u03b9 : Type u_1\nv : \u03b9 \u2192 M\ni : LinearIndependent R v\nw : Set M\ninst\u271d : Fintype \u2191w\ns : range v \u2264 \u2191(span R w)\nthis\u271d : Finite \u03b9\nthis : Fintype \u03b9 := Fintype.ofFinite \u03b9\n\u22a2 Cardinal.mk \u03b9 \u2264 \u2191(Fintype.card \u2191w)"}, {"line": "rw [Cardinal.mk_fintype]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\n\u03b9 : Type u_1\nv : \u03b9 \u2192 M\ni : LinearIndependent R v\nw : Set M\ninst\u271d : Fintype \u2191w\ns : range v \u2264 \u2191(span R w)\nthis\u271d : Finite \u03b9\nthis : Fintype \u03b9 := Fintype.ofFinite \u03b9\n\u22a2 \u2191(Fintype.card \u03b9) \u2264 \u2191(Fintype.card \u2191w)"}, {"line": "simp only [Nat.cast_le]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\n\u03b9 : Type u_1\nv : \u03b9 \u2192 M\ni : LinearIndependent R v\nw : Set M\ninst\u271d : Fintype \u2191w\ns : range v \u2264 \u2191(span R w)\nthis\u271d : Finite \u03b9\nthis : Fintype \u03b9 := Fintype.ofFinite \u03b9\n\u22a2 Fintype.card \u03b9 \u2264 Fintype.card \u2191w"}, {"line": "exact linearIndependent_le_span_aux' v i w s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearIndependent_le_span_finset {\u03b9 : Type*} (v : \u03b9 \u2192 M) (i : LinearIndependent R v)\n    (w : Finset M) (s : span R (w : Set M) = \u22a4) : #\u03b9 \u2264 w.card := by\n  simpa only [Finset.coe_sort_coe,Fintype.card_coe] using linearIndependent_le_span v i w s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Submodule Finsupp"], "variables": ["{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 : Type w} {\u03b9' : Type w'}", "[InvariantBasisNumber R]", "[RankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\n\u03b9 : Type u_1\nv : \u03b9 \u2192 M\ni : LinearIndependent R v\nw : Finset M\ns : span R \u2191w = \u22a4\n\u22a2 Cardinal.mk \u03b9 \u2264 \u2191w.card"}, {"line": "simpa only [Finset.coe_sort_coe,Fintype.card_coe] using linearIndependent_le_span v i w s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem maximal_linearIndependent_eq_infinite_basis {\u03b9 : Type w} (b : Basis \u03b9 R M) [Infinite \u03b9]\n    {\u03ba : Type w} (v : \u03ba \u2192 M) (i : LinearIndependent R v) (m : i.Maximal) : #\u03ba = #\u03b9 := by\n  apply le_antisymm\n  \u00b7 exact linearIndependent_le_basis b v i\n  \u00b7 haveI : Nontrivial R := nontrivial_of_invariantBasisNumber R\n    exact infinite_basis_le_maximal_linearIndependent b v i m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Submodule Finsupp"], "variables": ["{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 : Type w} {\u03b9' : Type w'}", "[InvariantBasisNumber R]", "[RankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\n\u03b9 : Type w\nb : Basis \u03b9 R M\ninst\u271d : Infinite \u03b9\n\u03ba : Type w\nv : \u03ba \u2192 M\ni : LinearIndependent R v\nm : i.Maximal\n\u22a2 Cardinal.mk \u03ba = Cardinal.mk \u03b9"}, {"line": "apply le_antisymm", "tactic_state": "case a\nR : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\n\u03b9 : Type w\nb : Basis \u03b9 R M\ninst\u271d : Infinite \u03b9\n\u03ba : Type w\nv : \u03ba \u2192 M\ni : LinearIndependent R v\nm : i.Maximal\n\u22a2 Cardinal.mk \u03ba \u2264 Cardinal.mk \u03b9\n---\ncase a\nR : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\n\u03b9 : Type w\nb : Basis \u03b9 R M\ninst\u271d : Infinite \u03b9\n\u03ba : Type w\nv : \u03ba \u2192 M\ni : LinearIndependent R v\nm : i.Maximal\n\u22a2 Cardinal.mk \u03b9 \u2264 Cardinal.mk \u03ba"}, {"line": "\u00b7 exact linearIndependent_le_basis b v i", "tactic_state": "case a\nR : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\n\u03b9 : Type w\nb : Basis \u03b9 R M\ninst\u271d : Infinite \u03b9\n\u03ba : Type w\nv : \u03ba \u2192 M\ni : LinearIndependent R v\nm : i.Maximal\n\u22a2 Cardinal.mk \u03b9 \u2264 Cardinal.mk \u03ba"}, {"line": "\u00b7 haveI : Nontrivial R := nontrivial_of_invariantBasisNumber R\n    exact infinite_basis_le_maximal_linearIndependent b v i m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Basis.mk_eq_rank'' {\u03b9 : Type v} (v : Basis \u03b9 R M) : #\u03b9 = Module.rank R M := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rw [Module.rank_def]\n  apply le_antisymm\n  \u00b7 trans\n    swap\n    \u00b7 apply le_ciSup (Cardinal.bddAbove_range _)\n      exact\n        \u27e8Set.range v, by\n          rw [LinearIndepOn]\n          convert v.reindexRange.linearIndependent\n          simp\u27e9\n    \u00b7 exact (Cardinal.mk_range_eq v v.injective).ge\n  \u00b7 apply ciSup_le'\n    rintro \u27e8s, li\u27e9\n    apply linearIndependent_le_basis v _ li\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Submodule Finsupp"], "variables": ["{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 : Type w} {\u03b9' : Type w'}", "[InvariantBasisNumber R]", "[RankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\n\u03b9 : Type v\nv : Basis \u03b9 R M\n\u22a2 Cardinal.mk \u03b9 = Module.rank R M"}, {"line": "haveI := nontrivial_of_invariantBasisNumber R", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\n\u03b9 : Type v\nv : Basis \u03b9 R M\nthis : Nontrivial R\n\u22a2 Cardinal.mk \u03b9 = Module.rank R M"}, {"line": "rw [Module.rank_def]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\n\u03b9 : Type v\nv : Basis \u03b9 R M\nthis : Nontrivial R\n\u22a2 Cardinal.mk \u03b9 = \u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9"}, {"line": "apply le_antisymm", "tactic_state": "case a\nR : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\n\u03b9 : Type v\nv : Basis \u03b9 R M\nthis : Nontrivial R\n\u22a2 Cardinal.mk \u03b9 \u2264 \u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9\n---\ncase a\nR : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\n\u03b9 : Type v\nv : Basis \u03b9 R M\nthis : Nontrivial R\n\u22a2 \u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9 \u2264 Cardinal.mk \u03b9"}, {"line": "\u00b7 trans\n    swap\n    \u00b7 apply le_ciSup (Cardinal.bddAbove_range _)\n      exact\n        \u27e8Set.range v, by\n          rw [LinearIndepOn]\n          convert v.reindexRange.linearIndependent\n          simp\u27e9\n    \u00b7 exact (Cardinal.mk_range_eq v v.injective).ge", "tactic_state": "case a\nR : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\n\u03b9 : Type v\nv : Basis \u03b9 R M\nthis : Nontrivial R\n\u22a2 \u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9 \u2264 Cardinal.mk \u03b9"}, {"line": "\u00b7 apply ciSup_le'\n    rintro \u27e8s, li\u27e9\n    apply linearIndependent_le_basis v _ li", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Basis.card_le_card_of_linearIndependent {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 R M)\n    {\u03b9' : Type*} [Fintype \u03b9'] {v : \u03b9' \u2192 M} (hv : LinearIndependent R v) :\n    Fintype.card \u03b9' \u2264 Fintype.card \u03b9 := by\n  letI := nontrivial_of_invariantBasisNumber R\n  simpa [rank_eq_card_basis b, Cardinal.mk_fintype] using hv.cardinal_lift_le_rank\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Submodule Finsupp"], "variables": ["{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 : Type w} {\u03b9' : Type w'}", "[InvariantBasisNumber R]", "[RankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : InvariantBasisNumber R\ninst\u271d\u00b3 : RankCondition R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\nb : Basis \u03b9 R M\n\u03b9' : Type u_2\ninst\u271d : Fintype \u03b9'\nv : \u03b9' \u2192 M\nhv : LinearIndependent R v\n\u22a2 Fintype.card \u03b9' \u2264 Fintype.card \u03b9"}, {"line": "letI := nontrivial_of_invariantBasisNumber R", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : InvariantBasisNumber R\ninst\u271d\u00b3 : RankCondition R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\nb : Basis \u03b9 R M\n\u03b9' : Type u_2\ninst\u271d : Fintype \u03b9'\nv : \u03b9' \u2192 M\nhv : LinearIndependent R v\nthis : Nontrivial R := sorry\n\u22a2 Fintype.card \u03b9' \u2264 Fintype.card \u03b9"}, {"line": "simpa [rank_eq_card_basis b, Cardinal.mk_fintype] using hv.cardinal_lift_le_rank", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_span_set {s : Set M} (hs : LinearIndepOn R id s) : Module.rank R \u2191(span R s) = #s := by\n  rw [\u2190 @setOf_mem_eq _ s]\n  rw [\u2190 Subtype.range_coe_subtype]\n  exact rank_span hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Submodule Finsupp"], "variables": ["{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 : Type w} {\u03b9' : Type w'}", "[InvariantBasisNumber R]", "[RankCondition R]", "[StrongRankCondition R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\ns : Set M\nhs : LinearIndepOn R id s\n\u22a2 Module.rank R \u21a5(span R s) = Cardinal.mk \u2191s"}, {"line": "rw [\u2190 @setOf_mem_eq _ s]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\ns : Set M\nhs : LinearIndepOn R id s\n\u22a2 Module.rank R \u21a5(span R {x | x \u2208 s}) = Cardinal.mk \u2191{x | x \u2208 s}"}, {"line": "rw [\u2190 Subtype.range_coe_subtype]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : InvariantBasisNumber R\ninst\u271d\u00b9 : RankCondition R\ninst\u271d : StrongRankCondition R\ns : Set M\nhs : LinearIndepOn R id s\n\u22a2 Module.rank R \u21a5(span R (range Subtype.val)) = Cardinal.mk \u2191(range Subtype.val)"}, {"line": "exact rank_span hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_lt_aleph0 [Module.Finite R M] : Module.rank R M < \u2135\u2080 := by\n  simp only [Module.rank_def]\n  obtain \u27e8S, hS\u27e9 := Module.finite_def.mp \u2039_\u203a\n  refine (ciSup_le' fun i => ?_).trans_lt (nat_lt_aleph0 S.card)\n  exact linearIndependent_le_span_finset _ i.prop S hS\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Submodule Finsupp"], "variables": ["{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 : Type w} {\u03b9' : Type w'}", "[InvariantBasisNumber R]", "[RankCondition R]", "[StrongRankCondition R]", "(R)", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\n\u22a2 Module.rank R M < aleph0"}, {"line": "simp only [Module.rank_def]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\n\u22a2 \u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9 < aleph0"}, {"line": "obtain \u27e8S, hS\u27e9 := Module.finite_def.mp \u2039_\u203a", "tactic_state": "case intro\nR : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nS : Finset M\nhS : span R \u2191S = \u22a4\n\u22a2 \u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9 < aleph0"}, {"line": "refine (ciSup_le' fun i => ?_).trans_lt (nat_lt_aleph0 S.card)", "tactic_state": "case intro\nR : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nS : Finset M\nhS : span R \u2191S = \u22a4\ni : { s // LinearIndepOn R id s }\n\u22a2 Cardinal.mk \u2191\u2191i \u2264 \u2191S.card"}, {"line": "exact linearIndependent_le_span_finset _ i.prop S hS", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem _root_.Submodule.finrank_eq_rank [Module.Finite R M] (N : Submodule R M) :\n    finrank R N = Module.rank R N := by\n  rw [finrank]\n  rw [Cardinal.cast_toNat_of_lt_aleph0]\n  exact lt_of_le_of_lt (Submodule.rank_le N) (rank_lt_aleph0 R M)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "context": {"open": ["Cardinal Basis Submodule Function Set Module", "Submodule Finsupp"], "variables": ["{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 : Type w} {\u03b9' : Type w'}", "[InvariantBasisNumber R]", "[RankCondition R]", "[StrongRankCondition R]", "(R)", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nN : Submodule R M\n\u22a2 \u2191(finrank R \u21a5N) = Module.rank R \u21a5N"}, {"line": "rw [finrank]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nN : Submodule R M\n\u22a2 \u2191(Cardinal.toNat (Module.rank R \u21a5N)) = Module.rank R \u21a5N"}, {"line": "rw [Cardinal.cast_toNat_of_lt_aleph0]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : InvariantBasisNumber R\ninst\u271d\u00b2 : RankCondition R\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Module.Finite R M\nN : Submodule R M\n\u22a2 Module.rank R \u21a5N < aleph0"}, {"line": "exact lt_of_le_of_lt (Submodule.rank_le N) (rank_lt_aleph0 R M)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem directSum_lof_tmul_lof (i\u2081 : \u03b9\u2081) (m\u2081 : M\u2081 i\u2081) (i\u2082 : \u03b9\u2082) (m\u2082 : M\u2082 i\u2082) :\n    TensorProduct.directSum R S M\u2081 M\u2082 (DirectSum.lof S \u03b9\u2081 M\u2081 i\u2081 m\u2081 \u2297\u209c DirectSum.lof R \u03b9\u2082 M\u2082 i\u2082 m\u2082) =\n      DirectSum.lof S (\u03b9\u2081 \u00d7 \u03b9\u2082) (fun i => M\u2081 i.1 \u2297[R] M\u2082 i.2) (i\u2081, i\u2082) (m\u2081 \u2297\u209c m\u2082) := by\n  simp [TensorProduct.directSum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "context": {"open": ["TensorProduct", "DirectSum", "LinearMap"], "variables": ["(R : Type u) [CommSemiring R] (S) [Semiring S] [Algebra R S]", "{\u03b9\u2081 : Type v\u2081} {\u03b9\u2082 : Type v\u2082}", "[DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082]", "(M\u2081 : \u03b9\u2081 \u2192 Type w\u2081) (M\u2081' : Type w\u2081') (M\u2082 : \u03b9\u2082 \u2192 Type w\u2082) (M\u2082' : Type w\u2082')", "[\u2200 i\u2081, AddCommMonoid (M\u2081 i\u2081)] [AddCommMonoid M\u2081']", "[\u2200 i\u2082, AddCommMonoid (M\u2082 i\u2082)] [AddCommMonoid M\u2082']", "[\u2200 i\u2081, Module R (M\u2081 i\u2081)] [Module R M\u2081'] [\u2200 i\u2082, Module R (M\u2082 i\u2082)] [Module R M\u2082']", "[\u2200 i\u2081, Module S (M\u2081 i\u2081)] [\u2200 i\u2081, IsScalarTower R S (M\u2081 i\u2081)]", "{M\u2081 M\u2081' M\u2082 M\u2082'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9\u2070 : CommSemiring R\nS : Type u_1\ninst\u271d\u2079 : Semiring S\ninst\u271d\u2078 : Algebra R S\n\u03b9\u2081 : Type v\u2081\n\u03b9\u2082 : Type v\u2082\ninst\u271d\u2077 : DecidableEq \u03b9\u2081\ninst\u271d\u2076 : DecidableEq \u03b9\u2082\nM\u2081 : \u03b9\u2081 \u2192 Type w\u2081\nM\u2082 : \u03b9\u2082 \u2192 Type w\u2082\ninst\u271d\u2075 : (i\u2081 : \u03b9\u2081) \u2192 AddCommMonoid (M\u2081 i\u2081)\ninst\u271d\u2074 : (i\u2082 : \u03b9\u2082) \u2192 AddCommMonoid (M\u2082 i\u2082)\ninst\u271d\u00b3 : (i\u2081 : \u03b9\u2081) \u2192 Module R (M\u2081 i\u2081)\ninst\u271d\u00b2 : (i\u2082 : \u03b9\u2082) \u2192 Module R (M\u2082 i\u2082)\ninst\u271d\u00b9 : (i\u2081 : \u03b9\u2081) \u2192 Module S (M\u2081 i\u2081)\ninst\u271d : \u2200 (i\u2081 : \u03b9\u2081), IsScalarTower R S (M\u2081 i\u2081)\ni\u2081 : \u03b9\u2081\nm\u2081 : M\u2081 i\u2081\ni\u2082 : \u03b9\u2082\nm\u2082 : M\u2082 i\u2082\n\u22a2 (TensorProduct.directSum R S M\u2081 M\u2082) ((lof S \u03b9\u2081 M\u2081 i\u2081) m\u2081 \u2297\u209c[R] (lof R \u03b9\u2082 M\u2082 i\u2082) m\u2082) =\n    (lof S (\u03b9\u2081 \u00d7 \u03b9\u2082) (fun i => TensorProduct R (M\u2081 i.1) (M\u2082 i.2)) (i\u2081, i\u2082)) (m\u2081 \u2297\u209c[R] m\u2082)"}, {"line": "simp [TensorProduct.directSum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem directSum_symm_lof_tmul (i\u2081 : \u03b9\u2081) (m\u2081 : M\u2081 i\u2081) (i\u2082 : \u03b9\u2082) (m\u2082 : M\u2082 i\u2082) :\n    (TensorProduct.directSum R S M\u2081 M\u2082).symm\n      (DirectSum.lof S (\u03b9\u2081 \u00d7 \u03b9\u2082) (fun i => M\u2081 i.1 \u2297[R] M\u2082 i.2) (i\u2081, i\u2082) (m\u2081 \u2297\u209c m\u2082)) =\n      (DirectSum.lof S \u03b9\u2081 M\u2081 i\u2081 m\u2081 \u2297\u209c DirectSum.lof R \u03b9\u2082 M\u2082 i\u2082 m\u2082) := by\n  rw [LinearEquiv.symm_apply_eq]\n  rw [directSum_lof_tmul_lof]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "context": {"open": ["TensorProduct", "DirectSum", "LinearMap"], "variables": ["(R : Type u) [CommSemiring R] (S) [Semiring S] [Algebra R S]", "{\u03b9\u2081 : Type v\u2081} {\u03b9\u2082 : Type v\u2082}", "[DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082]", "(M\u2081 : \u03b9\u2081 \u2192 Type w\u2081) (M\u2081' : Type w\u2081') (M\u2082 : \u03b9\u2082 \u2192 Type w\u2082) (M\u2082' : Type w\u2082')", "[\u2200 i\u2081, AddCommMonoid (M\u2081 i\u2081)] [AddCommMonoid M\u2081']", "[\u2200 i\u2082, AddCommMonoid (M\u2082 i\u2082)] [AddCommMonoid M\u2082']", "[\u2200 i\u2081, Module R (M\u2081 i\u2081)] [Module R M\u2081'] [\u2200 i\u2082, Module R (M\u2082 i\u2082)] [Module R M\u2082']", "[\u2200 i\u2081, Module S (M\u2081 i\u2081)] [\u2200 i\u2081, IsScalarTower R S (M\u2081 i\u2081)]", "{M\u2081 M\u2081' M\u2082 M\u2082'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9\u2070 : CommSemiring R\nS : Type u_1\ninst\u271d\u2079 : Semiring S\ninst\u271d\u2078 : Algebra R S\n\u03b9\u2081 : Type v\u2081\n\u03b9\u2082 : Type v\u2082\ninst\u271d\u2077 : DecidableEq \u03b9\u2081\ninst\u271d\u2076 : DecidableEq \u03b9\u2082\nM\u2081 : \u03b9\u2081 \u2192 Type w\u2081\nM\u2082 : \u03b9\u2082 \u2192 Type w\u2082\ninst\u271d\u2075 : (i\u2081 : \u03b9\u2081) \u2192 AddCommMonoid (M\u2081 i\u2081)\ninst\u271d\u2074 : (i\u2082 : \u03b9\u2082) \u2192 AddCommMonoid (M\u2082 i\u2082)\ninst\u271d\u00b3 : (i\u2081 : \u03b9\u2081) \u2192 Module R (M\u2081 i\u2081)\ninst\u271d\u00b2 : (i\u2082 : \u03b9\u2082) \u2192 Module R (M\u2082 i\u2082)\ninst\u271d\u00b9 : (i\u2081 : \u03b9\u2081) \u2192 Module S (M\u2081 i\u2081)\ninst\u271d : \u2200 (i\u2081 : \u03b9\u2081), IsScalarTower R S (M\u2081 i\u2081)\ni\u2081 : \u03b9\u2081\nm\u2081 : M\u2081 i\u2081\ni\u2082 : \u03b9\u2082\nm\u2082 : M\u2082 i\u2082\n\u22a2 (TensorProduct.directSum R S M\u2081 M\u2082).symm\n      ((lof S (\u03b9\u2081 \u00d7 \u03b9\u2082) (fun i => TensorProduct R (M\u2081 i.1) (M\u2082 i.2)) (i\u2081, i\u2082)) (m\u2081 \u2297\u209c[R] m\u2082)) =\n    (lof S \u03b9\u2081 M\u2081 i\u2081) m\u2081 \u2297\u209c[R] (lof R \u03b9\u2082 M\u2082 i\u2082) m\u2082"}, {"line": "rw [LinearEquiv.symm_apply_eq]", "tactic_state": "R : Type u\ninst\u271d\u00b9\u2070 : CommSemiring R\nS : Type u_1\ninst\u271d\u2079 : Semiring S\ninst\u271d\u2078 : Algebra R S\n\u03b9\u2081 : Type v\u2081\n\u03b9\u2082 : Type v\u2082\ninst\u271d\u2077 : DecidableEq \u03b9\u2081\ninst\u271d\u2076 : DecidableEq \u03b9\u2082\nM\u2081 : \u03b9\u2081 \u2192 Type w\u2081\nM\u2082 : \u03b9\u2082 \u2192 Type w\u2082\ninst\u271d\u2075 : (i\u2081 : \u03b9\u2081) \u2192 AddCommMonoid (M\u2081 i\u2081)\ninst\u271d\u2074 : (i\u2082 : \u03b9\u2082) \u2192 AddCommMonoid (M\u2082 i\u2082)\ninst\u271d\u00b3 : (i\u2081 : \u03b9\u2081) \u2192 Module R (M\u2081 i\u2081)\ninst\u271d\u00b2 : (i\u2082 : \u03b9\u2082) \u2192 Module R (M\u2082 i\u2082)\ninst\u271d\u00b9 : (i\u2081 : \u03b9\u2081) \u2192 Module S (M\u2081 i\u2081)\ninst\u271d : \u2200 (i\u2081 : \u03b9\u2081), IsScalarTower R S (M\u2081 i\u2081)\ni\u2081 : \u03b9\u2081\nm\u2081 : M\u2081 i\u2081\ni\u2082 : \u03b9\u2082\nm\u2082 : M\u2082 i\u2082\n\u22a2 (lof S (\u03b9\u2081 \u00d7 \u03b9\u2082) (fun i => TensorProduct R (M\u2081 i.1) (M\u2082 i.2)) (i\u2081, i\u2082)) (m\u2081 \u2297\u209c[R] m\u2082) =\n    (TensorProduct.directSum R S M\u2081 M\u2082) ((lof S \u03b9\u2081 M\u2081 i\u2081) m\u2081 \u2297\u209c[R] (lof R \u03b9\u2082 M\u2082 i\u2082) m\u2082)"}, {"line": "rw [directSum_lof_tmul_lof]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem directSumLeft_symm_lof_tmul (i : \u03b9\u2081) (x : M\u2081 i) (y : M\u2082') :\n    (directSumLeft R M\u2081 M\u2082').symm (DirectSum.lof R _ _ i (x \u2297\u209c[R] y)) =\n      DirectSum.lof R _ _ i x \u2297\u209c[R] y := by\n  rw [LinearEquiv.symm_apply_eq]\n  rw [directSumLeft_tmul_lof]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "context": {"open": ["TensorProduct", "DirectSum", "LinearMap"], "variables": ["(R : Type u) [CommSemiring R] (S) [Semiring S] [Algebra R S]", "{\u03b9\u2081 : Type v\u2081} {\u03b9\u2082 : Type v\u2082}", "[DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082]", "(M\u2081 : \u03b9\u2081 \u2192 Type w\u2081) (M\u2081' : Type w\u2081') (M\u2082 : \u03b9\u2082 \u2192 Type w\u2082) (M\u2082' : Type w\u2082')", "[\u2200 i\u2081, AddCommMonoid (M\u2081 i\u2081)] [AddCommMonoid M\u2081']", "[\u2200 i\u2082, AddCommMonoid (M\u2082 i\u2082)] [AddCommMonoid M\u2082']", "[\u2200 i\u2081, Module R (M\u2081 i\u2081)] [Module R M\u2081'] [\u2200 i\u2082, Module R (M\u2082 i\u2082)] [Module R M\u2082']", "[\u2200 i\u2081, Module S (M\u2081 i\u2081)] [\u2200 i\u2081, IsScalarTower R S (M\u2081 i\u2081)]", "{M\u2081 M\u2081' M\u2082 M\u2082'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : CommSemiring R\n\u03b9\u2081 : Type v\u2081\ninst\u271d\u2074 : DecidableEq \u03b9\u2081\nM\u2081 : \u03b9\u2081 \u2192 Type w\u2081\nM\u2082' : Type w\u2082'\ninst\u271d\u00b3 : (i\u2081 : \u03b9\u2081) \u2192 AddCommMonoid (M\u2081 i\u2081)\ninst\u271d\u00b2 : AddCommMonoid M\u2082'\ninst\u271d\u00b9 : (i\u2081 : \u03b9\u2081) \u2192 Module R (M\u2081 i\u2081)\ninst\u271d : Module R M\u2082'\ni : \u03b9\u2081\nx : M\u2081 i\ny : M\u2082'\n\u22a2 (directSumLeft R M\u2081 M\u2082').symm ((lof R \u03b9\u2081 (fun i => TensorProduct R (M\u2081 i) M\u2082') i) (x \u2297\u209c[R] y)) =\n    (lof R \u03b9\u2081 M\u2081 i) x \u2297\u209c[R] y"}, {"line": "rw [LinearEquiv.symm_apply_eq]", "tactic_state": "R : Type u\ninst\u271d\u2075 : CommSemiring R\n\u03b9\u2081 : Type v\u2081\ninst\u271d\u2074 : DecidableEq \u03b9\u2081\nM\u2081 : \u03b9\u2081 \u2192 Type w\u2081\nM\u2082' : Type w\u2082'\ninst\u271d\u00b3 : (i\u2081 : \u03b9\u2081) \u2192 AddCommMonoid (M\u2081 i\u2081)\ninst\u271d\u00b2 : AddCommMonoid M\u2082'\ninst\u271d\u00b9 : (i\u2081 : \u03b9\u2081) \u2192 Module R (M\u2081 i\u2081)\ninst\u271d : Module R M\u2082'\ni : \u03b9\u2081\nx : M\u2081 i\ny : M\u2082'\n\u22a2 (lof R \u03b9\u2081 (fun i => TensorProduct R (M\u2081 i) M\u2082') i) (x \u2297\u209c[R] y) = (directSumLeft R M\u2081 M\u2082') ((lof R \u03b9\u2081 M\u2081 i) x \u2297\u209c[R] y)"}, {"line": "rw [directSumLeft_tmul_lof]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem directSumRight_tmul_lof (x : M\u2081') (i : \u03b9\u2082) (y : M\u2082 i) :\n    directSumRight R M\u2081' M\u2082 (x \u2297\u209c[R] DirectSum.lof R _ _ i y) =\n    DirectSum.lof R _ _ i (x \u2297\u209c[R] y) := by\n  dsimp only [directSumRight, LinearEquiv.trans_apply, TensorProduct.comm_tmul]\n  rw [directSumLeft_tmul_lof]\n  exact DFinsupp.mapRange_single (hf := fun _ => rfl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "context": {"open": ["TensorProduct", "DirectSum", "LinearMap"], "variables": ["(R : Type u) [CommSemiring R] (S) [Semiring S] [Algebra R S]", "{\u03b9\u2081 : Type v\u2081} {\u03b9\u2082 : Type v\u2082}", "[DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082]", "(M\u2081 : \u03b9\u2081 \u2192 Type w\u2081) (M\u2081' : Type w\u2081') (M\u2082 : \u03b9\u2082 \u2192 Type w\u2082) (M\u2082' : Type w\u2082')", "[\u2200 i\u2081, AddCommMonoid (M\u2081 i\u2081)] [AddCommMonoid M\u2081']", "[\u2200 i\u2082, AddCommMonoid (M\u2082 i\u2082)] [AddCommMonoid M\u2082']", "[\u2200 i\u2081, Module R (M\u2081 i\u2081)] [Module R M\u2081'] [\u2200 i\u2082, Module R (M\u2082 i\u2082)] [Module R M\u2082']", "[\u2200 i\u2081, Module S (M\u2081 i\u2081)] [\u2200 i\u2081, IsScalarTower R S (M\u2081 i\u2081)]", "{M\u2081 M\u2081' M\u2082 M\u2082'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : CommSemiring R\n\u03b9\u2082 : Type v\u2082\ninst\u271d\u2074 : DecidableEq \u03b9\u2082\nM\u2081' : Type w\u2081'\nM\u2082 : \u03b9\u2082 \u2192 Type w\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2081'\ninst\u271d\u00b2 : (i\u2082 : \u03b9\u2082) \u2192 AddCommMonoid (M\u2082 i\u2082)\ninst\u271d\u00b9 : Module R M\u2081'\ninst\u271d : (i\u2082 : \u03b9\u2082) \u2192 Module R (M\u2082 i\u2082)\nx : M\u2081'\ni : \u03b9\u2082\ny : M\u2082 i\n\u22a2 (directSumRight R M\u2081' M\u2082) (x \u2297\u209c[R] (lof R \u03b9\u2082 M\u2082 i) y) = (lof R \u03b9\u2082 (fun i => TensorProduct R M\u2081' (M\u2082 i)) i) (x \u2297\u209c[R] y)"}, {"line": "dsimp only [directSumRight, LinearEquiv.trans_apply, TensorProduct.comm_tmul]", "tactic_state": "R : Type u\ninst\u271d\u2075 : CommSemiring R\n\u03b9\u2082 : Type v\u2082\ninst\u271d\u2074 : DecidableEq \u03b9\u2082\nM\u2081' : Type w\u2081'\nM\u2082 : \u03b9\u2082 \u2192 Type w\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2081'\ninst\u271d\u00b2 : (i\u2082 : \u03b9\u2082) \u2192 AddCommMonoid (M\u2082 i\u2082)\ninst\u271d\u00b9 : Module R M\u2081'\ninst\u271d : (i\u2082 : \u03b9\u2082) \u2192 Module R (M\u2082 i\u2082)\nx : M\u2081'\ni : \u03b9\u2082\ny : M\u2082 i\n\u22a2 (DFinsupp.mapRange.linearEquiv fun x => TensorProduct.comm R (M\u2082 x) M\u2081')\n      ((directSumLeft R M\u2082 M\u2081') ((lof R \u03b9\u2082 M\u2082 i) y \u2297\u209c[R] x)) =\n    (lof R \u03b9\u2082 (fun i => TensorProduct R M\u2081' (M\u2082 i)) i) (x \u2297\u209c[R] y)"}, {"line": "rw [directSumLeft_tmul_lof]", "tactic_state": "R : Type u\ninst\u271d\u2075 : CommSemiring R\n\u03b9\u2082 : Type v\u2082\ninst\u271d\u2074 : DecidableEq \u03b9\u2082\nM\u2081' : Type w\u2081'\nM\u2082 : \u03b9\u2082 \u2192 Type w\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2081'\ninst\u271d\u00b2 : (i\u2082 : \u03b9\u2082) \u2192 AddCommMonoid (M\u2082 i\u2082)\ninst\u271d\u00b9 : Module R M\u2081'\ninst\u271d : (i\u2082 : \u03b9\u2082) \u2192 Module R (M\u2082 i\u2082)\nx : M\u2081'\ni : \u03b9\u2082\ny : M\u2082 i\n\u22a2 (DFinsupp.mapRange.linearEquiv fun x => TensorProduct.comm R (M\u2082 x) M\u2081')\n      ((lof R \u03b9\u2082 (fun i => TensorProduct R (M\u2082 i) M\u2081') i) (y \u2297\u209c[R] x)) =\n    (lof R \u03b9\u2082 (fun i => TensorProduct R M\u2081' (M\u2082 i)) i) (x \u2297\u209c[R] y)"}, {"line": "exact DFinsupp.mapRange_single (hf := fun _ => rfl)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem directSumRight_symm_lof_tmul (x : M\u2081') (i : \u03b9\u2082) (y : M\u2082 i) :\n    (directSumRight R M\u2081' M\u2082).symm (DirectSum.lof R _ _ i (x \u2297\u209c[R] y)) =\n      x \u2297\u209c[R] DirectSum.lof R _ _ i y := by\n  rw [LinearEquiv.symm_apply_eq]\n  rw [directSumRight_tmul_lof]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "context": {"open": ["TensorProduct", "DirectSum", "LinearMap"], "variables": ["(R : Type u) [CommSemiring R] (S) [Semiring S] [Algebra R S]", "{\u03b9\u2081 : Type v\u2081} {\u03b9\u2082 : Type v\u2082}", "[DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082]", "(M\u2081 : \u03b9\u2081 \u2192 Type w\u2081) (M\u2081' : Type w\u2081') (M\u2082 : \u03b9\u2082 \u2192 Type w\u2082) (M\u2082' : Type w\u2082')", "[\u2200 i\u2081, AddCommMonoid (M\u2081 i\u2081)] [AddCommMonoid M\u2081']", "[\u2200 i\u2082, AddCommMonoid (M\u2082 i\u2082)] [AddCommMonoid M\u2082']", "[\u2200 i\u2081, Module R (M\u2081 i\u2081)] [Module R M\u2081'] [\u2200 i\u2082, Module R (M\u2082 i\u2082)] [Module R M\u2082']", "[\u2200 i\u2081, Module S (M\u2081 i\u2081)] [\u2200 i\u2081, IsScalarTower R S (M\u2081 i\u2081)]", "{M\u2081 M\u2081' M\u2082 M\u2082'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : CommSemiring R\n\u03b9\u2082 : Type v\u2082\ninst\u271d\u2074 : DecidableEq \u03b9\u2082\nM\u2081' : Type w\u2081'\nM\u2082 : \u03b9\u2082 \u2192 Type w\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2081'\ninst\u271d\u00b2 : (i\u2082 : \u03b9\u2082) \u2192 AddCommMonoid (M\u2082 i\u2082)\ninst\u271d\u00b9 : Module R M\u2081'\ninst\u271d : (i\u2082 : \u03b9\u2082) \u2192 Module R (M\u2082 i\u2082)\nx : M\u2081'\ni : \u03b9\u2082\ny : M\u2082 i\n\u22a2 (directSumRight R M\u2081' M\u2082).symm ((lof R \u03b9\u2082 (fun i => TensorProduct R M\u2081' (M\u2082 i)) i) (x \u2297\u209c[R] y)) =\n    x \u2297\u209c[R] (lof R \u03b9\u2082 M\u2082 i) y"}, {"line": "rw [LinearEquiv.symm_apply_eq]", "tactic_state": "R : Type u\ninst\u271d\u2075 : CommSemiring R\n\u03b9\u2082 : Type v\u2082\ninst\u271d\u2074 : DecidableEq \u03b9\u2082\nM\u2081' : Type w\u2081'\nM\u2082 : \u03b9\u2082 \u2192 Type w\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2081'\ninst\u271d\u00b2 : (i\u2082 : \u03b9\u2082) \u2192 AddCommMonoid (M\u2082 i\u2082)\ninst\u271d\u00b9 : Module R M\u2081'\ninst\u271d : (i\u2082 : \u03b9\u2082) \u2192 Module R (M\u2082 i\u2082)\nx : M\u2081'\ni : \u03b9\u2082\ny : M\u2082 i\n\u22a2 (lof R \u03b9\u2082 (fun i => TensorProduct R M\u2081' (M\u2082 i)) i) (x \u2297\u209c[R] y) = (directSumRight R M\u2081' M\u2082) (x \u2297\u209c[R] (lof R \u03b9\u2082 M\u2082 i) y)"}, {"line": "rw [directSumRight_tmul_lof]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finsuppLeft_symm_apply_single (i : \u03b9) (m : M) (n : N) :\n    (finsuppLeft R M N \u03b9).symm (Finsupp.single i (m \u2297\u209c[R] n)) =\n      Finsupp.single i m \u2297\u209c[R] n := by\n  simp [finsuppLeft, Finsupp.lsum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "context": {"open": ["DirectSum TensorProduct", "Set LinearMap Submodule"], "variables": ["(R : Type*) [CommSemiring R]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{R M N \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d : DecidableEq \u03b9\nM : Type u_4\nN : Type u_5\ni : \u03b9\nm : M\nn : N\n\u22a2 sorry = sorry"}, {"line": "simp [finsuppLeft, Finsupp.lsum]", "tactic_state": "\u03b9 : Type u_2\ninst\u271d : DecidableEq \u03b9\nM : Type u_4\nN : Type u_5\ni : \u03b9\nm : M\nn : N\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma finsuppRight_symm_apply_single (i : \u03b9) (m : M) (n : N) :\n    (finsuppRight R M N \u03b9).symm (Finsupp.single i (m \u2297\u209c[R] n)) =\n      m \u2297\u209c[R] Finsupp.single i n := by\n  simp [finsuppRight, Finsupp.lsum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "context": {"open": ["DirectSum TensorProduct", "Set LinearMap Submodule"], "variables": ["(R : Type*) [CommSemiring R]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d : DecidableEq \u03b9\nM : Type u_4\nN : Type u_5\ni : \u03b9\nm : M\nn : N\n\u22a2 sorry = sorry"}, {"line": "simp [finsuppRight, Finsupp.lsum]", "tactic_state": "\u03b9 : Type u_2\ninst\u271d : DecidableEq \u03b9\nM : Type u_4\nN : Type u_5\ni : \u03b9\nm : M\nn : N\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma finsuppScalarLeft_apply_tmul_apply (p : \u03b9 \u2192\u2080 R) (n : N) (i : \u03b9) :\n    finsuppScalarLeft R N \u03b9 (p \u2297\u209c[R] n) i = p i \u2022 n := by\n  simp [finsuppScalarLeft]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "context": {"open": ["DirectSum TensorProduct", "Set LinearMap Submodule"], "variables": ["(R : Type*) [CommSemiring R]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}", "{S : Type*} [CommSemiring S] [Algebra R S]", "(R M N \u03b9 S)", "{R M N \u03b9 S}", "(R M N \u03b9)", "{R M N \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_2\ninst\u271d : DecidableEq \u03b9\nN : Type ?u.1277\np : \u03b9 \u2192\u2080 R\nn : N\ni : \u03b9\n\u22a2 sorry"}, {"line": "simp [finsuppScalarLeft]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_2\ninst\u271d : DecidableEq \u03b9\nN : Type ?u.1277\np : \u03b9 \u2192\u2080 R\nn : N\ni : \u03b9\n\u22a2 sorry ()"}]}
{"declaration": "lemma finsuppScalarRight_apply_tmul_apply (m : M) (p : \u03b9 \u2192\u2080 R) (i : \u03b9) :\n    finsuppScalarRight R M \u03b9 (m \u2297\u209c[R] p) i = p i \u2022 m := by\n  simp [finsuppScalarRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "context": {"open": ["DirectSum TensorProduct", "Set LinearMap Submodule"], "variables": ["(R : Type*) [CommSemiring R]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}", "{S : Type*} [CommSemiring S] [Algebra R S]", "(R M N \u03b9 S)", "{R M N \u03b9 S}", "(R M N \u03b9)", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_2\ninst\u271d : DecidableEq \u03b9\nM : Type ?u.1555\nm : M\np : \u03b9 \u2192\u2080 R\ni : \u03b9\n\u22a2 sorry"}, {"line": "simp [finsuppScalarRight]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_2\ninst\u271d : DecidableEq \u03b9\nM : Type ?u.1555\nm : M\np : \u03b9 \u2192\u2080 R\ni : \u03b9\n\u22a2 sorry ()"}]}
{"declaration": "theorem finsuppTensorFinsupp_single (i : \u03b9) (m : M) (k : \u03ba) (n : N) :\n    finsuppTensorFinsupp R S M N \u03b9 \u03ba (Finsupp.single i m \u2297\u209c Finsupp.single k n) =\n      Finsupp.single (i, k) (m \u2297\u209c n) := by\n  simp [finsuppTensorFinsupp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "context": {"open": ["DirectSum TensorProduct", "Set LinearMap Submodule", "scoped Classical in"], "variables": ["(R : Type*) [CommSemiring R]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}", "{S : Type*} [CommSemiring S] [Algebra R S]", "(R M N \u03b9 S)", "{R M N \u03b9 S}", "(R M N \u03b9)", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}", "(R S M N \u03b9 \u03ba : Type*)", "[Module S M] [IsScalarTower R S M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\nN : Type u_5\n\u03b9 : Type u_6\n\u03ba : Type u_7\ni : \u03b9\nm : M\nk : \u03ba\nn : N\n\u22a2 sorry = fun\u2080 | (i, k) => m \u2297\u209c[?m.15087 M N \u03b9 \u03ba i m k n] n"}, {"line": "simp [finsuppTensorFinsupp]", "tactic_state": "M : Type u_4\nN : Type u_5\n\u03b9 : Type u_6\n\u03ba : Type u_7\ni : \u03b9\nm : M\nk : \u03ba\nn : N\n\u22a2 sorry () = fun\u2080 | (i, k) => m \u2297\u209c[?m.15087 M N \u03b9 \u03ba i m k n] n"}]}
{"declaration": "theorem finsuppTensorFinsuppLid_single_tmul_single (a : \u03b9) (b : \u03ba) (r : R) (n : N) :\n    finsuppTensorFinsuppLid R N \u03b9 \u03ba (Finsupp.single a r \u2297\u209c[R] Finsupp.single b n) =\n      Finsupp.single (a, b) (r \u2022 n) := by\n  simp [finsuppTensorFinsuppLid]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "context": {"open": ["DirectSum TensorProduct", "Set LinearMap Submodule", "scoped Classical in"], "variables": ["(R : Type*) [CommSemiring R]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}", "{S : Type*} [CommSemiring S] [Algebra R S]", "(R M N \u03b9 S)", "{R M N \u03b9 S}", "(R M N \u03b9)", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}", "(R S M N \u03b9 \u03ba : Type*)", "[Module S M] [IsScalarTower R S M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nN : Type u_5\n\u03b9 : Type u_6\n\u03ba : Type u_7\na : \u03b9\nb : \u03ba\nr : R\nn : N\n\u22a2 sorry = fun\u2080 | (a, b) => sorry"}, {"line": "simp [finsuppTensorFinsuppLid]", "tactic_state": "R : Type u_2\nN : Type u_5\n\u03b9 : Type u_6\n\u03ba : Type u_7\na : \u03b9\nb : \u03ba\nr : R\nn : N\n\u22a2 sorry () = fun\u2080 | (a, b) => sorry ()"}]}
{"declaration": "theorem finsuppTensorFinsuppRid_single_tmul_single (a : \u03b9) (b : \u03ba) (m : M) (r : R) :\n    finsuppTensorFinsuppRid R M \u03b9 \u03ba (Finsupp.single a m \u2297\u209c[R] Finsupp.single b r) =\n      Finsupp.single (a, b) (r \u2022 m) := by\n  simp [finsuppTensorFinsuppRid]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "context": {"open": ["DirectSum TensorProduct", "Set LinearMap Submodule", "scoped Classical in"], "variables": ["(R : Type*) [CommSemiring R]", "(\u03b9 : Type*) [DecidableEq \u03b9]", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}", "{S : Type*} [CommSemiring S] [Algebra R S]", "(R M N \u03b9 S)", "{R M N \u03b9 S}", "(R M N \u03b9)", "{R M N \u03b9}", "(R M N \u03b9)", "{R M N \u03b9}", "(R S M N \u03b9 \u03ba : Type*)", "[Module S M] [IsScalarTower R S M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nM : Type u_4\n\u03b9 : Type u_6\n\u03ba : Type u_7\na : \u03b9\nb : \u03ba\nm : M\nr : R\n\u22a2 sorry = fun\u2080 | (a, b) => sorry"}, {"line": "simp [finsuppTensorFinsuppRid]", "tactic_state": "R : Type u_2\nM : Type u_4\n\u03b9 : Type u_6\n\u03ba : Type u_7\na : \u03b9\nb : \u03ba\nm : M\nr : R\n\u22a2 sorry () = fun\u2080 | (a, b) => sorry ()"}]}
{"declaration": "theorem Module.Dual.eval_naturality (f : M\u2081 \u2192\u2097[R] M\u2082) :\n    f.dualMap.dualMap \u2218\u2097 eval R M\u2081 = eval R M\u2082 \u2218\u2097 f := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Defs.lean", "context": {"open": ["Module Submodule", "Module"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "{R M} {M' : Type*}", "[AddCommMonoid M'] [Module R M']", "{M'' : Type*} [AddCommMonoid M''] [Module R M'']", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u22a2 f.dualMap.dualMap \u2218\u2097 eval R M\u2081 = eval R M\u2082 \u2218\u2097 f"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_dualAnnihilator (\u03c6 : Module.Dual R M) : \u03c6 \u2208 W.dualAnnihilator \u2194 \u2200 w \u2208 W, \u03c6 w = 0 := by\n  refine LinearMap.mem_ker.trans ?_\n  simp_rw [LinearMap.ext_iff, dualRestrict_apply]\n  exact \u27e8fun h w hw => h \u27e8w, hw\u27e9, fun h w => h w.1 w.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Defs.lean", "context": {"open": ["Module Submodule", "Module", "Module Module.Dual Submodule LinearMap Module", "Function"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "{R M} {M' : Type*}", "[AddCommMonoid M'] [Module R M']", "{M'' : Type*} [AddCommMonoid M''] [Module R M'']", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "{K V : Type*}", "[CommRing K] [AddCommGroup V] [Module K V]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M N} in", "{R M N} in", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{W : Submodule R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\nW : Submodule R M\n\u03c6 : Dual R M\n\u22a2 \u03c6 \u2208 W.dualAnnihilator \u2194 \u2200 w \u2208 W, \u03c6 w = 0"}, {"line": "refine LinearMap.mem_ker.trans ?_", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\nW : Submodule R M\n\u03c6 : Dual R M\n\u22a2 W.dualRestrict \u03c6 = 0 \u2194 \u2200 w \u2208 W, \u03c6 w = 0"}, {"line": "simp_rw [LinearMap.ext_iff, dualRestrict_apply]", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\nW : Submodule R M\n\u03c6 : Dual R M\n\u22a2 (\u2200 (x : \u21a5W), \u03c6 \u2191x = 0 x) \u2194 \u2200 w \u2208 W, \u03c6 w = 0"}, {"line": "exact \u27e8fun h w hw => h \u27e8w, hw\u27e9, fun h w => h w.1 w.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_dualCoannihilator {\u03a6 : Submodule R (Module.Dual R M)} (x : M) :\n    x \u2208 \u03a6.dualCoannihilator \u2194 \u2200 \u03c6 \u2208 \u03a6, (\u03c6 x : R) = 0 := by\n  simp_rw [dualCoannihilator, mem_comap, mem_dualAnnihilator, Module.Dual.eval_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Defs.lean", "context": {"open": ["Module Submodule", "Module", "Module Module.Dual Submodule LinearMap Module", "Function"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "{R M} {M' : Type*}", "[AddCommMonoid M'] [Module R M']", "{M'' : Type*} [AddCommMonoid M''] [Module R M'']", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "{K V : Type*}", "[CommRing K] [AddCommGroup V] [Module K V]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M N} in", "{R M N} in", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{W : Submodule R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\n\u03a6 : Submodule R (Dual R M)\nx : M\n\u22a2 x \u2208 \u03a6.dualCoannihilator \u2194 \u2200 \u03c6 \u2208 \u03a6, \u03c6 x = 0"}, {"line": "simp_rw [dualCoannihilator, mem_comap, mem_dualAnnihilator, Module.Dual.eval_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dualAnnihilator_gc :\n    GaloisConnection\n      (OrderDual.toDual \u2218 (dualAnnihilator : Submodule R M \u2192 Submodule R (Module.Dual R M)))\n      (dualCoannihilator \u2218 OrderDual.ofDual) := by\n  intro a b\n  induction b using OrderDual.rec\n  simp only [Function.comp_apply]\n  simp only [OrderDual.toDual_le_toDual]\n  simp only [OrderDual.ofDual_toDual]\n  constructor <;>\n    \u00b7 intro h x hx\n      simp only [mem_dualAnnihilator]\n      simp only [mem_dualCoannihilator]\n      intro y hy\n      have := h hy\n      simp only [mem_dualAnnihilator] at this\n      simp only [mem_dualCoannihilator] at this\n      exact this x hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Defs.lean", "context": {"open": ["Module Submodule", "Module", "Module Module.Dual Submodule LinearMap Module", "Function"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "{R M} {M' : Type*}", "[AddCommMonoid M'] [Module R M']", "{M'' : Type*} [AddCommMonoid M''] [Module R M'']", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "{K V : Type*}", "[CommRing K] [AddCommGroup V] [Module K V]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M N} in", "{R M N} in", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{W : Submodule R M}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\n\u22a2 GaloisConnection (\u21d1OrderDual.toDual \u2218 dualAnnihilator) (dualCoannihilator \u2218 \u21d1OrderDual.ofDual)"}, {"line": "intro a b", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\na : Submodule R M\nb : (Submodule R (Dual R M))\u1d52\u1d48\n\u22a2 (\u21d1OrderDual.toDual \u2218 dualAnnihilator) a \u2264 b \u2194 a \u2264 (dualCoannihilator \u2218 \u21d1OrderDual.ofDual) b"}, {"line": "induction b using OrderDual.rec", "tactic_state": "case h\u2082\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\na : Submodule R M\na\u271d : Submodule R (Dual R M)\n\u22a2 (\u21d1OrderDual.toDual \u2218 dualAnnihilator) a \u2264 OrderDual.toDual a\u271d \u2194\n    a \u2264 (dualCoannihilator \u2218 \u21d1OrderDual.ofDual) (OrderDual.toDual a\u271d)"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "case h\u2082\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\na : Submodule R M\na\u271d : Submodule R (Dual R M)\n\u22a2 OrderDual.toDual a.dualAnnihilator \u2264 OrderDual.toDual a\u271d \u2194\n    a \u2264 (OrderDual.ofDual (OrderDual.toDual a\u271d)).dualCoannihilator"}, {"line": "simp only [OrderDual.toDual_le_toDual]", "tactic_state": "case h\u2082\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\na : Submodule R M\na\u271d : Submodule R (Dual R M)\n\u22a2 a\u271d \u2264 a.dualAnnihilator \u2194 a \u2264 (OrderDual.ofDual (OrderDual.toDual a\u271d)).dualCoannihilator"}, {"line": "simp only [OrderDual.ofDual_toDual]", "tactic_state": "case h\u2082\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\na : Submodule R M\na\u271d : Submodule R (Dual R M)\n\u22a2 a\u271d \u2264 a.dualAnnihilator \u2194 a \u2264 a\u271d.dualCoannihilator"}, {"line": "constructor <;>\n    \u00b7 intro h x hx\n      simp only [mem_dualAnnihilator]\n      simp only [mem_dualCoannihilator]\n      intro y hy\n      have := h hy\n      simp only [mem_dualAnnihilator] at this\n      simp only [mem_dualCoannihilator] at this\n      exact this x hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dualAnnihilator_top : (\u22a4 : Submodule R M).dualAnnihilator = \u22a5 := by\n  rw [eq_bot_iff]\n  intro v\n  simp_rw [mem_dualAnnihilator, mem_bot, mem_top, forall_true_left]\n  exact fun h => LinearMap.ext h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Defs.lean", "context": {"open": ["Module Submodule", "Module", "Module Module.Dual Submodule LinearMap Module", "Function"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "{R M} {M' : Type*}", "[AddCommMonoid M'] [Module R M']", "{M'' : Type*} [AddCommMonoid M''] [Module R M'']", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "{K V : Type*}", "[CommRing K] [AddCommGroup V] [Module K V]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M N} in", "{R M N} in", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{W : Submodule R M}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\n\u22a2 \u22a4.dualAnnihilator = \u22a5"}, {"line": "rw [eq_bot_iff]", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\n\u22a2 \u22a4.dualAnnihilator \u2264 \u22a5"}, {"line": "intro v", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\nv : Dual R M\n\u22a2 v \u2208 \u22a4.dualAnnihilator \u2192 v \u2208 \u22a5"}, {"line": "simp_rw [mem_dualAnnihilator, mem_bot, mem_top, forall_true_left]", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\nv : Dual R M\n\u22a2 (\u2200 (w : M), v w = 0) \u2192 v = 0"}, {"line": "exact fun h => LinearMap.ext h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_dualAnnihilator_le_inf (U V : Submodule R M) :\n    U.dualAnnihilator \u2294 V.dualAnnihilator \u2264 (U \u2293 V).dualAnnihilator := by\n  rw [le_dualAnnihilator_iff_le_dualCoannihilator]\n  rw [dualCoannihilator_sup_eq]\n  apply inf_le_inf <;> exact le_dualAnnihilator_dualCoannihilator _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Defs.lean", "context": {"open": ["Module Submodule", "Module", "Module Module.Dual Submodule LinearMap Module", "Function"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "{R M} {M' : Type*}", "[AddCommMonoid M'] [Module R M']", "{M'' : Type*} [AddCommMonoid M''] [Module R M'']", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "{K V : Type*}", "[CommRing K] [AddCommGroup V] [Module K V]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M N} in", "{R M N} in", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{W : Submodule R M}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\nU V : Submodule R M\n\u22a2 U.dualAnnihilator \u2294 V.dualAnnihilator \u2264 (U \u2293 V).dualAnnihilator"}, {"line": "rw [le_dualAnnihilator_iff_le_dualCoannihilator]", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\nU V : Submodule R M\n\u22a2 U \u2293 V \u2264 (U.dualAnnihilator \u2294 V.dualAnnihilator).dualCoannihilator"}, {"line": "rw [dualCoannihilator_sup_eq]", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\nU V : Submodule R M\n\u22a2 U \u2293 V \u2264 U.dualAnnihilator.dualCoannihilator \u2293 V.dualAnnihilator.dualCoannihilator"}, {"line": "apply inf_le_inf <;> exact le_dualAnnihilator_dualCoannihilator _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_dualAnnihilator_le_iInf {\u03b9 : Sort*} (U : \u03b9 \u2192 Submodule R M) :\n    \u2a06 i : \u03b9, (U i).dualAnnihilator \u2264 (\u2a05 i : \u03b9, U i).dualAnnihilator := by\n  rw [le_dualAnnihilator_iff_le_dualCoannihilator]\n  rw [dualCoannihilator_iSup_eq]\n  apply iInf_mono\n  exact fun i : \u03b9 => le_dualAnnihilator_dualCoannihilator (U i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Defs.lean", "context": {"open": ["Module Submodule", "Module", "Module Module.Dual Submodule LinearMap Module", "Function"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "{R M} {M' : Type*}", "[AddCommMonoid M'] [Module R M']", "{M'' : Type*} [AddCommMonoid M''] [Module R M'']", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "{K V : Type*}", "[CommRing K] [AddCommGroup V] [Module K V]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M N} in", "{R M N} in", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{W : Submodule R M}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\n\u03b9 : Sort u_14\nU : \u03b9 \u2192 Submodule R M\n\u22a2 \u2a06 i, (U i).dualAnnihilator \u2264 (\u2a05 i, U i).dualAnnihilator"}, {"line": "rw [le_dualAnnihilator_iff_le_dualCoannihilator]", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\n\u03b9 : Sort u_14\nU : \u03b9 \u2192 Submodule R M\n\u22a2 \u2a05 i, U i \u2264 (\u2a06 i, (U i).dualAnnihilator).dualCoannihilator"}, {"line": "rw [dualCoannihilator_iSup_eq]", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\n\u03b9 : Sort u_14\nU : \u03b9 \u2192 Submodule R M\n\u22a2 \u2a05 i, U i \u2264 \u2a05 i, (U i).dualAnnihilator.dualCoannihilator"}, {"line": "apply iInf_mono", "tactic_state": "case h\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\n\u03b9 : Sort u_14\nU : \u03b9 \u2192 Submodule R M\n\u22a2 \u2200 (i : \u03b9), U i \u2264 (U i).dualAnnihilator.dualCoannihilator"}, {"line": "exact fun i : \u03b9 => le_dualAnnihilator_dualCoannihilator (U i)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_dualAnnihilator_span (s : Set M) :\n    ((span R s).dualAnnihilator : Set (Module.Dual R M)) = {f | s \u2286 LinearMap.ker f} := by\n  ext f\n  simp only [SetLike.mem_coe]\n  simp only [mem_dualAnnihilator]\n  simp only [Set.mem_setOf_eq]\n  simp only [\u2190 LinearMap.mem_ker]\n  exact span_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Defs.lean", "context": {"open": ["Module Submodule", "Module", "Module Module.Dual Submodule LinearMap Module", "Function"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "{R M} {M' : Type*}", "[AddCommMonoid M'] [Module R M']", "{M'' : Type*} [AddCommMonoid M''] [Module R M'']", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "{K V : Type*}", "[CommRing K] [AddCommGroup V] [Module K V]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M N} in", "{R M N} in", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{W : Submodule R M}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\ns : Set M\n\u22a2 \u2191(span R s).dualAnnihilator = {f | s \u2286 \u2191(ker f)}"}, {"line": "ext f", "tactic_state": "case h\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\ns : Set M\nf : Dual R M\n\u22a2 f \u2208 \u2191(span R s).dualAnnihilator \u2194 f \u2208 {f | s \u2286 \u2191(ker f)}"}, {"line": "simp only [SetLike.mem_coe]", "tactic_state": "case h\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\ns : Set M\nf : Dual R M\n\u22a2 f \u2208 (span R s).dualAnnihilator \u2194 f \u2208 {f | s \u2286 \u2191(ker f)}"}, {"line": "simp only [mem_dualAnnihilator]", "tactic_state": "case h\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\ns : Set M\nf : Dual R M\n\u22a2 (\u2200 w \u2208 span R s, f w = 0) \u2194 f \u2208 {f | s \u2286 \u2191(ker f)}"}, {"line": "simp only [Set.mem_setOf_eq]", "tactic_state": "case h\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\ns : Set M\nf : Dual R M\n\u22a2 (\u2200 w \u2208 span R s, f w = 0) \u2194 s \u2286 \u2191(ker f)"}, {"line": "simp only [\u2190 LinearMap.mem_ker]", "tactic_state": "case h\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsReflexive R M\ns : Set M\nf : Dual R M\n\u22a2 (\u2200 w \u2208 span R s, w \u2208 ker f) \u2194 s \u2286 \u2191(ker f)"}, {"line": "exact span_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_dualMap_le_dualAnnihilator_ker :\n    LinearMap.range f.dualMap \u2264 (ker f).dualAnnihilator := by\n  rintro _ \u27e8\u03c8, rfl\u27e9\n  simp_rw [Submodule.mem_dualAnnihilator, mem_ker]\n  rintro x hx\n  rw [dualMap_apply]\n  rw [hx]\n  rw [map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Defs.lean", "context": {"open": ["Module Submodule", "Module", "Module Module.Dual Submodule LinearMap Module", "Function", "Module"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "{R M} {M' : Type*}", "[AddCommMonoid M'] [Module R M']", "{M'' : Type*} [AddCommMonoid M''] [Module R M'']", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "{K V : Type*}", "[CommRing K] [AddCommGroup V] [Module K V]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M N} in", "{R M N} in", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{W : Submodule R M}", "(R M) in", "{R M\u2081 M\u2082 : Type*} [CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "(f : M\u2081 \u2192\u2097[R] M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2081 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\nR : Type u_11\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u22a2 range f.dualMap \u2264 (ker f).dualAnnihilator"}, {"line": "rintro _ \u27e8\u03c8, rfl\u27e9", "tactic_state": "case intro\nM\u2081 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\nR : Type u_11\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u03c8 : Dual R M\u2082\n\u22a2 f.dualMap \u03c8 \u2208 (ker f).dualAnnihilator"}, {"line": "simp_rw [Submodule.mem_dualAnnihilator, mem_ker]", "tactic_state": "case intro\nM\u2081 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\nR : Type u_11\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u03c8 : Dual R M\u2082\n\u22a2 \u2200 (w : M\u2081), f w = 0 \u2192 (f.dualMap \u03c8) w = 0"}, {"line": "rintro x hx", "tactic_state": "case intro\nM\u2081 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\nR : Type u_11\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u03c8 : Dual R M\u2082\nx : M\u2081\nhx : f x = 0\n\u22a2 (f.dualMap \u03c8) x = 0"}, {"line": "rw [dualMap_apply]", "tactic_state": "case intro\nM\u2081 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\nR : Type u_11\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u03c8 : Dual R M\u2082\nx : M\u2081\nhx : f x = 0\n\u22a2 \u03c8 (f x) = 0"}, {"line": "rw [hx]", "tactic_state": "case intro\nM\u2081 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\nR : Type u_11\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u03c8 : Dual R M\u2082\nx : M\u2081\nhx : f x = 0\n\u22a2 \u03c8 0 = 0"}, {"line": "rw [map_zero]", "tactic_state": "M\u2081 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\nR : Type u_11\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u03c8 : Dual R M\u2082\nx : M\u2081\nhx : f x = 0\n\u22a2 ZeroHomClass (Dual R M\u2082) M\u2082 R"}]}
{"declaration": "theorem dualMap_surjective_iff {f : V\u2081 \u2192\u2097[K] V\u2082} :\n    Function.Surjective f.dualMap \u2194 Function.Injective f := by\n  rw [\u2190 LinearMap.range_eq_top]\n  rw [range_dualMap_eq_dualAnnihilator_ker]\n  rw [\u2190 Submodule.dualAnnihilator_bot]\n  rw [Subspace.dualAnnihilator_inj]\n  rw [LinearMap.ker_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Lemmas.lean", "context": {"open": ["Module Submodule", "Module Module.Dual Submodule LinearMap Cardinal Function", "Module Module.Dual Submodule LinearMap Cardinal Basis Module", "Function", "Module", "LinearMap Set FiniteDimensional", "Submodule LinearMap", "FiniteDimensional Module", "scoped Classical in", "Module", "Module", "LinearMap in", "LinearMap in", "Submodule"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "(M' : Type*) [AddCommMonoid M'] [Module R M']", "{R : Type uR} {M : Type uM} {K : Type uK} {V : Type uV} {\u03b9 : Type u\u03b9}", "[CommRing R] [AddCommGroup M] [Module R M] [DecidableEq \u03b9]", "(b : Basis \u03b9 R M)", "[Finite \u03b9]", "[Module.Finite R M]", "{K : Type uK} {V : Type uV}", "[CommRing K] [AddCommGroup V] [Module K V] [Projective K V]", "(K) (V)", "(K)", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] {p : Submodule R M}", "{\u03b9 \ud835\udd5c E : Type*} [Field \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "{K V : Type*} [Field K] [AddCommGroup V] [Module K V]", "{W : Subspace K V}", "[FiniteDimensional K V]", "{R M M' : Type*}", "[CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup M'] [Module R M']", "{K V\u2081 V\u2082 : Type*} [Field K]", "[AddCommGroup V\u2081] [Module K V\u2081] [AddCommGroup V\u2082] [Module K V\u2082]", "{f : Module.Dual K V\u2081}", "(hf : f \u2260 0)", "[FiniteDimensional K V\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_18\nV\u2081 : Type u_19\nV\u2082 : Type u_20\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : AddCommGroup V\u2081\ninst\u271d\u00b3 : Module K V\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\u2081\nf : V\u2081 \u2192\u2097[K] V\u2082\n\u22a2 Surjective \u21d1f.dualMap \u2194 Function.Injective \u21d1f"}, {"line": "rw [\u2190 LinearMap.range_eq_top]", "tactic_state": "K : Type u_18\nV\u2081 : Type u_19\nV\u2082 : Type u_20\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : AddCommGroup V\u2081\ninst\u271d\u00b3 : Module K V\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\u2081\nf : V\u2081 \u2192\u2097[K] V\u2082\n\u22a2 LinearMap.range f.dualMap = \u22a4 \u2194 Function.Injective \u21d1f"}, {"line": "rw [range_dualMap_eq_dualAnnihilator_ker]", "tactic_state": "K : Type u_18\nV\u2081 : Type u_19\nV\u2082 : Type u_20\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : AddCommGroup V\u2081\ninst\u271d\u00b3 : Module K V\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\u2081\nf : V\u2081 \u2192\u2097[K] V\u2082\n\u22a2 (ker f).dualAnnihilator = \u22a4 \u2194 Function.Injective \u21d1f"}, {"line": "rw [\u2190 Submodule.dualAnnihilator_bot]", "tactic_state": "K : Type u_18\nV\u2081 : Type u_19\nV\u2082 : Type u_20\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : AddCommGroup V\u2081\ninst\u271d\u00b3 : Module K V\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\u2081\nf : V\u2081 \u2192\u2097[K] V\u2082\n\u22a2 (ker f).dualAnnihilator = \u22a5.dualAnnihilator \u2194 Function.Injective \u21d1f"}, {"line": "rw [Subspace.dualAnnihilator_inj]", "tactic_state": "K : Type u_18\nV\u2081 : Type u_19\nV\u2082 : Type u_20\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : AddCommGroup V\u2081\ninst\u271d\u00b3 : Module K V\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\u2081\nf : V\u2081 \u2192\u2097[K] V\u2082\n\u22a2 ker f = \u22a5 \u2194 Function.Injective \u21d1f"}, {"line": "rw [LinearMap.ker_eq_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dualAnnihilator_iInf_eq {\u03b9 : Type*} [Finite \u03b9] (W : \u03b9 \u2192 Subspace K V\u2081) :\n    (\u2a05 i : \u03b9, W i).dualAnnihilator = \u2a06 i : \u03b9, (W i).dualAnnihilator := by\n  revert \u03b9\n  apply Finite.induction_empty_option\n  \u00b7 intro \u03b1 \u03b2 h hyp W\n    rw [\u2190 h.iInf_comp]\n    rw [hyp _]\n    rw [\u2190 h.iSup_comp]\n  \u00b7 intro W\n    rw [iSup_of_empty']\n    rw [iInf_of_isEmpty]\n    rw [sInf_empty]\n    rw [sSup_empty]\n    rw [dualAnnihilator_top]\n  \u00b7 intro \u03b1 _ h W\n    rw [iInf_option]\n    rw [iSup_option]\n    rw [dualAnnihilator_inf_eq]\n    rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Lemmas.lean", "context": {"open": ["Module Submodule", "Module Module.Dual Submodule LinearMap Cardinal Function", "Module Module.Dual Submodule LinearMap Cardinal Basis Module", "Function", "Module", "LinearMap Set FiniteDimensional", "Submodule LinearMap", "FiniteDimensional Module", "scoped Classical in", "Module", "Module", "LinearMap in", "LinearMap in", "Submodule", "Submodule"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "(M' : Type*) [AddCommMonoid M'] [Module R M']", "{R : Type uR} {M : Type uM} {K : Type uK} {V : Type uV} {\u03b9 : Type u\u03b9}", "[CommRing R] [AddCommGroup M] [Module R M] [DecidableEq \u03b9]", "(b : Basis \u03b9 R M)", "[Finite \u03b9]", "[Module.Finite R M]", "{K : Type uK} {V : Type uV}", "[CommRing K] [AddCommGroup V] [Module K V] [Projective K V]", "(K) (V)", "(K)", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] {p : Submodule R M}", "{\u03b9 \ud835\udd5c E : Type*} [Field \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "{K V : Type*} [Field K] [AddCommGroup V] [Module K V]", "{W : Subspace K V}", "[FiniteDimensional K V]", "{R M M' : Type*}", "[CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup M'] [Module R M']", "{K V\u2081 V\u2082 : Type*} [Field K]", "[AddCommGroup V\u2081] [Module K V\u2081] [AddCommGroup V\u2082] [Module K V\u2082]", "{f : Module.Dual K V\u2081}", "(hf : f \u2260 0)", "[FiniteDimensional K V\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_18\nV\u2081 : Type u_19\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : FiniteDimensional K V\u2081\n\u03b9 : Type u_21\ninst\u271d : Finite \u03b9\nW : \u03b9 \u2192 Subspace K V\u2081\n\u22a2 dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"line": "revert \u03b9", "tactic_state": "K : Type u_18\nV\u2081 : Type u_19\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\u2081\ninst\u271d\u00b9 : Module K V\u2081\ninst\u271d : FiniteDimensional K V\u2081\n\u22a2 \u2200 {\u03b9 : Type u_21} [inst : Finite \u03b9] (W : \u03b9 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"line": "apply Finite.induction_empty_option", "tactic_state": "case of_equiv\nK : Type u_18\nV\u2081 : Type u_19\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\u2081\ninst\u271d\u00b9 : Module K V\u2081\ninst\u271d : FiniteDimensional K V\u2081\n\u22a2 \u2200 {\u03b1 \u03b2 : Type u_21},\n    \u03b1 \u2243 \u03b2 \u2192\n      (\u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)) \u2192\n        \u2200 (W : \u03b2 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)\n---\ncase h_empty\nK : Type u_18\nV\u2081 : Type u_19\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\u2081\ninst\u271d\u00b9 : Module K V\u2081\ninst\u271d : FiniteDimensional K V\u2081\n\u22a2 \u2200 (W : PEmpty.{u_21 + 1} \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)\n---\ncase h_option\nK : Type u_18\nV\u2081 : Type u_19\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\u2081\ninst\u271d\u00b9 : Module K V\u2081\ninst\u271d : FiniteDimensional K V\u2081\n\u22a2 \u2200 {\u03b1 : Type u_21} [inst : Fintype \u03b1],\n    (\u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)) \u2192\n      \u2200 (W : Option \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"line": "\u00b7 intro \u03b1 \u03b2 h hyp W\n    rw [\u2190 h.iInf_comp]\n    rw [hyp _]\n    rw [\u2190 h.iSup_comp]", "tactic_state": "case h_empty\nK : Type u_18\nV\u2081 : Type u_19\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\u2081\ninst\u271d\u00b9 : Module K V\u2081\ninst\u271d : FiniteDimensional K V\u2081\n\u22a2 \u2200 (W : PEmpty.{u_21 + 1} \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)\n---\ncase h_option\nK : Type u_18\nV\u2081 : Type u_19\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\u2081\ninst\u271d\u00b9 : Module K V\u2081\ninst\u271d : FiniteDimensional K V\u2081\n\u22a2 \u2200 {\u03b1 : Type u_21} [inst : Fintype \u03b1],\n    (\u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)) \u2192\n      \u2200 (W : Option \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"line": "\u00b7 intro W\n    rw [iSup_of_empty']\n    rw [iInf_of_isEmpty]\n    rw [sInf_empty]\n    rw [sSup_empty]\n    rw [dualAnnihilator_top]", "tactic_state": "case h_option\nK : Type u_18\nV\u2081 : Type u_19\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\u2081\ninst\u271d\u00b9 : Module K V\u2081\ninst\u271d : FiniteDimensional K V\u2081\n\u22a2 \u2200 {\u03b1 : Type u_21} [inst : Fintype \u03b1],\n    (\u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)) \u2192\n      \u2200 (W : Option \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"line": "\u00b7 intro \u03b1 _ h W\n    rw [iInf_option]\n    rw [iSup_option]\n    rw [dualAnnihilator_inf_eq]\n    rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dualMap_bijective_iff {f : V\u2081 \u2192\u2097[K] V\u2082} :\n    Function.Bijective f.dualMap \u2194 Function.Bijective f := by\n  simp_rw [Function.Bijective, dualMap_surjective_iff, dualMap_injective_iff, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Dual/Lemmas.lean", "context": {"open": ["Module Submodule", "Module Module.Dual Submodule LinearMap Cardinal Function", "Module Module.Dual Submodule LinearMap Cardinal Basis Module", "Function", "Module", "LinearMap Set FiniteDimensional", "Submodule LinearMap", "FiniteDimensional Module", "scoped Classical in", "Module", "Module", "LinearMap in", "LinearMap in", "Submodule", "Submodule", "Module LinearMap"], "variables": ["(R A M : Type*)", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "(M' : Type*) [AddCommMonoid M'] [Module R M']", "{R : Type uR} {M : Type uM} {K : Type uK} {V : Type uV} {\u03b9 : Type u\u03b9}", "[CommRing R] [AddCommGroup M] [Module R M] [DecidableEq \u03b9]", "(b : Basis \u03b9 R M)", "[Finite \u03b9]", "[Module.Finite R M]", "{K : Type uK} {V : Type uV}", "[CommRing K] [AddCommGroup V] [Module K V] [Projective K V]", "(K) (V)", "(K)", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[IsReflexive R M]", "{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] {p : Submodule R M}", "{\u03b9 \ud835\udd5c E : Type*} [Field \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "{K V : Type*} [Field K] [AddCommGroup V] [Module K V]", "{W : Subspace K V}", "[FiniteDimensional K V]", "{R M M' : Type*}", "[CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup M'] [Module R M']", "{K V\u2081 V\u2082 : Type*} [Field K]", "[AddCommGroup V\u2081] [Module K V\u2081] [AddCommGroup V\u2082] [Module K V\u2082]", "{f : Module.Dual K V\u2081}", "(hf : f \u2260 0)", "[FiniteDimensional K V\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_18\nV\u2081 : Type u_19\nV\u2082 : Type u_20\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : AddCommGroup V\u2081\ninst\u271d\u00b3 : Module K V\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\u2081\nf : V\u2081 \u2192\u2097[K] V\u2082\n\u22a2 Bijective \u21d1f.dualMap \u2194 Bijective \u21d1f"}, {"line": "simp_rw [Function.Bijective, dualMap_surjective_iff, dualMap_injective_iff, and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma genEigenspace_directed {f : End R M} {\u03bc : R} {k : \u2115\u221e} :\n    Directed (\u00b7 \u2264 \u00b7) (fun l : {l : \u2115 // l \u2264 k} \u21a6 f.genEigenspace \u03bc l) := by\n  have aux : Monotone ((\u2191) : {l : \u2115 // l \u2264 k} \u2192 \u2115\u221e) := fun x y h \u21a6 by simpa using h\n  exact ((genEigenspace f \u03bc).monotone.comp aux).directed_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "context": {"open": ["Module Set"], "variables": ["{K R : Type v} {V M : Type w} [CommRing R] [AddCommGroup M] [Module R M] [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : End R M\n\u03bc : R\nk : \u2115\u221e\n\u22a2 Directed (fun x1 x2 => x1 \u2264 x2) fun l => (f.genEigenspace \u03bc) \u2191\u2191l"}, {"line": "have aux : Monotone ((\u2191) : {l : \u2115 // l \u2264 k} \u2192 \u2115\u221e) := fun x y h \u21a6 by simpa using h", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : End R M\n\u03bc : R\nk : \u2115\u221e\naux : Monotone fun x => \u2191\u2191x\n\u22a2 Directed (fun x1 x2 => x1 \u2264 x2) fun l => (f.genEigenspace \u03bc) \u2191\u2191l"}, {"line": "exact ((genEigenspace f \u03bc).monotone.comp aux).directed_le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_genEigenspace_top {f : End R M} {\u03bc : R} {x : M} :\n    x \u2208 f.genEigenspace \u03bc \u22a4 \u2194 \u2203 k : \u2115, x \u2208 LinearMap.ker ((f - \u03bc \u2022 1) ^ k) := by\n  simp [mem_genEigenspace]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "context": {"open": ["Module Set"], "variables": ["{K R : Type v} {V M : Type w} [CommRing R] [AddCommGroup M] [Module R M] [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : End R M\n\u03bc : R\nx : M\n\u22a2 x \u2208 (f.genEigenspace \u03bc) \u22a4 \u2194 \u2203 k, x \u2208 LinearMap.ker ((f - \u03bc \u2022 1) ^ k)"}, {"line": "simp [mem_genEigenspace]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma HasUnifEigenvector.pow_apply {f : End R M} {\u03bc : R} {v : M} (hv : f.HasUnifEigenvector \u03bc 1 v)\n    (n : \u2115) : (f ^ n) v = \u03bc ^ n \u2022 v := by\n  induction n <;> simp [*, pow_succ f, hv.apply_eq_smul, smul_smul, pow_succ' \u03bc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "context": {"open": ["Module Set"], "variables": ["{K R : Type v} {V M : Type w} [CommRing R] [AddCommGroup M] [Module R M] [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : End R M\n\u03bc : R\nv : M\nhv : f.HasUnifEigenvector \u03bc 1 v\nn : \u2115\n\u22a2 (f ^ n) v = \u03bc ^ n \u2022 v"}, {"line": "induction n <;> simp [*, pow_succ f, hv.apply_eq_smul, smul_smul, pow_succ' \u03bc]", "tactic_state": "case succ\nR : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : End R M\n\u03bc : R\nv : M\nhv : f.HasUnifEigenvector \u03bc 1 v\nn\u271d : \u2115\na\u271d : (f ^ n\u271d) v = \u03bc ^ n\u271d \u2022 v\n\u22a2 (f ^ n\u271d) (f v) = \u03bc ^ (n\u271d + 1) \u2022 v"}]}
{"declaration": "lemma HasUnifEigenvalue.exp_ne_zero {f : End R M} {\u03bc : R} {k : \u2115}\n    (h : f.HasUnifEigenvalue \u03bc k) : k \u2260 0 := by\n  rintro rfl\n  simp [HasUnifEigenvalue, Nat.cast_zero, genEigenspace_zero] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "context": {"open": ["Module Set"], "variables": ["{K R : Type v} {V M : Type w} [CommRing R] [AddCommGroup M] [Module R M] [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : End R M\n\u03bc : R\nk : \u2115\nh : f.HasUnifEigenvalue \u03bc \u2191k\n\u22a2 k \u2260 0"}, {"line": "rintro rfl", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : End R M\n\u03bc : R\nh : f.HasUnifEigenvalue \u03bc \u21910\n\u22a2 False"}, {"line": "simp [HasUnifEigenvalue, Nat.cast_zero, genEigenspace_zero] at h", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : End R M\n\u03bc : R\nh : f.HasUnifEigenvalue \u03bc 0\n\u22a2 False"}]}
{"declaration": "lemma injOn_genEigenspace [NoZeroSMulDivisors R M] (f : End R M) (k : \u2115\u221e) :\n    InjOn (f.genEigenspace \u00b7 k) {\u03bc | f.genEigenspace \u03bc k \u2260 \u22a5} := by\n  rintro \u03bc\u2081 _ \u03bc\u2082 h\u03bc\u2082 h\u03bc\u2081\u2082\n  by_contra contra\n  apply h\u03bc\u2082\n  simpa only [h\u03bc\u2081\u2082,disjoint_self] using f.disjoint_genEigenspace contra k k\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "context": {"open": ["Module Set"], "variables": ["{K R : Type v} {V M : Type w} [CommRing R] [AddCommGroup M] [Module R M] [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : End R M\nk : \u2115\u221e\n\u22a2 InjOn (fun x => (f.genEigenspace x) k) {\u03bc | (f.genEigenspace \u03bc) k \u2260 \u22a5}"}, {"line": "rintro \u03bc\u2081 _ \u03bc\u2082 h\u03bc\u2082 h\u03bc\u2081\u2082", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : End R M\nk : \u2115\u221e\n\u03bc\u2081 : R\na\u271d : \u03bc\u2081 \u2208 {\u03bc | (f.genEigenspace \u03bc) k \u2260 \u22a5}\n\u03bc\u2082 : R\nh\u03bc\u2082 : \u03bc\u2082 \u2208 {\u03bc | (f.genEigenspace \u03bc) k \u2260 \u22a5}\nh\u03bc\u2081\u2082 : (fun x => (f.genEigenspace x) k) \u03bc\u2081 = (fun x => (f.genEigenspace x) k) \u03bc\u2082\n\u22a2 \u03bc\u2081 = \u03bc\u2082"}, {"line": "by_contra contra", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : End R M\nk : \u2115\u221e\n\u03bc\u2081 : R\na\u271d : \u03bc\u2081 \u2208 {\u03bc | (f.genEigenspace \u03bc) k \u2260 \u22a5}\n\u03bc\u2082 : R\nh\u03bc\u2082 : \u03bc\u2082 \u2208 {\u03bc | (f.genEigenspace \u03bc) k \u2260 \u22a5}\nh\u03bc\u2081\u2082 : (fun x => (f.genEigenspace x) k) \u03bc\u2081 = (fun x => (f.genEigenspace x) k) \u03bc\u2082\ncontra : \u00ac\u03bc\u2081 = \u03bc\u2082\n\u22a2 False"}, {"line": "apply h\u03bc\u2082", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : End R M\nk : \u2115\u221e\n\u03bc\u2081 : R\na\u271d : \u03bc\u2081 \u2208 {\u03bc | (f.genEigenspace \u03bc) k \u2260 \u22a5}\n\u03bc\u2082 : R\nh\u03bc\u2082 : \u03bc\u2082 \u2208 {\u03bc | (f.genEigenspace \u03bc) k \u2260 \u22a5}\nh\u03bc\u2081\u2082 : (fun x => (f.genEigenspace x) k) \u03bc\u2081 = (fun x => (f.genEigenspace x) k) \u03bc\u2082\ncontra : \u00ac\u03bc\u2081 = \u03bc\u2082\n\u22a2 (f.genEigenspace \u03bc\u2082) k = \u22a5"}, {"line": "simpa only [h\u03bc\u2081\u2082,disjoint_self] using f.disjoint_genEigenspace contra k k", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_iSup_genEigenspace [NoZeroSMulDivisors R M]\n    (f : End R M) {\u03bc\u2081 \u03bc\u2082 : R} (h\u03bc : \u03bc\u2081 \u2260 \u03bc\u2082) :\n    Disjoint (\u2a06 k : \u2115, f.genEigenspace \u03bc\u2081 k) (\u2a06 k : \u2115, f.genEigenspace \u03bc\u2082 k) := by\n  simpa only [iSup_genEigenspace_eq] using disjoint_genEigenspace f h\u03bc \u22a4 \u22a4\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "context": {"open": ["Module Set"], "variables": ["{K R : Type v} {V M : Type w} [CommRing R] [AddCommGroup M] [Module R M] [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : End R M\n\u03bc\u2081 \u03bc\u2082 : R\nh\u03bc : \u03bc\u2081 \u2260 \u03bc\u2082\n\u22a2 Disjoint (\u2a06 k, (f.genEigenspace \u03bc\u2081) \u2191k) (\u2a06 k, (f.genEigenspace \u03bc\u2082) \u2191k)"}, {"line": "simpa only [iSup_genEigenspace_eq] using disjoint_genEigenspace f h\u03bc \u22a4 \u22a4", "tactic_state": "No Goals!"}]}
{"declaration": "theorem independent_maxGenEigenspace [NoZeroSMulDivisors R M] (f : End R M) :\n    iSupIndep f.maxGenEigenspace := by\n  apply independent_genEigenspace\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "context": {"open": ["Module Set"], "variables": ["{K R : Type v} {V M : Type w} [CommRing R] [AddCommGroup M] [Module R M] [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type v\nM : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : End R M\n\u22a2 iSupIndep f.maxGenEigenspace"}, {"line": "apply independent_genEigenspace", "tactic_state": "No Goals!"}]}
{"declaration": "theorem \u03b9Multi_zero_apply (v : Fin 0 \u2192 M) : \u03b9Multi R 0 v = 1 := by\n  simp [\u03b9Multi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean", "context": {"open": [], "variables": ["(R : Type u1) [CommRing R]", "(M : Type u2) [AddCommGroup M] [Module R M]", "{M}", "(n : \u2115) (M : Type u2) [AddCommGroup M] [Module R M]", "{R}", "{A : Type*} [Semiring A] [Algebra R A]", "(R)", "{R}", "(M)", "{M}", "(R) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u2\ninst\u271d : AddCommGroup M\nx\u271d : Sort u_2\n\u03b9Multi : x\u271d\nv : Fin 0 \u2192 M\n\u22a2 sorry = 1"}, {"line": "simp [\u03b9Multi]", "tactic_state": "M : Type u2\ninst\u271d : AddCommGroup M\nx\u271d : Sort u_2\n\u03b9Multi : x\u271d\nv : Fin 0 \u2192 M\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem toExterior_\u03b9 (m : M) :\n    TensorAlgebra.toExterior (TensorAlgebra.\u03b9 R m) = ExteriorAlgebra.\u03b9 R m := by\n  simp [toExterior]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean", "context": {"open": ["Function in"], "variables": ["(R : Type u1) [CommRing R]", "(M : Type u2) [AddCommGroup M] [Module R M]", "{M}", "(n : \u2115) (M : Type u2) [AddCommGroup M] [Module R M]", "{R}", "{A : Type*} [Semiring A] [Algebra R A]", "(R)", "{R}", "(M)", "{M}", "(R) in", "(R) in", "(R)", "{R}", "{N : Type u4} {N' : Type u5} [AddCommGroup N] [Module R N] [AddCommGroup N'] [Module R N']", "{K E F : Type*} [Field K] [AddCommGroup E]", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_5\nm : M\n\u22a2 sorry = sorry"}, {"line": "simp [toExterior]", "tactic_state": "M : Type u_5\nm : M\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem alternatingMapToDual_apply_\u03b9Multi {n : \u2115}\n    (f : (_ : Fin n) \u2192 Module.Dual R M) (v : Fin n \u2192 M) :\n    alternatingMapToDual R M n f (\u03b9Multi _ _ v) =\n      Matrix.det (n := Fin n) (.of (fun i j \u21a6 f j (v i))) := by\n  simp [alternatingMapToDual, Matrix.det_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorPower/Pairing.lean", "context": {"open": ["TensorProduct PiTensorProduct", "Equiv in", "Equiv in"], "variables": ["(R : Type*) (M : Type*) [CommRing R] [AddCommGroup M] [Module R M]", "{M} in", "{R M} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nR : Type u_1\nx\u271d : Sort u_2\nalternatingMapToDual : x\u271d\nn : \u2115\nf : Fin n \u2192 sorry\nv : Fin n \u2192 M\n\u22a2 sorry = (Matrix.of fun i j => sorry).det"}, {"line": "simp [alternatingMapToDual, Matrix.det_apply]", "tactic_state": "M : Type u_3\nR : Type u_1\nx\u271d : Sort u_2\nalternatingMapToDual : x\u271d\nn : \u2115\nf : Fin n \u2192 sorry\nv : Fin n \u2192 M\n\u22a2 sorry () = \u2211 x, Equiv.Perm.sign x \u2022 sorry () ^ n"}]}
{"declaration": "lemma pairingDual_\u03b9Multi_\u03b9Multi {n : \u2115} (f : (_ : Fin n) \u2192 Module.Dual R M) (v : Fin n \u2192 M) :\n    pairingDual R M n (\u03b9Multi _ _ f) (\u03b9Multi _ _ v) =\n      Matrix.det (n := Fin n) (.of (fun i j \u21a6 f j (v i))) := by\n  simp [pairingDual]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorPower/Pairing.lean", "context": {"open": ["TensorProduct PiTensorProduct", "Equiv in", "Equiv in", "Equiv in"], "variables": ["(R : Type*) (M : Type*) [CommRing R] [AddCommGroup M] [Module R M]", "{M} in", "{R M} in", "{R M} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nR : Type u_1\nx\u271d : Sort u_2\npairingDual : x\u271d\nn : \u2115\nf : Fin n \u2192 sorry\nv : Fin n \u2192 M\n\u22a2 sorry = (Matrix.of fun i j => sorry).det"}, {"line": "simp [pairingDual]", "tactic_state": "M : Type u_3\nR : Type u_1\nx\u271d : Sort u_2\npairingDual : x\u271d\nn : \u2115\nf : Fin n \u2192 sorry\nv : Fin n \u2192 M\n\u22a2 sorry () = (Matrix.of fun i j => sorry ()).det"}]}
{"declaration": "theorem map_id :\n    map n (LinearMap.id (R := R) (M := M)) = LinearMap.id := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorPower/Basic.lean", "context": {"open": ["scoped TensorProduct", "Function"], "variables": ["(R : Type u) [CommRing R] (n : \u2115) {M N N' : Type*}", "(M)", "{R} in", "{R M n}", "(n) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nmap : x\u271d\n\u22a2 sorry = LinearMap.id"}, {"line": "aesop", "tactic_state": "x : Sort u_4\nmap : x\n\u22a2 sorry () = LinearMap.id"}]}
{"declaration": "theorem map_comp (f : M \u2192\u2097[R] N) (g : N \u2192\u2097[R] N') :\n    map n (g \u2218\u2097 f) = map n g \u2218\u2097 map n f := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorPower/Basic.lean", "context": {"open": ["scoped TensorProduct", "Function"], "variables": ["(R : Type u) [CommRing R] (n : \u2115) {M N N' : Type*}", "(M)", "{R} in", "{R M n}", "(n) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nmap : x\u271d\nf : sorry\ng : sorry\n\u22a2 sorry = sorry \u2218\u2097 sorry"}, {"line": "aesop", "tactic_state": "x : Sort u_4\nmap : x\nf : sorry\ng : sorry\n\u22a2 sorry () = sorry () \u2218\u2097 sorry ()"}]}
{"declaration": "lemma zeroEquiv_\u03b9Multi (f : Fin 0 \u2192 M) :\n    zeroEquiv R M (\u03b9Multi _ _ f) = 1 := by\n  simp [zeroEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorPower/Basic.lean", "context": {"open": ["scoped TensorProduct", "Function"], "variables": ["(R : Type u) [CommRing R] (n : \u2115) {M N N' : Type*}", "(M)", "{R} in", "{R M n}", "(n) in", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nx\u271d : Sort u_4\nzeroEquiv : x\u271d\nf : Fin 0 \u2192 M\n\u22a2 sorry = 1"}, {"line": "simp [zeroEquiv]", "tactic_state": "M : Type u_1\nx\u271d : Sort u_4\nzeroEquiv : x\u271d\nf : Fin 0 \u2192 M\n\u22a2 sorry () = 1"}]}
{"declaration": "lemma zeroEquiv_naturality (f : M \u2192\u2097[R] N) :\n    (zeroEquiv R N).comp (map 0 f) = zeroEquiv R M := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorPower/Basic.lean", "context": {"open": ["scoped TensorProduct", "Function"], "variables": ["(R : Type u) [CommRing R] (n : \u2115) {M N N' : Type*}", "(M)", "{R} in", "{R M n}", "(n) in", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nzeroEquiv : x\u271d\nf : sorry\n\u22a2 sorry = sorry"}, {"line": "aesop", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nn : \u2115\nM : Type u_1\nN : Type u_2\nN' : Type u_3\nzeroEquiv : ?m.3465\nf : sorry\n\u22a2 Sort u_5"}]}
{"declaration": "lemma oneEquiv_\u03b9Multi (f : Fin 1 \u2192 M) :\n    oneEquiv R M (\u03b9Multi _ _ f) = f 0 := by\n  simp [oneEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorPower/Basic.lean", "context": {"open": ["scoped TensorProduct", "Function"], "variables": ["(R : Type u) [CommRing R] (n : \u2115) {M N N' : Type*}", "(M)", "{R} in", "{R M n}", "(n) in", "(R M) in", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nx\u271d : Sort u_4\noneEquiv : x\u271d\nf : Fin 1 \u2192 M\n\u22a2 sorry = f 0"}, {"line": "simp [oneEquiv]", "tactic_state": "M : Type u_1\nx\u271d : Sort u_4\noneEquiv : x\u271d\nf : Fin 1 \u2192 M\n\u22a2 sorry () = f 0"}]}
{"declaration": "lemma oneEquiv_naturality (f : M \u2192\u2097[R] N) :\n    (oneEquiv R N).comp (map 1 f) = f.comp (oneEquiv R M).toLinearMap := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/ExteriorPower/Basic.lean", "context": {"open": ["scoped TensorProduct", "Function"], "variables": ["(R : Type u) [CommRing R] (n : \u2115) {M N N' : Type*}", "(M)", "{R} in", "{R M n}", "(n) in", "(R M) in", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\noneEquiv : x\u271d\nf : sorry\n\u22a2 sorry = sorry"}, {"line": "aesop", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nn : \u2115\nM : Type u_1\nN : Type u_2\nN' : Type u_3\noneEquiv : ?m.3465\nf : sorry\n\u22a2 Sort u_5"}]}
{"declaration": "theorem basisSingleton_apply (\u03b9 : Type*) [Unique \u03b9] (h : finrank K V = 1) (v : V) (hv : v \u2260 0)\n    (i : \u03b9) : basisSingleton \u03b9 h v hv i = v := by\n  cases Unique.uniq \u2039Unique \u03b9\u203a i\n  simp [basisSingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/FiniteDimensional/Basic.lean", "context": {"open": ["Cardinal Function IsNoetherian Module Submodule", "Finset"], "variables": ["{K : Type u} {V : Type v}", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "{L : Type*} [Field L] [LinearOrder L] [IsStrictOrderedRing L]", "{W : Type v} [AddCommGroup W] [Module L W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\nV : Type v\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\nx\u271d : Sort u_3\nbasisSingleton : x\u271d\n\u03b9 : Type u_2\ninst\u271d : Unique \u03b9\nh : finrank K V = 1\nv : V\nhv : v \u2260 0\ni : \u03b9\n\u22a2 sorry = v"}, {"line": "cases Unique.uniq \u2039Unique \u03b9\u203a i", "tactic_state": "case refl\nK : Type u\nV : Type v\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\nx\u271d : Sort u_3\nbasisSingleton : x\u271d\n\u03b9 : Type u_2\ninst\u271d : Unique \u03b9\nh : finrank K V = 1\nv : V\nhv : v \u2260 0\n\u22a2 sorry = v"}, {"line": "simp [basisSingleton]", "tactic_state": "case refl\nK : Type u\nV : Type v\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\nx\u271d : Sort u_3\nbasisSingleton : x\u271d\n\u03b9 : Type u_2\ninst\u271d : Unique \u03b9\nh : finrank K V = 1\nv : V\nhv : v \u2260 0\n\u22a2 sorry () = v"}]}
{"declaration": "theorem coe_finsetBasisOfLinearIndependentOfCardEqFinrank {s : Finset V} (hs : s.Nonempty)\n    (lin_ind : LinearIndependent K ((\u2191) : s \u2192 V)) (card_eq : s.card = finrank K V) :\n    \u21d1(finsetBasisOfLinearIndependentOfCardEqFinrank hs lin_ind card_eq) = ((\u2191) : s \u2192 V) := by\n  simp [finsetBasisOfLinearIndependentOfCardEqFinrank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/FiniteDimensional/Lemmas.lean", "context": {"open": ["Cardinal Submodule Module Function", "IsNoetherian Module", "Module", "Module", "Classical in"], "variables": ["{K : Type u} {V : Type v}", "[DivisionRing K] [AddCommGroup V] [Module K V]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[FiniteDimensional K V] [FiniteDimensional K V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_2\nV : Type u_1\ninst\u271d\u00b9\u2077 : DivisionRing K\ninst\u271d\u00b9\u2076 : AddCommGroup V\ninst\u271d\u00b9\u2075 : Module K V\ninst\u271d\u00b9\u2074 : DivisionRing K\ninst\u271d\u00b9\u00b3 : AddCommGroup V\ninst\u271d\u00b9\u00b2 : Module K V\ninst\u271d\u00b9\u00b9 : DivisionRing K\ninst\u271d\u00b9\u2070 : AddCommGroup V\ninst\u271d\u2079 : Module K V\ninst\u271d\u2078 : DivisionRing K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Finset V\nhs : s.Nonempty\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : s.card = finrank K V\n\u22a2 sorry = Subtype.val"}, {"line": "simp [finsetBasisOfLinearIndependentOfCardEqFinrank]", "tactic_state": "K : Type u_2\nV : Type u_1\ninst\u271d\u00b9\u2077 : DivisionRing K\ninst\u271d\u00b9\u2076 : AddCommGroup V\ninst\u271d\u00b9\u2075 : Module K V\ninst\u271d\u00b9\u2074 : DivisionRing K\ninst\u271d\u00b9\u00b3 : AddCommGroup V\ninst\u271d\u00b9\u00b2 : Module K V\ninst\u271d\u00b9\u00b9 : DivisionRing K\ninst\u271d\u00b9\u2070 : AddCommGroup V\ninst\u271d\u2079 : Module K V\ninst\u271d\u2078 : DivisionRing K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Finset V\nhs : s.Nonempty\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : s.card = finrank K V\n\u22a2 sorry () = Subtype.val"}]}
{"declaration": "theorem coe_setBasisOfLinearIndependentOfCardEqFinrank {s : Set V} [Nonempty s] [Fintype s]\n    (lin_ind : LinearIndependent K ((\u2191) : s \u2192 V)) (card_eq : s.toFinset.card = finrank K V) :\n    \u21d1(setBasisOfLinearIndependentOfCardEqFinrank lin_ind card_eq) = ((\u2191) : s \u2192 V) := by\n  simp [setBasisOfLinearIndependentOfCardEqFinrank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/FiniteDimensional/Lemmas.lean", "context": {"open": ["Cardinal Submodule Module Function", "IsNoetherian Module", "Module", "Module", "Classical in"], "variables": ["{K : Type u} {V : Type v}", "[DivisionRing K] [AddCommGroup V] [Module K V]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[FiniteDimensional K V] [FiniteDimensional K V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_2\nV : Type u_1\ninst\u271d\u00b9\u2079 : DivisionRing K\ninst\u271d\u00b9\u2078 : AddCommGroup V\ninst\u271d\u00b9\u2077 : Module K V\ninst\u271d\u00b9\u2076 : DivisionRing K\ninst\u271d\u00b9\u2075 : AddCommGroup V\ninst\u271d\u00b9\u2074 : Module K V\ninst\u271d\u00b9\u00b3 : DivisionRing K\ninst\u271d\u00b9\u00b2 : AddCommGroup V\ninst\u271d\u00b9\u00b9 : Module K V\ninst\u271d\u00b9\u2070 : DivisionRing K\ninst\u271d\u2079 : AddCommGroup V\ninst\u271d\u2078 : Module K V\ninst\u271d\u2077 : DivisionRing K\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module K V\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module K V\ns : Set V\ninst\u271d\u00b9 : Nonempty \u2191s\ninst\u271d : Fintype \u2191s\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : s.toFinset.card = finrank K V\n\u22a2 sorry = Subtype.val"}, {"line": "simp [setBasisOfLinearIndependentOfCardEqFinrank]", "tactic_state": "K : Type u_2\nV : Type u_1\ninst\u271d\u00b9\u2079 : DivisionRing K\ninst\u271d\u00b9\u2078 : AddCommGroup V\ninst\u271d\u00b9\u2077 : Module K V\ninst\u271d\u00b9\u2076 : DivisionRing K\ninst\u271d\u00b9\u2075 : AddCommGroup V\ninst\u271d\u00b9\u2074 : Module K V\ninst\u271d\u00b9\u00b3 : DivisionRing K\ninst\u271d\u00b9\u00b2 : AddCommGroup V\ninst\u271d\u00b9\u00b9 : Module K V\ninst\u271d\u00b9\u2070 : DivisionRing K\ninst\u271d\u2079 : AddCommGroup V\ninst\u271d\u2078 : Module K V\ninst\u271d\u2077 : DivisionRing K\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module K V\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module K V\ns : Set V\ninst\u271d\u00b9 : Nonempty \u2191s\ninst\u271d : Fintype \u2191s\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : s.toFinset.card = finrank K V\n\u22a2 sorry () = Subtype.val"}]}
{"declaration": "theorem ker_pow_eq_ker_pow_finrank_of_le [FiniteDimensional K V] {f : End K V} {m : \u2115}\n    (hm : finrank K V \u2264 m) : LinearMap.ker (f ^ m) = LinearMap.ker (f ^ finrank K V) := by\n  obtain \u27e8k, h_k_le, hk\u27e9 :\n    \u2203 k, k \u2264 finrank K V \u2227 LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ) :=\n    exists_ker_pow_eq_ker_pow_succ f\n  calc\n    LinearMap.ker (f ^ m) = LinearMap.ker (f ^ (k + (m - k))) := by\n      rw [add_tsub_cancel_of_le (h_k_le.trans hm)]\n    _ = LinearMap.ker (f ^ k) := by rw [ker_pow_constant hk _]\n    _ = LinearMap.ker (f ^ (k + (finrank K V - k))) := ker_pow_constant hk (finrank K V - k)\n    _ = LinearMap.ker (f ^ finrank K V) := by rw [add_tsub_cancel_of_le h_k_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/FiniteDimensional/Lemmas.lean", "context": {"open": ["Cardinal Submodule Module Function", "IsNoetherian Module", "Module", "Module", "Classical in", "Module"], "variables": ["{K : Type u} {V : Type v}", "[DivisionRing K] [AddCommGroup V] [Module K V]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[FiniteDimensional K V] [FiniteDimensional K V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V] {V\u2082 : Type v'} [AddCommGroup V\u2082]", "[DivisionRing K] [AddCommGroup V] [Module K V]", "{F E : Type*} [Field F] [Ring E] [Algebra F E]", "[DivisionRing K] [AddCommGroup V] [Module K V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\nV : Type v\ninst\u271d\u00b2\u00b9 : DivisionRing K\ninst\u271d\u00b2\u2070 : AddCommGroup V\ninst\u271d\u00b9\u2079 : Module K V\ninst\u271d\u00b9\u2078 : DivisionRing K\ninst\u271d\u00b9\u2077 : AddCommGroup V\ninst\u271d\u00b9\u2076 : Module K V\ninst\u271d\u00b9\u2075 : DivisionRing K\ninst\u271d\u00b9\u2074 : AddCommGroup V\ninst\u271d\u00b9\u00b3 : Module K V\ninst\u271d\u00b9\u00b2 : DivisionRing K\ninst\u271d\u00b9\u00b9 : AddCommGroup V\ninst\u271d\u00b9\u2070 : Module K V\ninst\u271d\u2079 : DivisionRing K\ninst\u271d\u2078 : AddCommGroup V\ninst\u271d\u2077 : Module K V\ninst\u271d\u2076 : DivisionRing K\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module K V\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nf : End K V\nm : \u2115\nhm : finrank K V \u2264 m\n\u22a2 LinearMap.ker (f ^ m) = LinearMap.ker (f ^ finrank K V)"}, {"line": "obtain \u27e8k, h_k_le, hk\u27e9 :\n    \u2203 k, k \u2264 finrank K V \u2227 LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ) :=\n    exists_ker_pow_eq_ker_pow_succ f", "tactic_state": "case intro.intro\nK : Type u\nV : Type v\ninst\u271d\u00b2\u00b9 : DivisionRing K\ninst\u271d\u00b2\u2070 : AddCommGroup V\ninst\u271d\u00b9\u2079 : Module K V\ninst\u271d\u00b9\u2078 : DivisionRing K\ninst\u271d\u00b9\u2077 : AddCommGroup V\ninst\u271d\u00b9\u2076 : Module K V\ninst\u271d\u00b9\u2075 : DivisionRing K\ninst\u271d\u00b9\u2074 : AddCommGroup V\ninst\u271d\u00b9\u00b3 : Module K V\ninst\u271d\u00b9\u00b2 : DivisionRing K\ninst\u271d\u00b9\u00b9 : AddCommGroup V\ninst\u271d\u00b9\u2070 : Module K V\ninst\u271d\u2079 : DivisionRing K\ninst\u271d\u2078 : AddCommGroup V\ninst\u271d\u2077 : Module K V\ninst\u271d\u2076 : DivisionRing K\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module K V\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nf : End K V\nm : \u2115\nhm : finrank K V \u2264 m\nk : \u2115\nh_k_le : k \u2264 sorry\nhk : LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ)\n\u22a2 LinearMap.ker (f ^ m) = LinearMap.ker (f ^ finrank K V)"}, {"line": "calc\n    LinearMap.ker (f ^ m) = LinearMap.ker (f ^ (k + (m - k))) := by\n      rw [add_tsub_cancel_of_le (h_k_le.trans hm)]\n    _ = LinearMap.ker (f ^ k) := by rw [ker_pow_constant hk _]\n    _ = LinearMap.ker (f ^ (k + (finrank K V - k))) := ker_pow_constant hk (finrank K V - k)\n    _ = LinearMap.ker (f ^ finrank K V) := by rw [add_tsub_cancel_of_le h_k_le]", "tactic_state": "case intro.intro.calc.step\nK : Type u\nV : Type v\ninst\u271d\u00b2\u00b9 : DivisionRing K\ninst\u271d\u00b2\u2070 : AddCommGroup V\ninst\u271d\u00b9\u2079 : Module K V\ninst\u271d\u00b9\u2078 : DivisionRing K\ninst\u271d\u00b9\u2077 : AddCommGroup V\ninst\u271d\u00b9\u2076 : Module K V\ninst\u271d\u00b9\u2075 : DivisionRing K\ninst\u271d\u00b9\u2074 : AddCommGroup V\ninst\u271d\u00b9\u00b3 : Module K V\ninst\u271d\u00b9\u00b2 : DivisionRing K\ninst\u271d\u00b9\u00b9 : AddCommGroup V\ninst\u271d\u00b9\u2070 : Module K V\ninst\u271d\u2079 : DivisionRing K\ninst\u271d\u2078 : AddCommGroup V\ninst\u271d\u2077 : Module K V\ninst\u271d\u2076 : DivisionRing K\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module K V\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nf : End K V\nm : \u2115\nhm : finrank K V \u2264 m\nk : \u2115\nh_k_le : k \u2264 sorry\nhk : LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ)\n\u22a2 LinearMap.ker (f ^ sorry) = LinearMap.ker (f ^ finrank K V)"}]}
{"declaration": "theorem mem_supported_support (p : \u03b1 \u2192\u2080 M) : p \u2208 Finsupp.supported M R (p.support : Set \u03b1) := by\n  rw [Finsupp.mem_supported]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/Supported.lean", "context": {"open": ["Set LinearMap Submodule"], "variables": ["{\u03b1 : Type*} {M : Type*} {N : Type*} {P : Type*} {R : Type*} {S : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "(M R)", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np : \u03b1 \u2192\u2080 M\n\u22a2 p \u2208 Finsupp.supported M R \u2191p.support"}, {"line": "rw [Finsupp.mem_supported]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_smul_index_linearMap' [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M\u2082]\n    [Module R M\u2082] {v : \u03b1 \u2192\u2080 M} {c : R} {h : \u03b1 \u2192 M \u2192\u2097[R] M\u2082} :\n    ((c \u2022 v).sum fun a => h a) = c \u2022 v.sum fun a => h a := by\n  rw [Finsupp.sum_smul_index']\n  rw [Finsupp.smul_sum]\n  \u00b7 simp only [map_smul]\n  \u00b7 intro i\n    exact (h i).map_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/LSum.lean", "context": {"open": ["Set LinearMap Submodule"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {R : Type*} {M : Type*} {M\u2082 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nv : \u03b1 \u2192\u2080 M\nc : R\nh : \u03b1 \u2192 M \u2192\u2097[R] M\u2082\n\u22a2 ((c \u2022 v).sum fun a => \u21d1(h a)) = c \u2022 v.sum fun a => \u21d1(h a)"}, {"line": "rw [Finsupp.sum_smul_index']", "tactic_state": "\u03b1 : Type u_1\nR : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nv : \u03b1 \u2192\u2080 M\nc : R\nh : \u03b1 \u2192 M \u2192\u2097[R] M\u2082\n\u22a2 (v.sum fun i c_1 => (h i) (c \u2022 c_1)) = c \u2022 v.sum fun a => \u21d1(h a)\n---\n\u03b1 : Type u_1\nR : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nv : \u03b1 \u2192\u2080 M\nc : R\nh : \u03b1 \u2192 M \u2192\u2097[R] M\u2082\n\u22a2 \u2200 (i : \u03b1), (h i) 0 = 0"}, {"line": "rw [Finsupp.smul_sum]", "tactic_state": "\u03b1 : Type u_1\nR : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nv : \u03b1 \u2192\u2080 M\nc : R\nh : \u03b1 \u2192 M \u2192\u2097[R] M\u2082\n\u22a2 (v.sum fun i c_1 => (h i) (c \u2022 c_1)) = v.sum fun a b => c \u2022 (h a) b\n---\n\u03b1 : Type u_1\nR : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nv : \u03b1 \u2192\u2080 M\nc : R\nh : \u03b1 \u2192 M \u2192\u2097[R] M\u2082\n\u22a2 \u2200 (i : \u03b1), (h i) 0 = 0"}, {"line": "\u00b7 simp only [map_smul]", "tactic_state": "\u03b1 : Type u_1\nR : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M\u2082\ninst\u271d : Module R M\u2082\nv : \u03b1 \u2192\u2080 M\nc : R\nh : \u03b1 \u2192 M \u2192\u2097[R] M\u2082\n\u22a2 \u2200 (i : \u03b1), (h i) 0 = 0"}, {"line": "\u00b7 intro i\n    exact (h i).map_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulLeftMap_apply_single {M N : Submodule R S} {\u03b9 : Type*} (m : \u03b9 \u2192 M) (i : \u03b9) (n : N) :\n    mulLeftMap N m (Finsupp.single i n) = (m i).1 * n.1 := by\n  simp [mulLeftMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/LSum.lean", "context": {"open": ["Set LinearMap Submodule", "Finsupp", "Finsupp Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {R : Type*} {M : Type*} {M\u2082 : Type*}", "{\u03b1 : Type*} {M : Type*} {N : Type*} {P : Type*} {R : Type*} {S : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "(R S M N \u03b9 : Type*)", "[Semiring S] [AddCommMonoid M] [AddCommMonoid N] [Module S M] [Module S N]", "(S)", "[Module S N] [SMulCommClass R S N]", "(M) (R) (X : Type*) (S)", "[Module S M] [SMulCommClass R S M]", "{R : Type*} {M : Type*} {N : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "(R)", "{\u03b1 : Type*}", "{R : Type*} {R\u2082 : Type*} {M : Type*} {M\u2082 : Type*} {\u03b9 : Type*}", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}", "[Module R M] [Module R\u2082 M\u2082]", "{\u03b3 : Type*} [Zero \u03b3]", "{S : Type*} [Semiring S] [Module R S] [SMulCommClass R R S]", "[SMulCommClass R S S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : Semiring R\nS : Type u_27\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Module R S\ninst\u271d\u00b9 : SMulCommClass R R S\ninst\u271d : SMulCommClass R S S\nM N : Submodule R S\n\u03b9 : Type u_28\nm : \u03b9 \u2192 \u21a5M\ni : \u03b9\nn : \u21a5N\n\u22a2 ((mulLeftMap N m) fun\u2080 | i => n) = \u2191(m i) * \u2191n"}, {"line": "simp [mulLeftMap]", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : Semiring R\nS : Type u_27\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Module R S\ninst\u271d\u00b9 : SMulCommClass R R S\ninst\u271d : SMulCommClass R S S\nM N : Submodule R S\n\u03b9 : Type u_28\nm : \u03b9 \u2192 \u21a5M\ni : \u03b9\nn : \u21a5N\n\u22a2 ((fun\u2080 | i => n).sum fun i => \u21d1(\u2191(m i) \u2022 N.subtype)) = \u2191(m i) * \u2191n"}]}
{"declaration": "theorem mulRightMap_apply_single {M N : Submodule R S} {\u03b9 : Type*} (n : \u03b9 \u2192 N) (i : \u03b9) (m : M) :\n    mulRightMap M n (Finsupp.single i m) = m.1 * (n i).1 := by\n  simp [mulRightMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/LSum.lean", "context": {"open": ["Set LinearMap Submodule", "Finsupp", "Finsupp Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {R : Type*} {M : Type*} {M\u2082 : Type*}", "{\u03b1 : Type*} {M : Type*} {N : Type*} {P : Type*} {R : Type*} {S : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "(R S M N \u03b9 : Type*)", "[Semiring S] [AddCommMonoid M] [AddCommMonoid N] [Module S M] [Module S N]", "(S)", "[Module S N] [SMulCommClass R S N]", "(M) (R) (X : Type*) (S)", "[Module S M] [SMulCommClass R S M]", "{R : Type*} {M : Type*} {N : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "(R)", "{\u03b1 : Type*}", "{R : Type*} {R\u2082 : Type*} {M : Type*} {M\u2082 : Type*} {\u03b9 : Type*}", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}", "[Module R M] [Module R\u2082 M\u2082]", "{\u03b3 : Type*} [Zero \u03b3]", "{S : Type*} [Semiring S] [Module R S] [SMulCommClass R R S]", "[SMulCommClass R S S]", "[IsScalarTower R S S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d\u2075 : Semiring R\nS : Type u_27\ninst\u271d\u2074 : Semiring S\ninst\u271d\u00b3 : Module R S\ninst\u271d\u00b2 : SMulCommClass R R S\ninst\u271d\u00b9 : SMulCommClass R S S\ninst\u271d : IsScalarTower R S S\nM N : Submodule R S\n\u03b9 : Type u_28\nn : \u03b9 \u2192 \u21a5N\ni : \u03b9\nm : \u21a5M\n\u22a2 ((M.mulRightMap n) fun\u2080 | i => m) = \u2191m * \u2191(n i)"}, {"line": "simp [mulRightMap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearCombination_single (c : R) (a : \u03b1) :\n    linearCombination R v (single a c) = c \u2022 v a := by\n  simp [linearCombination_apply, sum_single_index]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/LinearCombination.lean", "context": {"open": ["Set LinearMap Submodule"], "variables": ["{\u03b1 : Type*} {M : Type*} {N : Type*} {P : Type*} {R : Type*} {S : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "(R)", "{\u03b1' : Type*} {M' : Type*} [AddCommMonoid M'] [Module R M'] (v : \u03b1 \u2192 M) {v' : \u03b1' \u2192 M'}", "{v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b1 \u2192 M\nx\u271d : Sort u_9\nlinearCombination : x\u271d\nc : R\na : \u03b1\n\u22a2 sorry = c \u2022 v a"}, {"line": "simp [linearCombination_apply, sum_single_index]", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b1 \u2192 M\nx\u271d : Sort u_9\nlinearCombination : x\u271d\nc : R\na : \u03b1\n\u22a2 sorry () = c \u2022 v a"}]}
{"declaration": "theorem linearCombination_zero_apply (x : \u03b1 \u2192\u2080 R) : (linearCombination R (0 : \u03b1 \u2192 M)) x = 0 := by\n  simp [linearCombination_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/LinearCombination.lean", "context": {"open": ["Set LinearMap Submodule"], "variables": ["{\u03b1 : Type*} {M : Type*} {N : Type*} {P : Type*} {R : Type*} {S : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "(R)", "{\u03b1' : Type*} {M' : Type*} [AddCommMonoid M'] [Module R M'] (v : \u03b1 \u2192 M) {v' : \u03b1' \u2192 M'}", "{v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_5\ninst\u271d : Semiring R\nx\u271d : Sort u_9\nlinearCombination : x\u271d\nx : \u03b1 \u2192\u2080 R\n\u22a2 sorry = 0"}, {"line": "simp [linearCombination_apply]", "tactic_state": "\u03b1 : Type u_1\nR : Type u_5\ninst\u271d : Semiring R\nx\u271d : Sort u_9\nlinearCombination : x\u271d\nx : \u03b1 \u2192\u2080 R\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem Fintype.bilinearCombination_apply_single [DecidableEq \u03b1] (i : \u03b1) (r : R) :\n    Fintype.bilinearCombination R S v (Pi.single i r) = r \u2022 v i := by\n  simp [Fintype.bilinearCombination]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/LinearCombination.lean", "context": {"open": ["Set LinearMap Submodule"], "variables": ["{\u03b1 : Type*} {M : Type*} {N : Type*} {P : Type*} {R : Type*} {S : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "(R)", "{\u03b1' : Type*} {M' : Type*} [AddCommMonoid M'] [Module R M'] (v : \u03b1 \u2192 M) {v' : \u03b1' \u2192 M'}", "{v}", "(\u03b1 M)", "{\u03b1 M}", "{R} in", "(\u03b1) (M) (v)", "{\u03b1} {M} {v}", "[Module S M] [SMulCommClass R S M]", "(S) in", "{\u03b1 M : Type*} (R : Type*) [Fintype \u03b1] [Semiring R] [AddCommMonoid M] [Module R M]", "(S : Type*) [Semiring S] [Module S M] [SMulCommClass R S M]", "(v : \u03b1 \u2192 M)", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nv : \u03b1 \u2192 M\ninst\u271d : DecidableEq \u03b1\ni : \u03b1\nr : R\n\u22a2 sorry = r \u2022 v i"}, {"line": "simp [Fintype.bilinearCombination]", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nv : \u03b1 \u2192 M\ninst\u271d : DecidableEq \u03b1\ni : \u03b1\nr : R\n\u22a2 sorry () = r \u2022 v i"}]}
{"declaration": "theorem Fintype.mem_span_image_iff_exists_fun {s : Set \u03b1} [Fintype s] :\n    x \u2208 span R (v '' s) \u2194 \u2203 c : s \u2192 R, \u2211 i, c i \u2022 v i = x := by\n  rw [\u2190 mem_span_range_iff_exists_fun]\n  rw [image_eq_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/LinearCombination.lean", "context": {"open": ["Set LinearMap Submodule"], "variables": ["{\u03b1 : Type*} {M : Type*} {N : Type*} {P : Type*} {R : Type*} {S : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "(R)", "{\u03b1' : Type*} {M' : Type*} [AddCommMonoid M'] [Module R M'] (v : \u03b1 \u2192 M) {v' : \u03b1' \u2192 M'}", "{v}", "(\u03b1 M)", "{\u03b1 M}", "{R} in", "(\u03b1) (M) (v)", "{\u03b1} {M} {v}", "[Module S M] [SMulCommClass R S M]", "(S) in", "{\u03b1 M : Type*} (R : Type*) [Fintype \u03b1] [Semiring R] [AddCommMonoid M] [Module R M]", "(S : Type*) [Semiring S] [Module S M] [SMulCommClass R S M]", "(v : \u03b1 \u2192 M)", "{S}", "{v} {x : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nv : \u03b1 \u2192 M\nx : M\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 x \u2208 span R (v '' s) \u2194 \u2203 c, \u2211 i, c i \u2022 v \u2191i = x"}, {"line": "rw [\u2190 mem_span_range_iff_exists_fun]", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_5\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nv : \u03b1 \u2192 M\nx : M\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 x \u2208 span R (v '' s) \u2194 x \u2208 span R (Set.range fun i => v \u2191i)"}, {"line": "rw [image_eq_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Span.finsupp_linearCombination_repr {w : Set M} (x : span R w) :\n    Finsupp.linearCombination R ((\u2191) : w \u2192 M) (Span.repr R w x) = x := by\n  rw [Span.repr_def]\n  exact ((Finsupp.mem_span_iff_linearCombination _ _ _).mp x.2).choose_spec\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/LinearCombination.lean", "context": {"open": ["Set LinearMap Submodule", "Finsupp"], "variables": ["{\u03b1 : Type*} {M : Type*} {N : Type*} {P : Type*} {R : Type*} {S : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "(R)", "{\u03b1' : Type*} {M' : Type*} [AddCommMonoid M'] [Module R M'] (v : \u03b1 \u2192 M) {v' : \u03b1' \u2192 M'}", "{v}", "(\u03b1 M)", "{\u03b1 M}", "{R} in", "(\u03b1) (M) (v)", "{\u03b1} {M} {v}", "[Module S M] [SMulCommClass R S M]", "(S) in", "{\u03b1 M : Type*} (R : Type*) [Fintype \u03b1] [Semiring R] [AddCommMonoid M] [Module R M]", "(S : Type*) [Semiring S] [Module S M] [SMulCommClass R S M]", "(v : \u03b1 \u2192 M)", "{S}", "{v} {x : M}", "{R : Type*} {M : Type*} {N : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\nM : Type u_11\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nw : Set M\nx : \u21a5(span R w)\n\u22a2 (linearCombination R Subtype.val) (repr R w x) = \u2191x"}, {"line": "rw [Span.repr_def]", "tactic_state": "R : Type u_10\nM : Type u_11\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nw : Set M\nx : \u21a5(span R w)\n\u22a2 (linearCombination R Subtype.val) \u22ef.choose = \u2191x"}, {"line": "exact ((Finsupp.mem_span_iff_linearCombination _ _ _).mp x.2).choose_spec", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Submodule.mem_span_set {m : M} {s : Set M} :\n    m \u2208 Submodule.span R s \u2194\n      \u2203 c : M \u2192\u2080 R, (c.support : Set M) \u2286 s \u2227 (c.sum fun mi r => r \u2022 mi) = m := by\n  conv_lhs => rw [\u2190 Set.image_id s]\n  exact Finsupp.mem_span_image_iff_linearCombination R (v := _root_.id (\u03b1 := M))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/LinearCombination.lean", "context": {"open": ["Set LinearMap Submodule", "Finsupp"], "variables": ["{\u03b1 : Type*} {M : Type*} {N : Type*} {P : Type*} {R : Type*} {S : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "(R)", "{\u03b1' : Type*} {M' : Type*} [AddCommMonoid M'] [Module R M'] (v : \u03b1 \u2192 M) {v' : \u03b1' \u2192 M'}", "{v}", "(\u03b1 M)", "{\u03b1 M}", "{R} in", "(\u03b1) (M) (v)", "{\u03b1} {M} {v}", "[Module S M] [SMulCommClass R S M]", "(S) in", "{\u03b1 M : Type*} (R : Type*) [Fintype \u03b1] [Semiring R] [AddCommMonoid M] [Module R M]", "(S : Type*) [Semiring S] [Module S M] [SMulCommClass R S M]", "(v : \u03b1 \u2192 M)", "{S}", "{v} {x : M}", "{R : Type*} {M : Type*} {N : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\nM : Type u_11\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nm : M\ns : Set M\n\u22a2 m \u2208 span R s \u2194 \u2203 c, \u2191c.support \u2286 s \u2227 (c.sum fun mi r => r \u2022 mi) = m"}, {"line": "conv_lhs => rw [\u2190 Set.image_id s]", "tactic_state": "R : Type u_10\nM : Type u_11\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nm : M\ns : Set M\n\u22a2 m \u2208 span R (_root_.id '' s) \u2194 \u2203 c, \u2191c.support \u2286 s \u2227 (c.sum fun mi r => r \u2022 mi) = m"}, {"line": "exact Finsupp.mem_span_image_iff_linearCombination R (v := _root_.id (\u03b1 := M))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Finset.sum_single_ite [Fintype n] (a : R) (i : n) :\n    (\u2211 x : n, Finsupp.single x (if i = x then a else 0)) = Finsupp.single i a := by\n  simp only [apply_ite (Finsupp.single _)]\n  simp only [Finsupp.single_zero]\n  simp only [Finset.sum_ite_eq]\n  simp only [if_pos (Finset.mem_univ _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Finsupp/VectorSpace.lean", "context": {"open": ["Set LinearMap Submodule", "LinearMap Submodule", "scoped Classical in"], "variables": ["{R : Type*} {M : Type*} {\u03b9 : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "(\u03b9 R M) in", "(\u03b9 R) in", "{R : Type*} {M : Type*} {\u03b9 : Type*}", "[Ring R] [AddCommGroup M] [Module R M]", "{\u03b9 : Type*} {R : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R M) in", "{R M n : Type*}", "[DecidableEq n]", "[Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_4\nR : Type u_2\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid sorry\ninst\u271d\u00b9 : Module R sorry\ninst\u271d : Fintype n\na : R\ni : n\n\u22a2 (\u2211 x, fun\u2080 | x => if i = x then a else 0) = fun\u2080 | i => a"}, {"line": "simp only [apply_ite (Finsupp.single _)]", "tactic_state": "n : Type u_4\nR : Type u_2\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid sorry\ninst\u271d\u00b9 : Module R sorry\ninst\u271d : Fintype n\na : R\ni : n\n\u22a2 (\u2211 x, if i = x then fun\u2080 | x => a else fun\u2080 | x => 0) = fun\u2080 | i => a"}, {"line": "simp only [Finsupp.single_zero]", "tactic_state": "n : Type u_4\nR : Type u_2\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid sorry\ninst\u271d\u00b9 : Module R sorry\ninst\u271d : Fintype n\na : R\ni : n\n\u22a2 (\u2211 x, if i = x then fun\u2080 | x => a else 0) = fun\u2080 | i => a"}, {"line": "simp only [Finset.sum_ite_eq]", "tactic_state": "n : Type u_4\nR : Type u_2\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid sorry\ninst\u271d\u00b9 : Module R sorry\ninst\u271d : Fintype n\na : R\ni : n\n\u22a2 (if i \u2208 Finset.univ then fun\u2080 | i => a else 0) = fun\u2080 | i => a"}, {"line": "simp only [if_pos (Finset.mem_univ _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.det_zero'' {R M : Type*} [CommRing R] [AddCommGroup M] [Module R M]\n    [Module.Free R M] [Module.Finite R M] [Nontrivial M] : LinearMap.det (0 : M \u2192\u2097[R] M) = 0 := by\n  letI : Nonempty (Module.Free.ChooseBasisIndex R M) := (Module.Free.chooseBasis R M).index_nonempty\n  nontriviality R\n  exact LinearMap.det_zero' (Module.Free.chooseBasis R M)", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/FreeModule/Determinant.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module.Free R M\ninst\u271d\u00b9 : Module.Finite R M\ninst\u271d : Nontrivial M\n\u22a2 LinearMap.det 0 = 0"}, {"line": "letI : Nonempty (Module.Free.ChooseBasisIndex R M) := (Module.Free.chooseBasis R M).index_nonempty", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module.Free R M\ninst\u271d\u00b9 : Module.Finite R M\ninst\u271d : Nontrivial M\nthis : Nonempty sorry := sorry\n\u22a2 LinearMap.det 0 = 0"}, {"line": "nontriviality R", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module.Free R M\ninst\u271d\u00b9 : Module.Finite R M\ninst\u271d : Nontrivial M\nthis : Nonempty sorry := sorry\na\u271d : Nontrivial R\n\u22a2 LinearMap.det 0 = 0"}, {"line": "exact LinearMap.det_zero' (Module.Free.chooseBasis R M)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_algHom_le_finrank : Nat.card (M \u2192\u2090[K] L) \u2264 finrank K M := by\n  convert toNat_le_toNat (cardinalMk_algHom_le_rank K M L) ?_\n  \u00b7 rw [toNat_lift, finrank]\n  \u00b7 rw [lift_lt_aleph0]; have := Module.nontrivial K L; apply Module.rank_lt_aleph0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean", "context": {"open": ["Module.Free (chooseBasis ChooseBasisIndex)", "Module (finrank)", "Cardinal", "Cardinal"], "variables": ["(R : Type u) (S : Type u') (M : Type v) (N : Type w)", "[Ring R] [Ring S] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M]", "[AddCommGroup N] [Module R N] [Module S N] [SMulCommClass R S N]", "[StrongRankCondition R] [StrongRankCondition S] [Module.Free S N]", "[Module R S] [SMulCommClass R S S]", "(K M : Type*) (L : Type v) [CommRing K] [Ring M] [Algebra K M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Nat.card sorry \u2264 finrank K M"}, {"line": "convert toNat_le_toNat (cardinalMk_algHom_le_rank K M L) ?_", "tactic_state": "case h.e'_3\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Nat.card sorry = Cardinal.toNat (mk (M \u2192\u2090[K] sorry))\n---\ncase h.e'_4\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 finrank K M = Cardinal.toNat (lift.{?u.40031, u_2} (Module.rank K M))\n---\ncase convert_1\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 CommRing K\n---\ncase convert_2\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Ring M\n---\ncase convert_3\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Algebra K M\n---\ncase convert_4\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Module.Free K M\n---\ncase convert_5\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Module.Finite K M\n---\ncase convert_6\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 CommRing sorry\n---\ncase convert_7\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 IsDomain sorry\n---\ncase convert_8\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Algebra K sorry\n---\ncase convert_9\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 lift.{?u.40031, u_2} (Module.rank K M) < aleph0"}, {"line": "\u00b7 rw [toNat_lift, finrank]", "tactic_state": "case h.e'_4\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 finrank K M = Cardinal.toNat (lift.{?u.40031, u_2} (Module.rank K M))\n---\ncase convert_1\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 CommRing K\n---\ncase convert_2\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Ring M\n---\ncase convert_3\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Algebra K M\n---\ncase convert_4\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Module.Free K M\n---\ncase convert_5\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Module.Finite K M\n---\ncase convert_6\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 CommRing sorry\n---\ncase convert_7\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 IsDomain sorry\n---\ncase convert_8\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Algebra K sorry\n---\ncase convert_9\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 lift.{?u.40031, u_2} (Module.rank K M) < aleph0"}, {"line": "\u00b7 rw [lift_lt_aleph0]; have := Module.nontrivial K L; apply Module.rank_lt_aleph0", "tactic_state": "case convert_1\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 CommRing K\n---\ncase convert_2\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Ring M\n---\ncase convert_3\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Algebra K M\n---\ncase convert_4\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Module.Free K M\n---\ncase convert_5\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Module.Finite K M\n---\ncase convert_6\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 CommRing sorry\n---\ncase convert_7\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 IsDomain sorry\n---\ncase convert_8\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 Algebra K sorry\n---\ncase convert_9\nK : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Ring M\ninst\u271d : Algebra K M\n\u22a2 lift.{?u.40031, u_2} (Module.rank K M) < aleph0"}]}
{"declaration": "theorem identify_one (i : I) : \u03b9' R A (DirectSum.lof R I A i 1) = 1 := by\n  suffices \u03b9' R A (DirectSum.lof R I A i 1) = mkAlgHom R A 1 by simpa\n  exact RingQuot.mkAlgHom_rel R <| rel_id R A (i := i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/FreeProduct/Basic.lean", "context": {"open": ["scoped DirectSum", "scoped Function -- required for scoped `on` notation", "TensorAlgebra DirectSum TensorPower", "scoped Function -- required for scoped `on` notation", "RingQuot Function"], "variables": ["{I : Type u} [DecidableEq I] {i : I} -- The type of the indexing set"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u\ninst\u271d : DecidableEq I\nx\u271d : Sort u_1\n\u03b9' : x\u271d\ni : I\n\u22a2 sorry = 1"}, {"line": "suffices \u03b9' R A (DirectSum.lof R I A i 1) = mkAlgHom R A 1 by simpa", "tactic_state": "I : Type u\ninst\u271d : DecidableEq I\nx\u271d : Sort u_1\n\u03b9' : x\u271d\ni : I\n\u22a2 sorry = sorry"}, {"line": "exact RingQuot.mkAlgHom_rel R <| rel_id R A (i := i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIndependent.map_of_injective_injective\u209b {R' M' : Type*}\n    [Semiring R'] [AddCommMonoid M'] [Module R' M'] (hv : LinearIndependent R v)\n    (i : R' \u2192 R) (j : M \u2192+ M') (hi : Injective i) (hj : Injective j)\n    (hc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m) : LinearIndependent R' (j \u2218 v) := by\n  rw [linearIndependent_iff'\u209b] at hv \u22a2\n  intro S r\u2081 r\u2082 H s hs\n  simp_rw [comp_apply, \u2190 hc, \u2190 map_sum] at H\n  exact hi <| hv _ _ _ (hj H) s hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Basic.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nR' : Type u_6\nM' : Type u_7\ninst\u271d\u00b2 : Semiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\nhv : LinearIndependent R v\ni : R' \u2192 R\nj : M \u2192+ M'\nhi : Injective i\nhj : Injective \u21d1j\nhc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m\n\u22a2 LinearIndependent R' (\u21d1j \u2218 v)"}, {"line": "rw [linearIndependent_iff'\u209b] at hv \u22a2", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nR' : Type u_6\nM' : Type u_7\ninst\u271d\u00b2 : Semiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\nhv : \u2200 (s : Finset \u03b9) (f g : \u03b9 \u2192 R), \u2211 i \u2208 s, f i \u2022 v i = \u2211 i \u2208 s, g i \u2022 v i \u2192 \u2200 i \u2208 s, f i = g i\ni : R' \u2192 R\nj : M \u2192+ M'\nhi : Injective i\nhj : Injective \u21d1j\nhc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m\n\u22a2 \u2200 (s : Finset \u03b9) (f g : \u03b9 \u2192 R'), \u2211 i \u2208 s, f i \u2022 (\u21d1j \u2218 v) i = \u2211 i \u2208 s, g i \u2022 (\u21d1j \u2218 v) i \u2192 \u2200 i \u2208 s, f i = g i"}, {"line": "intro S r\u2081 r\u2082 H s hs", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nR' : Type u_6\nM' : Type u_7\ninst\u271d\u00b2 : Semiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\nhv : \u2200 (s : Finset \u03b9) (f g : \u03b9 \u2192 R), \u2211 i \u2208 s, f i \u2022 v i = \u2211 i \u2208 s, g i \u2022 v i \u2192 \u2200 i \u2208 s, f i = g i\ni : R' \u2192 R\nj : M \u2192+ M'\nhi : Injective i\nhj : Injective \u21d1j\nhc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m\nS : Finset \u03b9\nr\u2081 r\u2082 : \u03b9 \u2192 R'\nH : \u2211 i \u2208 S, r\u2081 i \u2022 (\u21d1j \u2218 v) i = \u2211 i \u2208 S, r\u2082 i \u2022 (\u21d1j \u2218 v) i\ns : \u03b9\nhs : s \u2208 S\n\u22a2 r\u2081 s = r\u2082 s"}, {"line": "simp_rw [comp_apply, \u2190 hc, \u2190 map_sum] at H", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nR' : Type u_6\nM' : Type u_7\ninst\u271d\u00b2 : Semiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\nhv : \u2200 (s : Finset \u03b9) (f g : \u03b9 \u2192 R), \u2211 i \u2208 s, f i \u2022 v i = \u2211 i \u2208 s, g i \u2022 v i \u2192 \u2200 i \u2208 s, f i = g i\ni : R' \u2192 R\nj : M \u2192+ M'\nhi : Injective i\nhj : Injective \u21d1j\nhc : \u2200 (r : R') (m : M), j (i r \u2022 m) = r \u2022 j m\nS : Finset \u03b9\nr\u2081 r\u2082 : \u03b9 \u2192 R'\ns : \u03b9\nhs : s \u2208 S\nH : j (\u2211 x \u2208 S, i (r\u2081 x) \u2022 v x) = j (\u2211 x \u2208 S, i (r\u2082 x) \u2022 v x)\n\u22a2 r\u2081 s = r\u2082 s"}, {"line": "exact hi <| hv _ _ _ (hj H) s hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIndepOn.image_of_comp (f : \u03b9 \u2192 \u03b9') (g : \u03b9' \u2192 M) (hs : LinearIndepOn R (g \u2218 f) s) :\n    LinearIndepOn R g (f '' s) := by\n  nontriviality R\n  have : InjOn f s := injOn_iff_injective.2 hs.injective.of_comp\n  exact (linearIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Basic.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\ns : Set \u03b9\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : \u03b9 \u2192 \u03b9'\ng : \u03b9' \u2192 M\nhs : LinearIndepOn R (g \u2218 f) s\n\u22a2 LinearIndepOn R g (f '' s)"}, {"line": "nontriviality R", "tactic_state": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\ns : Set \u03b9\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : \u03b9 \u2192 \u03b9'\ng : \u03b9' \u2192 M\nhs : LinearIndepOn R (g \u2218 f) s\na\u271d : Nontrivial R\n\u22a2 LinearIndepOn R g (f '' s)"}, {"line": "have : InjOn f s := injOn_iff_injective.2 hs.injective.of_comp", "tactic_state": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\ns : Set \u03b9\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : \u03b9 \u2192 \u03b9'\ng : \u03b9' \u2192 M\nhs : LinearIndepOn R (g \u2218 f) s\na\u271d : Nontrivial R\nthis : InjOn f s\n\u22a2 LinearIndepOn R g (f '' s)"}, {"line": "exact (linearIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearIndepOn_congr {w : \u03b9 \u2192 M} (h : EqOn v w s) :\n    LinearIndepOn R v s \u2194 LinearIndepOn R w s := by\n  rw [LinearIndepOn]\n  rw [LinearIndepOn]\n  convert Iff.rfl using 2\n  ext x\n  exact h.symm x.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Basic.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\ns : Set \u03b9\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nw : \u03b9 \u2192 M\nh : EqOn v w s\n\u22a2 LinearIndepOn R v s \u2194 LinearIndepOn R w s"}, {"line": "rw [LinearIndepOn]", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\ns : Set \u03b9\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nw : \u03b9 \u2192 M\nh : EqOn v w s\n\u22a2 (LinearIndependent R fun (x : \u2191s) => v \u2191x) \u2194 LinearIndepOn R w s"}, {"line": "rw [LinearIndepOn]", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\ns : Set \u03b9\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nw : \u03b9 \u2192 M\nh : EqOn v w s\n\u22a2 (LinearIndependent R fun (x : \u2191s) => v \u2191x) \u2194 LinearIndependent R fun (x : \u2191s) => w \u2191x"}, {"line": "convert Iff.rfl using 2", "tactic_state": "case h.e'_2.h.e'_4\n\u03b9 : Type u'\nR : Type u_2\ns : Set \u03b9\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nw : \u03b9 \u2192 M\nh : EqOn v w s\n\u22a2 (fun x => w \u2191x) = fun x => v \u2191x"}, {"line": "ext x", "tactic_state": "case h.e'_2.h.e'_4.h\n\u03b9 : Type u'\nR : Type u_2\ns : Set \u03b9\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nw : \u03b9 \u2192 M\nh : EqOn v w s\nx : \u2191s\n\u22a2 w \u2191x = v \u2191x"}, {"line": "exact h.symm x.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIndependent.group_smul_iff {G : Type*} [hG : Group G] [MulAction G R]\n    [MulAction G M] [IsScalarTower G R M] [SMulCommClass G R M] (v : \u03b9 \u2192 M) (w : \u03b9 \u2192 G) :\n    LinearIndependent R (w \u2022 v) \u2194 LinearIndependent R v := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.group_smul w\u27e9\n  convert h.group_smul (fun i \u21a6 (w i)\u207b\u00b9)\n  simp [funext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Basic.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\n\u22a2 LinearIndependent R (w \u2022 v) \u2194 LinearIndependent R v"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.group_smul w\u27e9", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 LinearIndependent R v"}, {"line": "convert h.group_smul (fun i \u21a6 (w i)\u207b\u00b9)", "tactic_state": "case h.e'_4\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 v = (fun i => (w i)\u207b\u00b9) \u2022 w \u2022 v\n---\ncase convert_1\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 Group G\n---\ncase convert_2\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 MulAction G R\n---\ncase convert_3\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 SMul G M\n---\ncase convert_4\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 IsScalarTower G R M\n---\ncase convert_5\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 SMulCommClass G R M\n---\ncase convert_6\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 \u03b9 \u2192 Inv G"}, {"line": "simp [funext_iff]", "tactic_state": "case h.e'_4\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 \u2200 (x : \u03b9), v x = (w x)\u207b\u00b9 \u2022 w x \u2022 v x\n---\ncase convert_1\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 Group G\n---\ncase convert_2\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 MulAction G R\n---\ncase convert_3\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 SMul G M\n---\ncase convert_4\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 IsScalarTower G R M\n---\ncase convert_5\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 SMulCommClass G R M\n---\ncase convert_6\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nG : Type u_6\nhG : Group G\ninst\u271d\u00b3 : MulAction G R\ninst\u271d\u00b2 : MulAction G M\ninst\u271d\u00b9 : IsScalarTower G R M\ninst\u271d : SMulCommClass G R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 G\nh : LinearIndependent R (w \u2022 v)\n\u22a2 \u03b9 \u2192 Inv G"}]}
{"declaration": "theorem LinearIndependent.units_smul_iff (v : \u03b9 \u2192 M) (w : \u03b9 \u2192 R\u02e3) :\n    LinearIndependent R (w \u2022 v) \u2194 LinearIndependent R v := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.units_smul w\u27e9\n  convert h.units_smul (fun i \u21a6 (w i)\u207b\u00b9)\n  simp [funext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Basic.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 R\u02e3\n\u22a2 LinearIndependent R (w \u2022 v) \u2194 LinearIndependent R v"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.units_smul w\u27e9", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 R\u02e3\nh : LinearIndependent R (w \u2022 v)\n\u22a2 LinearIndependent R v"}, {"line": "convert h.units_smul (fun i \u21a6 (w i)\u207b\u00b9)", "tactic_state": "case h.e'_4\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 R\u02e3\nh : LinearIndependent R (w \u2022 v)\n\u22a2 v = (fun i => (w i)\u207b\u00b9) \u2022 w \u2022 v"}, {"line": "simp [funext_iff]", "tactic_state": "case h.e'_4\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 R\u02e3\nh : LinearIndependent R (w \u2022 v)\n\u22a2 \u2200 (x : \u03b9), v x = (w x)\u207b\u00b9 \u2022 w x \u2022 v x"}]}
{"declaration": "theorem LinearIndependent.eq_of_smul_apply_eq_smul_apply {M : Type*} [AddCommMonoid M] [Module R M]\n    {v : \u03b9 \u2192 M} (li : LinearIndependent R v) (c d : R) (i j : \u03b9) (hc : c \u2260 0)\n    (h : c \u2022 v i = d \u2022 v j) : i = j := by\n  have h_single_eq : Finsupp.single i c = Finsupp.single j d :=\n    li <| by simpa [Finsupp.linearCombination_apply] using h\n  rcases (Finsupp.single_eq_single_iff ..).mp h_single_eq with (\u27e8H, _\u27e9 | \u27e8hc, _\u27e9)\n  \u00b7 exact H\n  \u00b7 contradiction\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Basic.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\ninst\u271d\u00b2 : Semiring R\nM : Type u_6\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nli : LinearIndependent R v\nc d : R\ni j : \u03b9\nhc : c \u2260 0\nh : c \u2022 v i = d \u2022 v j\n\u22a2 i = j"}, {"line": "have h_single_eq : Finsupp.single i c = Finsupp.single j d :=\n    li <| by simpa [Finsupp.linearCombination_apply] using h", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\ninst\u271d\u00b2 : Semiring R\nM : Type u_6\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nli : LinearIndependent R v\nc d : R\ni j : \u03b9\nhc : c \u2260 0\nh : c \u2022 v i = d \u2022 v j\nh_single_eq : sorry = sorry\n\u22a2 i = j"}, {"line": "rcases (Finsupp.single_eq_single_iff ..).mp h_single_eq with (\u27e8H, _\u27e9 | \u27e8hc, _\u27e9)", "tactic_state": "case inl.intro\n\u03b9 : Type u'\nR : Type u_2\ninst\u271d\u00b2 : Semiring R\nM : Type u_6\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nli : LinearIndependent R v\nc d : R\ni j : \u03b9\nhc : c \u2260 0\nh : c \u2022 v i = d \u2022 v j\nh_single_eq : sorry = sorry\nH : ?m.3818 = ?m.3819\nright\u271d : ?m.3820 = ?m.3821\n\u22a2 i = j\n---\ncase inr.intro\n\u03b9 : Type u'\nR : Type u_2\ninst\u271d\u00b2 : Semiring R\nM : Type u_6\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nli : LinearIndependent R v\nc d : R\ni j : \u03b9\nhc\u271d : c \u2260 0\nh : c \u2022 v i = d \u2022 v j\nh_single_eq : sorry = sorry\nhc : ?m.3820 = 0\nright\u271d : ?m.3821 = 0\n\u22a2 i = j"}, {"line": "\u00b7 exact H", "tactic_state": "case inr.intro\n\u03b9 : Type u'\nR : Type u_2\ninst\u271d\u00b2 : Semiring R\nM : Type u_6\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nli : LinearIndependent R v\nc d : R\ni j : \u03b9\nhc\u271d : c \u2260 0\nh : c \u2022 v i = d \u2022 v j\nh_single_eq : sorry = sorry\nhc : ?m.3820 = 0\nright\u271d : ?m.3821 = 0\n\u22a2 i = j"}, {"line": "\u00b7 contradiction", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_linearIndepOn_id_of_span_subtype [Nontrivial R] {s t : Set M}\n    (hs : LinearIndepOn R id s) (h : t \u2286 s) (hst : s \u2286 span R t) : s = t := by\n  let f : t \u21aa s :=\n    \u27e8fun x => \u27e8x.1, h x.2\u27e9, fun a b hab => Subtype.coe_injective (Subtype.mk.inj hab)\u27e9\n  have h_surj : Surjective f := by\n    apply surjective_of_linearIndependent_of_span hs f _\n    convert hst <;> simp [f, comp_def]\n  show s = t\n  apply Subset.antisymm _ h\n  intro x hx\n  rcases h_surj \u27e8x, hx\u27e9 with \u27e8y, hy\u27e9\n  convert y.mem\n  rw [\u2190 Subtype.mk.inj hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Basic.lean", "context": {"open": ["Function Set Submodule", "LinearMap Finsupp"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nM : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\ns t : Set M\nhs : LinearIndepOn R _root_.id s\nh : t \u2286 s\nhst : s \u2286 \u2191(span R t)\n\u22a2 s = t"}, {"line": "let f : t \u21aa s :=\n    \u27e8fun x => \u27e8x.1, h x.2\u27e9, fun a b hab => Subtype.coe_injective (Subtype.mk.inj hab)\u27e9", "tactic_state": "R : Type u_2\nM : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\ns t : Set M\nhs : LinearIndepOn R _root_.id s\nh : t \u2286 s\nhst : s \u2286 \u2191(span R t)\nf : \u2191t \u21aa \u2191s := { toFun := fun x => \u27e8\u2191x, \u22ef\u27e9, inj' := \u22ef }\n\u22a2 s = t"}, {"line": "have h_surj : Surjective f := sorry", "tactic_state": "R : Type u_2\nM : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\ns t : Set M\nhs : LinearIndepOn R _root_.id s\nh : t \u2286 s\nhst : s \u2286 \u2191(span R t)\nf : \u2191t \u21aa \u2191s := { toFun := fun x => \u27e8\u2191x, \u22ef\u27e9, inj' := \u22ef }\nh_surj : Surjective \u21d1f\n\u22a2 s = t"}, {"line": "show s = t", "tactic_state": "R : Type u_2\nM : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\ns t : Set M\nhs : LinearIndepOn R _root_.id s\nh : t \u2286 s\nhst : s \u2286 \u2191(span R t)\nf : \u2191t \u21aa \u2191s := { toFun := fun x => \u27e8\u2191x, \u22ef\u27e9, inj' := \u22ef }\nh_surj : Surjective \u21d1f\n\u22a2 s = t"}, {"line": "apply Subset.antisymm _ h", "tactic_state": "R : Type u_2\nM : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\ns t : Set M\nhs : LinearIndepOn R _root_.id s\nh : t \u2286 s\nhst : s \u2286 \u2191(span R t)\nf : \u2191t \u21aa \u2191s := { toFun := fun x => \u27e8\u2191x, \u22ef\u27e9, inj' := \u22ef }\nh_surj : Surjective \u21d1f\n\u22a2 s \u2286 t"}, {"line": "intro x hx", "tactic_state": "R : Type u_2\nM : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\ns t : Set M\nhs : LinearIndepOn R _root_.id s\nh : t \u2286 s\nhst : s \u2286 \u2191(span R t)\nf : \u2191t \u21aa \u2191s := { toFun := fun x => \u27e8\u2191x, \u22ef\u27e9, inj' := \u22ef }\nh_surj : Surjective \u21d1f\nx : M\nhx : x \u2208 s\n\u22a2 x \u2208 t"}, {"line": "rcases h_surj \u27e8x, hx\u27e9 with \u27e8y, hy\u27e9", "tactic_state": "case intro\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\ns t : Set M\nhs : LinearIndepOn R _root_.id s\nh : t \u2286 s\nhst : s \u2286 \u2191(span R t)\nf : \u2191t \u21aa \u2191s := { toFun := fun x => \u27e8\u2191x, \u22ef\u27e9, inj' := \u22ef }\nh_surj : Surjective \u21d1f\nx : M\nhx : x \u2208 s\ny : \u2191t\nhy : f y = \u27e8x, hx\u27e9\n\u22a2 x \u2208 t"}, {"line": "convert y.mem", "tactic_state": "case h.e'_5\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Nontrivial R\ns t : Set M\nhs : LinearIndepOn R _root_.id s\nh : t \u2286 s\nhst : s \u2286 \u2191(span R t)\nf : \u2191t \u21aa \u2191s := { toFun := fun x => \u27e8\u2191x, \u22ef\u27e9, inj' := \u22ef }\nh_surj : Surjective \u21d1f\nx : M\nhx : x \u2208 s\ny : \u2191t\nhy : f y = \u27e8x, hx\u27e9\n\u22a2 x = \u2191y"}, {"line": "rw [\u2190 Subtype.mk.inj hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearIndependent_subsingleton_iff [Subsingleton M] (f : \u03b9 \u2192 M) :\n    LinearIndependent R f \u2194 IsEmpty \u03b9 := by\n  obtain h | i := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa\n  exact iff_of_false (fun hli \u21a6 hli.ne_zero i.some (Subsingleton.eq_zero (f i.some))) (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Basic.lean", "context": {"open": ["Function Set Submodule", "LinearMap Finsupp", "Finset in", "LinearMap"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']", "[Ring R] [Nontrivial R] [AddCommGroup M]", "[Module R M] [NoZeroSMulDivisors R M]", "{s t : Set M}", "(R) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b9\u2074 : Semiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : Subsingleton M\nf : \u03b9 \u2192 M\n\u22a2 LinearIndependent R f \u2194 IsEmpty \u03b9"}, {"line": "obtain h | i := isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b9\u2074 : Semiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : Subsingleton M\nf : \u03b9 \u2192 M\nh : IsEmpty \u03b9\n\u22a2 LinearIndependent R f \u2194 IsEmpty \u03b9\n---\ncase inr\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b9\u2074 : Semiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : Subsingleton M\nf : \u03b9 \u2192 M\ni : Nonempty \u03b9\n\u22a2 LinearIndependent R f \u2194 IsEmpty \u03b9"}, {"line": "\u00b7 simpa", "tactic_state": "case inr\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b9\u2074 : Semiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : Subsingleton M\nf : \u03b9 \u2192 M\ni : Nonempty \u03b9\n\u22a2 LinearIndependent R f \u2194 IsEmpty \u03b9"}, {"line": "exact iff_of_false (fun hli \u21a6 hli.ne_zero i.some (Subsingleton.eq_zero (f i.some))) (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIndependent.linearIndepOn_id (i : LinearIndependent R v) :\n    LinearIndepOn R id (range v) := by\n  simpa using i.comp _ (rangeSplitting_injective v)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Defs.lean", "context": {"open": ["Function Set Submodule", "Lean PrettyPrinter.Delaborator SubExpr in", "Finset in"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}", "(R M) in", "(R v) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "i : sorry\n\u22a2 sorry"}, {"line": "simpa using i.comp _ (rangeSplitting_injective v)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearIndependent_add_smul_iff {c : \u03b9 \u2192 R} {i : \u03b9} (h\u2080 : c i = 0) :\n    LinearIndependent R (v + (c \u00b7 \u2022 v i)) \u2194 LinearIndependent R v := by\n  simp [linearIndependent_iff_injective_finsuppLinearCombination,\n    \u2190 Finsupp.linearCombination_comp_addSingleEquiv i c h\u2080]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Defs.lean", "context": {"open": ["Function Set Submodule", "Lean PrettyPrinter.Delaborator SubExpr in", "Finset in"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}", "(R M) in", "(R v) in", "(hv : LinearIndependent R v)", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nM : Type u_1\ninst\u271d\u00b3 : AddCommMonoid M\nR : Type u_3\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nc : \u03b9 \u2192 R\ni : \u03b9\nh\u2080 : c i = 0\n\u22a2 LinearIndependent R (v + fun x => c x \u2022 v i) \u2194 LinearIndependent R v"}, {"line": "simp [linearIndependent_iff_injective_finsuppLinearCombination,\n    \u2190 Finsupp.linearCombination_comp_addSingleEquiv i c h\u2080]", "tactic_state": "\u03b9 : Type u_4\nM : Type u_1\ninst\u271d\u00b3 : AddCommMonoid M\nR : Type u_3\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nc : \u03b9 \u2192 R\ni : \u03b9\nh\u2080 : c i = 0\n\u22a2 Injective \u21d1(Finsupp.linearCombination R (v + fun x => c x \u2022 v i)) \u2194 Injective \u21d1(Finsupp.linearCombination R v)"}]}
{"declaration": "theorem linearDepOn_iff' : \u00acLinearIndepOn R v s \u2194\n      \u2203 f : \u03b9 \u2192\u2080 R, f \u2208 Finsupp.supported R R s \u2227 Finsupp.linearCombination R v f = 0 \u2227 f \u2260 0 := by\n  simp [linearIndepOn_iff, and_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Defs.lean", "context": {"open": ["Function Set Submodule", "Lean PrettyPrinter.Delaborator SubExpr in", "Finset in"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}", "(R M) in", "(R v) in", "(hv : LinearIndependent R v)", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\nM : Type u_1\ninst\u271d\u00b3 : AddCommMonoid M\nR : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\ns : Set \u03b9\n\u22a2 \u00acLinearIndepOn R v s \u2194 \u2203 f \u2208 Finsupp.supported R R s, (Finsupp.linearCombination R v) f = 0 \u2227 f \u2260 0"}, {"line": "simp [linearIndepOn_iff, and_left_comm]", "tactic_state": "\u03b9 : Type u_3\nM : Type u_1\ninst\u271d\u00b3 : AddCommMonoid M\nR : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\ns : Set \u03b9\n\u22a2 \u00acLinearIndepOn R v s \u2194 \u2203 f \u2208 Finsupp.supported R R s, (Finsupp.linearCombination R v) f = 0 \u2227 \u00acf = 0"}]}
{"declaration": "theorem linearIndependent_iff_not_mem_span :\n    LinearIndependent K v \u2194 \u2200 i, v i \u2209 span K (v '' (univ \\ {i})) := by\n  apply linearIndependent_iff_not_smul_mem_span.trans\n  constructor\n  \u00b7 intro h i h_in_span\n    apply one_ne_zero (h i 1 (by simp [h_in_span]))\n  \u00b7 intro h i a ha\n    by_contra ha'\n    exact False.elim (h _ ((smul_mem_iff _ ha').1 ha))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Defs.lean", "context": {"open": ["Function Set Submodule", "Lean PrettyPrinter.Delaborator SubExpr in", "Finset in", "LinearMap", "Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}", "(R M) in", "(R v) in", "(hv : LinearIndependent R v)", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']", "[DivisionRing K] [AddCommGroup V] [Module K V]", "{v : \u03b9 \u2192 V} {s t : Set \u03b9} {x y : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\n\u22a2 LinearIndependent K v \u2194 \u2200 (i : \u03b9), v i \u2209 span K (v '' (univ \\ {i}))"}, {"line": "apply linearIndependent_iff_not_smul_mem_span.trans", "tactic_state": "\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\n\u22a2 (\u2200 (i : \u03b9) (a : K), a \u2022 v i \u2208 span K (v '' (univ \\ {i})) \u2192 a = 0) \u2194 \u2200 (i : \u03b9), v i \u2209 span K (v '' (univ \\ {i}))"}, {"line": "constructor", "tactic_state": "case mp\n\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\n\u22a2 (\u2200 (i : \u03b9) (a : K), a \u2022 v i \u2208 span K (v '' (univ \\ {i})) \u2192 a = 0) \u2192 \u2200 (i : \u03b9), v i \u2209 span K (v '' (univ \\ {i}))\n---\ncase mpr\n\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\n\u22a2 (\u2200 (i : \u03b9), v i \u2209 span K (v '' (univ \\ {i}))) \u2192 \u2200 (i : \u03b9) (a : K), a \u2022 v i \u2208 span K (v '' (univ \\ {i})) \u2192 a = 0"}, {"line": "\u00b7 intro h i h_in_span\n    apply one_ne_zero (h i 1 (by simp [h_in_span]))", "tactic_state": "case mpr\n\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\n\u22a2 (\u2200 (i : \u03b9), v i \u2209 span K (v '' (univ \\ {i}))) \u2192 \u2200 (i : \u03b9) (a : K), a \u2022 v i \u2208 span K (v '' (univ \\ {i})) \u2192 a = 0"}, {"line": "\u00b7 intro h i a ha\n    by_contra ha'\n    exact False.elim (h _ ((smul_mem_iff _ ha').1 ha))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma linearIndepOn_iff_not_mem_span :\n    LinearIndepOn K v s \u2194 \u2200 i \u2208 s, v i \u2209 span K (v '' (s \\ {i})) := by\n  rw [LinearIndepOn]\n  rw [linearIndependent_iff_not_mem_span]\n  rw [\u2190 Function.comp_def]\n  simp_rw [Set.image_comp]\n  simp [Set.image_diff Subtype.val_injective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Defs.lean", "context": {"open": ["Function Set Submodule", "Lean PrettyPrinter.Delaborator SubExpr in", "Finset in", "LinearMap", "Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}", "(R M) in", "(R v) in", "(hv : LinearIndependent R v)", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']", "[DivisionRing K] [AddCommGroup V] [Module K V]", "{v : \u03b9 \u2192 V} {s t : Set \u03b9} {x y : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\ns : Set \u03b9\n\u22a2 LinearIndepOn K v s \u2194 \u2200 i \u2208 s, v i \u2209 span K (v '' (s \\ {i}))"}, {"line": "rw [LinearIndepOn]", "tactic_state": "\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\ns : Set \u03b9\n\u22a2 (LinearIndependent K fun (x : \u2191s) => v \u2191x) \u2194 \u2200 i \u2208 s, v i \u2209 span K (v '' (s \\ {i}))"}, {"line": "rw [linearIndependent_iff_not_mem_span]", "tactic_state": "\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\ns : Set \u03b9\n\u22a2 (\u2200 (i : \u2191s), v \u2191i \u2209 span K ((fun x => v \u2191x) '' (univ \\ {i}))) \u2194 \u2200 i \u2208 s, v i \u2209 span K (v '' (s \\ {i}))"}, {"line": "rw [\u2190 Function.comp_def]", "tactic_state": "\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\ns : Set \u03b9\n\u22a2 (\u2200 (i : \u2191s), v \u2191i \u2209 span K (v \u2218 Subtype.val '' (univ \\ {i}))) \u2194 \u2200 i \u2208 s, v i \u2209 span K (v '' (s \\ {i}))"}, {"line": "simp_rw [Set.image_comp]", "tactic_state": "\u03b9 : Type u'\nK : Type u_3\nV : Type u\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nv : \u03b9 \u2192 V\ns : Set \u03b9\n\u22a2 (\u2200 (i : \u2191s), v \u2191i \u2209 span K (v '' (Subtype.val '' (univ \\ {i})))) \u2194 \u2200 i \u2208 s, v i \u2209 span K (v '' (s \\ {i}))"}, {"line": "simp [Set.image_diff Subtype.val_injective]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fintype.linearIndependent_iff'\u209b [Fintype \u03b9] [DecidableEq \u03b9] :\n    LinearIndependent R v \u2194\n      Injective (LinearMap.lsum R (fun _ \u21a6 R) \u2115 fun i \u21a6 LinearMap.id.smulRight (v i)) := by\n  simp [Fintype.linearIndependent_iff\u209b, Injective, funext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\n\u22a2 LinearIndependent R v \u2194 Injective \u21d1((LinearMap.lsum R (fun x => R) \u2115) fun i => LinearMap.id.smulRight (v i))"}, {"line": "simp [Fintype.linearIndependent_iff\u209b, Injective, funext_iff]", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\n\u22a2 LinearIndependent R v \u2194 \u2200 \u2983a\u2081 a\u2082 : \u03b9 \u2192 R\u2984, \u2211 x, a\u2081 x \u2022 v x = \u2211 x, a\u2082 x \u2022 v x \u2192 \u2200 (x : \u03b9), a\u2081 x = a\u2082 x"}]}
{"declaration": "lemma LinearIndependent.eq_zero_of_pair' {x y : M} (h : LinearIndependent R ![x, y])\n    {s t : R} (h' : s \u2022 x = t \u2022 y) : s = 0 \u2227 t = 0 := by\n  suffices H : s = 0 \u2227 0 = t from \u27e8H.1, H.2.symm\u27e9\n  exact h.eq_of_pair (by simpa using h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx y : M\nh : LinearIndependent R ![x, y]\ns t : R\nh' : s \u2022 x = t \u2022 y\n\u22a2 s = 0 \u2227 t = 0"}, {"line": "suffices H : s = 0 \u2227 0 = t from \u27e8H.1, H.2.symm\u27e9", "tactic_state": "R : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx y : M\nh : LinearIndependent R ![x, y]\ns t : R\nh' : s \u2022 x = t \u2022 y\n\u22a2 s = 0 \u2227 0 = t"}, {"line": "exact h.eq_of_pair (by simpa using h')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearIndepOn_sUnion_of_directed {s : Set (Set \u03b9)} (hs : DirectedOn (\u00b7 \u2286 \u00b7) s)\n    (h : \u2200 a \u2208 s, LinearIndepOn R v a) : LinearIndepOn R v (\u22c3\u2080 s) := by\n  rw [sUnion_eq_iUnion]\n  exact linearIndepOn_iUnion_of_directed hs.directed_val (by simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set (Set \u03b9)\nhs : DirectedOn (fun x1 x2 => x1 \u2286 x2) s\nh : \u2200 a \u2208 s, LinearIndepOn R v a\n\u22a2 LinearIndepOn R v (\u22c3\u2080 s)"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set (Set \u03b9)\nhs : DirectedOn (fun x1 x2 => x1 \u2286 x2) s\nh : \u2200 a \u2208 s, LinearIndepOn R v a\n\u22a2 LinearIndepOn R v (\u22c3 i, \u2191i)"}, {"line": "exact linearIndepOn_iUnion_of_directed hs.directed_val (by simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearIndepOn_biUnion_of_directed {\u03b7} {s : Set \u03b7} {t : \u03b7 \u2192 Set \u03b9}\n    (hs : DirectedOn (t \u207b\u00b9'o (\u00b7 \u2286 \u00b7)) s) (h : \u2200 a \u2208 s, LinearIndepOn R v (t a)) :\n    LinearIndepOn R v (\u22c3 a \u2208 s, t a) := by\n  rw [biUnion_eq_iUnion]\n  exact linearIndepOn_iUnion_of_directed (directed_comp.2 <| hs.directed_val) (by simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b7 : Type u_6\ns : Set \u03b7\nt : \u03b7 \u2192 Set \u03b9\nhs : DirectedOn (t \u207b\u00b9'o fun x1 x2 => x1 \u2286 x2) s\nh : \u2200 a \u2208 s, LinearIndepOn R v (t a)\n\u22a2 LinearIndepOn R v (\u22c3 a \u2208 s, t a)"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\nv : \u03b9 \u2192 M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b7 : Type u_6\ns : Set \u03b7\nt : \u03b7 \u2192 Set \u03b9\nhs : DirectedOn (t \u207b\u00b9'o fun x1 x2 => x1 \u2286 x2) s\nh : \u2200 a \u2208 s, LinearIndepOn R v (t a)\n\u22a2 LinearIndepOn R v (\u22c3 x, t \u2191x)"}, {"line": "exact linearIndepOn_iUnion_of_directed (directed_comp.2 <| hs.directed_val) (by simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_maximal_linearIndepOn' (v : \u03b9 \u2192 M) :\n    \u2203 s : Set \u03b9, (LinearIndepOn R v s) \u2227 \u2200 t : Set \u03b9, s \u2286 t \u2192 (LinearIndepOn R v t) \u2192 s = t := by\n  let indep : Set \u03b9 \u2192 Prop := fun s => LinearIndepOn R v s\n  let X := { I : Set \u03b9 // indep I }\n  let r : X \u2192 X \u2192 Prop := fun I J => I.1 \u2286 J.1\n  have key : \u2200 c : Set X, IsChain r c \u2192 indep (\u22c3 (I : X) (_ : I \u2208 c), I) := by\n    intro c hc\n    dsimp [indep]\n    rw [linearIndepOn_iff\u209b]\n    intro f hfsupp g hgsupp hsum\n    rcases eq_empty_or_nonempty c with (rfl | hn)\n    \u00b7 rw [show f = 0 by simpa using hfsupp, show g = 0 by simpa using hgsupp]\n    haveI : IsRefl X r := \u27e8fun _ => Set.Subset.refl _\u27e9\n    classical\n    obtain \u27e8I, _I_mem, hI\u27e9 : \u2203 I \u2208 c, (f.support \u222a g.support : Set \u03b9) \u2286 I :=\n      f.support.coe_union _ \u25b8 hc.directedOn.exists_mem_subset_of_finset_subset_biUnion hn <| by\n        simpa using And.intro hfsupp hgsupp\n    exact linearIndepOn_iff\u209b.mp I.2 f (subset_union_left.trans hI)\n      g (subset_union_right.trans hI) hsum\n  have trans : Transitive r := fun I J K => Set.Subset.trans\n  obtain \u27e8\u27e8I, hli : indep I\u27e9, hmax : \u2200 a, r \u27e8I, hli\u27e9 a \u2192 r a \u27e8I, hli\u27e9\u27e9 :=\n    exists_maximal_of_chains_bounded\n      (fun c hc => \u27e8\u27e8\u22c3 I \u2208 c, (I : Set \u03b9), key c hc\u27e9, fun I => Set.subset_biUnion_of_mem\u27e9) @trans\n  exact \u27e8I, hli, fun J hsub hli => Set.Subset.antisymm hsub (hmax \u27e8J, hli\u27e9 hsub)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean", "context": {"open": ["Function Set Submodule", "LinearMap Finsupp"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}", "(hv : LinearIndependent R v)", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\n\u22a2 \u2203 s, LinearIndepOn R v s \u2227 \u2200 (t : Set \u03b9), s \u2286 t \u2192 LinearIndepOn R v t \u2192 s = t"}, {"line": "let indep : Set \u03b9 \u2192 Prop := fun s => LinearIndepOn R v s", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nindep : Set \u03b9 \u2192 Prop := fun s => sorry\n\u22a2 \u2203 s, LinearIndepOn R v s \u2227 \u2200 (t : Set \u03b9), s \u2286 t \u2192 LinearIndepOn R v t \u2192 s = t"}, {"line": "let X := { I : Set \u03b9 // indep I }", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nindep : Set \u03b9 \u2192 Prop := fun s => sorry\nX : Type (max 0 u') := { I // indep I }\n\u22a2 \u2203 s, LinearIndepOn R v s \u2227 \u2200 (t : Set \u03b9), s \u2286 t \u2192 LinearIndepOn R v t \u2192 s = t"}, {"line": "let r : X \u2192 X \u2192 Prop := fun I J => I.1 \u2286 J.1", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nindep : Set \u03b9 \u2192 Prop := fun s => sorry\nX : Type (max 0 u') := { I // indep I }\nr : X \u2192 X \u2192 Prop := fun I J => \u2191I \u2286 \u2191J\n\u22a2 \u2203 s, LinearIndepOn R v s \u2227 \u2200 (t : Set \u03b9), s \u2286 t \u2192 LinearIndepOn R v t \u2192 s = t"}, {"line": "have key : \u2200 c : Set X, IsChain r c \u2192 indep (\u22c3 (I : X) (_ : I \u2208 c), I) := sorry", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nindep : Set \u03b9 \u2192 Prop := fun s => sorry\nX : Type (max 0 u') := { I // indep I }\nr : X \u2192 X \u2192 Prop := fun I J => \u2191I \u2286 \u2191J\nkey : \u2200 (c : Set X), IsChain r c \u2192 indep (\u22c3 I \u2208 c, \u2191I)\n\u22a2 \u2203 s, LinearIndepOn R v s \u2227 \u2200 (t : Set \u03b9), s \u2286 t \u2192 LinearIndepOn R v t \u2192 s = t"}, {"line": "have trans : Transitive r := fun I J K => Set.Subset.trans", "tactic_state": "\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nindep : Set \u03b9 \u2192 Prop := fun s => sorry\nX : Type (max 0 u') := { I // indep I }\nr : X \u2192 X \u2192 Prop := fun I J => \u2191I \u2286 \u2191J\nkey : \u2200 (c : Set X), IsChain r c \u2192 indep (\u22c3 I \u2208 c, \u2191I)\ntrans : Transitive r\n\u22a2 \u2203 s, LinearIndepOn R v s \u2227 \u2200 (t : Set \u03b9), s \u2286 t \u2192 LinearIndepOn R v t \u2192 s = t"}, {"line": "obtain \u27e8\u27e8I, hli : indep I\u27e9, hmax : \u2200 a, r \u27e8I, hli\u27e9 a \u2192 r a \u27e8I, hli\u27e9\u27e9 :=\n    exists_maximal_of_chains_bounded\n      (fun c hc => \u27e8\u27e8\u22c3 I \u2208 c, (I : Set \u03b9), key c hc\u27e9, fun I => Set.subset_biUnion_of_mem\u27e9) @trans", "tactic_state": "case intro.mk\n\u03b9 : Type u'\nR : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nindep : Set \u03b9 \u2192 Prop := fun s => sorry\nX : Type (max 0 u') := { I // indep I }\nr : X \u2192 X \u2192 Prop := fun I J => \u2191I \u2286 \u2191J\nkey : \u2200 (c : Set X), IsChain r c \u2192 indep (\u22c3 I \u2208 c, \u2191I)\ntrans : Transitive r\nI : Set \u03b9\nhli : indep I\nhmax : \u2200 (a : X), r \u27e8I, hli\u27e9 a \u2192 r a \u27e8I, hli\u27e9\n\u22a2 \u2203 s, LinearIndepOn R v s \u2227 \u2200 (t : Set \u03b9), s \u2286 t \u2192 LinearIndepOn R v t \u2192 s = t"}, {"line": "exact \u27e8I, hli, fun J hsub hli => Set.Subset.antisymm hsub (hmax \u27e8J, hli\u27e9 hsub)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_linearIndepOn_id_extension (hs : LinearIndepOn K id s) (hst : s \u2286 t) :\n    \u2203 b \u2286 t, s \u2286 b \u2227 t \u2286 span K b \u2227 LinearIndepOn K id b := by\n  obtain \u27e8b, sb, h\u27e9 := by\n    refine zorn_subset_nonempty { b | b \u2286 t \u2227 LinearIndepOn K id b} ?_ _ \u27e8hst, hs\u27e9\n    \u00b7 refine fun c hc cc _c0 => \u27e8\u22c3\u2080 c, \u27e8?_, ?_\u27e9, fun x => ?_\u27e9\n      \u00b7 exact sUnion_subset fun x xc => (hc xc).1\n      \u00b7 exact linearIndepOn_sUnion_of_directed cc.directedOn fun x xc => (hc xc).2\n      \u00b7 exact subset_sUnion_of_mem\n  refine \u27e8b, h.prop.1, sb, fun x xt => by_contra fun hn \u21a6 hn ?_, h.prop.2\u27e9\n  exact subset_span <| h.mem_of_prop_insert \u27e8insert_subset xt h.prop.1, h.prop.2.insert hn\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean", "context": {"open": ["Function Set Submodule", "LinearMap Finsupp", "LinearMap", "Submodule"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}", "(hv : LinearIndependent R v)", "(R)", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']", "{x y : M}", "{S : Type*} [CommRing S] [Module S R] [Module S M]", "{v : \u03b9 \u2192 M}", "[Ring R] [AddCommGroup M] [AddCommGroup M']", "[Module R M] [Module R M']", "(R) in", "[DivisionRing K] [AddCommGroup V] [Module K V]", "{v : \u03b9 \u2192 V} {s t : Set V} {x y : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ns t : Set V\nhs : sorry\nhst : s \u2286 t\n\u22a2 \u2203 b \u2286 t, s \u2286 b \u2227 t \u2286 sorry \u2227 sorry"}, {"line": "obtain \u27e8b, sb, h\u27e9 := by\n    refine zorn_subset_nonempty { b | b \u2286 t \u2227 LinearIndepOn K id b} ?_ _ \u27e8hst, hs\u27e9\n    \u00b7 refine fun c hc cc _c0 => \u27e8\u22c3\u2080 c, \u27e8?_, ?_\u27e9, fun x => ?_\u27e9\n      \u00b7 exact sUnion_subset fun x xc => (hc xc).1\n      \u00b7 exact linearIndepOn_sUnion_of_directed cc.directedOn fun x xc => (hc xc).2\n      \u00b7 exact subset_sUnion_of_mem", "tactic_state": "case intro.intro\nV : Type u\ns t : Set V\nhs : sorry\nhst : s \u2286 t\nb : Set V\nsb : s \u2286 b\nh : Maximal (fun x => x \u2208 {b | b \u2286 t \u2227 sorry}) b\n\u22a2 \u2203 b \u2286 t, s \u2286 b \u2227 t \u2286 sorry \u2227 sorry"}, {"line": "refine \u27e8b, h.prop.1, sb, fun x xt => by_contra fun hn \u21a6 hn ?_, h.prop.2\u27e9", "tactic_state": "case intro.intro\nV : Type u\ns t : Set V\nhs : sorry\nhst : s \u2286 t\nb : Set V\nsb : s \u2286 b\nh : Maximal (fun x => x \u2208 {b | b \u2286 t \u2227 sorry}) b\nx : V\nxt : x \u2208 t\nhn : x \u2209 sorry\n\u22a2 x \u2208 sorry"}, {"line": "exact subset_span <| h.mem_of_prop_insert \u27e8insert_subset xt h.prop.1, h.prop.2.insert hn\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem circulant_single_one (\u03b1 n) [Zero \u03b1] [One \u03b1] [DecidableEq n] [AddGroup n] :\n    circulant (Pi.single 0 1 : n \u2192 \u03b1) = (1 : Matrix n n \u03b1) := by\n  ext i j\n  simp [one_apply, Pi.single_apply, sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Circulant.lean", "context": {"open": ["Function", "Matrix"], "variables": ["{\u03b1 \u03b2 n R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nn : Type u_6\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : AddGroup n\n\u22a2 circulant (Pi.single 0 1) = 1"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u_5\nn : Type u_6\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : AddGroup n\ni j : n\n\u22a2 circulant (Pi.single 0 1) i j = 1 i j"}, {"line": "simp [one_apply, Pi.single_apply, sub_eq_zero]", "tactic_state": "case a\n\u03b1 : Type u_5\nn : Type u_6\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : AddGroup n\ni j : n\n\u22a2 (if i - j = 0 then 1 else 0) = if i = j then 1 else 0"}]}
{"declaration": "theorem circulant_single (n) [Semiring \u03b1] [DecidableEq n] [AddGroup n] [Fintype n] (a : \u03b1) :\n    circulant (Pi.single 0 a : n \u2192 \u03b1) = scalar n a := by\n  ext i j\n  simp [Pi.single_apply, diagonal_apply, sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Circulant.lean", "context": {"open": ["Function", "Matrix"], "variables": ["{\u03b1 \u03b2 n R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : Type u_5\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : AddGroup n\ninst\u271d : Fintype n\na : \u03b1\n\u22a2 circulant (Pi.single 0 a) = (scalar n) a"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u_1\nn : Type u_5\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : AddGroup n\ninst\u271d : Fintype n\na : \u03b1\ni j : n\n\u22a2 circulant (Pi.single 0 a) i j = (scalar n) a i j"}, {"line": "simp [Pi.single_apply, diagonal_apply, sub_eq_zero]", "tactic_state": "case a\n\u03b1 : Type u_1\nn : Type u_5\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : AddGroup n\ninst\u271d : Fintype n\na : \u03b1\ni j : n\n\u22a2 (if i - j = 0 then a else 0) = if i = j then a else 0"}]}
{"declaration": "theorem det_ne_zero_of_sum_col_lt_diag (h : \u2200 k, \u2211 i \u2208 Finset.univ.erase k, \u2016A i k\u2016 < \u2016A k k\u2016) :\n    A.det \u2260 0 := by\n  rw [\u2190 Matrix.det_transpose]\n  exact det_ne_zero_of_sum_row_lt_diag (by simp_rw [Matrix.transpose_apply]; exact h)", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Gershgorin.lean", "context": {"open": [], "variables": ["{K n : Type*} [NormedField K] [Fintype n] [DecidableEq n] {A : Matrix n n K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nn : Type u_2\ninst\u271d\u00b2 : NormedField K\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nA : Matrix n n K\nh : \u2200 (k : n), \u2211 i \u2208 Finset.univ.erase k, \u2016A i k\u2016 < \u2016A k k\u2016\n\u22a2 A.det \u2260 0"}, {"line": "rw [\u2190 Matrix.det_transpose]", "tactic_state": "K : Type u_1\nn : Type u_2\ninst\u271d\u00b2 : NormedField K\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nA : Matrix n n K\nh : \u2200 (k : n), \u2211 i \u2208 Finset.univ.erase k, \u2016A i k\u2016 < \u2016A k k\u2016\n\u22a2 A.transpose.det \u2260 0"}, {"line": "exact det_ne_zero_of_sum_row_lt_diag (by simp_rw [Matrix.transpose_apply]; exact h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsDiag.map [Zero \u03b1] [Zero \u03b2] {A : Matrix n n \u03b1} (ha : A.IsDiag) {f : \u03b1 \u2192 \u03b2} (hf : f 0 = 0) :\n    (A.map f).IsDiag := by\n  intro i j h\n  simp [ha h, hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "context": {"open": ["Function", "Matrix Kronecker"], "variables": ["{\u03b1 \u03b2 R n m : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Type u_4\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : Zero \u03b2\nA : Matrix n n \u03b1\nha : A.IsDiag\nf : \u03b1 \u2192 \u03b2\nhf : f 0 = 0\n\u22a2 (A.map f).IsDiag"}, {"line": "intro i j h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Type u_4\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : Zero \u03b2\nA : Matrix n n \u03b1\nha : A.IsDiag\nf : \u03b1 \u2192 \u03b2\nhf : f 0 = 0\ni j : n\nh : i \u2260 j\n\u22a2 A.map f i j = 0"}, {"line": "simp [ha h, hf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsDiag.neg [SubtractionMonoid \u03b1] {A : Matrix n n \u03b1} (ha : A.IsDiag) : (-A).IsDiag := by\n  intro i j h\n  simp [ha h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "context": {"open": ["Function", "Matrix Kronecker"], "variables": ["{\u03b1 \u03b2 R n m : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\ninst\u271d : SubtractionMonoid \u03b1\nA : Matrix n n \u03b1\nha : A.IsDiag\n\u22a2 (-A).IsDiag"}, {"line": "intro i j h", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\ninst\u271d : SubtractionMonoid \u03b1\nA : Matrix n n \u03b1\nha : A.IsDiag\ni j : n\nh : i \u2260 j\n\u22a2 (-A) i j = 0"}, {"line": "simp [ha h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsDiag.add [AddZeroClass \u03b1] {A B : Matrix n n \u03b1} (ha : A.IsDiag) (hb : B.IsDiag) :\n    (A + B).IsDiag := by\n  intro i j h\n  simp [ha h, hb h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "context": {"open": ["Function", "Matrix Kronecker"], "variables": ["{\u03b1 \u03b2 R n m : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\ninst\u271d : AddZeroClass \u03b1\nA B : Matrix n n \u03b1\nha : A.IsDiag\nhb : B.IsDiag\n\u22a2 (A + B).IsDiag"}, {"line": "intro i j h", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\ninst\u271d : AddZeroClass \u03b1\nA B : Matrix n n \u03b1\nha : A.IsDiag\nhb : B.IsDiag\ni j : n\nh : i \u2260 j\n\u22a2 (A + B) i j = 0"}, {"line": "simp [ha h, hb h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsDiag.sub [SubtractionMonoid \u03b1] {A B : Matrix n n \u03b1} (ha : A.IsDiag) (hb : B.IsDiag) :\n    (A - B).IsDiag := by\n  intro i j h\n  simp [ha h, hb h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "context": {"open": ["Function", "Matrix Kronecker"], "variables": ["{\u03b1 \u03b2 R n m : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\ninst\u271d : SubtractionMonoid \u03b1\nA B : Matrix n n \u03b1\nha : A.IsDiag\nhb : B.IsDiag\n\u22a2 (A - B).IsDiag"}, {"line": "intro i j h", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\ninst\u271d : SubtractionMonoid \u03b1\nA B : Matrix n n \u03b1\nha : A.IsDiag\nhb : B.IsDiag\ni j : n\nh : i \u2260 j\n\u22a2 (A - B) i j = 0"}, {"line": "simp [ha h, hb h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsDiag.smul [Zero \u03b1] [SMulZeroClass R \u03b1] (k : R) {A : Matrix n n \u03b1}\n    (ha : A.IsDiag) : (k \u2022 A).IsDiag := by\n  intro i j h\n  simp [ha h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "context": {"open": ["Function", "Matrix Kronecker"], "variables": ["{\u03b1 \u03b2 R n m : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_3\nn : Type u_4\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : SMulZeroClass R \u03b1\nk : R\nA : Matrix n n \u03b1\nha : A.IsDiag\n\u22a2 (k \u2022 A).IsDiag"}, {"line": "intro i j h", "tactic_state": "\u03b1 : Type u_1\nR : Type u_3\nn : Type u_4\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : SMulZeroClass R \u03b1\nk : R\nA : Matrix n n \u03b1\nha : A.IsDiag\ni j : n\nh : i \u2260 j\n\u22a2 (k \u2022 A) i j = 0"}, {"line": "simp [ha h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsDiag.fromBlocks [Zero \u03b1] {A : Matrix m m \u03b1} {D : Matrix n n \u03b1} (ha : A.IsDiag)\n    (hd : D.IsDiag) : (A.fromBlocks 0 0 D).IsDiag := by\n  rintro (i | i) (j | j) hij\n  \u00b7 exact ha (ne_of_apply_ne _ hij)\n  \u00b7 rfl\n  \u00b7 rfl\n  \u00b7 exact hd (ne_of_apply_ne _ hij)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "context": {"open": ["Function", "Matrix Kronecker"], "variables": ["{\u03b1 \u03b2 R n m : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\n\u22a2 (Matrix.fromBlocks A 0 0 D).IsDiag"}, {"line": "rintro (i | i) (j | j) hij", "tactic_state": "case inl.inl\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni j : m\nhij : Sum.inl i \u2260 Sum.inl j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inl i) (Sum.inl j) = 0\n---\ncase inl.inr\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni : m\nj : n\nhij : Sum.inl i \u2260 Sum.inr j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inl i) (Sum.inr j) = 0\n---\ncase inr.inl\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni : n\nj : m\nhij : Sum.inr i \u2260 Sum.inl j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inr i) (Sum.inl j) = 0\n---\ncase inr.inr\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni j : n\nhij : Sum.inr i \u2260 Sum.inr j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inr i) (Sum.inr j) = 0"}, {"line": "\u00b7 exact ha (ne_of_apply_ne _ hij)", "tactic_state": "case inl.inr\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni : m\nj : n\nhij : Sum.inl i \u2260 Sum.inr j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inl i) (Sum.inr j) = 0\n---\ncase inr.inl\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni : n\nj : m\nhij : Sum.inr i \u2260 Sum.inl j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inr i) (Sum.inl j) = 0\n---\ncase inr.inr\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni j : n\nhij : Sum.inr i \u2260 Sum.inr j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inr i) (Sum.inr j) = 0"}, {"line": "\u00b7 rfl", "tactic_state": "case inr.inl\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni : n\nj : m\nhij : Sum.inr i \u2260 Sum.inl j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inr i) (Sum.inl j) = 0\n---\ncase inr.inr\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni j : n\nhij : Sum.inr i \u2260 Sum.inr j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inr i) (Sum.inr j) = 0"}, {"line": "\u00b7 rfl", "tactic_state": "case inr.inr\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nD : Matrix n n \u03b1\nha : A.IsDiag\nhd : D.IsDiag\ni j : n\nhij : Sum.inr i \u2260 Sum.inr j\n\u22a2 Matrix.fromBlocks A 0 0 D (Sum.inr i) (Sum.inr j) = 0"}, {"line": "\u00b7 exact hd (ne_of_apply_ne _ hij)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isDiag_fromBlocks_iff [Zero \u03b1] {A : Matrix m m \u03b1} {B : Matrix m n \u03b1} {C : Matrix n m \u03b1}\n    {D : Matrix n n \u03b1} : (A.fromBlocks B C D).IsDiag \u2194 A.IsDiag \u2227 B = 0 \u2227 C = 0 \u2227 D.IsDiag := by\n  constructor\n  \u00b7 intro h\n    refine \u27e8fun i j hij => ?_, ext fun i j => ?_, ext fun i j => ?_, fun i j hij => ?_\u27e9\n    \u00b7 exact h (Sum.inl_injective.ne hij)\n    \u00b7 exact h Sum.inl_ne_inr\n    \u00b7 exact h Sum.inr_ne_inl\n    \u00b7 exact h (Sum.inr_injective.ne hij)\n  \u00b7 rintro \u27e8ha, hb, hc, hd\u27e9\n    convert IsDiag.fromBlocks ha hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "context": {"open": ["Function", "Matrix Kronecker"], "variables": ["{\u03b1 \u03b2 R n m : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nB : Matrix m n \u03b1\nC : Matrix n m \u03b1\nD : Matrix n n \u03b1\n\u22a2 (fromBlocks A B C D).IsDiag \u2194 A.IsDiag \u2227 B = 0 \u2227 C = 0 \u2227 D.IsDiag"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nB : Matrix m n \u03b1\nC : Matrix n m \u03b1\nD : Matrix n n \u03b1\n\u22a2 (fromBlocks A B C D).IsDiag \u2192 A.IsDiag \u2227 B = 0 \u2227 C = 0 \u2227 D.IsDiag\n---\ncase mpr\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nB : Matrix m n \u03b1\nC : Matrix n m \u03b1\nD : Matrix n n \u03b1\n\u22a2 A.IsDiag \u2227 B = 0 \u2227 C = 0 \u2227 D.IsDiag \u2192 (fromBlocks A B C D).IsDiag"}, {"line": "\u00b7 intro h\n    refine \u27e8fun i j hij => ?_, ext fun i j => ?_, ext fun i j => ?_, fun i j hij => ?_\u27e9\n    \u00b7 exact h (Sum.inl_injective.ne hij)\n    \u00b7 exact h Sum.inl_ne_inr\n    \u00b7 exact h Sum.inr_ne_inl\n    \u00b7 exact h (Sum.inr_injective.ne hij)", "tactic_state": "case mpr\n\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nB : Matrix m n \u03b1\nC : Matrix n m \u03b1\nD : Matrix n n \u03b1\n\u22a2 A.IsDiag \u2227 B = 0 \u2227 C = 0 \u2227 D.IsDiag \u2192 (fromBlocks A B C D).IsDiag"}, {"line": "\u00b7 rintro \u27e8ha, hb, hc, hd\u27e9\n    convert IsDiag.fromBlocks ha hd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsDiag.fromBlocks_of_isSymm [Zero \u03b1] {A : Matrix m m \u03b1} {C : Matrix n m \u03b1}\n    {D : Matrix n n \u03b1} (h : (A.fromBlocks 0 C D).IsSymm) (ha : A.IsDiag) (hd : D.IsDiag) :\n    (A.fromBlocks 0 C D).IsDiag := by\n  rw [\u2190 (isSymm_fromBlocks_iff.1 h).2.1]\n  exact ha.fromBlocks hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "context": {"open": ["Function", "Matrix Kronecker"], "variables": ["{\u03b1 \u03b2 R n m : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nC : Matrix n m \u03b1\nD : Matrix n n \u03b1\nh : (fromBlocks A 0 C D).IsSymm\nha : A.IsDiag\nhd : D.IsDiag\n\u22a2 (fromBlocks A 0 C D).IsDiag"}, {"line": "rw [\u2190 (isSymm_fromBlocks_iff.1 h).2.1]", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\nm : Type u_5\ninst\u271d : Zero \u03b1\nA : Matrix m m \u03b1\nC : Matrix n m \u03b1\nD : Matrix n n \u03b1\nh : (fromBlocks A 0 C D).IsSymm\nha : A.IsDiag\nhd : D.IsDiag\n\u22a2 (fromBlocks A 0 (transpose 0) D).IsDiag"}, {"line": "exact ha.fromBlocks hd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invOf_eq [Invertible A.det] [Invertible A] : \u215f A = \u215f A.det \u2022 A.adjugate := by\n  letI := invertibleOfDetInvertible A\n  convert (rfl : \u215f A = _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A.det\ninst\u271d : Invertible A\n\u22a2 \u215f A = \u215f A.det \u2022 A.adjugate"}, {"line": "letI := invertibleOfDetInvertible A", "tactic_state": "case refine_4\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A.det\ninst\u271d : Invertible A\nthis : Invertible A := sorry\n\u22a2 \u215f A = \u215f A.det \u2022 A.adjugate\n---\ncase refine_1\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A.det\ninst\u271d : Invertible A\n\u22a2 Fintype n\n---\ncase refine_2\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A.det\ninst\u271d : Invertible A\n\u22a2 DecidableEq n\n---\ncase refine_3\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A.det\ninst\u271d : Invertible A\n\u22a2 CommRing \u03b1"}, {"line": "convert (rfl : \u215f A = _)", "tactic_state": "case h.e'_3\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A.det\ninst\u271d : Invertible A\nthis : Invertible A := sorry\n\u22a2 \u215f A.det \u2022 A.adjugate = \u215f A\n---\ncase refine_1\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A.det\ninst\u271d : Invertible A\n\u22a2 Fintype n\n---\ncase refine_2\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A.det\ninst\u271d : Invertible A\n\u22a2 DecidableEq n\n---\ncase refine_3\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A.det\ninst\u271d : Invertible A\n\u22a2 CommRing \u03b1"}]}
{"declaration": "theorem det_invOf [Invertible A] [Invertible A.det] : (\u215f A).det = \u215f A.det := by\n  letI := detInvertibleOfInvertible A\n  convert (rfl : _ = \u215f A.det)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A\ninst\u271d : Invertible A.det\n\u22a2 (\u215f A).det = \u215f A.det"}, {"line": "letI := detInvertibleOfInvertible A", "tactic_state": "case refine_4\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A\ninst\u271d : Invertible A.det\nthis : Invertible A.det := sorry\n\u22a2 (\u215f A).det = \u215f A.det\n---\ncase refine_1\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A\ninst\u271d : Invertible A.det\n\u22a2 Fintype n\n---\ncase refine_2\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A\ninst\u271d : Invertible A.det\n\u22a2 DecidableEq n\n---\ncase refine_3\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A\ninst\u271d : Invertible A.det\n\u22a2 CommRing \u03b1"}, {"line": "convert (rfl : _ = \u215f A.det)", "tactic_state": "case h.e'_2\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A\ninst\u271d : Invertible A.det\nthis : Invertible A.det := sorry\n\u22a2 (\u215f A).det = \u215f A.det\n---\ncase refine_1\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A\ninst\u271d : Invertible A.det\n\u22a2 Fintype n\n---\ncase refine_2\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A\ninst\u271d : Invertible A.det\n\u22a2 DecidableEq n\n---\ncase refine_3\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d\u00b9 : Invertible A\ninst\u271d : Invertible A.det\n\u22a2 CommRing \u03b1"}]}
{"declaration": "theorem isUnit_det_transpose (h : IsUnit A.det) : IsUnit A\u1d40.det := by\n  rw [det_transpose]\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : IsUnit A.det\n\u22a2 IsUnit A.transpose.det"}, {"line": "rw [det_transpose]", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : IsUnit A.det\n\u22a2 IsUnit A.det"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_units_inv (A : (Matrix n n \u03b1)\u02e3) : \u2191A\u207b\u00b9 = (A\u207b\u00b9 : Matrix n n \u03b1) := by\n  letI := A.invertible\n  rw [\u2190 invOf_eq_nonsing_inv]\n  rw [invOf_units]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : (Matrix n n \u03b1)\u02e3\n\u22a2 \u2191A\u207b\u00b9 = (\u2191A)\u207b\u00b9"}, {"line": "letI := A.invertible", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : (Matrix n n \u03b1)\u02e3\nthis : Invertible \u2191A := sorry\n\u22a2 \u2191A\u207b\u00b9 = (\u2191A)\u207b\u00b9"}, {"line": "rw [\u2190 invOf_eq_nonsing_inv]", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : (Matrix n n \u03b1)\u02e3\nthis : Invertible \u2191A := sorry\n\u22a2 \u2191A\u207b\u00b9 = \u215f \u2191A"}, {"line": "rw [invOf_units]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonsing_inv_eq_ringInverse : A\u207b\u00b9 = Ring.inverse A := by\n  by_cases h_det : IsUnit A.det\n  \u00b7 cases (A.isUnit_iff_isUnit_det.mpr h_det).nonempty_invertible\n    rw [\u2190 invOf_eq_nonsing_inv]\n    rw [Ring.inverse_invertible]\n  \u00b7 have h := mt A.isUnit_iff_isUnit_det.mp h_det\n    rw [Ring.inverse_non_unit _ h]\n    rw [nonsing_inv_apply_not_isUnit A h_det]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\n\u22a2 A\u207b\u00b9 = Ring.inverse A"}, {"line": "by_cases h_det : IsUnit A.det", "tactic_state": "case pos\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh_det : sorry\n\u22a2 A\u207b\u00b9 = Ring.inverse A\n---\ncase neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh_det : \u00acsorry\n\u22a2 A\u207b\u00b9 = Ring.inverse A"}, {"line": "\u00b7 cases (A.isUnit_iff_isUnit_det.mpr h_det).nonempty_invertible\n    rw [\u2190 invOf_eq_nonsing_inv]\n    rw [Ring.inverse_invertible]", "tactic_state": "case neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh_det : \u00acsorry\n\u22a2 A\u207b\u00b9 = Ring.inverse A"}, {"line": "\u00b7 have h := mt A.isUnit_iff_isUnit_det.mp h_det\n    rw [Ring.inverse_non_unit _ h]\n    rw [nonsing_inv_apply_not_isUnit A h_det]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_nonsing_inv_cancel_right (B : Matrix m n \u03b1) (h : IsUnit A.det) : B * A * A\u207b\u00b9 = B := by\n  simp [Matrix.mul_assoc, mul_nonsing_inv A h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nB : Matrix m n \u03b1\nh : IsUnit A.det\n\u22a2 B * A * A\u207b\u00b9 = B"}, {"line": "simp [Matrix.mul_assoc, mul_nonsing_inv A h]", "tactic_state": "m : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nB : Matrix m n \u03b1\nh : IsUnit A.det\n\u22a2 B * (A * A\u207b\u00b9) = B"}]}
{"declaration": "theorem mul_nonsing_inv_cancel_left (B : Matrix n m \u03b1) (h : IsUnit A.det) : A * (A\u207b\u00b9 * B) = B := by\n  simp [\u2190 Matrix.mul_assoc, mul_nonsing_inv A h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nB : Matrix n m \u03b1\nh : IsUnit A.det\n\u22a2 A * (A\u207b\u00b9 * B) = B"}, {"line": "simp [\u2190 Matrix.mul_assoc, mul_nonsing_inv A h]", "tactic_state": "m : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nB : Matrix n m \u03b1\nh : IsUnit A.det\n\u22a2 A * A\u207b\u00b9 * B = B"}]}
{"declaration": "theorem nonsing_inv_mul_cancel_right (B : Matrix m n \u03b1) (h : IsUnit A.det) : B * A\u207b\u00b9 * A = B := by\n  simp [Matrix.mul_assoc, nonsing_inv_mul A h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nB : Matrix m n \u03b1\nh : IsUnit A.det\n\u22a2 B * A\u207b\u00b9 * A = B"}, {"line": "simp [Matrix.mul_assoc, nonsing_inv_mul A h]", "tactic_state": "m : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nB : Matrix m n \u03b1\nh : IsUnit A.det\n\u22a2 B * (A\u207b\u00b9 * A) = B"}]}
{"declaration": "theorem nonsing_inv_mul_cancel_left (B : Matrix n m \u03b1) (h : IsUnit A.det) : A\u207b\u00b9 * (A * B) = B := by\n  simp [\u2190 Matrix.mul_assoc, nonsing_inv_mul A h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nB : Matrix n m \u03b1\nh : IsUnit A.det\n\u22a2 A\u207b\u00b9 * (A * B) = B"}, {"line": "simp [\u2190 Matrix.mul_assoc, nonsing_inv_mul A h]", "tactic_state": "m : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nB : Matrix n m \u03b1\nh : IsUnit A.det\n\u22a2 A\u207b\u00b9 * A * B = B"}]}
{"declaration": "theorem linearIndependent_cols_iff_isUnit {A : Matrix m m K} :\n    LinearIndependent K A.col \u2194 IsUnit A := by\n  rw [\u2190 row_transpose]\n  rw [linearIndependent_rows_iff_isUnit]\n  rw [isUnit_transpose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "[Fintype n] [Fintype m] [DecidableEq m] [CommRing \u03b1]", "{R : Type*} [Semiring R]", "[DecidableEq m] {R K : Type*} [CommRing R] [Field K] [Fintype m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq m\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : Fintype m\nA : Matrix m m K\n\u22a2 LinearIndependent K A.col \u2194 IsUnit A"}, {"line": "rw [\u2190 row_transpose]", "tactic_state": "m : Type u\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq m\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : Fintype m\nA : Matrix m m K\n\u22a2 LinearIndependent K A.transpose.row \u2194 IsUnit A"}, {"line": "rw [linearIndependent_rows_iff_isUnit]", "tactic_state": "m : Type u\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq m\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : Fintype m\nA : Matrix m m K\n\u22a2 IsUnit A.transpose \u2194 IsUnit A\n---\nm : Type u\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq m\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : Fintype m\nA : Matrix m m K\n\u22a2 DecidableEq m\n---\nm : Type u\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq m\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : Fintype m\nA : Matrix m m K\n\u22a2 Fintype m"}, {"line": "rw [isUnit_transpose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonsing_inv_cancel_or_zero : A\u207b\u00b9 * A = 1 \u2227 A * A\u207b\u00b9 = 1 \u2228 A\u207b\u00b9 = 0 := by\n  by_cases h : IsUnit A.det\n  \u00b7 exact Or.inl \u27e8nonsing_inv_mul _ h, mul_nonsing_inv _ h\u27e9\n  \u00b7 exact Or.inr (nonsing_inv_apply_not_isUnit _ h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "[Fintype n] [Fintype m] [DecidableEq m] [CommRing \u03b1]", "{R : Type*} [Semiring R]", "[DecidableEq m] {R K : Type*} [CommRing R] [Field K] [Fintype m]", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\n\u22a2 A\u207b\u00b9 * A = 1 \u2227 A * A\u207b\u00b9 = 1 \u2228 A\u207b\u00b9 = 0"}, {"line": "by_cases h : IsUnit A.det", "tactic_state": "case pos\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : sorry\n\u22a2 A\u207b\u00b9 * A = 1 \u2227 A * A\u207b\u00b9 = 1 \u2228 A\u207b\u00b9 = 0\n---\ncase neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : \u00acsorry\n\u22a2 A\u207b\u00b9 * A = 1 \u2227 A * A\u207b\u00b9 = 1 \u2228 A\u207b\u00b9 = 0"}, {"line": "\u00b7 exact Or.inl \u27e8nonsing_inv_mul _ h, mul_nonsing_inv _ h\u27e9", "tactic_state": "case neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : \u00acsorry\n\u22a2 A\u207b\u00b9 * A = 1 \u2227 A * A\u207b\u00b9 = 1 \u2228 A\u207b\u00b9 = 0"}, {"line": "\u00b7 exact Or.inr (nonsing_inv_apply_not_isUnit _ h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_nonsing_inv : A\u207b\u00b9.det = Ring.inverse A.det := by\n  by_cases h : IsUnit A.det\n  \u00b7 cases h.nonempty_invertible\n    letI := invertibleOfDetInvertible A\n    rw [Ring.inverse_invertible]\n    rw [\u2190 invOf_eq_nonsing_inv]\n    rw [det_invOf]\n  cases isEmpty_or_nonempty n\n  \u00b7 rw [det_isEmpty, det_isEmpty, Ring.inverse_one]\n  \u00b7 rw [Ring.inverse_non_unit _ h, nonsing_inv_apply_not_isUnit _ h, det_zero \u2039_\u203a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "[Fintype n] [Fintype m] [DecidableEq m] [CommRing \u03b1]", "{R : Type*} [Semiring R]", "[DecidableEq m] {R K : Type*} [CommRing R] [Field K] [Fintype m]", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\n\u22a2 A\u207b\u00b9.det = Ring.inverse A.det"}, {"line": "by_cases h : IsUnit A.det", "tactic_state": "case pos\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : sorry\n\u22a2 A\u207b\u00b9.det = Ring.inverse A.det\n---\ncase neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : \u00acsorry\n\u22a2 A\u207b\u00b9.det = Ring.inverse A.det"}, {"line": "\u00b7 cases h.nonempty_invertible\n    letI := invertibleOfDetInvertible A\n    rw [Ring.inverse_invertible]\n    rw [\u2190 invOf_eq_nonsing_inv]\n    rw [det_invOf]", "tactic_state": "case neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : \u00acsorry\n\u22a2 A\u207b\u00b9.det = Ring.inverse A.det"}, {"line": "cases isEmpty_or_nonempty n", "tactic_state": "case neg.inl\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : \u00acsorry\nh\u271d : IsEmpty n\n\u22a2 A\u207b\u00b9.det = Ring.inverse A.det\n---\ncase neg.inr\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : \u00acsorry\nh\u271d : Nonempty n\n\u22a2 A\u207b\u00b9.det = Ring.inverse A.det"}, {"line": "\u00b7 rw [det_isEmpty, det_isEmpty, Ring.inverse_one]", "tactic_state": "case neg.inr\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : \u00acsorry\nh\u271d : Nonempty n\n\u22a2 A\u207b\u00b9.det = Ring.inverse A.det"}, {"line": "\u00b7 rw [Ring.inverse_non_unit _ h, nonsing_inv_apply_not_isUnit _ h, det_zero \u2039_\u203a]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isUnit_nonsing_inv_det_iff {A : Matrix n n \u03b1} : IsUnit A\u207b\u00b9.det \u2194 IsUnit A.det := by\n  rw [Matrix.det_nonsing_inv]\n  rw [isUnit_ringInverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "[Fintype n] [Fintype m] [DecidableEq m] [CommRing \u03b1]", "{R : Type*} [Semiring R]", "[DecidableEq m] {R K : Type*} [CommRing R] [Field K] [Fintype m]", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\n\u22a2 IsUnit A\u207b\u00b9.det \u2194 IsUnit A.det"}, {"line": "rw [Matrix.det_nonsing_inv]", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\n\u22a2 IsUnit (Ring.inverse A.det) \u2194 IsUnit A.det"}, {"line": "rw [isUnit_ringInverse]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isUnit_nonsing_inv_iff {A : Matrix n n \u03b1} : IsUnit A\u207b\u00b9 \u2194 IsUnit A := by\n  simp_rw [isUnit_iff_isUnit_det, isUnit_nonsing_inv_det_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "[Fintype n] [Fintype m] [DecidableEq m] [CommRing \u03b1]", "{R : Type*} [Semiring R]", "[DecidableEq m] {R K : Type*} [CommRing R] [Field K] [Fintype m]", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\n\u22a2 IsUnit A\u207b\u00b9 \u2194 IsUnit A"}, {"line": "simp_rw [isUnit_iff_isUnit_det, isUnit_nonsing_inv_det_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_diagonal (v : n \u2192 \u03b1) : (diagonal v)\u207b\u00b9 = diagonal (Ring.inverse v) := by\n  rw [nonsing_inv_eq_ringInverse]\n  by_cases h : IsUnit v\n  \u00b7 have := isUnit_diagonal.mpr h\n    cases this.nonempty_invertible\n    cases h.nonempty_invertible\n    rw [Ring.inverse_invertible]\n    rw [Ring.inverse_invertible]\n    rw [invOf_diagonal_eq]\n  \u00b7 have := isUnit_diagonal.not.mpr h\n    rw [Ring.inverse_non_unit _ h]\n    rw [Pi.zero_def]\n    rw [diagonal_zero]\n    rw [Ring.inverse_non_unit _ this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "[Fintype n] [Fintype m] [DecidableEq m] [CommRing \u03b1]", "{R : Type*} [Semiring R]", "[DecidableEq m] {R K : Type*} [CommRing R] [Field K] [Fintype m]", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A} {B}", "{C : Matrix n n \u03b1}", "(A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nv : n \u2192 \u03b1\n\u22a2 (diagonal v)\u207b\u00b9 = diagonal (Ring.inverse v)"}, {"line": "rw [nonsing_inv_eq_ringInverse]", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nv : n \u2192 \u03b1\n\u22a2 Ring.inverse (diagonal v) = diagonal (Ring.inverse v)"}, {"line": "by_cases h : IsUnit v", "tactic_state": "case pos\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nv : n \u2192 \u03b1\nh : sorry\n\u22a2 Ring.inverse (diagonal v) = diagonal (Ring.inverse v)\n---\ncase neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nv : n \u2192 \u03b1\nh : \u00acsorry\n\u22a2 Ring.inverse (diagonal v) = diagonal (Ring.inverse v)"}, {"line": "\u00b7 have := isUnit_diagonal.mpr h\n    cases this.nonempty_invertible\n    cases h.nonempty_invertible\n    rw [Ring.inverse_invertible]\n    rw [Ring.inverse_invertible]\n    rw [invOf_diagonal_eq]", "tactic_state": "case neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nv : n \u2192 \u03b1\nh : \u00acsorry\n\u22a2 Ring.inverse (diagonal v) = diagonal (Ring.inverse v)"}, {"line": "\u00b7 have := isUnit_diagonal.not.mpr h\n    rw [Ring.inverse_non_unit _ h]\n    rw [Pi.zero_def]\n    rw [diagonal_zero]\n    rw [Ring.inverse_non_unit _ this]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_inv_inv (A : Matrix n n \u03b1) : A\u207b\u00b9\u207b\u00b9\u207b\u00b9 = A\u207b\u00b9 := by\n  by_cases h : IsUnit A.det\n  \u00b7 rw [nonsing_inv_nonsing_inv _ h]\n  \u00b7 simp [nonsing_inv_apply_not_isUnit _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "[Fintype n] [Fintype m] [DecidableEq m] [CommRing \u03b1]", "{R : Type*} [Semiring R]", "[DecidableEq m] {R K : Type*} [CommRing R] [Field K] [Fintype m]", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A} {B}", "{C : Matrix n n \u03b1}", "(A)", "[Fintype m] [DecidableEq m]", "(A : Matrix n n \u03b1) (U : Matrix n m \u03b1) (C : Matrix m m \u03b1) (V : Matrix m n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\n\u22a2 A\u207b\u00b9\u207b\u00b9\u207b\u00b9 = A\u207b\u00b9"}, {"line": "by_cases h : IsUnit A.det", "tactic_state": "case pos\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : sorry\n\u22a2 A\u207b\u00b9\u207b\u00b9\u207b\u00b9 = A\u207b\u00b9\n---\ncase neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : \u00acsorry\n\u22a2 A\u207b\u00b9\u207b\u00b9\u207b\u00b9 = A\u207b\u00b9"}, {"line": "\u00b7 rw [nonsing_inv_nonsing_inv _ h]", "tactic_state": "case neg\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nh : \u00acsorry\n\u22a2 A\u207b\u00b9\u207b\u00b9\u207b\u00b9 = A\u207b\u00b9"}, {"line": "\u00b7 simp [nonsing_inv_apply_not_isUnit _ h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_add_inv {A B : Matrix n n \u03b1} (h : IsUnit A \u2194 IsUnit B) :\n    A\u207b\u00b9 + B\u207b\u00b9 = A\u207b\u00b9 * (A + B) * B\u207b\u00b9 := by\n  simpa only [nonsing_inv_eq_ringInverse] using Ring.inverse_add_inverse h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "[Fintype n] [Fintype m] [DecidableEq m] [CommRing \u03b1]", "{R : Type*} [Semiring R]", "[DecidableEq m] {R K : Type*} [CommRing R] [Field K] [Fintype m]", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A} {B}", "{C : Matrix n n \u03b1}", "(A)", "[Fintype m] [DecidableEq m]", "(A : Matrix n n \u03b1) (U : Matrix n m \u03b1) (C : Matrix m m \u03b1) (V : Matrix m n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\ninst\u271d\u2078 : CommRing \u03b1\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : CommRing \u03b1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA B : Matrix n n \u03b1\nh : IsUnit A \u2194 IsUnit B\n\u22a2 A\u207b\u00b9 + B\u207b\u00b9 = A\u207b\u00b9 * (A + B) * B\u207b\u00b9"}, {"line": "simpa only [nonsing_inv_eq_ringInverse] using Ring.inverse_add_inverse h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_submatrix_equiv (A : Matrix m m \u03b1) (e\u2081 e\u2082 : n \u2243 m) :\n    (A.submatrix e\u2081 e\u2082)\u207b\u00b9 = A\u207b\u00b9.submatrix e\u2082 e\u2081 := by\n  by_cases h : IsUnit A\n  \u00b7 cases h.nonempty_invertible\n    letI := submatrixEquivInvertible A e\u2081 e\u2082\n    rw [\u2190 invOf_eq_nonsing_inv]\n    rw [\u2190 invOf_eq_nonsing_inv]\n    rw [invOf_submatrix_equiv_eq A]\n  \u00b7 have := (isUnit_submatrix_equiv e\u2081 e\u2082).not.mpr h\n    simp_rw [nonsing_inv_eq_ringInverse, Ring.inverse_non_unit _ h, Ring.inverse_non_unit _ this,\n      submatrix_zero, Pi.zero_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "context": {"open": ["Matrix Equiv Equiv.Perm Finset"], "variables": ["{l : Type*} {m : Type u} {n : Type u'} {\u03b1 : Type v}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A B}", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "[Fintype n] [Fintype m] [DecidableEq m] [CommRing \u03b1]", "{R : Type*} [Semiring R]", "[DecidableEq m] {R K : Type*} [CommRing R] [Field K] [Fintype m]", "[Fintype n] [DecidableEq n] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (B : Matrix n n \u03b1)", "{A} {B}", "{C : Matrix n n \u03b1}", "(A)", "[Fintype m] [DecidableEq m]", "(A : Matrix n n \u03b1) (U : Matrix n m \u03b1) (C : Matrix m m \u03b1) (V : Matrix m n \u03b1)", "[Fintype m]", "[DecidableEq m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2078 : Fintype n\ninst\u271d\u00b9\u2077 : DecidableEq n\ninst\u271d\u00b9\u2076 : CommRing \u03b1\ninst\u271d\u00b9\u2075 : Fintype n\ninst\u271d\u00b9\u2074 : DecidableEq n\ninst\u271d\u00b9\u00b3 : CommRing \u03b1\ninst\u271d\u00b9\u00b2 : Fintype n\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : CommRing \u03b1\ninst\u271d\u2078 : DecidableEq m\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : CommRing \u03b1\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nA : Matrix m m \u03b1\ne\u2081 e\u2082 : n \u2243 m\n\u22a2 (A.submatrix \u21d1e\u2081 \u21d1e\u2082)\u207b\u00b9 = A\u207b\u00b9.submatrix \u21d1e\u2082 \u21d1e\u2081"}, {"line": "by_cases h : IsUnit A", "tactic_state": "case pos\nm : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2078 : Fintype n\ninst\u271d\u00b9\u2077 : DecidableEq n\ninst\u271d\u00b9\u2076 : CommRing \u03b1\ninst\u271d\u00b9\u2075 : Fintype n\ninst\u271d\u00b9\u2074 : DecidableEq n\ninst\u271d\u00b9\u00b3 : CommRing \u03b1\ninst\u271d\u00b9\u00b2 : Fintype n\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : CommRing \u03b1\ninst\u271d\u2078 : DecidableEq m\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : CommRing \u03b1\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nA : Matrix m m \u03b1\ne\u2081 e\u2082 : n \u2243 m\nh : sorry\n\u22a2 (A.submatrix \u21d1e\u2081 \u21d1e\u2082)\u207b\u00b9 = A\u207b\u00b9.submatrix \u21d1e\u2082 \u21d1e\u2081\n---\ncase neg\nm : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2078 : Fintype n\ninst\u271d\u00b9\u2077 : DecidableEq n\ninst\u271d\u00b9\u2076 : CommRing \u03b1\ninst\u271d\u00b9\u2075 : Fintype n\ninst\u271d\u00b9\u2074 : DecidableEq n\ninst\u271d\u00b9\u00b3 : CommRing \u03b1\ninst\u271d\u00b9\u00b2 : Fintype n\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : CommRing \u03b1\ninst\u271d\u2078 : DecidableEq m\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : CommRing \u03b1\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nA : Matrix m m \u03b1\ne\u2081 e\u2082 : n \u2243 m\nh : \u00acsorry\n\u22a2 (A.submatrix \u21d1e\u2081 \u21d1e\u2082)\u207b\u00b9 = A\u207b\u00b9.submatrix \u21d1e\u2082 \u21d1e\u2081"}, {"line": "\u00b7 cases h.nonempty_invertible\n    letI := submatrixEquivInvertible A e\u2081 e\u2082\n    rw [\u2190 invOf_eq_nonsing_inv]\n    rw [\u2190 invOf_eq_nonsing_inv]\n    rw [invOf_submatrix_equiv_eq A]", "tactic_state": "case neg\nm : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b9\u2078 : Fintype n\ninst\u271d\u00b9\u2077 : DecidableEq n\ninst\u271d\u00b9\u2076 : CommRing \u03b1\ninst\u271d\u00b9\u2075 : Fintype n\ninst\u271d\u00b9\u2074 : DecidableEq n\ninst\u271d\u00b9\u00b3 : CommRing \u03b1\ninst\u271d\u00b9\u00b2 : Fintype n\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : CommRing \u03b1\ninst\u271d\u2078 : DecidableEq m\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : CommRing \u03b1\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nA : Matrix m m \u03b1\ne\u2081 e\u2082 : n \u2243 m\nh : \u00acsorry\n\u22a2 (A.submatrix \u21d1e\u2081 \u21d1e\u2082)\u207b\u00b9 = A\u207b\u00b9.submatrix \u21d1e\u2082 \u21d1e\u2081"}, {"line": "\u00b7 have := (isUnit_submatrix_equiv e\u2081 e\u2082).not.mpr h\n    simp_rw [nonsing_inv_eq_ringInverse, Ring.inverse_non_unit _ h, Ring.inverse_non_unit _ this,\n      submatrix_zero, Pi.zero_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem permanent_zero [Nonempty n] : permanent (0 : Matrix n n R) = 0 := by simp [permanent]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Permanent.lean", "context": {"open": ["Equiv Fintype Finset"], "variables": ["{n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nx\u271d : Sort u_3\npermanent : x\u271d\ninst\u271d : Nonempty n\n\u22a2 sorry = 0"}, {"line": "simp [permanent]", "tactic_state": "n : Type u_1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nx\u271d : Sort u_3\npermanent : x\u271d\ninst\u271d : Nonempty n\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem permanent_isEmpty [IsEmpty n] {A : Matrix n n R} : permanent A = 1 := by simp [permanent]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Permanent.lean", "context": {"open": ["Equiv Fintype Finset"], "variables": ["{n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\nx\u271d : Sort u_3\npermanent : x\u271d\ninst\u271d : IsEmpty n\nA : Matrix n n R\n\u22a2 sorry = 1"}, {"line": "simp [permanent]", "tactic_state": "n : Type u_1\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\nx\u271d : Sort u_3\npermanent : x\u271d\ninst\u271d : IsEmpty n\nA : Matrix n n R\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem permanent_unique {n : Type*} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :\n    permanent A = A default default := by simp [permanent, univ_unique]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Permanent.lean", "context": {"open": ["Equiv Fintype Finset"], "variables": ["{n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b3 : CommSemiring R\nx\u271d : Sort u_4\npermanent : x\u271d\nn : Type u_3\ninst\u271d\u00b2 : Unique n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nA : Matrix n n R\n\u22a2 sorry = A default default"}, {"line": "simp [permanent, univ_unique]", "tactic_state": "R : Type u_2\ninst\u271d\u00b3 : CommSemiring R\nx\u271d : Sort u_4\npermanent : x\u271d\nn : Type u_3\ninst\u271d\u00b2 : Unique n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nA : Matrix n n R\n\u22a2 sorry () = A default default"}]}
{"declaration": "theorem permanent_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) :\n    permanent A = A k k := by\n  have := uniqueOfSubsingleton k\n  convert permanent_unique A\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Permanent.lean", "context": {"open": ["Equiv Fintype Finset"], "variables": ["{n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\nx\u271d : Sort u_3\npermanent : x\u271d\ninst\u271d : Subsingleton n\nA : Matrix n n R\nk : n\n\u22a2 sorry = A k k"}, {"line": "have := uniqueOfSubsingleton k", "tactic_state": "n : Type u_1\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\nx\u271d : Sort u_3\npermanent : x\u271d\ninst\u271d : Subsingleton n\nA : Matrix n n R\nk : n\nthis : Unique n\n\u22a2 sorry = A k k"}, {"line": "convert permanent_unique A", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reindexLinearEquiv_comp (e\u2081 : m \u2243 m') (e\u2082 : n \u2243 n') (e\u2081' : m' \u2243 m'') (e\u2082' : n' \u2243 n'') :\n    reindexLinearEquiv R A e\u2081' e\u2082' \u2218 reindexLinearEquiv R A e\u2081 e\u2082 =\n      reindexLinearEquiv R A (e\u2081.trans e\u2081') (e\u2082.trans e\u2082') := by\n  rw [\u2190 reindexLinearEquiv_trans]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Reindex.lean", "context": {"open": ["Equiv Matrix"], "variables": ["{l m n o : Type*} {l' m' n' o' : Type*} {m'' n'' : Type*}", "(R A : Type*)", "[Semiring R] [AddCommMonoid A] [Module R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\nm' : Type u_6\nn' : Type u_7\nm'' : Type u_9\nn'' : Type u_10\nR : Type u_11\nA : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid A\ninst\u271d : Module R A\ne\u2081 : m \u2243 m'\ne\u2082 : n \u2243 n'\ne\u2081' : m' \u2243 m''\ne\u2082' : n' \u2243 n''\n\u22a2 \u21d1(reindexLinearEquiv R A e\u2081' e\u2082') \u2218 \u21d1(reindexLinearEquiv R A e\u2081 e\u2082) =\n    \u21d1(reindexLinearEquiv R A (e\u2081.trans e\u2081') (e\u2082.trans e\u2082'))"}, {"line": "rw [\u2190 reindexLinearEquiv_trans]", "tactic_state": "m : Type u_2\nn : Type u_3\nm' : Type u_6\nn' : Type u_7\nm'' : Type u_9\nn'' : Type u_10\nR : Type u_11\nA : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid A\ninst\u271d : Module R A\ne\u2081 : m \u2243 m'\ne\u2082 : n \u2243 n'\ne\u2081' : m' \u2243 m''\ne\u2082' : n' \u2243 n''\n\u22a2 \u21d1(reindexLinearEquiv R A e\u2081' e\u2082') \u2218 \u21d1(reindexLinearEquiv R A e\u2081 e\u2082) =\n    \u21d1(reindexLinearEquiv R A e\u2081 e\u2082 \u226a\u226b\u2097 reindexLinearEquiv R A e\u2081' e\u2082')"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cramer_transpose_apply (i : n) : cramer A\u1d40 b i = (A.updateRow i b).det := by\n  rw [cramer_apply]\n  rw [updateCol_transpose]\n  rw [det_transpose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "context": {"open": ["Matrix Polynomial Equiv Equiv.Perm Finset"], "variables": ["{m : Type u} {n : Type v} {\u03b1 : Type w}", "[DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (b : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni : n\n\u22a2 A.transpose.cramer b i = (A.updateRow i b).det"}, {"line": "rw [cramer_apply]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni : n\n\u22a2 (A.transpose.updateCol i b).det = (A.updateRow i b).det"}, {"line": "rw [updateCol_transpose]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni : n\n\u22a2 (A.updateRow i b).transpose.det = (A.updateRow i b).det"}, {"line": "rw [det_transpose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cramer_transpose_row_self (i : n) : A\u1d40.cramer (A i) = Pi.single i A.det := by\n  ext j\n  rw [cramer_apply]\n  rw [Pi.single_apply]\n  split_ifs with h\n  \u00b7 -- i = j: this entry should be `A.det`\n    subst h\n    simp only [updateCol_transpose]\n    simp only [det_transpose]\n    simp only [updateRow_eq_self]\n  \u00b7 -- i \u2260 j: this entry should be 0\n    rw [updateCol_transpose]\n    rw [det_transpose]\n    apply det_zero_of_row_eq h\n    rw [updateRow_self]\n    rw [updateRow_ne (Ne.symm h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "context": {"open": ["Matrix Polynomial Equiv Equiv.Perm Finset"], "variables": ["{m : Type u} {n : Type v} {\u03b1 : Type w}", "[DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (b : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni : n\n\u22a2 A.transpose.cramer (A i) = Pi.single i A.det"}, {"line": "ext j", "tactic_state": "case h\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 A.transpose.cramer (A i) j = Pi.single i A.det j"}, {"line": "rw [cramer_apply]", "tactic_state": "case h\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 (A.transpose.updateCol j (A i)).det = Pi.single i A.det j"}, {"line": "rw [Pi.single_apply]", "tactic_state": "case h\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 (A.transpose.updateCol j (A i)).det = if j = i then A.det else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\nh : j = i\n\u22a2 (A.transpose.updateCol j (A i)).det = A.det\n---\ncase neg\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\nh : \u00acj = i\n\u22a2 (A.transpose.updateCol j (A i)).det = 0"}, {"line": "\u00b7 -- i = j: this entry should be `A.det`\n    subst h\n    simp only [updateCol_transpose]\n    simp only [det_transpose]\n    simp only [updateRow_eq_self]", "tactic_state": "case neg\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\nh : \u00acj = i\n\u22a2 (A.transpose.updateCol j (A i)).det = 0"}, {"line": "\u00b7 -- i \u2260 j: this entry should be 0\n    rw [updateCol_transpose]\n    rw [det_transpose]\n    apply det_zero_of_row_eq h\n    rw [updateRow_self]\n    rw [updateRow_ne (Ne.symm h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjugate_apply (A : Matrix n n \u03b1) (i j : n) :\n    adjugate A i j = (A.updateRow j (Pi.single i 1)).det := by\n  rw [adjugate_def]\n  rw [of_apply]\n  rw [cramer_apply]\n  rw [updateCol_transpose]\n  rw [det_transpose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "context": {"open": ["Matrix Polynomial Equiv Equiv.Perm Finset"], "variables": ["{m : Type u} {n : Type v} {\u03b1 : Type w}", "[DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (b : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 A.adjugate i j = (A.updateRow j (Pi.single i 1)).det"}, {"line": "rw [adjugate_def]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 of (fun i => A.transpose.cramer (Pi.single i 1)) i j = (A.updateRow j (Pi.single i 1)).det"}, {"line": "rw [of_apply]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 A.transpose.cramer (Pi.single i 1) j = (A.updateRow j (Pi.single i 1)).det"}, {"line": "rw [cramer_apply]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 (A.transpose.updateCol j (Pi.single i 1)).det = (A.updateRow j (Pi.single i 1)).det"}, {"line": "rw [updateCol_transpose]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 (A.updateRow j (Pi.single i 1)).transpose.det = (A.updateRow j (Pi.single i 1)).det"}, {"line": "rw [det_transpose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjugate_transpose (A : Matrix n n \u03b1) : (adjugate A)\u1d40 = adjugate A\u1d40 := by\n  ext i j\n  rw [transpose_apply]\n  rw [adjugate_apply]\n  rw [adjugate_apply]\n  rw [updateRow_transpose]\n  rw [det_transpose]\n  rw [det_apply']\n  rw [det_apply']\n  apply Finset.sum_congr rfl\n  intro \u03c3 _\n  congr 1\n  by_cases h : i = \u03c3 j\n  \u00b7 -- Everything except `(i , j)` (= `(\u03c3 j , j)`) is given by A, and the rest is a single `1`.\n    congr\n    ext j'\n    subst h\n    have : \u03c3 j' = \u03c3 j \u2194 j' = j := \u03c3.injective.eq_iff\n    rw [updateRow_apply]\n    rw [updateCol_apply]\n    simp_rw [this]\n    rw [\u2190 dite_eq_ite]\n    rw [\u2190 dite_eq_ite]\n    congr 1 with rfl\n    rw [Pi.single_eq_same]\n    rw [Pi.single_eq_same]\n  \u00b7 -- Otherwise, we need to show that there is a `0` somewhere in the product.\n    have : (\u220f j' : n, updateCol A j (Pi.single i 1) (\u03c3 j') j') = 0 := by\n      apply prod_eq_zero (mem_univ j)\n      rw [updateCol_self]\n      rw [Pi.single_eq_of_ne' h]\n    rw [this]\n    apply prod_eq_zero (mem_univ (\u03c3\u207b\u00b9 i))\n    erw [apply_symm_apply \u03c3 i, updateRow_self]\n    apply Pi.single_eq_of_ne\n    intro h'\n    exact h ((symm_apply_eq \u03c3).mp h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "context": {"open": ["Matrix Polynomial Equiv Equiv.Perm Finset"], "variables": ["{m : Type u} {n : Type v} {\u03b1 : Type w}", "[DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (b : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\n\u22a2 A.adjugate.transpose = A.transpose.adjugate"}, {"line": "ext i j", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 A.adjugate.transpose i j = A.transpose.adjugate i j"}, {"line": "rw [transpose_apply]", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 A.adjugate j i = A.transpose.adjugate i j"}, {"line": "rw [adjugate_apply]", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 (A.updateRow i (Pi.single j 1)).det = A.transpose.adjugate i j"}, {"line": "rw [adjugate_apply]", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 (A.updateRow i (Pi.single j 1)).det = (A.transpose.updateRow j (Pi.single i 1)).det"}, {"line": "rw [updateRow_transpose]", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 (A.updateRow i (Pi.single j 1)).det = (A.updateCol j (Pi.single i 1)).transpose.det"}, {"line": "rw [det_transpose]", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 (A.updateRow i (Pi.single j 1)).det = (A.updateCol j (Pi.single i 1)).det"}, {"line": "rw [det_apply']", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 \u2211 \u03c3, \u2191\u2191(sign \u03c3) * \u220f i_1, A.updateRow i (Pi.single j 1) (\u03c3 i_1) i_1 = (A.updateCol j (Pi.single i 1)).det"}, {"line": "rw [det_apply']", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 \u2211 \u03c3, \u2191\u2191(sign \u03c3) * \u220f i_1, A.updateRow i (Pi.single j 1) (\u03c3 i_1) i_1 =\n    \u2211 \u03c3, \u2191\u2191(sign \u03c3) * \u220f i_1, A.updateCol j (Pi.single i 1) (\u03c3 i_1) i_1"}, {"line": "apply Finset.sum_congr rfl", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u22a2 \u2200 x \u2208 univ,\n    \u2191\u2191(sign x) * \u220f i_1, A.updateRow i (Pi.single j 1) (x i_1) i_1 =\n      \u2191\u2191(sign x) * \u220f i_1, A.updateCol j (Pi.single i 1) (x i_1) i_1"}, {"line": "intro \u03c3 _", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u03c3 : Perm n\na\u271d : \u03c3 \u2208 univ\n\u22a2 \u2191\u2191(sign \u03c3) * \u220f i_1, A.updateRow i (Pi.single j 1) (\u03c3 i_1) i_1 =\n    \u2191\u2191(sign \u03c3) * \u220f i_1, A.updateCol j (Pi.single i 1) (\u03c3 i_1) i_1"}, {"line": "congr 1", "tactic_state": "case a.e_a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u03c3 : Perm n\na\u271d : \u03c3 \u2208 univ\n\u22a2 \u220f i_1, A.updateRow i (Pi.single j 1) (\u03c3 i_1) i_1 = \u220f i_1, A.updateCol j (Pi.single i 1) (\u03c3 i_1) i_1"}, {"line": "by_cases h : i = \u03c3 j", "tactic_state": "case pos\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u03c3 : Perm n\na\u271d : \u03c3 \u2208 univ\nh : i = \u03c3 j\n\u22a2 \u220f i_1, A.updateRow i (Pi.single j 1) (\u03c3 i_1) i_1 = \u220f i_1, A.updateCol j (Pi.single i 1) (\u03c3 i_1) i_1\n---\ncase neg\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u03c3 : Perm n\na\u271d : \u03c3 \u2208 univ\nh : \u00aci = \u03c3 j\n\u22a2 \u220f i_1, A.updateRow i (Pi.single j 1) (\u03c3 i_1) i_1 = \u220f i_1, A.updateCol j (Pi.single i 1) (\u03c3 i_1) i_1"}, {"line": "\u00b7 -- Everything except `(i , j)` (= `(\u03c3 j , j)`) is given by A, and the rest is a single `1`.\n    congr\n    ext j'\n    subst h\n    have : \u03c3 j' = \u03c3 j \u2194 j' = j := \u03c3.injective.eq_iff\n    rw [updateRow_apply]\n    rw [updateCol_apply]\n    simp_rw [this]\n    rw [\u2190 dite_eq_ite]\n    rw [\u2190 dite_eq_ite]\n    congr 1 with rfl\n    rw [Pi.single_eq_same]\n    rw [Pi.single_eq_same]", "tactic_state": "case neg\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\ni j : n\n\u03c3 : Perm n\na\u271d : \u03c3 \u2208 univ\nh : \u00aci = \u03c3 j\n\u22a2 \u220f i_1, A.updateRow i (Pi.single j 1) (\u03c3 i_1) i_1 = \u220f i_1, A.updateCol j (Pi.single i 1) (\u03c3 i_1) i_1"}, {"line": "\u00b7 -- Otherwise, we need to show that there is a `0` somewhere in the product.\n    have : (\u220f j' : n, updateCol A j (Pi.single i 1) (\u03c3 j') j') = 0 := by\n      apply prod_eq_zero (mem_univ j)\n      rw [updateCol_self]\n      rw [Pi.single_eq_of_ne' h]\n    rw [this]\n    apply prod_eq_zero (mem_univ (\u03c3\u207b\u00b9 i))\n    erw [apply_symm_apply \u03c3 i, updateRow_self]\n    apply Pi.single_eq_of_ne\n    intro h'\n    exact h ((symm_apply_eq \u03c3).mp h')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjugate_smul (r : \u03b1) (A : Matrix n n \u03b1) :\n    adjugate (r \u2022 A) = r ^ (Fintype.card n - 1) \u2022 adjugate A := by\n  rw [adjugate]\n  rw [adjugate]\n  rw [transpose_smul]\n  rw [cramer_smul]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "context": {"open": ["Matrix Polynomial Equiv Equiv.Perm Finset"], "variables": ["{m : Type u} {n : Type v} {\u03b1 : Type w}", "[DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (b : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nr : \u03b1\nA : Matrix n n \u03b1\n\u22a2 (r \u2022 A).adjugate = r ^ (Fintype.card n - 1) \u2022 A.adjugate"}, {"line": "rw [adjugate]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nr : \u03b1\nA : Matrix n n \u03b1\n\u22a2 (of fun i => (r \u2022 A).transpose.cramer (Pi.single i 1)) = r ^ (Fintype.card n - 1) \u2022 A.adjugate"}, {"line": "rw [adjugate]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nr : \u03b1\nA : Matrix n n \u03b1\n\u22a2 (of fun i => (r \u2022 A).transpose.cramer (Pi.single i 1)) =\n    r ^ (Fintype.card n - 1) \u2022 of fun i => A.transpose.cramer (Pi.single i 1)"}, {"line": "rw [transpose_smul]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nr : \u03b1\nA : Matrix n n \u03b1\n\u22a2 (of fun i => (r \u2022 A.transpose).cramer (Pi.single i 1)) =\n    r ^ (Fintype.card n - 1) \u2022 of fun i => A.transpose.cramer (Pi.single i 1)"}, {"line": "rw [cramer_smul]", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\nr : \u03b1\nA : Matrix n n \u03b1\n\u22a2 (of fun i => (r ^ (Fintype.card n - 1) \u2022 A.transpose.cramer) (Pi.single i 1)) =\n    r ^ (Fintype.card n - 1) \u2022 of fun i => A.transpose.cramer (Pi.single i 1)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjugate_subsingleton [Subsingleton n] (A : Matrix n n \u03b1) : adjugate A = 1 := by\n  ext i j\n  simp [Subsingleton.elim i j, adjugate_apply, det_eq_elem_of_subsingleton _ i, one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "context": {"open": ["Matrix Polynomial Equiv Equiv.Perm Finset"], "variables": ["{m : Type u} {n : Type v} {\u03b1 : Type w}", "[DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (b : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Subsingleton n\nA : Matrix n n \u03b1\n\u22a2 A.adjugate = 1"}, {"line": "ext i j", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Subsingleton n\nA : Matrix n n \u03b1\ni j : n\n\u22a2 A.adjugate i j = 1 i j"}, {"line": "simp [Subsingleton.elim i j, adjugate_apply, det_eq_elem_of_subsingleton _ i, one_apply]", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Subsingleton n\nA : Matrix n n \u03b1\ni j : n\n\u22a2 (A.updateRow j (Pi.single i 1)).det = 1 i j"}]}
{"declaration": "theorem adjugate_one : adjugate (1 : Matrix n n \u03b1) = 1 := by\n  ext\n  simp [adjugate_def, Matrix.one_apply, Pi.single_apply, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "context": {"open": ["Matrix Polynomial Equiv Equiv.Perm Finset"], "variables": ["{m : Type u} {n : Type v} {\u03b1 : Type w}", "[DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (b : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\n\u22a2 adjugate 1 = 1"}, {"line": "ext", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\ni\u271d j\u271d : n\n\u22a2 adjugate 1 i\u271d j\u271d = 1 i\u271d j\u271d"}, {"line": "simp [adjugate_def, Matrix.one_apply, Pi.single_apply, eq_comm]", "tactic_state": "case a\nn : Type v\n\u03b1 : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing \u03b1\ni\u271d j\u271d : n\n\u22a2 (if i\u271d = j\u271d then 1 else 0) = if j\u271d = i\u271d then 1 else 0"}]}
{"declaration": "theorem adjugate_fin_two (A : Matrix (Fin 2) (Fin 2) \u03b1) :\n    adjugate A = !![A 1 1, -A 0 1; -A 1 0, A 0 0] := by\n  ext i j\n  rw [adjugate_fin_succ_eq_det_submatrix]\n  fin_cases i <;> fin_cases j <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "context": {"open": ["Matrix Polynomial Equiv Equiv.Perm Finset"], "variables": ["{m : Type u} {n : Type v} {\u03b1 : Type w}", "[DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (b : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\n\u22a2 A.adjugate = !![A 1 1, -A 0 1; -A 1 0, A 0 0]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\ni j : Fin 2\n\u22a2 A.adjugate i j = !![A 1 1, -A 0 1; -A 1 0, A 0 0] i j"}, {"line": "rw [adjugate_fin_succ_eq_det_submatrix]", "tactic_state": "case a\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\ni j : Fin 2\n\u22a2 (-1) ^ (\u2191j + \u2191i) * (A.submatrix j.succAbove i.succAbove).det = !![A 1 1, -A 0 1; -A 1 0, A 0 0] i j"}, {"line": "fin_cases i <;> fin_cases j <;> simp", "tactic_state": "case a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab1\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\n\u22a2 -1 * A 0 1 = -A 0 1\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab0\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\n\u22a2 -1 * A 1 0 = -A 1 0\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab1\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\n\u22a2 (-1) ^ 2 * A 0 0 = A 0 0"}]}
{"declaration": "theorem adjugate_fin_three (A : Matrix (Fin 3) (Fin 3) \u03b1) :\n    adjugate A =\n    !![A 1 1 * A 2 2 - A 1 2 * A 2 1,\n      -(A 0 1 * A 2 2) + A 0 2 * A 2 1,\n      A 0 1 * A 1 2 - A 0 2 * A 1 1;\n      -(A 1 0 * A 2 2) + A 1 2 * A 2 0,\n      A 0 0 * A 2 2 - A 0 2 * A 2 0,\n      -(A 0 0 * A 1 2) + A 0 2 * A 1 0;\n      A 1 0 * A 2 1 - A 1 1 * A 2 0,\n      -(A 0 0 * A 2 1) + A 0 1 * A 2 0,\n      A 0 0 * A 1 1 - A 0 1 * A 1 0] := by\n  ext i j\n  rw [adjugate_fin_succ_eq_det_submatrix]\n  rw [det_fin_two]\n  fin_cases i <;> fin_cases j <;> simp [updateRow, Fin.succAbove, Fin.lt_def] <;> ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "context": {"open": ["Matrix Polynomial Equiv Equiv.Perm Finset"], "variables": ["{m : Type u} {n : Type v} {\u03b1 : Type w}", "[DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing \u03b1]", "(A : Matrix n n \u03b1) (b : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 A.adjugate =\n    !![A 1 1 * A 2 2 - A 1 2 * A 2 1, -(A 0 1 * A 2 2) + A 0 2 * A 2 1, A 0 1 * A 1 2 - A 0 2 * A 1 1;\n      -(A 1 0 * A 2 2) + A 1 2 * A 2 0, A 0 0 * A 2 2 - A 0 2 * A 2 0, -(A 0 0 * A 1 2) + A 0 2 * A 1 0;\n      A 1 0 * A 2 1 - A 1 1 * A 2 0, -(A 0 0 * A 2 1) + A 0 1 * A 2 0, A 0 0 * A 1 1 - A 0 1 * A 1 0]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\ni j : Fin 3\n\u22a2 A.adjugate i j =\n    !![A 1 1 * A 2 2 - A 1 2 * A 2 1, -(A 0 1 * A 2 2) + A 0 2 * A 2 1, A 0 1 * A 1 2 - A 0 2 * A 1 1;\n        -(A 1 0 * A 2 2) + A 1 2 * A 2 0, A 0 0 * A 2 2 - A 0 2 * A 2 0, -(A 0 0 * A 1 2) + A 0 2 * A 1 0;\n        A 1 0 * A 2 1 - A 1 1 * A 2 0, -(A 0 0 * A 2 1) + A 0 1 * A 2 0, A 0 0 * A 1 1 - A 0 1 * A 1 0]\n      i j"}, {"line": "rw [adjugate_fin_succ_eq_det_submatrix]", "tactic_state": "case a\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\ni j : Fin 3\n\u22a2 (-1) ^ (\u2191j + \u2191i) * (A.submatrix j.succAbove i.succAbove).det =\n    !![A 1 1 * A 2 2 - A 1 2 * A 2 1, -(A 0 1 * A 2 2) + A 0 2 * A 2 1, A 0 1 * A 1 2 - A 0 2 * A 1 1;\n        -(A 1 0 * A 2 2) + A 1 2 * A 2 0, A 0 0 * A 2 2 - A 0 2 * A 2 0, -(A 0 0 * A 1 2) + A 0 2 * A 1 0;\n        A 1 0 * A 2 1 - A 1 1 * A 2 0, -(A 0 0 * A 2 1) + A 0 1 * A 2 0, A 0 0 * A 1 1 - A 0 1 * A 1 0]\n      i j"}, {"line": "rw [det_fin_two]", "tactic_state": "case a\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\ni j : Fin 3\n\u22a2 (-1) ^ (\u2191j + \u2191i) *\n      (A.submatrix j.succAbove i.succAbove 0 0 * A.submatrix j.succAbove i.succAbove 1 1 -\n        A.submatrix j.succAbove i.succAbove 0 1 * A.submatrix j.succAbove i.succAbove 1 0) =\n    !![A 1 1 * A 2 2 - A 1 2 * A 2 1, -(A 0 1 * A 2 2) + A 0 2 * A 2 1, A 0 1 * A 1 2 - A 0 2 * A 1 1;\n        -(A 1 0 * A 2 2) + A 1 2 * A 2 0, A 0 0 * A 2 2 - A 0 2 * A 2 0, -(A 0 0 * A 1 2) + A 0 2 * A 1 0;\n        A 1 0 * A 2 1 - A 1 1 * A 2 0, -(A 0 0 * A 2 1) + A 0 1 * A 2 0, A 0 0 * A 1 1 - A 0 1 * A 1 0]\n      i j"}, {"line": "fin_cases i <;> fin_cases j <;> simp [updateRow, Fin.succAbove, Fin.lt_def] <;> ring", "tactic_state": "case a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab1\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 -1 * (A 0 1 * A 2 2 - A 0 2 * A 2 1) = -(A 0 1 * A 2 2) + A 0 2 * A 2 1\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab2\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 (-1) ^ 2 * (A 0 1 * A 1 2 - A 0 2 * A 1 1) = A 0 1 * A 1 2 - A 0 2 * A 1 1\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab0\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 -1 * (A 1 0 * A 2 2 - A 1 2 * A 2 0) = -(A 1 0 * A 2 2) + A 1 2 * A 2 0\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab1\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 (-1) ^ 2 * (A 0 0 * A 2 2 - A 0 2 * A 2 0) = A 0 0 * A 2 2 - A 0 2 * A 2 0\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab2\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 (-1) ^ 3 * (A 0 0 * A 1 2 - A 0 2 * A 1 0) = -(A 0 0 * A 1 2) + A 0 2 * A 1 0\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab2\u00bb.\u00ab0\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 (-1) ^ 2 * (A 1 0 * A 2 1 - A 1 1 * A 2 0) = A 1 0 * A 2 1 - A 1 1 * A 2 0\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab2\u00bb.\u00ab1\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 (-1) ^ 3 * (A 0 0 * A 2 1 - A 0 1 * A 2 0) = -(A 0 0 * A 2 1) + A 0 1 * A 2 0\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab2\u00bb.\u00ab2\u00bb\n\u03b1 : Type w\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 (-1) ^ 4 * (A 0 0 * A 1 1 - A 0 1 * A 1 0) = A 0 0 * A 1 1 - A 0 1 * A 1 0"}]}
{"declaration": "theorem toMatrix_eq_toMatrix_constr [Fintype \u03b9] [DecidableEq \u03b9] (v : \u03b9 \u2192 M) :\n    e.toMatrix v = LinearMap.toMatrix e e (e.constr \u2115 v) := by\n  ext\n  rw [Basis.toMatrix_apply]\n  rw [LinearMap.toMatrix_apply]\n  rw [Basis.constr_basis]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Basis.lean", "context": {"open": ["LinearMap Matrix Set Submodule", "Matrix", "Function Matrix"], "variables": ["{\u03b9 \u03b9' \u03ba \u03ba' : Type*}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2082 M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "(e : Basis \u03b9 R M) (v : \u03b9' \u2192 M) (i : \u03b9) (j : \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ne : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 M\n\u22a2 e.toMatrix v = (toMatrix e e) ((e.constr \u2115) v)"}, {"line": "ext", "tactic_state": "case a\n\u03b9 : Type u_1\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ne : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 M\ni\u271d j\u271d : \u03b9\n\u22a2 e.toMatrix v i\u271d j\u271d = (toMatrix e e) ((e.constr \u2115) v) i\u271d j\u271d"}, {"line": "rw [Basis.toMatrix_apply]", "tactic_state": "case a\n\u03b9 : Type u_1\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ne : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 M\ni\u271d j\u271d : \u03b9\n\u22a2 (e.repr (v j\u271d)) i\u271d = (toMatrix e e) ((e.constr \u2115) v) i\u271d j\u271d"}, {"line": "rw [LinearMap.toMatrix_apply]", "tactic_state": "case a\n\u03b9 : Type u_1\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ne : Basis \u03b9 R M\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 M\ni\u271d j\u271d : \u03b9\n\u22a2 (e.repr (v j\u271d)) i\u271d = (e.repr (((e.constr \u2115) v) (e j\u271d))) i\u271d"}, {"line": "rw [Basis.constr_basis]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coePiBasisFun.toMatrix_eq_transpose [Finite \u03b9] :\n    ((Pi.basisFun R \u03b9).toMatrix : Matrix \u03b9 \u03b9 R \u2192 Matrix \u03b9 \u03b9 R) = Matrix.transpose := by\n  ext M i j\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Basis.lean", "context": {"open": ["LinearMap Matrix Set Submodule", "Matrix", "Function Matrix"], "variables": ["{\u03b9 \u03b9' \u03ba \u03ba' : Type*}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2082 M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "(e : Basis \u03b9 R M) (v : \u03b9' \u2192 M) (i : \u03b9) (j : \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Finite \u03b9\n\u22a2 (Pi.basisFun R \u03b9).toMatrix = transpose"}, {"line": "ext M i j", "tactic_state": "case h.a\n\u03b9 : Type u_1\nR : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Finite \u03b9\nM : \u03b9 \u2192 \u03b9 \u2192 R\ni j : \u03b9\n\u22a2 (Pi.basisFun R \u03b9).toMatrix M i j = transpose M i j"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toMatrix_self [DecidableEq \u03b9] : e.toMatrix e = 1 := by\n  unfold Basis.toMatrix\n  ext i j\n  simp [Basis.equivFun, Matrix.one_apply, Finsupp.single_apply, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Basis.lean", "context": {"open": ["LinearMap Matrix Set Submodule", "Matrix", "Function Matrix"], "variables": ["{\u03b9 \u03b9' \u03ba \u03ba' : Type*}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2082 M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "(e : Basis \u03b9 R M) (v : \u03b9' \u2192 M) (i : \u03b9) (j : \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ne : Basis \u03b9 R M\ninst\u271d : DecidableEq \u03b9\n\u22a2 e.toMatrix \u21d1e = 1"}, {"line": "unfold Basis.toMatrix", "tactic_state": "\u03b9 : Type u_1\nR : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ne : Basis \u03b9 R M\ninst\u271d : DecidableEq \u03b9\n\u22a2 (fun i j => (e.repr (e j)) i) = 1"}, {"line": "ext i j", "tactic_state": "case a\n\u03b9 : Type u_1\nR : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ne : Basis \u03b9 R M\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\n\u22a2 (e.repr (e j)) i = 1 i j"}, {"line": "simp [Basis.equivFun, Matrix.one_apply, Finsupp.single_apply, eq_comm]", "tactic_state": "case a\n\u03b9 : Type u_1\nR : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ne : Basis \u03b9 R M\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\n\u22a2 (if i = j then 1 else 0) = (fun\u2080 | j => 1) i"}]}
{"declaration": "theorem toMatrix_unitsSMul [DecidableEq \u03b9] (e : Basis \u03b9 R\u2082 M\u2082) (w : \u03b9 \u2192 R\u2082\u02e3) :\n    e.toMatrix (e.unitsSMul w) = diagonal ((\u2191) \u2218 w) := by\n  ext i j\n  by_cases h : i = j\n  \u00b7 simp [h, toMatrix_apply, unitsSMul_apply, Units.smul_def]\n  \u00b7 simp [h, toMatrix_apply, unitsSMul_apply, Units.smul_def, Ne.symm h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Basis.lean", "context": {"open": ["LinearMap Matrix Set Submodule", "Matrix", "Function Matrix"], "variables": ["{\u03b9 \u03b9' \u03ba \u03ba' : Type*}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2082 M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "(e : Basis \u03b9 R M) (v : \u03b9' \u2192 M) (i : \u03b9) (j : \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR\u2082 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u00b3 : CommRing R\u2082\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : DecidableEq \u03b9\ne : Basis \u03b9 R\u2082 M\u2082\nw : \u03b9 \u2192 R\u2082\u02e3\n\u22a2 e.toMatrix \u21d1(e.unitsSMul w) = Matrix.diagonal (Units.val \u2218 w)"}, {"line": "ext i j", "tactic_state": "case a\n\u03b9 : Type u_1\nR\u2082 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u00b3 : CommRing R\u2082\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : DecidableEq \u03b9\ne : Basis \u03b9 R\u2082 M\u2082\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 e.toMatrix (\u21d1(e.unitsSMul w)) i j = Matrix.diagonal (Units.val \u2218 w) i j"}, {"line": "by_cases h : i = j", "tactic_state": "case pos\n\u03b9 : Type u_1\nR\u2082 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u00b3 : CommRing R\u2082\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : DecidableEq \u03b9\ne : Basis \u03b9 R\u2082 M\u2082\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\nh : i = j\n\u22a2 e.toMatrix (\u21d1(e.unitsSMul w)) i j = Matrix.diagonal (Units.val \u2218 w) i j\n---\ncase neg\n\u03b9 : Type u_1\nR\u2082 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u00b3 : CommRing R\u2082\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : DecidableEq \u03b9\ne : Basis \u03b9 R\u2082 M\u2082\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\nh : \u00aci = j\n\u22a2 e.toMatrix (\u21d1(e.unitsSMul w)) i j = Matrix.diagonal (Units.val \u2218 w) i j"}, {"line": "\u00b7 simp [h, toMatrix_apply, unitsSMul_apply, Units.smul_def]", "tactic_state": "case neg\n\u03b9 : Type u_1\nR\u2082 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u00b3 : CommRing R\u2082\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\ninst\u271d : DecidableEq \u03b9\ne : Basis \u03b9 R\u2082 M\u2082\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\nh : \u00aci = j\n\u22a2 e.toMatrix (\u21d1(e.unitsSMul w)) i j = Matrix.diagonal (Units.val \u2218 w) i j"}, {"line": "\u00b7 simp [h, toMatrix_apply, unitsSMul_apply, Units.smul_def, Ne.symm h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toMatrix_smul {R\u2081 S : Type*} [CommSemiring R\u2081] [Semiring S] [Algebra R\u2081 S] [Fintype \u03b9]\n    [DecidableEq \u03b9] (x : S) (b : Basis \u03b9 R\u2081 S) (w : \u03b9 \u2192 S) :\n    (b.toMatrix (x \u2022 w)) = (Algebra.leftMulMatrix b x) * (b.toMatrix w) := by\n  ext\n  rw [Basis.toMatrix_apply]\n  rw [Pi.smul_apply]\n  rw [smul_eq_mul]\n  rw [\u2190 Algebra.leftMulMatrix_mulVec_repr]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Basis.lean", "context": {"open": ["LinearMap Matrix Set Submodule", "Matrix", "Function Matrix"], "variables": ["{\u03b9 \u03b9' \u03ba \u03ba' : Type*}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2082 M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "(e : Basis \u03b9 R M) (v : \u03b9' \u2192 M) (i : \u03b9) (j : \u03b9')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR\u2081 : Type u_9\nS : Type u_10\ninst\u271d\u2074 : CommSemiring R\u2081\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Algebra R\u2081 S\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nx : S\nb : Basis \u03b9 R\u2081 S\nw : \u03b9 \u2192 S\n\u22a2 b.toMatrix (x \u2022 w) = (Algebra.leftMulMatrix b) x * b.toMatrix w"}, {"line": "ext", "tactic_state": "case a\n\u03b9 : Type u_1\nR\u2081 : Type u_9\nS : Type u_10\ninst\u271d\u2074 : CommSemiring R\u2081\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Algebra R\u2081 S\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nx : S\nb : Basis \u03b9 R\u2081 S\nw : \u03b9 \u2192 S\ni\u271d j\u271d : \u03b9\n\u22a2 b.toMatrix (x \u2022 w) i\u271d j\u271d = ((Algebra.leftMulMatrix b) x * b.toMatrix w) i\u271d j\u271d"}, {"line": "rw [Basis.toMatrix_apply]", "tactic_state": "case a\n\u03b9 : Type u_1\nR\u2081 : Type u_9\nS : Type u_10\ninst\u271d\u2074 : CommSemiring R\u2081\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Algebra R\u2081 S\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nx : S\nb : Basis \u03b9 R\u2081 S\nw : \u03b9 \u2192 S\ni\u271d j\u271d : \u03b9\n\u22a2 (b.repr ((x \u2022 w) j\u271d)) i\u271d = ((Algebra.leftMulMatrix b) x * b.toMatrix w) i\u271d j\u271d"}, {"line": "rw [Pi.smul_apply]", "tactic_state": "case a\n\u03b9 : Type u_1\nR\u2081 : Type u_9\nS : Type u_10\ninst\u271d\u2074 : CommSemiring R\u2081\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Algebra R\u2081 S\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nx : S\nb : Basis \u03b9 R\u2081 S\nw : \u03b9 \u2192 S\ni\u271d j\u271d : \u03b9\n\u22a2 (b.repr (x \u2022 w j\u271d)) i\u271d = ((Algebra.leftMulMatrix b) x * b.toMatrix w) i\u271d j\u271d"}, {"line": "rw [smul_eq_mul]", "tactic_state": "case a\n\u03b9 : Type u_1\nR\u2081 : Type u_9\nS : Type u_10\ninst\u271d\u2074 : CommSemiring R\u2081\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Algebra R\u2081 S\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nx : S\nb : Basis \u03b9 R\u2081 S\nw : \u03b9 \u2192 S\ni\u271d j\u271d : \u03b9\n\u22a2 (b.repr (x * w j\u271d)) i\u271d = ((Algebra.leftMulMatrix b) x * b.toMatrix w) i\u271d j\u271d"}, {"line": "rw [\u2190 Algebra.leftMulMatrix_mulVec_repr]", "tactic_state": "case a\n\u03b9 : Type u_1\nR\u2081 : Type u_9\nS : Type u_10\ninst\u271d\u2074 : CommSemiring R\u2081\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Algebra R\u2081 S\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nx : S\nb : Basis \u03b9 R\u2081 S\nw : \u03b9 \u2192 S\ni\u271d j\u271d : \u03b9\n\u22a2 ((Algebra.leftMulMatrix b) x).mulVec (\u21d1(b.repr (w j\u271d))) i\u271d = ((Algebra.leftMulMatrix b) x * b.toMatrix w) i\u271d j\u271d\n---\n\u03b9 : Type u_1\nR\u2081 : Type u_9\nS : Type u_10\ninst\u271d\u2074 : CommSemiring R\u2081\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Algebra R\u2081 S\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nx : S\nb : Basis \u03b9 R\u2081 S\nw : \u03b9 \u2192 S\ni\u271d j\u271d : \u03b9\n\u22a2 Fintype \u03b9\n---\n\u03b9 : Type u_1\nR\u2081 : Type u_9\nS : Type u_10\ninst\u271d\u2074 : CommSemiring R\u2081\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : Algebra R\u2081 S\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nx : S\nb : Basis \u03b9 R\u2081 S\nw : \u03b9 \u2192 S\ni\u271d j\u271d : \u03b9\n\u22a2 DecidableEq \u03b9"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Basis.toMatrix_mul_toMatrix {\u03b9'' : Type*} [Fintype \u03b9'] (b'' : \u03b9'' \u2192 M) :\n    b.toMatrix b' * b'.toMatrix b'' = b.toMatrix b'' := by\n  haveI := Classical.decEq \u03b9\n  haveI := Classical.decEq \u03b9'\n  haveI := Classical.decEq \u03b9''\n  ext i j\n  simp only [Matrix.mul_apply]\n  simp only [Basis.toMatrix_apply]\n  simp only [Basis.sum_repr_mul_repr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Basis.lean", "context": {"open": ["LinearMap Matrix Set Submodule", "Matrix", "Function Matrix", "LinearMap"], "variables": ["{\u03b9 \u03b9' \u03ba \u03ba' : Type*}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2082 M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "(e : Basis \u03b9 R M) (v : \u03b9' \u2192 M) (i : \u03b9) (j : \u03b9')", "(R\u2082) in", "{N : Type*} [AddCommMonoid N] [Module R N]", "(b : Basis \u03b9 R M) (b' : Basis \u03b9' R M) (c : Basis \u03ba R N) (c' : Basis \u03ba' R N)", "(f : M \u2192\u2097[R] N)", "[Fintype \u03b9']", "[Finite \u03ba] [Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nb : Basis \u03b9 R M\nb' : Basis \u03b9' R M\ninst\u271d\u00b2 : Fintype \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\n\u03b9'' : Type u_9\ninst\u271d : Fintype \u03b9'\nb'' : \u03b9'' \u2192 M\n\u22a2 b.toMatrix \u21d1b' * b'.toMatrix b'' = b.toMatrix b''"}, {"line": "haveI := Classical.decEq \u03b9", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nb : Basis \u03b9 R M\nb' : Basis \u03b9' R M\ninst\u271d\u00b2 : Fintype \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\n\u03b9'' : Type u_9\ninst\u271d : Fintype \u03b9'\nb'' : \u03b9'' \u2192 M\nthis : DecidableEq \u03b9\n\u22a2 b.toMatrix \u21d1b' * b'.toMatrix b'' = b.toMatrix b''"}, {"line": "haveI := Classical.decEq \u03b9'", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nb : Basis \u03b9 R M\nb' : Basis \u03b9' R M\ninst\u271d\u00b2 : Fintype \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\n\u03b9'' : Type u_9\ninst\u271d : Fintype \u03b9'\nb'' : \u03b9'' \u2192 M\nthis\u271d : DecidableEq \u03b9\nthis : DecidableEq \u03b9'\n\u22a2 b.toMatrix \u21d1b' * b'.toMatrix b'' = b.toMatrix b''"}, {"line": "haveI := Classical.decEq \u03b9''", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nb : Basis \u03b9 R M\nb' : Basis \u03b9' R M\ninst\u271d\u00b2 : Fintype \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\n\u03b9'' : Type u_9\ninst\u271d : Fintype \u03b9'\nb'' : \u03b9'' \u2192 M\nthis\u271d\u00b9 : DecidableEq \u03b9\nthis\u271d : DecidableEq \u03b9'\nthis : DecidableEq \u03b9''\n\u22a2 b.toMatrix \u21d1b' * b'.toMatrix b'' = b.toMatrix b''"}, {"line": "ext i j", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nb : Basis \u03b9 R M\nb' : Basis \u03b9' R M\ninst\u271d\u00b2 : Fintype \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\n\u03b9'' : Type u_9\ninst\u271d : Fintype \u03b9'\nb'' : \u03b9'' \u2192 M\nthis\u271d\u00b9 : DecidableEq \u03b9\nthis\u271d : DecidableEq \u03b9'\nthis : DecidableEq \u03b9''\ni : \u03b9\nj : \u03b9''\n\u22a2 (b.toMatrix \u21d1b' * b'.toMatrix b'') i j = b.toMatrix b'' i j"}, {"line": "simp only [Matrix.mul_apply]", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nb : Basis \u03b9 R M\nb' : Basis \u03b9' R M\ninst\u271d\u00b2 : Fintype \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\n\u03b9'' : Type u_9\ninst\u271d : Fintype \u03b9'\nb'' : \u03b9'' \u2192 M\nthis\u271d\u00b9 : DecidableEq \u03b9\nthis\u271d : DecidableEq \u03b9'\nthis : DecidableEq \u03b9''\ni : \u03b9\nj : \u03b9''\n\u22a2 \u2211 j_1, b.toMatrix (\u21d1b') i j_1 * b'.toMatrix b'' j_1 j = b.toMatrix b'' i j"}, {"line": "simp only [Basis.toMatrix_apply]", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nb : Basis \u03b9 R M\nb' : Basis \u03b9' R M\ninst\u271d\u00b2 : Fintype \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\n\u03b9'' : Type u_9\ninst\u271d : Fintype \u03b9'\nb'' : \u03b9'' \u2192 M\nthis\u271d\u00b9 : DecidableEq \u03b9\nthis\u271d : DecidableEq \u03b9'\nthis : DecidableEq \u03b9''\ni : \u03b9\nj : \u03b9''\n\u22a2 \u2211 x, (b.repr (b' x)) i * (b'.repr (b'' j)) x = (b.repr (b'' j)) i"}, {"line": "simp only [Basis.sum_repr_mul_repr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Basis.toMatrix_reindex (b : Basis \u03b9 R M) (v : \u03b9' \u2192 M) (e : \u03b9 \u2243 \u03b9') :\n    (b.reindex e).toMatrix v = (b.toMatrix v).submatrix e.symm _root_.id := by\n  ext\n  simp only [Basis.toMatrix_apply]\n  simp only [Basis.repr_reindex]\n  simp only [Matrix.submatrix_apply]\n  simp only [_root_.id]\n  simp only [Finsupp.mapDomain_equiv_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Basis.lean", "context": {"open": ["LinearMap Matrix Set Submodule", "Matrix", "Function Matrix", "LinearMap"], "variables": ["{\u03b9 \u03b9' \u03ba \u03ba' : Type*}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "{R\u2082 M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "(e : Basis \u03b9 R M) (v : \u03b9' \u2192 M) (i : \u03b9) (j : \u03b9')", "(R\u2082) in", "{N : Type*} [AddCommMonoid N] [Module R N]", "(b : Basis \u03b9 R M) (b' : Basis \u03b9' R M) (c : Basis \u03ba R N) (c' : Basis \u03ba' R N)", "(f : M \u2192\u2097[R] N)", "[Fintype \u03b9']", "[Finite \u03ba] [Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Fintype \u03b9'\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nv : \u03b9' \u2192 M\ne : \u03b9 \u2243 \u03b9'\n\u22a2 (b.reindex e).toMatrix v = (b.toMatrix v).submatrix (\u21d1e.symm) _root_.id"}, {"line": "ext", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Fintype \u03b9'\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nv : \u03b9' \u2192 M\ne : \u03b9 \u2243 \u03b9'\ni\u271d j\u271d : \u03b9'\n\u22a2 (b.reindex e).toMatrix v i\u271d j\u271d = (b.toMatrix v).submatrix (\u21d1e.symm) _root_.id i\u271d j\u271d"}, {"line": "simp only [Basis.toMatrix_apply]", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Fintype \u03b9'\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nv : \u03b9' \u2192 M\ne : \u03b9 \u2243 \u03b9'\ni\u271d j\u271d : \u03b9'\n\u22a2 ((b.reindex e).repr (v j\u271d)) i\u271d = (b.toMatrix v).submatrix (\u21d1e.symm) _root_.id i\u271d j\u271d"}, {"line": "simp only [Basis.repr_reindex]", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Fintype \u03b9'\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nv : \u03b9' \u2192 M\ne : \u03b9 \u2243 \u03b9'\ni\u271d j\u271d : \u03b9'\n\u22a2 (Finsupp.mapDomain (\u21d1e) (b.repr (v j\u271d))) i\u271d = (b.toMatrix v).submatrix (\u21d1e.symm) _root_.id i\u271d j\u271d"}, {"line": "simp only [Matrix.submatrix_apply]", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Fintype \u03b9'\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nv : \u03b9' \u2192 M\ne : \u03b9 \u2243 \u03b9'\ni\u271d j\u271d : \u03b9'\n\u22a2 (Finsupp.mapDomain (\u21d1e) (b.repr (v j\u271d))) i\u271d = b.toMatrix v (e.symm i\u271d) (_root_.id j\u271d)"}, {"line": "simp only [_root_.id]", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Fintype \u03b9'\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nv : \u03b9' \u2192 M\ne : \u03b9 \u2243 \u03b9'\ni\u271d j\u271d : \u03b9'\n\u22a2 (Finsupp.mapDomain (\u21d1e) (b.repr (v j\u271d))) i\u271d = b.toMatrix v (e.symm i\u271d) j\u271d"}, {"line": "simp only [Finsupp.mapDomain_equiv_apply]", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_5\nM : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Fintype \u03b9'\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R M\nv : \u03b9' \u2192 M\ne : \u03b9 \u2243 \u03b9'\ni\u271d j\u271d : \u03b9'\n\u22a2 (b.repr (v j\u271d)) (e.symm i\u271d) = b.toMatrix v (e.symm i\u271d) j\u271d"}]}
{"declaration": "theorem toBilin'Aux_toMatrixAux [DecidableEq n] (B\u2082 : BilinForm R\u2081 (n \u2192 R\u2081)) :\n    Matrix.toBilin'Aux (BilinForm.toMatrixAux (fun j => Pi.single j 1) B\u2082) = B\u2082 := by\n  rw [BilinForm.toMatrixAux]\n  rw [Matrix.toBilin'Aux]\n  rw [toLinearMap\u2082'Aux_toMatrix\u2082Aux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "context": {"open": ["LinearMap (BilinForm)", "Finset LinearMap Matrix", "Matrix"], "variables": ["{R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "{n o : Type*}", "[Fintype n] [Fintype o]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2081 : Type u_1\ninst\u271d\u00b2 : CommSemiring R\u2081\nn : Type u_5\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nB\u2082 : BilinForm R\u2081 (n \u2192 R\u2081)\n\u22a2 ((BilinForm.toMatrixAux fun j => Pi.single j 1) B\u2082).toBilin'Aux = B\u2082"}, {"line": "rw [BilinForm.toMatrixAux]", "tactic_state": "R\u2081 : Type u_1\ninst\u271d\u00b2 : CommSemiring R\u2081\nn : Type u_5\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nB\u2082 : BilinForm R\u2081 (n \u2192 R\u2081)\n\u22a2 ((toMatrix\u2082Aux R\u2081 (fun j => Pi.single j 1) fun j => Pi.single j 1) B\u2082).toBilin'Aux = B\u2082"}, {"line": "rw [Matrix.toBilin'Aux]", "tactic_state": "R\u2081 : Type u_1\ninst\u271d\u00b2 : CommSemiring R\u2081\nn : Type u_5\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nB\u2082 : BilinForm R\u2081 (n \u2192 R\u2081)\n\u22a2 toLinearMap\u2082'Aux (RingHom.id R\u2081) (RingHom.id R\u2081)\n      ((toMatrix\u2082Aux R\u2081 (fun j => Pi.single j 1) fun j => Pi.single j 1) B\u2082) =\n    B\u2082"}, {"line": "rw [toLinearMap\u2082'Aux_toMatrix\u2082Aux]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.toBilin'_single (M : Matrix n n R\u2081) (i j : n) :\n    Matrix.toBilin' M (Pi.single i 1) (Pi.single j 1) = M i j := by\n  simp [Matrix.toBilin'_apply, Pi.single_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "context": {"open": ["LinearMap (BilinForm)", "Finset LinearMap Matrix", "Matrix"], "variables": ["{R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "{n o : Type*}", "[Fintype n] [Fintype o]", "[DecidableEq n] [DecidableEq o]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2081 : Type u_1\ninst\u271d\u00b2 : CommSemiring R\u2081\nn : Type u_5\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix n n R\u2081\ni j : n\n\u22a2 ((toBilin' M) (Pi.single i 1)) (Pi.single j 1) = M i j"}, {"line": "simp [Matrix.toBilin'_apply, Pi.single_apply]", "tactic_state": "R\u2081 : Type u_1\ninst\u271d\u00b2 : CommSemiring R\u2081\nn : Type u_5\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix n n R\u2081\ni j : n\n\u22a2 1 * M i j * 1 = M i j"}]}
{"declaration": "theorem BilinForm.toMatrix_basisFun :\n    BilinForm.toMatrix (Pi.basisFun R\u2081 n) = BilinForm.toMatrix' := by\n  rw [BilinForm.toMatrix]\n  rw [BilinForm.toMatrix']\n  rw [LinearMap.toMatrix\u2082_basisFun]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "context": {"open": ["LinearMap (BilinForm)", "Finset LinearMap Matrix", "Matrix"], "variables": ["{R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "{n o : Type*}", "[Fintype n] [Fintype o]", "[DecidableEq n] [DecidableEq o]", "[DecidableEq n] (b : Basis n R\u2081 M\u2081)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2081 : Type u_1\ninst\u271d\u00b3 : CommSemiring R\u2081\nn : Type u_5\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 inst\u271d : DecidableEq n\n\u22a2 toMatrix (Pi.basisFun R\u2081 n) = BilinForm.toMatrix'"}, {"line": "rw [BilinForm.toMatrix]", "tactic_state": "R\u2081 : Type u_1\ninst\u271d\u00b3 : CommSemiring R\u2081\nn : Type u_5\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 inst\u271d : DecidableEq n\n\u22a2 toMatrix\u2082 (Pi.basisFun R\u2081 n) (Pi.basisFun R\u2081 n) = BilinForm.toMatrix'"}, {"line": "rw [BilinForm.toMatrix']", "tactic_state": "R\u2081 : Type u_1\ninst\u271d\u00b3 : CommSemiring R\u2081\nn : Type u_5\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 inst\u271d : DecidableEq n\n\u22a2 toMatrix\u2082 (Pi.basisFun R\u2081 n) (Pi.basisFun R\u2081 n) = toMatrix\u2082' R\u2081"}, {"line": "rw [LinearMap.toMatrix\u2082_basisFun]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_pairSelfAdjointMatricesSubmodule' :\n    A \u2208 pairSelfAdjointMatricesSubmodule J J\u2083 \u2194 Matrix.IsAdjointPair J J\u2083 A A := by\n  simp only [mem_pairSelfAdjointMatricesSubmodule]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "context": {"open": ["LinearMap (BilinForm)", "Finset LinearMap Matrix", "Matrix", "Matrix"], "variables": ["{R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "{n o : Type*}", "[Fintype n] [Fintype o]", "[DecidableEq n] [DecidableEq o]", "[DecidableEq n] (b : Basis n R\u2081 M\u2081)", "{M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']", "(c : Basis o R\u2081 M\u2082')", "[DecidableEq o]", "{n : Type*} [Fintype n]", "(b : Basis n R\u2082 M\u2082)", "(J J\u2083 A A' : Matrix n n R\u2082)", "[DecidableEq n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2082 : Type u_3\ninst\u271d\u00b2 : CommRing R\u2082\nn : Type u_8\ninst\u271d\u00b9 : Fintype n\nJ J\u2083 A : Matrix n n R\u2082\ninst\u271d : DecidableEq n\n\u22a2 A \u2208 pairSelfAdjointMatricesSubmodule J J\u2083 \u2194 J.IsAdjointPair J\u2083 A A"}, {"line": "simp only [mem_pairSelfAdjointMatricesSubmodule]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_selfAdjointMatricesSubmodule' :\n    A \u2208 selfAdjointMatricesSubmodule J \u2194 J.IsSelfAdjoint A := by\n  simp only [mem_selfAdjointMatricesSubmodule]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "context": {"open": ["LinearMap (BilinForm)", "Finset LinearMap Matrix", "Matrix", "Matrix"], "variables": ["{R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "{n o : Type*}", "[Fintype n] [Fintype o]", "[DecidableEq n] [DecidableEq o]", "[DecidableEq n] (b : Basis n R\u2081 M\u2081)", "{M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']", "(c : Basis o R\u2081 M\u2082')", "[DecidableEq o]", "{n : Type*} [Fintype n]", "(b : Basis n R\u2082 M\u2082)", "(J J\u2083 A A' : Matrix n n R\u2082)", "[DecidableEq n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2082 : Type u_3\ninst\u271d\u00b2 : CommRing R\u2082\nn : Type u_8\ninst\u271d\u00b9 : Fintype n\nJ A : Matrix n n R\u2082\ninst\u271d : DecidableEq n\n\u22a2 A \u2208 selfAdjointMatricesSubmodule J \u2194 J.IsSelfAdjoint A"}, {"line": "simp only [mem_selfAdjointMatricesSubmodule]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_skewAdjointMatricesSubmodule' :\n    A \u2208 skewAdjointMatricesSubmodule J \u2194 J.IsSkewAdjoint A := by\n  simp only [mem_skewAdjointMatricesSubmodule]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "context": {"open": ["LinearMap (BilinForm)", "Finset LinearMap Matrix", "Matrix", "Matrix"], "variables": ["{R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "{n o : Type*}", "[Fintype n] [Fintype o]", "[DecidableEq n] [DecidableEq o]", "[DecidableEq n] (b : Basis n R\u2081 M\u2081)", "{M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']", "(c : Basis o R\u2081 M\u2082')", "[DecidableEq o]", "{n : Type*} [Fintype n]", "(b : Basis n R\u2082 M\u2082)", "(J J\u2083 A A' : Matrix n n R\u2082)", "[DecidableEq n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2082 : Type u_3\ninst\u271d\u00b2 : CommRing R\u2082\nn : Type u_8\ninst\u271d\u00b9 : Fintype n\nJ A : Matrix n n R\u2082\ninst\u271d : DecidableEq n\n\u22a2 A \u2208 skewAdjointMatricesSubmodule J \u2194 J.IsSkewAdjoint A"}, {"line": "simp only [mem_skewAdjointMatricesSubmodule]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Matrix.nondegenerate_toBilin_iff {M : Matrix \u03b9 \u03b9 R\u2082} (b : Basis \u03b9 R\u2082 M\u2082) :\n    (Matrix.toBilin b M).Nondegenerate \u2194 M.Nondegenerate := by\n  rw [\u2190 Matrix.nondegenerate_toBilin'_iff_nondegenerate_toBilin]\n  rw [Matrix.nondegenerate_toBilin'_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "context": {"open": ["LinearMap (BilinForm)", "Finset LinearMap Matrix", "Matrix", "Matrix", "Matrix"], "variables": ["{R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "{n o : Type*}", "[Fintype n] [Fintype o]", "[DecidableEq n] [DecidableEq o]", "[DecidableEq n] (b : Basis n R\u2081 M\u2081)", "{M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']", "(c : Basis o R\u2081 M\u2082')", "[DecidableEq o]", "{n : Type*} [Fintype n]", "(b : Basis n R\u2082 M\u2082)", "(J J\u2083 A A' : Matrix n n R\u2082)", "[DecidableEq n]", "{A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2082 : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u2074 : CommRing R\u2082\ninst\u271d\u00b3 : AddCommGroup M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03b9 : Type u_10\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\nM : Matrix \u03b9 \u03b9 R\u2082\nb : Basis \u03b9 R\u2082 M\u2082\n\u22a2 ((toBilin b) M).Nondegenerate \u2194 M.Nondegenerate"}, {"line": "rw [\u2190 Matrix.nondegenerate_toBilin'_iff_nondegenerate_toBilin]", "tactic_state": "R\u2082 : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u2074 : CommRing R\u2082\ninst\u271d\u00b3 : AddCommGroup M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03b9 : Type u_10\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\nM : Matrix \u03b9 \u03b9 R\u2082\nb : Basis \u03b9 R\u2082 M\u2082\n\u22a2 (toBilin' M).Nondegenerate \u2194 M.Nondegenerate"}, {"line": "rw [Matrix.nondegenerate_toBilin'_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nondegenerate_toBilin'_iff_det_ne_zero {M : Matrix \u03b9 \u03b9 A} :\n    M.toBilin'.Nondegenerate \u2194 M.det \u2260 0 := by\n  rw [Matrix.nondegenerate_toBilin'_iff]\n  rw [Matrix.nondegenerate_iff_det_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "context": {"open": ["LinearMap (BilinForm)", "Finset LinearMap Matrix", "Matrix", "Matrix", "Matrix"], "variables": ["{R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "{R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "{n o : Type*}", "[Fintype n] [Fintype o]", "[DecidableEq n] [DecidableEq o]", "[DecidableEq n] (b : Basis n R\u2081 M\u2081)", "{M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']", "(c : Basis o R\u2081 M\u2082')", "[DecidableEq o]", "{n : Type*} [Fintype n]", "(b : Basis n R\u2082 M\u2082)", "(J J\u2083 A A' : Matrix n n R\u2082)", "[DecidableEq n]", "{A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_9\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : IsDomain A\n\u03b9 : Type u_10\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\nM : Matrix \u03b9 \u03b9 A\n\u22a2 (toBilin' M).Nondegenerate \u2194 M.det \u2260 0"}, {"line": "rw [Matrix.nondegenerate_toBilin'_iff]", "tactic_state": "A : Type u_9\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : IsDomain A\n\u03b9 : Type u_10\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\nM : Matrix \u03b9 \u03b9 A\n\u22a2 M.Nondegenerate \u2194 M.det \u2260 0"}, {"line": "rw [Matrix.nondegenerate_iff_det_ne_zero]", "tactic_state": "A : Type u_9\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : IsDomain A\n\u03b9 : Type u_10\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\nM : Matrix \u03b9 \u03b9 A\n\u22a2 IsDomain A"}]}
{"declaration": "theorem blockTriangular_reindex_iff {b : n \u2192 \u03b1} {e : m \u2243 n} :\n    (reindex e e M).BlockTriangular b \u2194 M.BlockTriangular (b \u2218 e) := by\n  refine \u27e8fun h => ?_, fun h => ?_\u27e9\n  \u00b7 convert h.submatrix\n    simp only [reindex_apply]\n    simp only [submatrix_submatrix]\n    simp only [submatrix_id_id]\n    simp only [Equiv.symm_comp_self]\n  \u00b7 convert h.submatrix\n    simp only [comp_assoc b e e.symm]\n    simp only [Equiv.self_comp_symm]\n    simp only [comp_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Block.lean", "context": {"open": ["Finset Function OrderDual", "Matrix"], "variables": ["{\u03b1 \u03b2 m n o : Type*} {m' n' : \u03b1 \u2192 Type*}", "{R : Type v} {M N : Matrix m m R} {b : m \u2192 \u03b1}", "[LT \u03b1]", "[Zero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\nM : Matrix m m R\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : Zero R\nb : n \u2192 \u03b1\ne : m \u2243 n\n\u22a2 ((reindex e e) M).BlockTriangular b \u2194 M.BlockTriangular (b \u2218 \u21d1e)"}, {"line": "refine \u27e8fun h => ?_, fun h => ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\nM : Matrix m m R\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : Zero R\nb : n \u2192 \u03b1\ne : m \u2243 n\nh : ((reindex e e) M).BlockTriangular b\n\u22a2 M.BlockTriangular (b \u2218 \u21d1e)\n---\ncase refine_2\n\u03b1 : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\nM : Matrix m m R\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : Zero R\nb : n \u2192 \u03b1\ne : m \u2243 n\nh : M.BlockTriangular (b \u2218 \u21d1e)\n\u22a2 ((reindex e e) M).BlockTriangular b"}, {"line": "\u00b7 convert h.submatrix\n    simp only [reindex_apply]\n    simp only [submatrix_submatrix]\n    simp only [submatrix_id_id]\n    simp only [Equiv.symm_comp_self]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\nM : Matrix m m R\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : Zero R\nb : n \u2192 \u03b1\ne : m \u2243 n\nh : M.BlockTriangular (b \u2218 \u21d1e)\n\u22a2 ((reindex e e) M).BlockTriangular b"}, {"line": "\u00b7 convert h.submatrix\n    simp only [comp_assoc b e e.symm]\n    simp only [Equiv.self_comp_symm]\n    simp only [comp_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upper_two_blockTriangular [Zero R] [Preorder \u03b1] (A : Matrix m m R) (B : Matrix m n R)\n    (D : Matrix n n R) {a b : \u03b1} (hab : a < b) :\n    BlockTriangular (fromBlocks A B 0 D) (Sum.elim (fun _ => a) fun _ => b) := by\n  rintro (c | c) (d | d) hcd <;> first | simp [hab.not_lt] at hcd \u22a2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Block.lean", "context": {"open": ["Finset Function OrderDual", "Matrix"], "variables": ["{\u03b1 \u03b2 m n o : Type*} {m' n' : \u03b1 \u2192 Type*}", "{R : Type v} {M N : Matrix m m R} {b : m \u2192 \u03b1}", "[LT \u03b1]", "[Zero R]", "[Preorder \u03b1]", "[Zero R]", "[DecidableEq m]", "[CommRing R] [DecidableEq m]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Zero R\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : Zero R\ninst\u271d : Preorder \u03b1\nA : Matrix m m R\nB : Matrix m n R\nD : Matrix n n R\na b : \u03b1\nhab : a < b\n\u22a2 (fromBlocks A B 0 D).BlockTriangular (Sum.elim (fun x => a) fun x => b)"}, {"line": "rintro (c | c) (d | d) hcd <;> first | simp [hab.not_lt] at hcd \u22a2", "tactic_state": "case inl.inl\n\u03b1 : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Zero R\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : Zero R\ninst\u271d : Preorder \u03b1\nA : Matrix m m R\nB : Matrix m n R\nD : Matrix n n R\na b : \u03b1\nhab : a < b\nc d : m\nhcd : a < a\n\u22a2 A c d = 0\n---\ncase inl.inr\n\u03b1 : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Zero R\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : Zero R\ninst\u271d : Preorder \u03b1\nA : Matrix m m R\nB : Matrix m n R\nD : Matrix n n R\na b : \u03b1\nhab : a < b\nc : m\nd : n\nhcd : b < a\n\u22a2 B c d = 0\n---\ncase inr.inr\n\u03b1 : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Zero R\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : Zero R\ninst\u271d : Preorder \u03b1\nA : Matrix m m R\nB : Matrix m n R\nD : Matrix n n R\na b : \u03b1\nhab : a < b\nc d : n\nhcd : b < b\n\u22a2 D c d = 0"}]}
{"declaration": "theorem equiv_block_det (M : Matrix m m R) {p q : m \u2192 Prop} [DecidablePred p] [DecidablePred q]\n    (e : \u2200 x, q x \u2194 p x) : (toSquareBlockProp M p).det = (toSquareBlockProp M q).det := by\n  convert Matrix.det_reindex_self (Equiv.subtypeEquivRight e) (toSquareBlockProp M q)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Block.lean", "context": {"open": ["Finset Function OrderDual", "Matrix"], "variables": ["{\u03b1 \u03b2 m n o : Type*} {m' n' : \u03b1 \u2192 Type*}", "{R : Type v} {M N : Matrix m m R} {b : m \u2192 \u03b1}", "[LT \u03b1]", "[Zero R]", "[Preorder \u03b1]", "[Zero R]", "[DecidableEq m]", "[CommRing R] [DecidableEq m]", "[LinearOrder \u03b1]", "[CommRing R] [DecidableEq m] [Fintype m] [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_3\nR : Type v\ninst\u271d\u2079 inst\u271d\u2078 : Zero R\ninst\u271d\u2077 : DecidableEq m\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\nM : Matrix m m R\np q : m \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : \u2200 (x : m), q x \u2194 p x\n\u22a2 (M.toSquareBlockProp p).det = (M.toSquareBlockProp q).det"}, {"line": "convert Matrix.det_reindex_self (Equiv.subtypeEquivRight e) (toSquareBlockProp M q)", "tactic_state": "case convert_1\nm : Type u_3\nR : Type v\ninst\u271d\u2079 inst\u271d\u2078 : Zero R\ninst\u271d\u2077 : DecidableEq m\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\nM : Matrix m m R\np q : m \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : \u2200 (x : m), q x \u2194 p x\n\u22a2 DecidableEq { x // p x }\n---\ncase convert_2\nm : Type u_3\nR : Type v\ninst\u271d\u2079 inst\u271d\u2078 : Zero R\ninst\u271d\u2077 : DecidableEq m\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\nM : Matrix m m R\np q : m \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : \u2200 (x : m), q x \u2194 p x\n\u22a2 Fintype { x // p x }"}]}
{"declaration": "theorem dotProduct_self_star_pos_iff {v : n \u2192 R} : 0 < dotProduct v (star v) \u2194 v \u2260 0 := by\n  simpa using dotProduct_star_self_pos_iff (v := star v)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/DotProduct.lean", "context": {"open": [], "variables": ["{m n p R : Type*}", "[Semiring R] [Fintype n]", "[Semiring R] [PartialOrder R] [IsOrderedRing R] [Fintype n]", "[Fintype m] [Fintype n] [Fintype p]", "[PartialOrder R] [NonUnitalRing R] [StarRing R] [StarOrderedRing R]", "[NoZeroDivisors R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\nR : Type u_4\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : IsOrderedRing R\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype n\ninst\u271d : NoZeroDivisors R\nv : n \u2192 R\n\u22a2 0 < v \u2b1d\u1d65 sorry \u2194 v \u2260 0"}, {"line": "simpa using dotProduct_star_self_pos_iff (v := star v)", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma A_c_eq_zero {A : \u0394 m} (ha : A.1 1 0 = 0) : A.1 0 0 * A.1 1 1 = m := by\n  simpa only [det_fin_two,ha,mul_zero,sub_zero] using A.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/FixedDetMatrices.lean", "context": {"open": ["Matrix hiding mul_smul", "ModularGroup SpecialLinearGroup MatrixGroups"], "variables": ["(n : Type*) [DecidableEq n] [Fintype n] (R : Type*) [CommRing R]", "{m : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2124\nx\u271d : Sort u_3\n\u0394 : x\u271d\nA : sorry\nha : sorry = 0\n\u22a2 sorry * sorry = m"}, {"line": "simpa only [det_fin_two,ha,mul_zero,sub_zero] using A.2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma T_S_rel_smul (A : \u0394 m) : S \u2022 S \u2022 S \u2022 T \u2022 S \u2022 T \u2022 S \u2022 A = T\u207b\u00b9 \u2022 A := by\n  simp_rw [\u2190 T_S_rel, \u2190 smul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/FixedDetMatrices.lean", "context": {"open": ["Matrix hiding mul_smul", "ModularGroup SpecialLinearGroup MatrixGroups"], "variables": ["(n : Type*) [DecidableEq n] [Fintype n] (R : Type*) [CommRing R]", "{m : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\n\u0394 : x\u271d\nA : sorry\n\u22a2 S \u2022 S \u2022 S \u2022 T \u2022 S \u2022 T \u2022 S \u2022 A = T\u207b\u00b9 \u2022 A"}, {"line": "simp_rw [\u2190 T_S_rel, \u2190 smul_assoc]", "tactic_state": "x\u271d : Sort u_3\n\u0394 : x\u271d\nA : sorry\n\u22a2 S \u2022 S \u2022 S \u2022 T \u2022 S \u2022 T \u2022 S \u2022 A = ((((((S \u2022 S) \u2022 S) \u2022 T) \u2022 S) \u2022 T) \u2022 S) \u2022 A"}]}
{"declaration": "lemma isHermitian_diagonal_iff [DecidableEq n] {d : n \u2192 \u03b1} :\n    IsHermitian (diagonal d) \u2194 (\u2200 i : n, IsSelfAdjoint (d i)) := by\n  simp [isSelfAdjoint_iff, IsHermitian, conjTranspose, diagonal_transpose, diagonal_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Hermitian.lean", "context": {"open": ["scoped Matrix"], "variables": ["{\u03b1 \u03b2 : Type*} {m n : Type*} {A : Matrix n n \u03b1}", "[Star \u03b1] [Star \u03b2]", "[InvolutiveStar \u03b1]", "[AddMonoid \u03b1] [StarAddMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\ninst\u271d\u2074 : Star \u03b1\ninst\u271d\u00b3 : InvolutiveStar \u03b1\ninst\u271d\u00b2 : AddMonoid \u03b1\ninst\u271d\u00b9 : StarAddMonoid \u03b1\nx\u271d : Sort u_5\nIsHermitian : x\u271d\ninst\u271d : DecidableEq n\nd : n \u2192 \u03b1\n\u22a2 sorry \u2194 \u2200 (i : n), IsSelfAdjoint (d i)"}, {"line": "simp [isSelfAdjoint_iff, IsHermitian, conjTranspose, diagonal_transpose, diagonal_map]", "tactic_state": "\u03b1 : Type u_1\nn : Type u_4\ninst\u271d\u2074 : Star \u03b1\ninst\u271d\u00b3 : InvolutiveStar \u03b1\ninst\u271d\u00b2 : AddMonoid \u03b1\ninst\u271d\u00b9 : StarAddMonoid \u03b1\nx\u271d : Sort u_5\nIsHermitian : x\u271d\ninst\u271d : DecidableEq n\nd : n \u2192 \u03b1\n\u22a2 sorry () \u2194 \u2200 (i : n), star (d i) = d i"}]}
{"declaration": "theorem matrix_apply_stdBasisMatrix [DecidableEq n] {c : RingCon R} {i j : n} {x y : R} :\n    c.matrix n (Matrix.stdBasisMatrix i j x) (Matrix.stdBasisMatrix i j y) \u2194 c x y := by\n  refine \u27e8fun h \u21a6 by simpa using h i j, fun h i' j' \u21a6 ?_\u27e9\n  obtain hi | rfl := ne_or_eq i i'\n  \u00b7 simpa [hi] using c.refl 0\n  obtain hj | rfl := ne_or_eq j j'\n  \u00b7 simpa [hj] using c.refl _\n  simpa using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Ideal.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{R : Type*} [Semiring R]", "{R : Type*} [Ring R] {n : Type*} [Fintype n] [DecidableEq n]", "{R n : Type*}", "[NonUnitalNonAssocSemiring R] [Fintype n]", "(n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nn : Type u_5\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nc : RingCon R\ni j : n\nx y : R\n\u22a2 (RingCon.matrix n c) (stdBasisMatrix i j x) (stdBasisMatrix i j y) \u2194 c x y"}, {"line": "refine \u27e8fun h \u21a6 by simpa using h i j, fun h i' j' \u21a6 ?_\u27e9", "tactic_state": "R : Type u_4\nn : Type u_5\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nc : RingCon R\ni j : n\nx y : R\nh : c x y\ni' j' : n\n\u22a2 c (stdBasisMatrix i j x i' j') (stdBasisMatrix i j y i' j')"}, {"line": "obtain hi | rfl := ne_or_eq i i'", "tactic_state": "case inl\nR : Type u_4\nn : Type u_5\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nc : RingCon R\ni j : n\nx y : R\nh : c x y\ni' j' : n\nhi : i \u2260 i'\n\u22a2 c (stdBasisMatrix i j x i' j') (stdBasisMatrix i j y i' j')\n---\ncase inr\nR : Type u_4\nn : Type u_5\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nc : RingCon R\ni j : n\nx y : R\nh : c x y\nj' : n\n\u22a2 c (stdBasisMatrix i j x i j') (stdBasisMatrix i j y i j')"}, {"line": "\u00b7 simpa [hi] using c.refl 0", "tactic_state": "case inr\nR : Type u_4\nn : Type u_5\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nc : RingCon R\ni j : n\nx y : R\nh : c x y\nj' : n\n\u22a2 c (stdBasisMatrix i j x i j') (stdBasisMatrix i j y i j')"}, {"line": "obtain hj | rfl := ne_or_eq j j'", "tactic_state": "case inr.inl\nR : Type u_4\nn : Type u_5\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nc : RingCon R\ni j : n\nx y : R\nh : c x y\nj' : n\nhj : j \u2260 j'\n\u22a2 c (stdBasisMatrix i j x i j') (stdBasisMatrix i j y i j')\n---\ncase inr.inr\nR : Type u_4\nn : Type u_5\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nc : RingCon R\ni j : n\nx y : R\nh : c x y\n\u22a2 c (stdBasisMatrix i j x i j) (stdBasisMatrix i j y i j)"}, {"line": "\u00b7 simpa [hj] using c.refl _", "tactic_state": "case inr.inr\nR : Type u_4\nn : Type u_5\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nc : RingCon R\ni j : n\nx y : R\nh : c x y\n\u22a2 c (stdBasisMatrix i j x i j) (stdBasisMatrix i j y i j)"}, {"line": "simpa using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem jacobson_matricesOver (I : TwoSidedIdeal R) :\n    (I.matricesOver n).jacobson = I.jacobson.matricesOver n := by\n  apply le_antisymm\n  \u00b7 apply jacobson_matricesOver_le\n  \u00b7 show asIdeal (I.matricesOver n).jacobson \u2265 asIdeal (I.jacobson.matricesOver n)\n    simp [asIdeal_jacobson, asIdeal_matricesOver, Ideal.matricesOver_jacobson_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Ideal.lean", "context": {"open": ["Matrix", "Matrix", "Matrix", "Matrix", "Matrix", "Matrix"], "variables": ["{R : Type*} [Semiring R]", "{R : Type*} [Ring R] {n : Type*} [Fintype n] [DecidableEq n]", "{R n : Type*}", "[NonUnitalNonAssocSemiring R] [Fintype n]", "(n)", "{n}", "[NonAssocSemiring R] [Fintype n]", "{R : Type*} (n : Type*)", "[NonUnitalNonAssocRing R] [Fintype n]", "[NonAssocRing R] [Fintype n] [Nonempty n] [DecidableEq n]", "{n}", "[Ring R] [Fintype n]", "{R : Type*} [Ring R] {n : Type*} [Fintype n] [DecidableEq n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_8\ninst\u271d\u00b2 : Ring R\nn : Type u_9\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nI : TwoSidedIdeal R\n\u22a2 (TwoSidedIdeal.matricesOver n I).jacobson = TwoSidedIdeal.matricesOver n I.jacobson"}, {"line": "apply le_antisymm", "tactic_state": "case a\nR : Type u_8\ninst\u271d\u00b2 : Ring R\nn : Type u_9\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nI : TwoSidedIdeal R\n\u22a2 (TwoSidedIdeal.matricesOver n I).jacobson \u2264 TwoSidedIdeal.matricesOver n I.jacobson\n---\ncase a\nR : Type u_8\ninst\u271d\u00b2 : Ring R\nn : Type u_9\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nI : TwoSidedIdeal R\n\u22a2 TwoSidedIdeal.matricesOver n I.jacobson \u2264 (TwoSidedIdeal.matricesOver n I).jacobson"}, {"line": "\u00b7 apply jacobson_matricesOver_le", "tactic_state": "case a\nR : Type u_8\ninst\u271d\u00b2 : Ring R\nn : Type u_9\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nI : TwoSidedIdeal R\n\u22a2 TwoSidedIdeal.matricesOver n I.jacobson \u2264 (TwoSidedIdeal.matricesOver n I).jacobson"}, {"line": "\u00b7 show asIdeal (I.matricesOver n).jacobson \u2265 asIdeal (I.jacobson.matricesOver n)\n    simp [asIdeal_jacobson, asIdeal_matricesOver, Ideal.matricesOver_jacobson_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LDL.lowerInv_eq_gramSchmidtBasis :\n    LDL.lowerInv hS =\n      ((Pi.basisFun \ud835\udd5c n).toMatrix\n          (@gramSchmidtBasis \ud835\udd5c (n \u2192 \ud835\udd5c) _ (_ :) (InnerProductSpace.ofMatrix hS.transpose) n _ _ _\n            (Pi.basisFun \ud835\udd5c n)))\u1d40 := by\n  letI := NormedAddCommGroup.ofMatrix hS.transpose\n  letI := InnerProductSpace.ofMatrix hS.transpose\n  ext i j\n  rw [LDL.lowerInv]\n  rw [Basis.coePiBasisFun.toMatrix_eq_transpose]\n  rw [coe_gramSchmidtBasis]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/LDL.lean", "context": {"open": ["Matrix", "scoped Matrix ComplexOrder"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{n : Type*} [LinearOrder n] [WellFoundedLT n] [LocallyFiniteOrderBot n]", "{S : Matrix n n \ud835\udd5c} [Fintype n] (hS : S.PosDef)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nn : Type u_2\ninst\u271d\u00b3 : LinearOrder n\ninst\u271d\u00b2 : WellFoundedLT n\ninst\u271d\u00b9 : LocallyFiniteOrderBot n\nS : Matrix n n \ud835\udd5c\ninst\u271d : Fintype n\nhS : S.PosDef\n\u22a2 lowerInv hS = ((Pi.basisFun \ud835\udd5c n).toMatrix \u21d1(gramSchmidtBasis (Pi.basisFun \ud835\udd5c n))).transpose"}, {"line": "letI := NormedAddCommGroup.ofMatrix hS.transpose", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nn : Type u_2\ninst\u271d\u00b3 : LinearOrder n\ninst\u271d\u00b2 : WellFoundedLT n\ninst\u271d\u00b9 : LocallyFiniteOrderBot n\nS : Matrix n n \ud835\udd5c\ninst\u271d : Fintype n\nhS : S.PosDef\nthis : NormedAddCommGroup (n \u2192 \ud835\udd5c) := sorry\n\u22a2 lowerInv hS = ((Pi.basisFun \ud835\udd5c n).toMatrix \u21d1(gramSchmidtBasis (Pi.basisFun \ud835\udd5c n))).transpose"}, {"line": "letI := InnerProductSpace.ofMatrix hS.transpose", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nn : Type u_2\ninst\u271d\u00b3 : LinearOrder n\ninst\u271d\u00b2 : WellFoundedLT n\ninst\u271d\u00b9 : LocallyFiniteOrderBot n\nS : Matrix n n \ud835\udd5c\ninst\u271d : Fintype n\nhS : S.PosDef\nthis\u271d : NormedAddCommGroup (n \u2192 \ud835\udd5c) := sorry\nthis : InnerProductSpace \ud835\udd5c (n \u2192 \ud835\udd5c) := sorry\n\u22a2 lowerInv hS = ((Pi.basisFun \ud835\udd5c n).toMatrix \u21d1(gramSchmidtBasis (Pi.basisFun \ud835\udd5c n))).transpose"}, {"line": "ext i j", "tactic_state": "case a\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nn : Type u_2\ninst\u271d\u00b3 : LinearOrder n\ninst\u271d\u00b2 : WellFoundedLT n\ninst\u271d\u00b9 : LocallyFiniteOrderBot n\nS : Matrix n n \ud835\udd5c\ninst\u271d : Fintype n\nhS : S.PosDef\nthis\u271d : NormedAddCommGroup (n \u2192 \ud835\udd5c) := sorry\nthis : InnerProductSpace \ud835\udd5c (n \u2192 \ud835\udd5c) := sorry\ni j : n\n\u22a2 lowerInv hS i j = ((Pi.basisFun \ud835\udd5c n).toMatrix \u21d1(gramSchmidtBasis (Pi.basisFun \ud835\udd5c n))).transpose i j"}, {"line": "rw [LDL.lowerInv]", "tactic_state": "case a\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nn : Type u_2\ninst\u271d\u00b3 : LinearOrder n\ninst\u271d\u00b2 : WellFoundedLT n\ninst\u271d\u00b9 : LocallyFiniteOrderBot n\nS : Matrix n n \ud835\udd5c\ninst\u271d : Fintype n\nhS : S.PosDef\nthis\u271d : NormedAddCommGroup (n \u2192 \ud835\udd5c) := sorry\nthis : InnerProductSpace \ud835\udd5c (n \u2192 \ud835\udd5c) := sorry\ni j : n\n\u22a2 gramSchmidt \ud835\udd5c (\u21d1(Pi.basisFun \ud835\udd5c n)) i j =\n    ((Pi.basisFun \ud835\udd5c n).toMatrix \u21d1(gramSchmidtBasis (Pi.basisFun \ud835\udd5c n))).transpose i j"}, {"line": "rw [Basis.coePiBasisFun.toMatrix_eq_transpose]", "tactic_state": "case a\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nn : Type u_2\ninst\u271d\u00b3 : LinearOrder n\ninst\u271d\u00b2 : WellFoundedLT n\ninst\u271d\u00b9 : LocallyFiniteOrderBot n\nS : Matrix n n \ud835\udd5c\ninst\u271d : Fintype n\nhS : S.PosDef\nthis\u271d : NormedAddCommGroup (n \u2192 \ud835\udd5c) := sorry\nthis : InnerProductSpace \ud835\udd5c (n \u2192 \ud835\udd5c) := sorry\ni j : n\n\u22a2 gramSchmidt \ud835\udd5c (\u21d1(Pi.basisFun \ud835\udd5c n)) i j = (transpose \u21d1(gramSchmidtBasis (Pi.basisFun \ud835\udd5c n))).transpose i j"}, {"line": "rw [coe_gramSchmidtBasis]", "tactic_state": "case a\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nn : Type u_2\ninst\u271d\u00b3 : LinearOrder n\ninst\u271d\u00b2 : WellFoundedLT n\ninst\u271d\u00b9 : LocallyFiniteOrderBot n\nS : Matrix n n \ud835\udd5c\ninst\u271d : Fintype n\nhS : S.PosDef\nthis\u271d : NormedAddCommGroup (n \u2192 \ud835\udd5c) := sorry\nthis : InnerProductSpace \ud835\udd5c (n \u2192 \ud835\udd5c) := sorry\ni j : n\n\u22a2 gramSchmidt \ud835\udd5c (\u21d1(Pi.basisFun \ud835\udd5c n)) i j = (transpose (gramSchmidt \ud835\udd5c \u21d1(Pi.basisFun \ud835\udd5c n))).transpose i j"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma transpose_permMatrix [Zero R] [One R] : (\u03c3.permMatrix R).transpose = (\u03c3\u207b\u00b9).permMatrix R := by\n  rw [\u2190 PEquiv.toMatrix_symm]\n  rw [\u2190 Equiv.toPEquiv_symm]\n  rw [\u2190 Equiv.Perm.inv_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Permutation.lean", "context": {"open": ["Equiv"], "variables": ["{n R : Type*} [DecidableEq n] (\u03c3 : Perm n)", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq n\n\u03c3 : Perm n\ninst\u271d\u00b9 : Zero R\ninst\u271d : One R\n\u22a2 (Perm.permMatrix R \u03c3).transpose = Perm.permMatrix R \u03c3\u207b\u00b9"}, {"line": "rw [\u2190 PEquiv.toMatrix_symm]", "tactic_state": "n : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq n\n\u03c3 : Perm n\ninst\u271d\u00b9 : Zero R\ninst\u271d : One R\n\u22a2 (toPEquiv \u03c3).symm.toMatrix = Perm.permMatrix R \u03c3\u207b\u00b9\n---\nn : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq n\n\u03c3 : Perm n\ninst\u271d\u00b9 : Zero R\ninst\u271d : One R\n\u22a2 DecidableEq n"}, {"line": "rw [\u2190 Equiv.toPEquiv_symm]", "tactic_state": "n : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq n\n\u03c3 : Perm n\ninst\u271d\u00b9 : Zero R\ninst\u271d : One R\n\u22a2 (Equiv.symm \u03c3).toPEquiv.toMatrix = Perm.permMatrix R \u03c3\u207b\u00b9\n---\nn : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq n\n\u03c3 : Perm n\ninst\u271d\u00b9 : Zero R\ninst\u271d : One R\n\u22a2 DecidableEq n"}, {"line": "rw [\u2190 Equiv.Perm.inv_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PosSemidef.dotProduct_mulVec_zero_iff\n    {A : Matrix n n \ud835\udd5c} (hA : PosSemidef A) (x : n \u2192 \ud835\udd5c) :\n    star x \u2b1d\u1d65 A *\u1d65 x = 0 \u2194 A *\u1d65 x = 0 := by\n  constructor\n  \u00b7 obtain \u27e8B, rfl\u27e9 := posSemidef_iff_eq_transpose_mul_self.mp hA\n    rw [\u2190 Matrix.mulVec_mulVec]\n    rw [dotProduct_mulVec]\n    rw [vecMul_conjTranspose]\n    rw [star_star]\n    rw [dotProduct_star_self_eq_zero]\n    intro h0\n    rw [h0]\n    rw [mulVec_zero]\n  \u00b7 intro h0\n    rw [h0]\n    rw [dotProduct_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/PosDef.lean", "context": {"open": ["scoped ComplexOrder", "scoped Matrix", "Lean PrettyPrinter.Delaborator SubExpr in"], "variables": ["{m n R \ud835\udd5c : Type*}", "[Fintype m] [Fintype n]", "[CommRing R] [PartialOrder R] [StarRing R]", "[RCLike \ud835\udd5c]", "[DecidableEq n] {A : Matrix n n \ud835\udd5c} (hA : PosSemidef A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type ?u.1295\nn\u271d : Type u_1\nR : Type ?u.1301\n\ud835\udd5c\u271d : Type u_2\nPosSemidef : ?m.1292\ninst\u271d\u2079 : Fintype m\ninst\u271d\u2078 : Fintype n\u271d\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : RCLike \ud835\udd5c\u271d\ninst\u271d\u00b3 : DecidableEq n\u271d\nA\u271d : Matrix n\u271d n\u271d \ud835\udd5c\u271d\nhA\u271d : sorry\nn : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : DecidableEq n\nA : Matrix n n \ud835\udd5c\nhA : sorry\nx : n \u2192 \ud835\udd5c\n\u22a2 star x \u2b1d\u1d65 A.mulVec x = 0 \u2194 A.mulVec x = 0"}, {"line": "constructor", "tactic_state": "case mp\nm : Type ?u.1295\nn\u271d : Type u_1\nR : Type ?u.1301\n\ud835\udd5c\u271d : Type u_2\nPosSemidef : ?m.1292\ninst\u271d\u2079 : Fintype m\ninst\u271d\u2078 : Fintype n\u271d\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : RCLike \ud835\udd5c\u271d\ninst\u271d\u00b3 : DecidableEq n\u271d\nA\u271d : Matrix n\u271d n\u271d \ud835\udd5c\u271d\nhA\u271d : sorry\nn : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : DecidableEq n\nA : Matrix n n \ud835\udd5c\nhA : sorry\nx : n \u2192 \ud835\udd5c\n\u22a2 star x \u2b1d\u1d65 A.mulVec x = 0 \u2192 A.mulVec x = 0\n---\ncase mpr\nm : Type ?u.1295\nn\u271d : Type u_1\nR : Type ?u.1301\n\ud835\udd5c\u271d : Type u_2\nPosSemidef : ?m.1292\ninst\u271d\u2079 : Fintype m\ninst\u271d\u2078 : Fintype n\u271d\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : RCLike \ud835\udd5c\u271d\ninst\u271d\u00b3 : DecidableEq n\u271d\nA\u271d : Matrix n\u271d n\u271d \ud835\udd5c\u271d\nhA\u271d : sorry\nn : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : DecidableEq n\nA : Matrix n n \ud835\udd5c\nhA : sorry\nx : n \u2192 \ud835\udd5c\n\u22a2 A.mulVec x = 0 \u2192 star x \u2b1d\u1d65 A.mulVec x = 0"}, {"line": "\u00b7 obtain \u27e8B, rfl\u27e9 := posSemidef_iff_eq_transpose_mul_self.mp hA\n    rw [\u2190 Matrix.mulVec_mulVec]\n    rw [dotProduct_mulVec]\n    rw [vecMul_conjTranspose]\n    rw [star_star]\n    rw [dotProduct_star_self_eq_zero]\n    intro h0\n    rw [h0]\n    rw [mulVec_zero]", "tactic_state": "case mpr\nm : Type ?u.1295\nn\u271d : Type u_1\nR : Type ?u.1301\n\ud835\udd5c\u271d : Type u_2\nPosSemidef : ?m.1292\ninst\u271d\u2079 : Fintype m\ninst\u271d\u2078 : Fintype n\u271d\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : RCLike \ud835\udd5c\u271d\ninst\u271d\u00b3 : DecidableEq n\u271d\nA\u271d : Matrix n\u271d n\u271d \ud835\udd5c\u271d\nhA\u271d : sorry\nn : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : DecidableEq n\nA : Matrix n n \ud835\udd5c\nhA : sorry\nx : n \u2192 \ud835\udd5c\n\u22a2 A.mulVec x = 0 \u2192 star x \u2b1d\u1d65 A.mulVec x = 0"}, {"line": "\u00b7 intro h0\n    rw [h0]\n    rw [dotProduct_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PosSemidef.toLinearMap\u2082'_zero_iff [DecidableEq n]\n    {A : Matrix n n \ud835\udd5c} (hA : PosSemidef A) (x : n \u2192 \ud835\udd5c) :\n    Matrix.toLinearMap\u2082' \ud835\udd5c A (star x) x = 0 \u2194 Matrix.toLin' A x = 0 := by\n  simpa only [toLinearMap\u2082'_apply',toLin'_apply] using hA.dotProduct_mulVec_zero_iff x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/PosDef.lean", "context": {"open": ["scoped ComplexOrder", "scoped Matrix", "Lean PrettyPrinter.Delaborator SubExpr in"], "variables": ["{m n R \ud835\udd5c : Type*}", "[Fintype m] [Fintype n]", "[CommRing R] [PartialOrder R] [StarRing R]", "[RCLike \ud835\udd5c]", "[DecidableEq n] {A : Matrix n n \ud835\udd5c} (hA : PosSemidef A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type ?u.1295\nn\u271d : Type u_1\nR : Type ?u.1301\n\ud835\udd5c\u271d : Type u_2\nPosSemidef : ?m.1292\ninst\u271d\u00b9\u2070 : Fintype m\ninst\u271d\u2079 : Fintype n\u271d\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : StarRing R\ninst\u271d\u2075 : RCLike \ud835\udd5c\u271d\ninst\u271d\u2074 : DecidableEq n\u271d\nA\u271d : Matrix n\u271d n\u271d \ud835\udd5c\u271d\nhA\u271d : sorry\nn : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 inst\u271d : DecidableEq n\nA : Matrix n n \ud835\udd5c\nhA : sorry\nx : n \u2192 \ud835\udd5c\n\u22a2 sorry = 0 \u2194 (Matrix.toLin' A) x = 0"}, {"line": "simpa only [toLinearMap\u2082'_apply',toLin'_apply] using hA.dotProduct_mulVec_zero_iff x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_selfAdjointMatricesSubmodule :\n    A\u2081 \u2208 selfAdjointMatricesSubmodule J \u2194 J.IsSelfAdjoint A\u2081 := by\n  erw [mem_pairSelfAdjointMatricesSubmodule]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/SesquilinearForm.lean", "context": {"open": ["Finset LinearMap Matrix", "Matrix", "scoped RightActions", "Matrix"], "variables": ["{R R\u2081 S\u2081 R\u2082 S\u2082 M\u2081 M\u2082 M\u2081' M\u2082' N\u2082 n m n' m' \u03b9 : Type*}", "[Semiring R\u2081] [Semiring S\u2081] [Semiring R\u2082] [Semiring S\u2082] [AddCommMonoid N\u2082]", "[Fintype n] [Fintype m]", "(\u03c3\u2081 : R\u2081 \u2192+* S\u2081) (\u03c3\u2082 : R\u2082 \u2192+* S\u2082)", "[DecidableEq n] [DecidableEq m]", "[CommSemiring R] [Semiring R\u2081] [Semiring S\u2081] [Semiring R\u2082] [Semiring S\u2082]", "[AddCommMonoid M\u2081] [Module R\u2081 M\u2081] [AddCommMonoid M\u2082] [Module R\u2082 M\u2082] [AddCommMonoid N\u2082]", "{\u03c3\u2081 : R\u2081 \u2192+* S\u2081} {\u03c3\u2082 : R\u2082 \u2192+* S\u2082}", "(R)", "[Fintype n] [Fintype m]", "[DecidableEq n] [DecidableEq m]", "[CommSemiring R] [AddCommMonoid N\u2082] [Module R N\u2082] [Semiring R\u2081] [Semiring R\u2082]", "{\u03c3\u2081 : R\u2081 \u2192+* S\u2081} {\u03c3\u2082 : R\u2082 \u2192+* S\u2082}", "[Fintype n] [Fintype m]", "[DecidableEq n] [DecidableEq m]", "(R)", "(\u03c3\u2081 \u03c3\u2082)", "{R}", "{R : Type*} [CommSemiring R]", "[Fintype n] [Fintype m]", "[DecidableEq n] [DecidableEq m]", "[Fintype n'] [Fintype m']", "[DecidableEq n'] [DecidableEq m']", "[CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082] [AddCommMonoid N\u2082]", "[DecidableEq n] [Fintype n]", "[DecidableEq m] [Fintype m]", "(b\u2081 : Basis n R M\u2081) (b\u2082 : Basis m R M\u2082)", "(b\u2081 : Basis n R M\u2081) (b\u2082 : Basis m R M\u2082)", "[AddCommMonoid M\u2081'] [Module R M\u2081']", "[AddCommMonoid M\u2082'] [Module R M\u2082']", "(b\u2081' : Basis n' R M\u2081')", "(b\u2082' : Basis m' R M\u2082')", "[Fintype n'] [Fintype m']", "[DecidableEq n'] [DecidableEq m']", "[CommRing R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "[Fintype n] [Fintype n']", "(b\u2081 : Basis n R M\u2081) (b\u2082 : Basis n' R M\u2082)", "(J J\u2082 : Matrix n n R) (J' : Matrix n' n' R)", "(A : Matrix n' n R) (A' : Matrix n n' R)", "(A\u2081 A\u2082 : Matrix n n R)", "[DecidableEq n] [DecidableEq n']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_11\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq n\ninst\u271d\u00b9\u00b2 : Fintype n\ninst\u271d\u00b9\u00b9 : DecidableEq n\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\nR : Type u_16\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Fintype n\nJ A\u2081 : Matrix n n R\ninst\u271d : DecidableEq n\n\u22a2 A\u2081 \u2208 selfAdjointMatricesSubmodule J \u2194 J.IsSelfAdjoint A\u2081"}, {"line": "erw [mem_pairSelfAdjointMatricesSubmodule]", "tactic_state": "n : Type u_11\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq n\ninst\u271d\u00b9\u00b2 : Fintype n\ninst\u271d\u00b9\u00b9 : DecidableEq n\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\nR : Type u_16\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Fintype n\nJ A\u2081 : Matrix n n R\ninst\u271d : DecidableEq n\n\u22a2 J.IsAdjointPair J A\u2081 A\u2081 \u2194 J.IsSelfAdjoint A\u2081"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_skewAdjointMatricesSubmodule :\n    A\u2081 \u2208 skewAdjointMatricesSubmodule J \u2194 J.IsSkewAdjoint A\u2081 := by\n  erw [mem_pairSelfAdjointMatricesSubmodule]\n  simp [Matrix.IsSkewAdjoint, Matrix.IsAdjointPair]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/SesquilinearForm.lean", "context": {"open": ["Finset LinearMap Matrix", "Matrix", "scoped RightActions", "Matrix"], "variables": ["{R R\u2081 S\u2081 R\u2082 S\u2082 M\u2081 M\u2082 M\u2081' M\u2082' N\u2082 n m n' m' \u03b9 : Type*}", "[Semiring R\u2081] [Semiring S\u2081] [Semiring R\u2082] [Semiring S\u2082] [AddCommMonoid N\u2082]", "[Fintype n] [Fintype m]", "(\u03c3\u2081 : R\u2081 \u2192+* S\u2081) (\u03c3\u2082 : R\u2082 \u2192+* S\u2082)", "[DecidableEq n] [DecidableEq m]", "[CommSemiring R] [Semiring R\u2081] [Semiring S\u2081] [Semiring R\u2082] [Semiring S\u2082]", "[AddCommMonoid M\u2081] [Module R\u2081 M\u2081] [AddCommMonoid M\u2082] [Module R\u2082 M\u2082] [AddCommMonoid N\u2082]", "{\u03c3\u2081 : R\u2081 \u2192+* S\u2081} {\u03c3\u2082 : R\u2082 \u2192+* S\u2082}", "(R)", "[Fintype n] [Fintype m]", "[DecidableEq n] [DecidableEq m]", "[CommSemiring R] [AddCommMonoid N\u2082] [Module R N\u2082] [Semiring R\u2081] [Semiring R\u2082]", "{\u03c3\u2081 : R\u2081 \u2192+* S\u2081} {\u03c3\u2082 : R\u2082 \u2192+* S\u2082}", "[Fintype n] [Fintype m]", "[DecidableEq n] [DecidableEq m]", "(R)", "(\u03c3\u2081 \u03c3\u2082)", "{R}", "{R : Type*} [CommSemiring R]", "[Fintype n] [Fintype m]", "[DecidableEq n] [DecidableEq m]", "[Fintype n'] [Fintype m']", "[DecidableEq n'] [DecidableEq m']", "[CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082] [AddCommMonoid N\u2082]", "[DecidableEq n] [Fintype n]", "[DecidableEq m] [Fintype m]", "(b\u2081 : Basis n R M\u2081) (b\u2082 : Basis m R M\u2082)", "(b\u2081 : Basis n R M\u2081) (b\u2082 : Basis m R M\u2082)", "[AddCommMonoid M\u2081'] [Module R M\u2081']", "[AddCommMonoid M\u2082'] [Module R M\u2082']", "(b\u2081' : Basis n' R M\u2081')", "(b\u2082' : Basis m' R M\u2082')", "[Fintype n'] [Fintype m']", "[DecidableEq n'] [DecidableEq m']", "[CommRing R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "[Fintype n] [Fintype n']", "(b\u2081 : Basis n R M\u2081) (b\u2082 : Basis n' R M\u2082)", "(J J\u2082 : Matrix n n R) (J' : Matrix n' n' R)", "(A : Matrix n' n R) (A' : Matrix n n' R)", "(A\u2081 A\u2082 : Matrix n n R)", "[DecidableEq n] [DecidableEq n']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_11\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq n\ninst\u271d\u00b9\u00b2 : Fintype n\ninst\u271d\u00b9\u00b9 : DecidableEq n\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\nR : Type u_16\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Fintype n\nJ A\u2081 : Matrix n n R\ninst\u271d : DecidableEq n\n\u22a2 A\u2081 \u2208 skewAdjointMatricesSubmodule J \u2194 J.IsSkewAdjoint A\u2081"}, {"line": "erw [mem_pairSelfAdjointMatricesSubmodule]", "tactic_state": "n : Type u_11\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq n\ninst\u271d\u00b9\u00b2 : Fintype n\ninst\u271d\u00b9\u00b9 : DecidableEq n\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\nR : Type u_16\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Fintype n\nJ A\u2081 : Matrix n n R\ninst\u271d : DecidableEq n\n\u22a2 (-J).IsAdjointPair J A\u2081 A\u2081 \u2194 J.IsSkewAdjoint A\u2081"}, {"line": "simp [Matrix.IsSkewAdjoint, Matrix.IsAdjointPair]", "tactic_state": "n : Type u_11\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq n\ninst\u271d\u00b9\u00b2 : Fintype n\ninst\u271d\u00b9\u00b9 : DecidableEq n\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq n\nR : Type u_16\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Fintype n\nJ A\u2081 : Matrix n n R\ninst\u271d : DecidableEq n\n\u22a2 A\u2081.transpose * J = -J * A\u2081 \u2194 A\u2081.transpose * J = J * -A\u2081"}]}
{"declaration": "theorem separatingLeft_toLinearMap\u2082'_iff_det_ne_zero {M : Matrix \u03b9 \u03b9 R\u2081} :\n    (Matrix.toLinearMap\u2082' R\u2081 M).SeparatingLeft (R := R\u2081) \u2194 M.det \u2260 0 := by\n  rw [Matrix.separatingLeft_toLinearMap\u2082'_iff]\n  rw [Matrix.nondegenerate_iff_det_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/SesquilinearForm.lean", "context": {"open": ["Finset LinearMap Matrix", "Matrix", "scoped RightActions", "Matrix", "Matrix"], "variables": ["{R R\u2081 S\u2081 R\u2082 S\u2082 M\u2081 M\u2082 M\u2081' M\u2082' N\u2082 n m n' m' \u03b9 : Type*}", "[Semiring R\u2081] [Semiring S\u2081] [Semiring R\u2082] [Semiring S\u2082] [AddCommMonoid N\u2082]", "[Fintype n] [Fintype m]", "(\u03c3\u2081 : R\u2081 \u2192+* S\u2081) (\u03c3\u2082 : R\u2082 \u2192+* S\u2082)", "[DecidableEq n] [DecidableEq m]", "[CommSemiring R] [Semiring R\u2081] [Semiring S\u2081] [Semiring R\u2082] [Semiring S\u2082]", "[AddCommMonoid M\u2081] [Module R\u2081 M\u2081] [AddCommMonoid M\u2082] [Module R\u2082 M\u2082] [AddCommMonoid N\u2082]", "{\u03c3\u2081 : R\u2081 \u2192+* S\u2081} {\u03c3\u2082 : R\u2082 \u2192+* S\u2082}", "(R)", "[Fintype n] [Fintype m]", "[DecidableEq n] [DecidableEq m]", "[CommSemiring R] [AddCommMonoid N\u2082] [Module R N\u2082] [Semiring R\u2081] [Semiring R\u2082]", "{\u03c3\u2081 : R\u2081 \u2192+* S\u2081} {\u03c3\u2082 : R\u2082 \u2192+* S\u2082}", "[Fintype n] [Fintype m]", "[DecidableEq n] [DecidableEq m]", "(R)", "(\u03c3\u2081 \u03c3\u2082)", "{R}", "{R : Type*} [CommSemiring R]", "[Fintype n] [Fintype m]", "[DecidableEq n] [DecidableEq m]", "[Fintype n'] [Fintype m']", "[DecidableEq n'] [DecidableEq m']", "[CommSemiring R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082] [AddCommMonoid N\u2082]", "[DecidableEq n] [Fintype n]", "[DecidableEq m] [Fintype m]", "(b\u2081 : Basis n R M\u2081) (b\u2082 : Basis m R M\u2082)", "(b\u2081 : Basis n R M\u2081) (b\u2082 : Basis m R M\u2082)", "[AddCommMonoid M\u2081'] [Module R M\u2081']", "[AddCommMonoid M\u2082'] [Module R M\u2082']", "(b\u2081' : Basis n' R M\u2081')", "(b\u2082' : Basis m' R M\u2082')", "[Fintype n'] [Fintype m']", "[DecidableEq n'] [DecidableEq m']", "[CommRing R]", "[AddCommMonoid M\u2081] [Module R M\u2081] [AddCommMonoid M\u2082] [Module R M\u2082]", "[Fintype n] [Fintype n']", "(b\u2081 : Basis n R M\u2081) (b\u2082 : Basis n' R M\u2082)", "(J J\u2082 : Matrix n n R) (J' : Matrix n' n' R)", "(A : Matrix n' n R) (A' : Matrix n n' R)", "(A\u2081 A\u2082 : Matrix n n R)", "[DecidableEq n] [DecidableEq n']", "[CommRing R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]", "[DecidableEq \u03b9] [Fintype \u03b9]", "[IsDomain R\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2081 : Type u_2\n\u03b9 : Type u_15\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : Semiring R\u2081\ninst\u271d\u00b3 : CommRing R\u2081\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : IsDomain R\u2081\nM : Matrix \u03b9 \u03b9 R\u2081\n\u22a2 ((toLinearMap\u2082' R\u2081) M).SeparatingLeft \u2194 M.det \u2260 0"}, {"line": "rw [Matrix.separatingLeft_toLinearMap\u2082'_iff]", "tactic_state": "R\u2081 : Type u_2\n\u03b9 : Type u_15\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : Semiring R\u2081\ninst\u271d\u00b3 : CommRing R\u2081\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : IsDomain R\u2081\nM : Matrix \u03b9 \u03b9 R\u2081\n\u22a2 M.Nondegenerate \u2194 M.det \u2260 0"}, {"line": "rw [Matrix.nondegenerate_iff_det_ne_zero]", "tactic_state": "R\u2081 : Type u_2\n\u03b9 : Type u_15\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : Semiring R\u2081\ninst\u271d\u00b3 : CommRing R\u2081\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : IsDomain R\u2081\nM : Matrix \u03b9 \u03b9 R\u2081\n\u22a2 IsDomain R\u2081"}]}
{"declaration": "lemma mulVecSL {v : Fin 2 \u2192 R} (hab : IsCoprime (v 0) (v 1)) (A : SL(2, R)) :\n    IsCoprime ((A.1 *\u1d65 v) 0) ((A.1 *\u1d65 v) 1) := by\n  simpa only [\u2190 vecMul_transpose] using hab.vecMulSL A.transpose\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "context": {"open": ["LinearMap", "Subgroup", "scoped Classical in", "scoped MatrixGroups", "Matrix MatrixGroups SpecialLinearGroup"], "variables": ["(n : Type u) [DecidableEq n] [Fintype n] (R : Type v) [CommRing R]", "{n : Type u} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R]", "(A B : SpecialLinearGroup n R)", "{S : Type*} [CommRing S]", "[Fact (Even (Fintype.card n))]", "{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d : CommRing R\nv : Fin 2 \u2192 R\nhab : IsCoprime (v 0) (v 1)\nA : SpecialLinearGroup (Fin 2) R\n\u22a2 IsCoprime ((\u2191A).mulVec v 0) ((\u2191A).mulVec v 1)"}, {"line": "simpa only [\u2190 vecMul_transpose] using hab.vecMulSL A.transpose", "tactic_state": "No Goals!"}]}
{"declaration": "theorem T_pow_mul_apply_one (n : \u2124) (g : SL(2, \u2124)) : (T ^ n * g) 1 = g 1 := by\n  ext j\n  simp [coe_T_zpow, Matrix.vecMul, dotProduct, Fin.sum_univ_succ, vecTail]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "context": {"open": ["LinearMap", "Subgroup", "scoped Classical in", "scoped MatrixGroups", "Matrix MatrixGroups SpecialLinearGroup", "MatrixGroups", "Matrix Matrix.SpecialLinearGroup"], "variables": ["(n : Type u) [DecidableEq n] [Fintype n] (R : Type v) [CommRing R]", "{n : Type u} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R]", "(A B : SpecialLinearGroup n R)", "{S : Type*} [CommRing S]", "[Fact (Even (Fintype.card n))]", "{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : SpecialLinearGroup (Fin 2) \u2124\nn : \u2124\ng : SpecialLinearGroup (Fin 2) \u2124\n\u22a2 \u2191(T ^ n * g) 1 = \u2191g 1"}, {"line": "ext j", "tactic_state": "case h\nT : SpecialLinearGroup (Fin 2) \u2124\nn : \u2124\ng : SpecialLinearGroup (Fin 2) \u2124\nj : Fin 2\n\u22a2 \u2191(T ^ n * g) 1 j = \u2191g 1 j"}, {"line": "simp [coe_T_zpow, Matrix.vecMul, dotProduct, Fin.sum_univ_succ, vecTail]", "tactic_state": "case h\nT : SpecialLinearGroup (Fin 2) \u2124\nn : \u2124\ng : SpecialLinearGroup (Fin 2) \u2124\nj : Fin 2\n\u22a2 (\u2191(T ^ n) * \u2191g) 1 j = \u2191g 1 j"}]}
{"declaration": "theorem T_mul_apply_one (g : SL(2, \u2124)) : (T * g) 1 = g 1 := by\n  simpa using T_pow_mul_apply_one 1 g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "context": {"open": ["LinearMap", "Subgroup", "scoped Classical in", "scoped MatrixGroups", "Matrix MatrixGroups SpecialLinearGroup", "MatrixGroups", "Matrix Matrix.SpecialLinearGroup"], "variables": ["(n : Type u) [DecidableEq n] [Fintype n] (R : Type v) [CommRing R]", "{n : Type u} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R]", "(A B : SpecialLinearGroup n R)", "{S : Type*} [CommRing S]", "[Fact (Even (Fintype.card n))]", "{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T g : SpecialLinearGroup (Fin 2) \u2124\n\u22a2 \u2191(T * g) 1 = \u2191g 1"}, {"line": "simpa using T_pow_mul_apply_one 1 g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem T_inv_mul_apply_one (g : SL(2, \u2124)) : (T\u207b\u00b9 * g) 1 = g 1 := by\n  simpa using T_pow_mul_apply_one (-1) g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "context": {"open": ["LinearMap", "Subgroup", "scoped Classical in", "scoped MatrixGroups", "Matrix MatrixGroups SpecialLinearGroup", "MatrixGroups", "Matrix Matrix.SpecialLinearGroup"], "variables": ["(n : Type u) [DecidableEq n] [Fintype n] (R : Type v) [CommRing R]", "{n : Type u} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R]", "(A B : SpecialLinearGroup n R)", "{S : Type*} [CommRing S]", "[Fact (Even (Fintype.card n))]", "{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T g : SpecialLinearGroup (Fin 2) \u2124\n\u22a2 \u2191(T\u207b\u00b9 * g) 1 = \u2191g 1"}, {"line": "simpa using T_pow_mul_apply_one (-1) g", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mulVec_eigenvectorBasis (j : n) :\n    A *\u1d65 \u21d1(hA.eigenvectorBasis j) = (hA.eigenvalues j) \u2022 \u21d1(hA.eigenvectorBasis j) := by\n  simpa only [eigenvectorBasis,OrthonormalBasis.reindex_apply,toEuclideanLin_apply,RCLike.real_smul_eq_coe_smul (K := \ud835\udd5c)] using\n      congr(\u21d1$((isHermitian_iff_isSymmetric.1 hA).apply_eigenvectorBasis\n        finrank_euclideanSpace ((Fintype.equivOfCardEq (Fintype.card_fin _)).symm j)))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Spectrum.lean", "context": {"open": [], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {n : Type*} [Fintype n]", "{A : Matrix n n \ud835\udd5c}", "[DecidableEq n]", "(hA : A.IsHermitian)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nn : Type u_2\ninst\u271d\u00b9 : Fintype n\nA : Matrix n n \ud835\udd5c\ninst\u271d : DecidableEq n\nhA : A.IsHermitian\nj : n\n\u22a2 A * sorry = hA.eigenvalues j \u2022 (WithLp.equiv 2 ((i : n) \u2192 (fun x => \ud835\udd5c) i)) (hA.eigenvectorBasis j)"}, {"line": "simpa only [eigenvectorBasis,OrthonormalBasis.reindex_apply,toEuclideanLin_apply,RCLike.real_smul_eq_coe_smul (K := \ud835\udd5c)] using\n      congr(\u21d1$((isHermitian_iff_isSymmetric.1 hA).apply_eigenvectorBasis\n        finrank_euclideanSpace ((Fintype.equivOfCardEq (Fintype.card_fin _)).symm j)))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem matrix_apply (b : Basis \u03b9 R M) (i : m) (j : n) (k : \u03b9) [DecidableEq m] [DecidableEq n] :\n    b.matrix m n (i, j, k) = Matrix.stdBasisMatrix i j (b k) := by\n  simp [Basis.matrix, Matrix.stdBasisMatrix_eq_of_single_single]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/StdBasis.lean", "context": {"open": [], "variables": ["{\u03b9 R M : Type*} (m n : Type*)", "[Fintype m] [Fintype n] [Semiring R] [AddCommMonoid M] [Module R M]", "{n m}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d\u2076 : Fintype m\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ni : m\nj : n\nk : \u03b9\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq n\n\u22a2 (Basis.matrix m n b) (i, j, k) = Matrix.stdBasisMatrix i j (b k)"}, {"line": "simp [Basis.matrix, Matrix.stdBasisMatrix_eq_of_single_single]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d\u2076 : Fintype m\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nb : Basis \u03b9 R M\ni : m\nj : n\nk : \u03b9\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq n\n\u22a2 (Pi.basis fun x => Pi.basis fun x => b) \u27e8i, \u27e8j, k\u27e9\u27e9 = Pi.single i (Pi.single j (b k))"}]}
{"declaration": "theorem stdBasis_eq_stdBasisMatrix (i : m) (j : n) [DecidableEq m] [DecidableEq n] :\n    stdBasis R m n (i, j) = stdBasisMatrix i j (1 : R) := by\n  simp [stdBasis, stdBasisMatrix_eq_of_single_single]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/StdBasis.lean", "context": {"open": [], "variables": ["{\u03b9 R M : Type*} (m n : Type*)", "[Fintype m] [Fintype n] [Semiring R] [AddCommMonoid M] [Module R M]", "{n m}", "(R : Type*) (m n : Type*) [Fintype m] [Finite n] [Semiring R]", "{n m}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_7\nn : Type u_8\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Finite n\nx\u271d\u00b9 : Sort u_9\nstdBasis : x\u271d\u00b9\nx\u271d : Sort u_10\nstdBasisMatrix : x\u271d\ni : m\nj : n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq n\n\u22a2 sorry = sorry"}, {"line": "simp [stdBasis, stdBasisMatrix_eq_of_single_single]", "tactic_state": "m : Type u_7\nn : Type u_8\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Finite n\nx\u271d\u00b9 : Sort u_9\nstdBasis : x\u271d\u00b9\nx\u271d : Sort u_10\nstdBasisMatrix : x\u271d\ni : m\nj : n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq n\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma transpose_swap (i j : n) : (swap R i j).transpose = swap R i j := by\n  simp [swap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d : DecidableEq n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\n\u22a2 sorry = sorry"}, {"line": "simp [swap]", "tactic_state": "n : Type u_2\ninst\u271d : DecidableEq n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma conjTranspose_swap {R : Type*} [NonAssocSemiring R] [StarRing R] (i j : n) :\n    (swap R i j).conjTranspose = swap R i j := by\n  simp [swap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d\u00b2 : DecidableEq n\nx\u271d : Sort u_4\nswap : x\u271d\nR : Type u_3\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : StarRing R\ni j : n\n\u22a2 sorry = sorry"}, {"line": "simp [swap]", "tactic_state": "n : Type u_2\ninst\u271d\u00b2 : DecidableEq n\nx\u271d : Sort u_4\nswap : x\u271d\nR : Type u_3\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : StarRing R\ni j : n\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma map_swap {S : Type*} [NonAssocSemiring S] (f : R \u2192+* S) (i j : n) :\n    (swap R i j).map f = swap S i j := by\n  simp [swap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in", "{R n m : Type*} [Semiring R] [DecidableEq n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d\u00b9 : DecidableEq n\nx\u271d : Sort u_4\nswap : x\u271d\nS : Type u_3\ninst\u271d : NonAssocSemiring S\nf : sorry\ni j : n\n\u22a2 sorry = sorry"}, {"line": "simp [swap]", "tactic_state": "n : Type u_2\ninst\u271d\u00b9 : DecidableEq n\nx\u271d : Sort u_4\nswap : x\u271d\nS : Type u_3\ninst\u271d : NonAssocSemiring S\nf : sorry\ni j : n\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma swap_mulVec (i j : n) (a : n \u2192 R) :\n    swap R i j *\u1d65 a = a \u2218 Equiv.swap i j := by\n  simp [swap, PEquiv.toMatrix_toPEquiv_mulVec]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in", "{R n m : Type*} [Semiring R] [DecidableEq n]", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\na : n \u2192 R\n\u22a2 sorry * sorry = a \u2218 \u21d1(Equiv.swap i j)"}, {"line": "simp [swap, PEquiv.toMatrix_toPEquiv_mulVec]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\na : n \u2192 R\n\u22a2 sorry () * sorry () = a \u2218 \u21d1(Equiv.swap i j)"}]}
{"declaration": "lemma vecMul_swap (i j : n) (a : n \u2192 R) :\n    a \u1d65* swap R i j = a \u2218 Equiv.swap i j := by\n  simp [swap, PEquiv.vecMul_toMatrix_toPEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in", "{R n m : Type*} [Semiring R] [DecidableEq n]", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\na : n \u2192 R\n\u22a2 sorry * sorry = a \u2218 \u21d1(Equiv.swap i j)"}, {"line": "simp [swap, PEquiv.vecMul_toMatrix_toPEquiv]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\na : n \u2192 R\n\u22a2 sorry () * sorry () = a \u2218 \u21d1(Equiv.swap i j)"}]}
{"declaration": "lemma swap_mulVec_apply (i j : n) (a : n \u2192 R) :\n    (swap R i j *\u1d65 a) i = a j := by\n  simp [swap, PEquiv.toMatrix_toPEquiv_mulVec]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in", "{R n m : Type*} [Semiring R] [DecidableEq n]", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\na : n \u2192 R\n\u22a2 sorry = a j"}, {"line": "simp [swap, PEquiv.toMatrix_toPEquiv_mulVec]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\na : n \u2192 R\n\u22a2 sorry () = a j"}]}
{"declaration": "lemma vecMul_swap_apply (i j : n) (a : n \u2192 R) :\n    (a \u1d65* swap R i j) i = a j := by\n  simp [swap, PEquiv.vecMul_toMatrix_toPEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in", "{R n m : Type*} [Semiring R] [DecidableEq n]", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\na : n \u2192 R\n\u22a2 sorry = a j"}, {"line": "simp [swap, PEquiv.vecMul_toMatrix_toPEquiv]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx\u271d : Sort u_3\nswap : x\u271d\ni j : n\na : n \u2192 R\n\u22a2 sorry () = a j"}]}
{"declaration": "lemma swap_mul_apply_left (i j : n) (a : m) (g : Matrix n m R) :\n    (swap R i j * g) i a = g j a := by\n  simp [swap, PEquiv.toMatrix_toPEquiv_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in", "{R n m : Type*} [Semiring R] [DecidableEq n]", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Type u_3\nx\u271d : Sort u_4\nswap : x\u271d\ni j : n\na : m\ng : Matrix n m R\n\u22a2 sorry = g j a"}, {"line": "simp [swap, PEquiv.toMatrix_toPEquiv_mul]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Type u_3\nx\u271d : Sort u_4\nswap : x\u271d\ni j : n\na : m\ng : Matrix n m R\n\u22a2 sorry () = g j a"}]}
{"declaration": "lemma swap_mul_of_ne {i j a : n} {b : m} (hai : a \u2260 i) (haj : a \u2260 j) (g : Matrix n m R) :\n    (swap R i j * g) a b = g a b := by\n  simp [swap, PEquiv.toMatrix_toPEquiv_mul, Equiv.swap_apply_of_ne_of_ne hai haj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in", "{R n m : Type*} [Semiring R] [DecidableEq n]", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Type u_3\nx\u271d : Sort u_4\nswap : x\u271d\ni j a : n\nb : m\nhai : a \u2260 i\nhaj : a \u2260 j\ng : Matrix n m R\n\u22a2 sorry = g a b"}, {"line": "simp [swap, PEquiv.toMatrix_toPEquiv_mul, Equiv.swap_apply_of_ne_of_ne hai haj]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Type u_3\nx\u271d : Sort u_4\nswap : x\u271d\ni j a : n\nb : m\nhai : a \u2260 i\nhaj : a \u2260 j\ng : Matrix n m R\n\u22a2 sorry () = g a b"}]}
{"declaration": "lemma mul_swap_apply_left (i j : n) (a : m) (g : Matrix m n R) :\n    (g * swap R i j) a i = g a j := by\n  simp [swap, PEquiv.mul_toMatrix_toPEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in", "{R n m : Type*} [Semiring R] [DecidableEq n]", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Type u_3\nx\u271d : Sort u_4\nswap : x\u271d\ni j : n\na : m\ng : Matrix m n R\n\u22a2 sorry = g a j"}, {"line": "simp [swap, PEquiv.mul_toMatrix_toPEquiv]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Type u_3\nx\u271d : Sort u_4\nswap : x\u271d\ni j : n\na : m\ng : Matrix m n R\n\u22a2 sorry () = g a j"}]}
{"declaration": "lemma mul_swap_of_ne {i j b : n} {a : m} (hbi : b \u2260 i) (hbj : b \u2260 j) (g : Matrix m n R) :\n    (g * swap R i j) a b = g a b := by\n  simp [swap, PEquiv.mul_toMatrix_toPEquiv, Equiv.swap_apply_of_ne_of_ne hbi hbj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Swap.lean", "context": {"open": [], "variables": ["{R n : Type*} [Zero R] [One R] [DecidableEq n]", "(R) in", "{R n m : Type*} [Semiring R] [DecidableEq n]", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Type u_3\nx\u271d : Sort u_4\nswap : x\u271d\ni j b : n\na : m\nhbi : b \u2260 i\nhbj : b \u2260 j\ng : Matrix m n R\n\u22a2 sorry = g a b"}, {"line": "simp [swap, PEquiv.mul_toMatrix_toPEquiv, Equiv.swap_apply_of_ne_of_ne hbi hbj]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Type u_3\nx\u271d : Sort u_4\nswap : x\u271d\ni j b : n\na : m\nhbi : b \u2260 i\nhbj : b \u2260 j\ng : Matrix m n R\n\u22a2 sorry () = g a b"}]}
{"declaration": "lemma Matrix.linearIndependent_rows_of_isUnit {R : Type*} [Ring R] {A : Matrix m m R}\n    [DecidableEq m] (ha : IsUnit A) : LinearIndependent R A.row := by\n  rw [\u2190 Matrix.vecMul_injective_iff]\n  exact Matrix.vecMul_injective_of_isUnit ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_3\ninst\u271d\u00b2 : Fintype m\nR : Type u_5\ninst\u271d\u00b9 : Ring R\nA : Matrix m m R\ninst\u271d : DecidableEq m\nha : IsUnit A\n\u22a2 LinearIndependent R A.row"}, {"line": "rw [\u2190 Matrix.vecMul_injective_iff]", "tactic_state": "m : Type u_3\ninst\u271d\u00b2 : Fintype m\nR : Type u_5\ninst\u271d\u00b9 : Ring R\nA : Matrix m m R\ninst\u271d : DecidableEq m\nha : IsUnit A\n\u22a2 Function.Injective fun v => vecMul v A\n---\nm : Type u_3\ninst\u271d\u00b2 : Fintype m\nR : Type u_5\ninst\u271d\u00b9 : Ring R\nA : Matrix m m R\ninst\u271d : DecidableEq m\nha : IsUnit A\n\u22a2 Fintype m"}, {"line": "exact Matrix.vecMul_injective_of_isUnit ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.ker_mulVecLin_eq_bot_iff {M : Matrix m n R} :\n    (LinearMap.ker M.mulVecLin) = \u22a5 \u2194 \u2200 v, M *\u1d65 v = 0 \u2192 v = 0 := by\n  simp only [Submodule.eq_bot_iff]\n  simp only [LinearMap.mem_ker]\n  simp only [Matrix.mulVecLin_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : CommSemiring R\nm : Type u_8\nn : Type u_9\ninst\u271d : Fintype n\nM : Matrix m n R\n\u22a2 ker M.mulVecLin = \u22a5 \u2194 \u2200 (v : n \u2192 R), M.mulVec v = 0 \u2192 v = 0"}, {"line": "simp only [Submodule.eq_bot_iff]", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : CommSemiring R\nm : Type u_8\nn : Type u_9\ninst\u271d : Fintype n\nM : Matrix m n R\n\u22a2 (\u2200 x \u2208 ker M.mulVecLin, x = 0) \u2194 \u2200 (v : n \u2192 R), M.mulVec v = 0 \u2192 v = 0"}, {"line": "simp only [LinearMap.mem_ker]", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : CommSemiring R\nm : Type u_8\nn : Type u_9\ninst\u271d : Fintype n\nM : Matrix m n R\n\u22a2 (\u2200 (x : n \u2192 R), M.mulVecLin x = 0 \u2192 x = 0) \u2194 \u2200 (v : n \u2192 R), M.mulVec v = 0 \u2192 v = 0"}, {"line": "simp only [Matrix.mulVecLin_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.range_mulVecLin (M : Matrix m n R) :\n    LinearMap.range M.mulVecLin = span R (range M.col) := by\n  rw [\u2190 vecMulLinear_transpose]\n  rw [range_vecMulLinear]\n  rw [row_transpose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : CommSemiring R\nm : Type u_8\nn : Type u_9\ninst\u271d : Fintype n\nM : Matrix m n R\n\u22a2 LinearMap.range M.mulVecLin = span R (Set.range M.col)"}, {"line": "rw [\u2190 vecMulLinear_transpose]", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : CommSemiring R\nm : Type u_8\nn : Type u_9\ninst\u271d : Fintype n\nM : Matrix m n R\n\u22a2 LinearMap.range M.transpose.vecMulLinear = span R (Set.range M.col)"}, {"line": "rw [range_vecMulLinear]", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : CommSemiring R\nm : Type u_8\nn : Type u_9\ninst\u271d : Fintype n\nM : Matrix m n R\n\u22a2 span R (Set.range M.transpose.row) = span R (Set.range M.col)"}, {"line": "rw [row_transpose]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Matrix.linearIndependent_cols_of_isUnit {R : Type*} [CommRing R] [Fintype m]\n    {A : Matrix m m R} [DecidableEq m] (ha : IsUnit A) :\n    LinearIndependent R A.col := by\n  rw [\u2190 Matrix.mulVec_injective_iff]\n  exact Matrix.mulVec_injective_of_isUnit ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_8\nR : Type u_10\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Fintype m\nA : Matrix m m R\ninst\u271d : DecidableEq m\nha : IsUnit A\n\u22a2 LinearIndependent R A.col"}, {"line": "rw [\u2190 Matrix.mulVec_injective_iff]", "tactic_state": "m : Type u_8\nR : Type u_10\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Fintype m\nA : Matrix m m R\ninst\u271d : DecidableEq m\nha : IsUnit A\n\u22a2 Function.Injective A.mulVec\n---\nm : Type u_8\nR : Type u_10\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Fintype m\nA : Matrix m m R\ninst\u271d : DecidableEq m\nha : IsUnit A\n\u22a2 Fintype m"}, {"line": "exact Matrix.mulVec_injective_of_isUnit ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrix'_apply (f : (n \u2192 R) \u2192\u2097[R] m \u2192 R) (i j) :\n    LinearMap.toMatrix' f i j = f (fun j' \u21a6 if j' = j then 1 else 0) i := by\n  simp only [LinearMap.toMatrix']\n  simp only [LinearEquiv.coe_mk]\n  simp only [of_apply]\n  congr! with i\n  split_ifs with h\n  \u00b7 rw [h, Pi.single_eq_same]\n  apply Pi.single_eq_of_ne h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nf : (n \u2192 R) \u2192\u2097[R] m \u2192 R\ni : m\nj : n\n\u22a2 toMatrix' f i j = f (fun j' => if j' = j then 1 else 0) i"}, {"line": "simp only [LinearMap.toMatrix']", "tactic_state": "R : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nf : (n \u2192 R) \u2192\u2097[R] m \u2192 R\ni : m\nj : n\n\u22a2 { toFun := fun f => of fun i j => f (Pi.single j 1) i, map_add' := \u22ef, map_smul' := \u22ef, invFun := mulVecLin,\n        left_inv := \u22ef, right_inv := \u22ef }\n      f i j =\n    f (fun j' => if j' = j then 1 else 0) i"}, {"line": "simp only [LinearEquiv.coe_mk]", "tactic_state": "R : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nf : (n \u2192 R) \u2192\u2097[R] m \u2192 R\ni : m\nj : n\n\u22a2 of (fun i j => f (Pi.single j 1) i) i j = f (fun j' => if j' = j then 1 else 0) i"}, {"line": "simp only [of_apply]", "tactic_state": "R : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nf : (n \u2192 R) \u2192\u2097[R] m \u2192 R\ni : m\nj : n\n\u22a2 f (Pi.single j 1) i = f (fun j' => if j' = j then 1 else 0) i"}, {"line": "congr! with i", "tactic_state": "case h.e'_3.h\nR : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nf : (n \u2192 R) \u2192\u2097[R] m \u2192 R\ni\u271d : m\nj i : n\n\u22a2 Pi.single j 1 i = if i = j then 1 else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nR : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nf : (n \u2192 R) \u2192\u2097[R] m \u2192 R\ni\u271d : m\nj i : n\nh : i = j\n\u22a2 Pi.single j 1 i = 1\n---\ncase neg\nR : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nf : (n \u2192 R) \u2192\u2097[R] m \u2192 R\ni\u271d : m\nj i : n\nh : \u00aci = j\n\u22a2 Pi.single j 1 i = 0"}, {"line": "\u00b7 rw [h, Pi.single_eq_same]", "tactic_state": "case neg\nR : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nf : (n \u2192 R) \u2192\u2097[R] m \u2192 R\ni\u271d : m\nj i : n\nh : \u00aci = j\n\u22a2 Pi.single j 1 i = 0"}, {"line": "apply Pi.single_eq_of_ne h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrix'_id : LinearMap.toMatrix' (LinearMap.id : (n \u2192 R) \u2192\u2097[R] n \u2192 R) = 1 := by\n  ext\n  rw [Matrix.one_apply]\n  rw [LinearMap.toMatrix'_apply]\n  rw [id_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\n\u22a2 toMatrix' id = 1"}, {"line": "ext", "tactic_state": "case a\nR : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\ni\u271d j\u271d : n\n\u22a2 toMatrix' id i\u271d j\u271d = 1 i\u271d j\u271d"}, {"line": "rw [Matrix.one_apply]", "tactic_state": "case a\nR : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\ni\u271d j\u271d : n\n\u22a2 toMatrix' id i\u271d j\u271d = if i\u271d = j\u271d then 1 else 0"}, {"line": "rw [LinearMap.toMatrix'_apply]", "tactic_state": "case a\nR : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\ni\u271d j\u271d : n\n\u22a2 id (fun j' => if j' = j\u271d then 1 else 0) i\u271d = if i\u271d = j\u271d then 1 else 0"}, {"line": "rw [id_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.toLin'_mul_apply [Fintype m] [DecidableEq m] (M : Matrix l m R) (N : Matrix m n R)\n    (x) : Matrix.toLin' (M * N) x = Matrix.toLin' M (Matrix.toLin' N x) := by\n  rw [Matrix.toLin'_mul]\n  rw [LinearMap.comp_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\ninst\u271d\u2074 : CommSemiring R\nl : Type u_12\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nM : Matrix l m R\nN : Matrix m n R\nx : n \u2192 R\n\u22a2 (toLin' (M * N)) x = (toLin' M) ((toLin' N) x)"}, {"line": "rw [Matrix.toLin'_mul]", "tactic_state": "R : Type u_10\ninst\u271d\u2074 : CommSemiring R\nl : Type u_12\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nM : Matrix l m R\nN : Matrix m n R\nx : n \u2192 R\n\u22a2 (toLin' M \u2218\u2097 toLin' N) x = (toLin' M) ((toLin' N) x)\n---\nR : Type u_10\ninst\u271d\u2074 : CommSemiring R\nl : Type u_12\nm : Type u_13\nn : Type u_14\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nM : Matrix l m R\nN : Matrix m n R\nx : n \u2192 R\n\u22a2 DecidableEq m"}, {"line": "rw [LinearMap.comp_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrix'_algebraMap (x : R) :\n    LinearMap.toMatrix' (algebraMap R (Module.End R (n \u2192 R)) x) = scalar n x := by\n  simp [Module.algebraMap_end_eq_smul_id, smul_eq_diagonal_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx : R\n\u22a2 toMatrix' ((algebraMap R (Module.End R (n \u2192 R))) x) = (scalar n) x"}, {"line": "simp [Module.algebraMap_end_eq_smul_id, smul_eq_diagonal_mul]", "tactic_state": "R : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nx : R\n\u22a2 toMatrix' (x \u2022 id) = Matrix.diagonal fun x_1 => x"}]}
{"declaration": "theorem LinearMap.toMatrixAlgEquiv'_apply (f : (n \u2192 R) \u2192\u2097[R] n \u2192 R) (i j) :\n    LinearMap.toMatrixAlgEquiv' f i j = f (fun j' \u21a6 if j' = j then 1 else 0) i := by\n  simp [LinearMap.toMatrixAlgEquiv']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\ninst\u271d\u00b2 : CommSemiring R\nn : Type u_14\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nf : (n \u2192 R) \u2192\u2097[R] n \u2192 R\ni j : n\n\u22a2 toMatrixAlgEquiv' f i j = f (fun j' => if j' = j then 1 else 0) i"}, {"line": "simp [LinearMap.toMatrixAlgEquiv']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.toLin_toMatrix (f : M\u2081 \u2192\u2097[R] M\u2082) :\n    Matrix.toLin v\u2081 v\u2082 (LinearMap.toMatrix v\u2081 v\u2082 f) = f := by\n  rw [\u2190 Matrix.toLin_symm]\n  rw [LinearEquiv.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_15\ninst\u271d\u2077 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Finite m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u22a2 (toLin v\u2081 v\u2082) ((toMatrix v\u2081 v\u2082) f) = f"}, {"line": "rw [\u2190 Matrix.toLin_symm]", "tactic_state": "R : Type u_15\ninst\u271d\u2077 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Finite m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u22a2 (toLin v\u2081 v\u2082) ((toLin v\u2081 v\u2082).symm f) = f"}, {"line": "rw [LinearEquiv.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrix_toLin (M : Matrix m n R) :\n    LinearMap.toMatrix v\u2081 v\u2082 (Matrix.toLin v\u2081 v\u2082 M) = M := by\n  rw [\u2190 Matrix.toLin_symm]\n  rw [LinearEquiv.symm_apply_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_15\ninst\u271d\u2077 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Finite m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\n\u22a2 (toMatrix v\u2081 v\u2082) ((toLin v\u2081 v\u2082) M) = M"}, {"line": "rw [\u2190 Matrix.toLin_symm]", "tactic_state": "R : Type u_15\ninst\u271d\u2077 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Finite m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\n\u22a2 (toLin v\u2081 v\u2082).symm ((toLin v\u2081 v\u2082) M) = M"}, {"line": "rw [LinearEquiv.symm_apply_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrix_id : LinearMap.toMatrix v\u2081 v\u2081 id = 1 := by\n  ext i j\n  simp [LinearMap.toMatrix_apply, Matrix.one_apply, Finsupp.single_apply, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_15\ninst\u271d\u2074 : CommSemiring R\nn : Type u_18\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_19\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\n\u22a2 (toMatrix v\u2081 v\u2081) id = 1"}, {"line": "ext i j", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u2074 : CommSemiring R\nn : Type u_18\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_19\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\ni j : n\n\u22a2 (toMatrix v\u2081 v\u2081) id i j = 1 i j"}, {"line": "simp [LinearMap.toMatrix_apply, Matrix.one_apply, Finsupp.single_apply, eq_comm]", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u2074 : CommSemiring R\nn : Type u_18\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_19\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\ni j : n\n\u22a2 (if i = j then 1 else 0) = (fun\u2080 | j => 1) i"}]}
{"declaration": "lemma LinearMap.toMatrix_singleton {\u03b9 : Type*} [Unique \u03b9] (f : R \u2192\u2097[R] R) (i j : \u03b9) :\n    f.toMatrix (.singleton \u03b9 R) (.singleton \u03b9 R) i j = f 1 := by\n  simp [toMatrix, Subsingleton.elim j default]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_15\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_21\ninst\u271d : Unique \u03b9\nf : R \u2192\u2097[R] R\ni j : \u03b9\n\u22a2 (toMatrix (Basis.singleton \u03b9 R) (Basis.singleton \u03b9 R)) f i j = f 1"}, {"line": "simp [toMatrix, Subsingleton.elim j default]", "tactic_state": "R : Type u_15\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_21\ninst\u271d : Unique \u03b9\nf : R \u2192\u2097[R] R\ni j : \u03b9\n\u22a2 f ((Basis.singleton \u03b9 R).equivFun.symm fun j' => if j' = j then 1 else 0) = f 1"}]}
{"declaration": "theorem LinearMap.toMatrix_reindexRange [DecidableEq M\u2081] (f : M\u2081 \u2192\u2097[R] M\u2082) (k : m) (i : n) :\n    LinearMap.toMatrix v\u2081.reindexRange v\u2082.reindexRange f \u27e8v\u2082 k, Set.mem_range_self k\u27e9\n        \u27e8v\u2081 i, Set.mem_range_self i\u27e9 =\n      LinearMap.toMatrix v\u2081 v\u2082 f k i := by\n  simp_rw [LinearMap.toMatrix_apply, Basis.reindexRange_self, Basis.reindexRange_repr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_15\ninst\u271d\u2078 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Finite m\ninst\u271d\u2075 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2074 : AddCommMonoid M\u2081\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\ninst\u271d : DecidableEq M\u2081\nf : M\u2081 \u2192\u2097[R] M\u2082\nk : m\ni : n\n\u22a2 (toMatrix v\u2081.reindexRange v\u2082.reindexRange) f \u27e8v\u2082 k, \u22ef\u27e9 \u27e8v\u2081 i, \u22ef\u27e9 = (toMatrix v\u2081 v\u2082) f k i"}, {"line": "simp_rw [LinearMap.toMatrix_apply, Basis.reindexRange_self, Basis.reindexRange_repr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrix_algebraMap (x : R) :\n    LinearMap.toMatrix v\u2081 v\u2081 (algebraMap R (Module.End R M\u2081) x) = scalar n x := by\n  simp [Module.algebraMap_end_eq_smul_id, LinearMap.toMatrix_id, smul_eq_diagonal_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_15\ninst\u271d\u2074 : CommSemiring R\nn : Type u_18\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_19\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nx : R\n\u22a2 (toMatrix v\u2081 v\u2081) ((algebraMap R (Module.End R M\u2081)) x) = (scalar n) x"}, {"line": "simp [Module.algebraMap_end_eq_smul_id, LinearMap.toMatrix_id, smul_eq_diagonal_mul]", "tactic_state": "R : Type u_15\ninst\u271d\u2074 : CommSemiring R\nn : Type u_18\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_19\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nx : R\n\u22a2 (toMatrix v\u2081 v\u2081) (x \u2022 id) = Matrix.diagonal fun x_1 => x"}]}
{"declaration": "theorem LinearMap.toMatrix_basis_equiv [Fintype l] [DecidableEq l] (b : Basis l R M\u2081)\n    (b' : Basis l R M\u2082) :\n    LinearMap.toMatrix b' b (b'.equiv b (Equiv.refl l) : M\u2082 \u2192\u2097[R] M\u2081) = 1 := by\n  ext i j\n  simp [LinearMap.toMatrix_apply, Matrix.one_apply, Finsupp.single_apply, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_15\ninst\u271d\u2076 : CommSemiring R\nl : Type u_16\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Fintype l\ninst\u271d : DecidableEq l\nb : Basis l R M\u2081\nb' : Basis l R M\u2082\n\u22a2 (toMatrix b' b) \u2191(b'.equiv b (Equiv.refl l)) = 1"}, {"line": "ext i j", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u2076 : CommSemiring R\nl : Type u_16\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Fintype l\ninst\u271d : DecidableEq l\nb : Basis l R M\u2081\nb' : Basis l R M\u2082\ni j : l\n\u22a2 (toMatrix b' b) (\u2191(b'.equiv b (Equiv.refl l))) i j = 1 i j"}, {"line": "simp [LinearMap.toMatrix_apply, Matrix.one_apply, Finsupp.single_apply, eq_comm]", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u2076 : CommSemiring R\nl : Type u_16\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Fintype l\ninst\u271d : DecidableEq l\nb : Basis l R M\u2081\nb' : Basis l R M\u2082\ni j : l\n\u22a2 (if i = j then 1 else 0) = (fun\u2080 | j => 1) i"}]}
{"declaration": "theorem LinearMap.toMatrix_smulBasis_left {G} [Group G] [DistribMulAction G M\u2081]\n    [SMulCommClass G R M\u2081] (g : G) (f : M\u2081 \u2192\u2097[R] M\u2082) :\n    LinearMap.toMatrix (g \u2022 v\u2081) v\u2082 f =\n      LinearMap.toMatrix v\u2081 v\u2082 (f \u2218\u2097 DistribMulAction.toLinearMap _ _ g) := by\n  ext\n  rw [LinearMap.toMatrix_apply]\n  rw [LinearMap.toMatrix_apply]\n  dsimp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_15\ninst\u271d\u00b9\u2070 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Finite m\ninst\u271d\u2077 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nG : Type u_21\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G M\u2081\ninst\u271d : SMulCommClass G R M\u2081\ng : G\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u22a2 (toMatrix (g \u2022 v\u2081) v\u2082) f = (toMatrix v\u2081 v\u2082) (f \u2218\u2097 DistribMulAction.toLinearMap R M\u2081 g)"}, {"line": "ext", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u00b9\u2070 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Finite m\ninst\u271d\u2077 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nG : Type u_21\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G M\u2081\ninst\u271d : SMulCommClass G R M\u2081\ng : G\nf : M\u2081 \u2192\u2097[R] M\u2082\ni\u271d : m\nj\u271d : n\n\u22a2 (toMatrix (g \u2022 v\u2081) v\u2082) f i\u271d j\u271d = (toMatrix v\u2081 v\u2082) (f \u2218\u2097 DistribMulAction.toLinearMap R M\u2081 g) i\u271d j\u271d"}, {"line": "rw [LinearMap.toMatrix_apply]", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u00b9\u2070 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Finite m\ninst\u271d\u2077 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nG : Type u_21\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G M\u2081\ninst\u271d : SMulCommClass G R M\u2081\ng : G\nf : M\u2081 \u2192\u2097[R] M\u2082\ni\u271d : m\nj\u271d : n\n\u22a2 (v\u2082.repr (f ((g \u2022 v\u2081) j\u271d))) i\u271d = (toMatrix v\u2081 v\u2082) (f \u2218\u2097 DistribMulAction.toLinearMap R M\u2081 g) i\u271d j\u271d"}, {"line": "rw [LinearMap.toMatrix_apply]", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u00b9\u2070 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Finite m\ninst\u271d\u2077 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nG : Type u_21\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G M\u2081\ninst\u271d : SMulCommClass G R M\u2081\ng : G\nf : M\u2081 \u2192\u2097[R] M\u2082\ni\u271d : m\nj\u271d : n\n\u22a2 (v\u2082.repr (f ((g \u2022 v\u2081) j\u271d))) i\u271d = (v\u2082.repr ((f \u2218\u2097 DistribMulAction.toLinearMap R M\u2081 g) (v\u2081 j\u271d))) i\u271d"}, {"line": "dsimp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrix_smulBasis_right {G} [Group G] [DistribMulAction G M\u2082]\n    [SMulCommClass G R M\u2082] (g : G) (f : M\u2081 \u2192\u2097[R] M\u2082) :\n    LinearMap.toMatrix v\u2081 (g \u2022 v\u2082) f =\n      LinearMap.toMatrix v\u2081 v\u2082 (DistribMulAction.toLinearMap _ _ g\u207b\u00b9 \u2218\u2097 f) := by\n  ext\n  rw [LinearMap.toMatrix_apply]\n  rw [LinearMap.toMatrix_apply]\n  dsimp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_15\ninst\u271d\u00b9\u2070 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Finite m\ninst\u271d\u2077 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nG : Type u_21\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G M\u2082\ninst\u271d : SMulCommClass G R M\u2082\ng : G\nf : M\u2081 \u2192\u2097[R] M\u2082\n\u22a2 (toMatrix v\u2081 (g \u2022 v\u2082)) f = (toMatrix v\u2081 v\u2082) (DistribMulAction.toLinearMap R M\u2082 g\u207b\u00b9 \u2218\u2097 f)"}, {"line": "ext", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u00b9\u2070 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Finite m\ninst\u271d\u2077 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nG : Type u_21\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G M\u2082\ninst\u271d : SMulCommClass G R M\u2082\ng : G\nf : M\u2081 \u2192\u2097[R] M\u2082\ni\u271d : m\nj\u271d : n\n\u22a2 (toMatrix v\u2081 (g \u2022 v\u2082)) f i\u271d j\u271d = (toMatrix v\u2081 v\u2082) (DistribMulAction.toLinearMap R M\u2082 g\u207b\u00b9 \u2218\u2097 f) i\u271d j\u271d"}, {"line": "rw [LinearMap.toMatrix_apply]", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u00b9\u2070 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Finite m\ninst\u271d\u2077 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nG : Type u_21\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G M\u2082\ninst\u271d : SMulCommClass G R M\u2082\ng : G\nf : M\u2081 \u2192\u2097[R] M\u2082\ni\u271d : m\nj\u271d : n\n\u22a2 ((g \u2022 v\u2082).repr (f (v\u2081 j\u271d))) i\u271d = (toMatrix v\u2081 v\u2082) (DistribMulAction.toLinearMap R M\u2082 g\u207b\u00b9 \u2218\u2097 f) i\u271d j\u271d"}, {"line": "rw [LinearMap.toMatrix_apply]", "tactic_state": "case a\nR : Type u_15\ninst\u271d\u00b9\u2070 : CommSemiring R\nm : Type u_17\nn : Type u_18\ninst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Finite m\ninst\u271d\u2077 : DecidableEq n\nM\u2081 : Type u_19\nM\u2082 : Type u_20\ninst\u271d\u2076 : AddCommMonoid M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nG : Type u_21\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DistribMulAction G M\u2082\ninst\u271d : SMulCommClass G R M\u2082\ng : G\nf : M\u2081 \u2192\u2097[R] M\u2082\ni\u271d : m\nj\u271d : n\n\u22a2 ((g \u2022 v\u2082).repr (f (v\u2081 j\u271d))) i\u271d = (v\u2082.repr ((DistribMulAction.toLinearMap R M\u2082 g\u207b\u00b9 \u2218\u2097 f) (v\u2081 j\u271d))) i\u271d"}, {"line": "dsimp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.toLinAlgEquiv_toMatrixAlgEquiv (f : M\u2081 \u2192\u2097[R] M\u2081) :\n    Matrix.toLinAlgEquiv v\u2081 (LinearMap.toMatrixAlgEquiv v\u2081 f) = f := by\n  rw [\u2190 Matrix.toLinAlgEquiv_symm]\n  rw [AlgEquiv.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Fintype m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{M\u2083 : Type*} [AddCommMonoid M\u2083] [Module R M\u2083] (v\u2083 : Basis l R M\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : CommSemiring R\nn : Type u_24\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_25\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nf : M\u2081 \u2192\u2097[R] M\u2081\n\u22a2 (toLinAlgEquiv v\u2081) ((toMatrixAlgEquiv v\u2081) f) = f"}, {"line": "rw [\u2190 Matrix.toLinAlgEquiv_symm]", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : CommSemiring R\nn : Type u_24\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_25\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nf : M\u2081 \u2192\u2097[R] M\u2081\n\u22a2 (toLinAlgEquiv v\u2081) ((toLinAlgEquiv v\u2081).symm f) = f"}, {"line": "rw [AlgEquiv.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrixAlgEquiv_toLinAlgEquiv (M : Matrix n n R) :\n    LinearMap.toMatrixAlgEquiv v\u2081 (Matrix.toLinAlgEquiv v\u2081 M) = M := by\n  rw [\u2190 Matrix.toLinAlgEquiv_symm]\n  rw [AlgEquiv.symm_apply_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Fintype m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{M\u2083 : Type*} [AddCommMonoid M\u2083] [Module R M\u2083] (v\u2083 : Basis l R M\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : CommSemiring R\nn : Type u_24\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_25\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nM : Matrix n n R\n\u22a2 (toMatrixAlgEquiv v\u2081) ((toLinAlgEquiv v\u2081) M) = M"}, {"line": "rw [\u2190 Matrix.toLinAlgEquiv_symm]", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : CommSemiring R\nn : Type u_24\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_25\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nM : Matrix n n R\n\u22a2 (toLinAlgEquiv v\u2081).symm ((toLinAlgEquiv v\u2081) M) = M"}, {"line": "rw [AlgEquiv.symm_apply_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrixAlgEquiv_apply (f : M\u2081 \u2192\u2097[R] M\u2081) (i j : n) :\n    LinearMap.toMatrixAlgEquiv v\u2081 f i j = v\u2081.repr (f (v\u2081 j)) i := by\n  simp [LinearMap.toMatrixAlgEquiv, LinearMap.toMatrix_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Fintype m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{M\u2083 : Type*} [AddCommMonoid M\u2083] [Module R M\u2083] (v\u2083 : Basis l R M\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : CommSemiring R\nn : Type u_24\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_25\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nf : M\u2081 \u2192\u2097[R] M\u2081\ni j : n\n\u22a2 (toMatrixAlgEquiv v\u2081) f i j = (v\u2081.repr (f (v\u2081 j))) i"}, {"line": "simp [LinearMap.toMatrixAlgEquiv, LinearMap.toMatrix_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrixAlgEquiv_reindexRange [DecidableEq M\u2081] (f : M\u2081 \u2192\u2097[R] M\u2081) (k i : n) :\n    LinearMap.toMatrixAlgEquiv v\u2081.reindexRange f\n        \u27e8v\u2081 k, Set.mem_range_self k\u27e9 \u27e8v\u2081 i, Set.mem_range_self i\u27e9 =\n      LinearMap.toMatrixAlgEquiv v\u2081 f k i := by\n  simp_rw [LinearMap.toMatrixAlgEquiv_apply, Basis.reindexRange_self, Basis.reindexRange_repr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Fintype m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{M\u2083 : Type*} [AddCommMonoid M\u2083] [Module R M\u2083] (v\u2083 : Basis l R M\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d\u2075 : CommSemiring R\nn : Type u_24\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\nM\u2081 : Type u_25\ninst\u271d\u00b2 : AddCommMonoid M\u2081\ninst\u271d\u00b9 : Module R M\u2081\nv\u2081 : Basis n R M\u2081\ninst\u271d : DecidableEq M\u2081\nf : M\u2081 \u2192\u2097[R] M\u2081\nk i : n\n\u22a2 (toMatrixAlgEquiv v\u2081.reindexRange) f \u27e8v\u2081 k, \u22ef\u27e9 \u27e8v\u2081 i, \u22ef\u27e9 = (toMatrixAlgEquiv v\u2081) f k i"}, {"line": "simp_rw [LinearMap.toMatrixAlgEquiv_apply, Basis.reindexRange_self, Basis.reindexRange_repr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.toMatrixAlgEquiv_comp (f g : M\u2081 \u2192\u2097[R] M\u2081) :\n    LinearMap.toMatrixAlgEquiv v\u2081 (f.comp g) =\n      LinearMap.toMatrixAlgEquiv v\u2081 f * LinearMap.toMatrixAlgEquiv v\u2081 g := by\n  simp [LinearMap.toMatrixAlgEquiv, LinearMap.toMatrix_comp v\u2081 v\u2081 v\u2081 f g]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Fintype m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{M\u2083 : Type*} [AddCommMonoid M\u2083] [Module R M\u2083] (v\u2083 : Basis l R M\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : CommSemiring R\nn : Type u_24\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_25\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nf g : M\u2081 \u2192\u2097[R] M\u2081\n\u22a2 (toMatrixAlgEquiv v\u2081) (f \u2218\u2097 g) = (toMatrixAlgEquiv v\u2081) f * (toMatrixAlgEquiv v\u2081) g"}, {"line": "simp [LinearMap.toMatrixAlgEquiv, LinearMap.toMatrix_comp v\u2081 v\u2081 v\u2081 f g]", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : CommSemiring R\nn : Type u_24\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_25\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nf g : M\u2081 \u2192\u2097[R] M\u2081\n\u22a2 (toMatrix v\u2081 v\u2081) (f \u2218\u2097 g) = (toMatrix v\u2081 v\u2081) f * (toMatrix v\u2081 v\u2081) g"}]}
{"declaration": "theorem Matrix.toLinAlgEquiv_mul (A B : Matrix n n R) :\n    Matrix.toLinAlgEquiv v\u2081 (A * B) =\n      (Matrix.toLinAlgEquiv v\u2081 A).comp (Matrix.toLinAlgEquiv v\u2081 B) := by\n  convert Matrix.toLin_mul v\u2081 v\u2081 v\u2081 A B\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Fintype m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{M\u2083 : Type*} [AddCommMonoid M\u2083] [Module R M\u2083] (v\u2083 : Basis l R M\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d\u2074 : CommSemiring R\nn : Type u_24\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\nM\u2081 : Type u_25\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R M\u2081\nv\u2081 : Basis n R M\u2081\nA B : Matrix n n R\n\u22a2 (toLinAlgEquiv v\u2081) (A * B) = (toLinAlgEquiv v\u2081) A \u2218\u2097 (toLinAlgEquiv v\u2081) B"}, {"line": "convert Matrix.toLin_mul v\u2081 v\u2081 v\u2081 A B", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.toLin_finTwoProd_apply (a b c d : R) (x : R \u00d7 R) :\n    Matrix.toLin (Basis.finTwoProd R) (Basis.finTwoProd R) !![a, b; c, d] x =\n      (a * x.fst + b * x.snd, c * x.fst + d * x.snd) := by\n  simp [Matrix.toLin_apply, Matrix.mulVec, dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Fintype m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{M\u2083 : Type*} [AddCommMonoid M\u2083] [Module R M\u2083] (v\u2083 : Basis l R M\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d : CommSemiring R\na b c d : R\nx : R \u00d7 R\n\u22a2 ((toLin (Basis.finTwoProd R) (Basis.finTwoProd R)) !![a, b; c, d]) x = (a * x.1 + b * x.2, c * x.1 + d * x.2)"}, {"line": "simp [Matrix.toLin_apply, Matrix.mulVec, dotProduct]", "tactic_state": "R : Type u_21\ninst\u271d : CommSemiring R\na b c d : R\nx : R \u00d7 R\n\u22a2 (a * x.1 + b * x.2) * 1 + 0 = a * x.1 + b * x.2 \u2227 0 + (c * x.1 + d * x.2) * 1 = c * x.1 + d * x.2"}]}
{"declaration": "lemma LinearMap.toMatrix_prodMap [DecidableEq m] [DecidableEq (n \u2295 m)]\n    (\u03c6\u2081 : Module.End R M\u2081) (\u03c6\u2082 : Module.End R M\u2082) :\n    toMatrix (v\u2081.prod v\u2082) (v\u2081.prod v\u2082) (\u03c6\u2081.prodMap \u03c6\u2082) =\n      Matrix.fromBlocks (toMatrix v\u2081 v\u2081 \u03c6\u2081) 0 0 (toMatrix v\u2082 v\u2082 \u03c6\u2082) := by\n  ext (i|i) (j|j) <;> simp [toMatrix]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "context": {"open": ["LinearMap Matrix Set Submodule"], "variables": ["{R : Type*} [Semiring R]", "{l m n : Type*}", "[Fintype m]", "[DecidableEq m]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*}", "[Fintype n]", "{R : Type*} [CommSemiring R]", "{k l m n : Type*} [DecidableEq n] [Fintype n]", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Finite m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{R : Type*} [CommSemiring R]", "{l m n : Type*} [Fintype n] [Fintype m] [DecidableEq n]", "{M\u2081 M\u2082 : Type*} [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082]", "(v\u2081 : Basis n R M\u2081) (v\u2082 : Basis m R M\u2082)", "{M\u2083 : Type*} [AddCommMonoid M\u2083] [Module R M\u2083] (v\u2083 : Basis l R M\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_21\ninst\u271d\u2079 : CommSemiring R\nm : Type u_23\nn : Type u_24\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : DecidableEq n\nM\u2081 : Type u_25\nM\u2082 : Type u_26\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq (n \u2295 m)\n\u03c6\u2081 : Module.End R M\u2081\n\u03c6\u2082 : Module.End R M\u2082\n\u22a2 (toMatrix (v\u2081.prod v\u2082) (v\u2081.prod v\u2082)) (prodMap \u03c6\u2081 \u03c6\u2082) = fromBlocks ((toMatrix v\u2081 v\u2081) \u03c6\u2081) 0 0 ((toMatrix v\u2082 v\u2082) \u03c6\u2082)"}, {"line": "ext (i|i) (j|j) <;> simp [toMatrix]", "tactic_state": "case a.inl.inl\nR : Type u_21\ninst\u271d\u2079 : CommSemiring R\nm : Type u_23\nn : Type u_24\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : DecidableEq n\nM\u2081 : Type u_25\nM\u2082 : Type u_26\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq (n \u2295 m)\n\u03c6\u2081 : Module.End R M\u2081\n\u03c6\u2082 : Module.End R M\u2082\ni j : n\n\u22a2 (v\u2081.repr (\u03c6\u2081 ((v\u2081.prod v\u2082).equivFun.symm fun j' => if j' = Sum.inl j then 1 else 0).1)) i =\n    (v\u2081.repr (\u03c6\u2081 (v\u2081.equivFun.symm fun j' => if j' = j then 1 else 0))) i\n---\ncase a.inl.inr\nR : Type u_21\ninst\u271d\u2079 : CommSemiring R\nm : Type u_23\nn : Type u_24\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : DecidableEq n\nM\u2081 : Type u_25\nM\u2082 : Type u_26\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq (n \u2295 m)\n\u03c6\u2081 : Module.End R M\u2081\n\u03c6\u2082 : Module.End R M\u2082\ni : n\nj : m\n\u22a2 (v\u2081.repr (\u03c6\u2081 ((v\u2081.prod v\u2082).equivFun.symm fun j' => if j' = Sum.inr j then 1 else 0).1)) i = 0\n---\ncase a.inr.inl\nR : Type u_21\ninst\u271d\u2079 : CommSemiring R\nm : Type u_23\nn : Type u_24\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : DecidableEq n\nM\u2081 : Type u_25\nM\u2082 : Type u_26\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq (n \u2295 m)\n\u03c6\u2081 : Module.End R M\u2081\n\u03c6\u2082 : Module.End R M\u2082\ni : m\nj : n\n\u22a2 (v\u2082.repr (\u03c6\u2082 ((v\u2081.prod v\u2082).equivFun.symm fun j' => if j' = Sum.inl j then 1 else 0).2)) i = 0\n---\ncase a.inr.inr\nR : Type u_21\ninst\u271d\u2079 : CommSemiring R\nm : Type u_23\nn : Type u_24\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : DecidableEq n\nM\u2081 : Type u_25\nM\u2082 : Type u_26\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq (n \u2295 m)\n\u03c6\u2081 : Module.End R M\u2081\n\u03c6\u2082 : Module.End R M\u2082\ni j : m\n\u22a2 (v\u2082.repr (\u03c6\u2082 ((v\u2081.prod v\u2082).equivFun.symm fun j' => if j' = Sum.inr j then 1 else 0).2)) i =\n    (v\u2082.repr (\u03c6\u2082 (v\u2082.equivFun.symm fun j' => if j' = j then 1 else 0))) i"}]}
{"declaration": "lemma trace_diagonal {o} [Fintype o] [DecidableEq o] (d : o \u2192 R) :\n    trace (diagonal d) = \u2211 i, d i := by\n  simp only [trace]\n  simp only [diag_apply]\n  simp only [diagonal_apply_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Trace.lean", "context": {"open": ["Matrix"], "variables": ["{\u03b9 m n p : Type*} {\u03b1 R S : Type*}", "[Fintype m] [Fintype n] [Fintype p]", "[AddCommMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : AddCommMonoid R\no : Type u_8\ninst\u271d\u00b9 : Fintype o\ninst\u271d : DecidableEq o\nd : o \u2192 R\n\u22a2 (diagonal d).trace = \u2211 i, d i"}, {"line": "simp only [trace]", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : AddCommMonoid R\no : Type u_8\ninst\u271d\u00b9 : Fintype o\ninst\u271d : DecidableEq o\nd : o \u2192 R\n\u22a2 \u2211 i, (diagonal d).diag i = \u2211 i, d i"}, {"line": "simp only [diag_apply]", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : AddCommMonoid R\no : Type u_8\ninst\u271d\u00b9 : Fintype o\ninst\u271d : DecidableEq o\nd : o \u2192 R\n\u22a2 \u2211 x, diagonal d x x = \u2211 i, d i"}, {"line": "simp only [diagonal_apply_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma trace_eq_zero_of_isEmpty [IsEmpty n] (A : Matrix n n R) : trace A = 0 := by simp [trace]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Trace.lean", "context": {"open": ["Matrix"], "variables": ["{\u03b9 m n p : Type*} {\u03b1 R S : Type*}", "[Fintype m] [Fintype n] [Fintype p]", "[AddCommMonoid R]", "(n R)", "{n R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\nR : Type u_6\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : IsEmpty n\nA : Matrix n n R\n\u22a2 A.trace = 0"}, {"line": "simp [trace]", "tactic_state": "n : Type u_3\nR : Type u_6\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : IsEmpty n\nA : Matrix n n R\n\u22a2 \u2211 x, A x x = 0"}]}
{"declaration": "lemma trace_blockDiagonal [DecidableEq p] (M : p \u2192 Matrix n n R) :\n    trace (blockDiagonal M) = \u2211 i, trace (M i) := by\n  simp [blockDiagonal, trace, Finset.sum_comm (\u03b3 := n), Fintype.sum_prod_type]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Trace.lean", "context": {"open": ["Matrix"], "variables": ["{\u03b9 m n p : Type*} {\u03b1 R S : Type*}", "[Fintype m] [Fintype n] [Fintype p]", "[AddCommMonoid R]", "(n R)", "{n R}", "(n \u03b1 R)", "{n \u03b1 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\np : Type u_4\nR : Type u_6\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : Fintype p\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : DecidableEq p\nM : p \u2192 Matrix n n R\n\u22a2 (blockDiagonal M).trace = \u2211 i, (M i).trace"}, {"line": "simp [blockDiagonal, trace, Finset.sum_comm (\u03b3 := n), Fintype.sum_prod_type]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma trace_blockDiagonal' [DecidableEq p] {m : p \u2192 Type*} [\u2200 i, Fintype (m i)]\n    (M : \u2200 i, Matrix (m i) (m i) R) :\n    trace (blockDiagonal' M) = \u2211 i, trace (M i) := by\n  simp [blockDiagonal', trace, Finset.sum_sigma']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Trace.lean", "context": {"open": ["Matrix"], "variables": ["{\u03b9 m n p : Type*} {\u03b1 R S : Type*}", "[Fintype m] [Fintype n] [Fintype p]", "[AddCommMonoid R]", "(n R)", "{n R}", "(n \u03b1 R)", "{n \u03b1 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Type u_4\nR : Type u_6\ninst\u271d\u00b3 : Fintype p\ninst\u271d\u00b2 : AddCommMonoid R\ninst\u271d\u00b9 : DecidableEq p\nm : p \u2192 Type u_8\ninst\u271d : (i : p) \u2192 Fintype (m i)\nM : (i : p) \u2192 Matrix (m i) (m i) R\n\u22a2 (blockDiagonal' M).trace = \u2211 i, (M i).trace"}, {"line": "simp [blockDiagonal', trace, Finset.sum_sigma']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trace_mul_comm [AddCommMonoid R] [CommMagma R] (A : Matrix m n R) (B : Matrix n m R) :\n    trace (A * B) = trace (B * A) := by rw [\u2190 trace_transpose, \u2190 trace_transpose_mul, transpose_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Trace.lean", "context": {"open": ["Matrix"], "variables": ["{\u03b9 m n p : Type*} {\u03b1 R S : Type*}", "[Fintype m] [Fintype n] [Fintype p]", "[AddCommMonoid R]", "(n R)", "{n R}", "(n \u03b1 R)", "{n \u03b1 R}", "[AddCommGroup R]", "[DecidableEq n] [AddCommMonoidWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_6\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : AddCommMonoid R\ninst\u271d\u2074 : AddCommGroup R\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : AddCommMonoidWithOne R\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : CommMagma R\nA : Matrix m n R\nB : Matrix n m R\n\u22a2 (A * B).trace = (B * A).trace"}, {"line": "rw [\u2190 trace_transpose, \u2190 trace_transpose_mul, transpose_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trace_replicateCol_mul_replicateRow {\u03b9 : Type*} [Unique \u03b9] [NonUnitalNonAssocSemiring R]\n    (a b : n \u2192 R) : trace (replicateCol \u03b9 a * replicateRow \u03b9 b) = dotProduct a b := by\n  apply Finset.sum_congr rfl\n  simp [mul_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Trace.lean", "context": {"open": ["Matrix"], "variables": ["{\u03b9 m n p : Type*} {\u03b1 R S : Type*}", "[Fintype m] [Fintype n] [Fintype p]", "[AddCommMonoid R]", "(n R)", "{n R}", "(n \u03b1 R)", "{n \u03b1 R}", "[AddCommGroup R]", "[DecidableEq n] [AddCommMonoidWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\nR : Type u_6\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : AddCommMonoid R\ninst\u271d\u2074 : AddCommGroup R\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : AddCommMonoidWithOne R\n\u03b9 : Type u_8\ninst\u271d\u00b9 : Unique \u03b9\ninst\u271d : NonUnitalNonAssocSemiring R\na b : n \u2192 R\n\u22a2 (replicateCol \u03b9 a * replicateRow \u03b9 b).trace = a \u2b1d\u1d65 b"}, {"line": "apply Finset.sum_congr rfl", "tactic_state": "n : Type u_3\nR : Type u_6\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : AddCommMonoid R\ninst\u271d\u2074 : AddCommGroup R\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : AddCommMonoidWithOne R\n\u03b9 : Type u_8\ninst\u271d\u00b9 : Unique \u03b9\ninst\u271d : NonUnitalNonAssocSemiring R\na b : n \u2192 R\n\u22a2 \u2200 x \u2208 Finset.univ, (replicateCol \u03b9 a * replicateRow \u03b9 b).diag x = a x * b x"}, {"line": "simp [mul_apply]", "tactic_state": "n : Type u_3\nR : Type u_6\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : AddCommMonoid R\ninst\u271d\u2074 : AddCommGroup R\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : AddCommMonoidWithOne R\n\u03b9 : Type u_8\ninst\u271d\u00b9 : Unique \u03b9\ninst\u271d : NonUnitalNonAssocSemiring R\na b : n \u2192 R\n\u22a2 \u2200 (x : n), Fintype.card \u03b9 \u2022 (a x * b x) = a x * b x"}]}
{"declaration": "lemma trace_submatrix_succ {n : \u2115} [AddCommMonoid R]\n    (M : Matrix (Fin n.succ) (Fin n.succ) R) :\n    M 0 0 + trace (submatrix M Fin.succ Fin.succ) = trace M := by\n  delta trace\n  rw [\u2190 (finSuccEquiv n).symm.sum_comp]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Trace.lean", "context": {"open": ["Matrix"], "variables": ["{\u03b9 m n p : Type*} {\u03b1 R S : Type*}", "[Fintype m] [Fintype n] [Fintype p]", "[AddCommMonoid R]", "(n R)", "{n R}", "(n \u03b1 R)", "{n \u03b1 R}", "[AddCommGroup R]", "[DecidableEq n] [AddCommMonoidWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : AddCommGroup R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\nn : \u2115\ninst\u271d : AddCommMonoid R\nM : Matrix (Fin n.succ) (Fin n.succ) R\n\u22a2 M 0 0 + (M.submatrix Fin.succ Fin.succ).trace = M.trace"}, {"line": "delta trace", "tactic_state": "R : Type u_6\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : AddCommGroup R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\nn : \u2115\ninst\u271d : AddCommMonoid R\nM : Matrix (Fin n.succ) (Fin n.succ) R\n\u22a2 M 0 0 + \u2211 i, (M.submatrix Fin.succ Fin.succ).diag i = \u2211 i, M.diag i"}, {"line": "rw [\u2190 (finSuccEquiv n).symm.sum_comp]", "tactic_state": "R : Type u_6\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : AddCommGroup R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\nn : \u2115\ninst\u271d : AddCommMonoid R\nM : Matrix (Fin n.succ) (Fin n.succ) R\n\u22a2 M 0 0 + \u2211 i, (M.submatrix Fin.succ Fin.succ).diag i = \u2211 i, M.diag ((finSuccEquiv n).symm i)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trace_zero (h : j \u2260 i) : trace (stdBasisMatrix i j c) = 0 := by\n  -- Porting note: added `-diag_apply`\n  simp [trace, -diag_apply, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Trace.lean", "context": {"open": ["Matrix"], "variables": ["{\u03b9 m n p : Type*} {\u03b1 R S : Type*}", "[Fintype m] [Fintype n] [Fintype p]", "[AddCommMonoid R]", "(n R)", "{n R}", "(n \u03b1 R)", "{n \u03b1 R}", "[AddCommGroup R]", "[DecidableEq n] [AddCommMonoidWithOne R]", "[DecidableEq m] [CommSemiring R]", "[AddCommMonoid R]", "{l m n : Type*} {R \u03b1 : Type*} [DecidableEq l] [DecidableEq m] [DecidableEq n]", "[Fintype n] [AddCommMonoid \u03b1] (i j : n) (c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_10\n\u03b1 : Type u_12\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : AddCommMonoid \u03b1\ni j : n\nc : \u03b1\nh : j \u2260 i\n\u22a2 (stdBasisMatrix i j c).trace = 0"}, {"line": "simp [trace, -diag_apply, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trace_eq : trace (stdBasisMatrix i i c) = c := by\n  -- Porting note: added `-diag_apply`\n  simp [trace, -diag_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Trace.lean", "context": {"open": ["Matrix"], "variables": ["{\u03b9 m n p : Type*} {\u03b1 R S : Type*}", "[Fintype m] [Fintype n] [Fintype p]", "[AddCommMonoid R]", "(n R)", "{n R}", "(n \u03b1 R)", "{n \u03b1 R}", "[AddCommGroup R]", "[DecidableEq n] [AddCommMonoidWithOne R]", "[DecidableEq m] [CommSemiring R]", "[AddCommMonoid R]", "{l m n : Type*} {R \u03b1 : Type*} [DecidableEq l] [DecidableEq m] [DecidableEq n]", "[Fintype n] [AddCommMonoid \u03b1] (i j : n) (c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_10\n\u03b1 : Type u_12\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : AddCommMonoid \u03b1\ni : n\nc : \u03b1\n\u22a2 (stdBasisMatrix i i c).trace = c"}, {"line": "simp [trace, -diag_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transvection_zero : transvection i j (0 : R) = 1 := by simp [transvection]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": [], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ntransvection : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [transvection]", "tactic_state": "x\u271d : Sort u_4\ntransvection : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem transvection_mul_transvection_same (h : i \u2260 j) (c d : R) :\n    transvection i j c * transvection i j d = transvection i j (c + d) := by\n  simp [transvection, Matrix.add_mul, Matrix.mul_add, h, h.symm, add_smul, add_assoc,\n    stdBasisMatrix_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": [], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\ni j : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\nh : i \u2260 j\nc d : R\n\u22a2 sorry * sorry = sorry"}, {"line": "simp [transvection, Matrix.add_mul, Matrix.mul_add, h, h.symm, add_smul, add_assoc,\n    stdBasisMatrix_add]", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\ni j : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\nh : i \u2260 j\nc d : R\n\u22a2 sorry () * sorry () = sorry ()"}]}
{"declaration": "theorem transvection_mul_apply_same (b : n) (c : R) (M : Matrix n n R) :\n    (transvection i j c * M) i b = M i b + c * M j b := by simp [transvection, Matrix.add_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": [], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\ni j : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\nb : n\nc : R\nM : Matrix n n R\n\u22a2 sorry = M i b + c * M j b"}, {"line": "simp [transvection, Matrix.add_mul]", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\ni j : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\nb : n\nc : R\nM : Matrix n n R\n\u22a2 sorry () = M i b + c * M j b"}]}
{"declaration": "theorem mul_transvection_apply_same (a : n) (c : R) (M : Matrix n n R) :\n    (M * transvection i j c) a j = M a j + c * M a i := by\n  simp [transvection, Matrix.mul_add, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": [], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\ni j : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\na : n\nc : R\nM : Matrix n n R\n\u22a2 sorry = M a j + c * M a i"}, {"line": "simp [transvection, Matrix.mul_add, mul_comm]", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\ni j : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\na : n\nc : R\nM : Matrix n n R\n\u22a2 sorry () = M a j + c * M a i"}]}
{"declaration": "theorem transvection_mul_apply_of_ne (a b : n) (ha : a \u2260 i) (c : R) (M : Matrix n n R) :\n    (transvection i j c * M) a b = M a b := by simp [transvection, Matrix.add_mul, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": [], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\ni : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\na b : n\nha : a \u2260 i\nc : R\nM : Matrix n n R\n\u22a2 sorry = M a b"}, {"line": "simp [transvection, Matrix.add_mul, ha]", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\ni : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\na b : n\nha : a \u2260 i\nc : R\nM : Matrix n n R\n\u22a2 sorry () = M a b"}]}
{"declaration": "theorem mul_transvection_apply_of_ne (a b : n) (hb : b \u2260 j) (c : R) (M : Matrix n n R) :\n    (M * transvection i j c) a b = M a b := by simp [transvection, Matrix.mul_add, hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": [], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)", "[Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\nj : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\na b : n\nhb : b \u2260 j\nc : R\nM : Matrix n n R\n\u22a2 sorry = M a b"}, {"line": "simp [transvection, Matrix.mul_add, hb]", "tactic_state": "n : Type u_1\nR : Type u\u2082\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : CommRing R\nj : n\ninst\u271d : Fintype n\nx\u271d : Sort u_4\ntransvection : x\u271d\na b : n\nhb : b \u2260 j\nc : R\nM : Matrix n n R\n\u22a2 sorry () = M a b"}]}
{"declaration": "theorem length_listTransvecCol : (listTransvecCol M).length = r := by simp [listTransvecCol]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": ["Sum", "Unit Sum Fin TransvectionStruct"], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)", "[Fintype n]", "(R n)", "{R n}", "[Fintype n]", "{p}", "[Fintype n] [Fintype p]", "{R} {r : \u2115} (M : Matrix (Fin r \u2295 Unit) (Fin r \u2295 Unit) \ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nlistTransvecCol : x\u271d\n\u03b1\u271d : Sort u_5\nr : \u03b1\u271d\n\u22a2 sorry = r"}, {"line": "simp [listTransvecCol]", "tactic_state": "x\u271d : Sort u_4\nlistTransvecCol : x\u271d\n\u03b1\u271d : Sort u_5\nr : \u03b1\u271d\n\u22a2 sorry () = r"}]}
{"declaration": "theorem listTransvecCol_getElem {i : \u2115} (h : i < (listTransvecCol M).length) :\n    (listTransvecCol M)[i] =\n      letI i' : Fin r := \u27e8i, length_listTransvecCol M \u25b8 h\u27e9\n      transvection (inl i') (inr unit) <| -M (inl i') (inr unit) / M (inr unit) (inr unit) := by\n  simp [listTransvecCol]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": ["Sum", "Unit Sum Fin TransvectionStruct"], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)", "[Fintype n]", "(R n)", "{R n}", "[Fintype n]", "{p}", "[Fintype n] [Fintype p]", "{R} {r : \u2115} (M : Matrix (Fin r \u2295 Unit) (Fin r \u2295 Unit) \ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_4\nlistTransvecCol : x\u271d\u00b2\nr : \u2115\nx\u271d\u00b9 : Sort u_5\nlength_listTransvecCol : x\u271d\u00b9\nx\u271d : Sort u_6\ntransvection : x\u271d\ni : \u2115\nh : i < sorry\n\u22a2 sorry[i] = sorry"}, {"line": "simp [listTransvecCol]", "tactic_state": "x\u271d\u00b2 : Sort u_4\nlistTransvecCol : x\u271d\u00b2\nr : \u2115\nx\u271d\u00b9 : Sort u_5\nlength_listTransvecCol : x\u271d\u00b9\nx\u271d : Sort u_6\ntransvection : x\u271d\ni : \u2115\nh : i < sorry\n\u22a2 (sorry ())[i] = sorry ()"}]}
{"declaration": "theorem length_listTransvecRow : (listTransvecRow M).length = r := by simp [listTransvecRow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": ["Sum", "Unit Sum Fin TransvectionStruct"], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)", "[Fintype n]", "(R n)", "{R n}", "[Fintype n]", "{p}", "[Fintype n] [Fintype p]", "{R} {r : \u2115} (M : Matrix (Fin r \u2295 Unit) (Fin r \u2295 Unit) \ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nlistTransvecRow : x\u271d\n\u03b1\u271d : Sort u_5\nr : \u03b1\u271d\n\u22a2 sorry = r"}, {"line": "simp [listTransvecRow]", "tactic_state": "x\u271d : Sort u_4\nlistTransvecRow : x\u271d\n\u03b1\u271d : Sort u_5\nr : \u03b1\u271d\n\u22a2 sorry () = r"}]}
{"declaration": "theorem listTransvecRow_getElem {i : \u2115} (h : i < (listTransvecRow M).length) :\n    (listTransvecRow M)[i] =\n      letI i' : Fin r := \u27e8i, length_listTransvecRow M \u25b8 h\u27e9\n      transvection (inr unit) (inl i') <| -M (inr unit) (inl i') / M (inr unit) (inr unit) := by\n  simp [listTransvecRow, Fin.cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Transvection.lean", "context": {"open": ["Sum", "Unit Sum Fin TransvectionStruct"], "variables": ["(n p : Type*) (R : Type u\u2082) {\ud835\udd5c : Type*} [Field \ud835\udd5c]", "[DecidableEq n] [DecidableEq p]", "[CommRing R]", "{R n} (i j : n)", "[Fintype n]", "(R n)", "{R n}", "[Fintype n]", "{p}", "[Fintype n] [Fintype p]", "{R} {r : \u2115} (M : Matrix (Fin r \u2295 Unit) (Fin r \u2295 Unit) \ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_4\nlistTransvecRow : x\u271d\u00b2\nr : \u2115\nx\u271d\u00b9 : Sort u_5\nlength_listTransvecRow : x\u271d\u00b9\nx\u271d : Sort u_6\ntransvection : x\u271d\ni : \u2115\nh : i < sorry\n\u22a2 sorry[i] = sorry"}, {"line": "simp [listTransvecRow, Fin.cast]", "tactic_state": "x\u271d\u00b2 : Sort u_4\nlistTransvecRow : x\u271d\u00b2\nr : \u2115\nx\u271d\u00b9 : Sort u_5\nlength_listTransvecRow : x\u271d\u00b9\nx\u271d : Sort u_6\ntransvection : x\u271d\ni : \u2115\nh : i < sorry\n\u22a2 (sorry ())[i] = sorry ()"}]}
{"declaration": "theorem zpow_neg_natCast (A : M) (n : \u2115) : A ^ (-n : \u2124) = (A ^ n)\u207b\u00b9 := by\n  cases n\n  \u00b7 simp\n  \u00b7 exact DivInvMonoid.zpow_neg' _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ZPow.lean", "context": {"open": ["Matrix", "Int"], "variables": ["{n' : Type*} [DecidableEq n'] [Fintype n'] {R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nA : M\nn : \u2115\n\u22a2 sorry"}, {"line": "cases n", "tactic_state": "case zero\nM : Type u_3\nA : M\n\u22a2 sorry\n---\ncase succ\nM : Type u_3\nA : M\nn\u271d : \u2115\n\u22a2 sorry"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nM : Type u_3\nA : M\nn\u271d : \u2115\n\u22a2 sorry"}, {"line": "\u00b7 exact DivInvMonoid.zpow_neg' _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.IsUnit.det_zpow {A : M} (h : IsUnit A.det) (n : \u2124) : IsUnit (A ^ n).det := by\n  rcases n with n | n\n  \u00b7 simpa using h.pow n\n  \u00b7 simpa using h.pow n.succ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/ZPow.lean", "context": {"open": ["Matrix", "Int"], "variables": ["{n' : Type*} [DecidableEq n'] [Fintype n'] {R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nA : M\nh : IsUnit sorry\nn : \u2124\n\u22a2 IsUnit sorry"}, {"line": "rcases n with n | n", "tactic_state": "case ofNat\nM : Type u_3\nA : M\nh : IsUnit sorry\nn : \u2115\n\u22a2 IsUnit sorry\n---\ncase negSucc\nM : Type u_3\nA : M\nh : IsUnit sorry\nn : \u2115\n\u22a2 IsUnit sorry"}, {"line": "\u00b7 simpa using h.pow n", "tactic_state": "case negSucc\nM : Type u_3\nA : M\nh : IsUnit sorry\nn : \u2115\n\u22a2 IsUnit sorry"}, {"line": "\u00b7 simpa using h.pow n.succ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trace_eq_sum_roots_charpoly_of_splits (hAps : A.charpoly.Splits (RingHom.id R)) :\n    A.trace = (Matrix.charpoly A).roots.sum := by\n  rcases isEmpty_or_nonempty n with h | _\n  \u00b7 rw [Matrix.trace, Fintype.sum_empty, Matrix.charpoly,\n      det_eq_one_of_card_eq_zero (Fintype.card_eq_zero_iff.2 h), Polynomial.roots_one,\n      Multiset.empty_eq_zero, Multiset.sum_zero]\n  \u00b7 rw [trace_eq_neg_charpoly_coeff, neg_eq_iff_eq_neg,\n      \u2190 Polynomial.sum_roots_eq_nextCoeff_of_monic_of_split A.charpoly_monic hAps, nextCoeff,\n      charpoly_natDegree_eq_dim, if_neg (Fintype.card_ne_zero : Fintype.card n \u2260 0)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Eigs.lean", "context": {"open": ["Matrix Polynomial", "scoped Matrix"], "variables": ["{n : Type*} [Fintype n] [DecidableEq n]", "{R : Type*} [Field R]", "{A : Matrix n n R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\nR : Type u_2\ninst\u271d : Field R\nA : Matrix n n R\nhAps : Splits (RingHom.id R) A.charpoly\n\u22a2 A.trace = A.charpoly.roots.sum"}, {"line": "rcases isEmpty_or_nonempty n with h | _", "tactic_state": "case inl\nn : Type u_1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\nR : Type u_2\ninst\u271d : Field R\nA : Matrix n n R\nhAps : Splits (RingHom.id R) A.charpoly\nh : IsEmpty n\n\u22a2 A.trace = A.charpoly.roots.sum\n---\ncase inr\nn : Type u_1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\nR : Type u_2\ninst\u271d : Field R\nA : Matrix n n R\nhAps : Splits (RingHom.id R) A.charpoly\nh\u271d : Nonempty n\n\u22a2 A.trace = A.charpoly.roots.sum"}, {"line": "\u00b7 rw [Matrix.trace, Fintype.sum_empty, Matrix.charpoly,\n      det_eq_one_of_card_eq_zero (Fintype.card_eq_zero_iff.2 h), Polynomial.roots_one,\n      Multiset.empty_eq_zero, Multiset.sum_zero]", "tactic_state": "case inr\nn : Type u_1\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\nR : Type u_2\ninst\u271d : Field R\nA : Matrix n n R\nhAps : Splits (RingHom.id R) A.charpoly\nh\u271d : Nonempty n\n\u22a2 A.trace = A.charpoly.roots.sum"}, {"line": "\u00b7 rw [trace_eq_neg_charpoly_coeff, neg_eq_iff_eq_neg,\n      \u2190 Polynomial.sum_roots_eq_nextCoeff_of_monic_of_split A.charpoly_monic hAps, nextCoeff,\n      charpoly_natDegree_eq_dim, if_neg (Fintype.card_ne_zero : Fintype.card n \u2260 0)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ZMod.charpoly_pow_card {p : \u2115} [Fact p.Prime] (M : Matrix n n (ZMod p)) :\n    (M ^ p).charpoly = M.charpoly := by\n  have h := FiniteField.Matrix.charpoly_pow_card M\n  rwa [ZMod.card] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/FiniteField.lean", "context": {"open": ["Polynomial Matrix", "scoped Polynomial"], "variables": ["{n : Type*} [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nM : Matrix n n (ZMod p)\n\u22a2 (M ^ p).charpoly = M.charpoly"}, {"line": "have h := FiniteField.Matrix.charpoly_pow_card M", "tactic_state": "case refine_5\nn : Type u_1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nM : Matrix n n (ZMod p)\nh : (M ^ Fintype.card (ZMod p)).charpoly = M.charpoly\n\u22a2 (M ^ p).charpoly = M.charpoly\n---\ncase refine_1\nn : Type u_1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nM : Matrix n n (ZMod p)\n\u22a2 DecidableEq n\n---\ncase refine_2\nn : Type u_1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nM : Matrix n n (ZMod p)\n\u22a2 Fintype n\n---\ncase refine_3\nn : Type u_1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nM : Matrix n n (ZMod p)\n\u22a2 Field (ZMod p)\n---\ncase refine_4\nn : Type u_1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nM : Matrix n n (ZMod p)\n\u22a2 Fintype (ZMod p)"}, {"line": "rwa [ZMod.card] at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem charmatrix_apply_eq : charmatrix M i i = (X : R[X]) - C (M i i) := by\n  simp only [charmatrix]\n  simp only [RingHom.mapMatrix_apply]\n  simp only [sub_apply]\n  simp only [scalar_apply]\n  simp only [map_apply]\n  simp only [diagonal_apply_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\ni : n\n\u22a2 M.charmatrix i i = X - C (M i i)"}, {"line": "simp only [charmatrix]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\ni : n\n\u22a2 ((scalar n) X - C.mapMatrix M) i i = X - C (M i i)"}, {"line": "simp only [RingHom.mapMatrix_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\ni : n\n\u22a2 ((scalar n) X - M.map \u21d1C) i i = X - C (M i i)"}, {"line": "simp only [sub_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\ni : n\n\u22a2 (scalar n) X i i - M.map (\u21d1C) i i = X - C (M i i)"}, {"line": "simp only [scalar_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\ni : n\n\u22a2 diagonal (fun x => X) i i - M.map (\u21d1C) i i = X - C (M i i)"}, {"line": "simp only [map_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\ni : n\n\u22a2 diagonal (fun x => X) i i - C (M i i) = X - C (M i i)"}, {"line": "simp only [diagonal_apply_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem charmatrix_reindex (e : n \u2243 m) :\n    charmatrix (reindex e e M) = reindex e e (charmatrix M) := by\n  ext i j x\n  by_cases h : i = j\n  all_goals simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM : Matrix n n R\ne : n \u2243 m\n\u22a2 ((reindex e e) M).charmatrix = (reindex e e) M.charmatrix"}, {"line": "ext i j x", "tactic_state": "case a\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM : Matrix n n R\ne : n \u2243 m\ni j : m\n\u22a2 ((reindex e e) M).charmatrix i j = (reindex e e) M.charmatrix i j"}, {"line": "by_cases h : i = j", "tactic_state": "case pos\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM : Matrix n n R\ne : n \u2243 m\ni j : m\nh : i = j\n\u22a2 ((reindex e e) M).charmatrix i j = (reindex e e) M.charmatrix i j\n---\ncase neg\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM : Matrix n n R\ne : n \u2243 m\ni j : m\nh : \u00aci = j\n\u22a2 ((reindex e e) M).charmatrix i j = (reindex e e) M.charmatrix i j"}, {"line": "all_goals simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma charmatrix_map (M : Matrix n n R) (f : R \u2192+* S) :\n    charmatrix (M.map f) = (charmatrix M).map (Polynomial.map f) := by\n  ext i j\n  by_cases h : i = j <;> simp [h, charmatrix, diagonal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nf : R \u2192+* S\n\u22a2 (M.map \u21d1f).charmatrix = M.charmatrix.map (Polynomial.map f)"}, {"line": "ext i j", "tactic_state": "case a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nf : R \u2192+* S\ni j : n\n\u22a2 (M.map \u21d1f).charmatrix i j = M.charmatrix.map (Polynomial.map f) i j"}, {"line": "by_cases h : i = j <;> simp [h, charmatrix, diagonal]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma charmatrix_fromBlocks :\n    charmatrix (fromBlocks M\u2081\u2081 M\u2081\u2082 M\u2082\u2081 M\u2082\u2082) =\n      fromBlocks (charmatrix M\u2081\u2081) (- M\u2081\u2082.map C) (- M\u2082\u2081.map C) (charmatrix M\u2082\u2082) := by\n  simp only [charmatrix]\n  ext (i|i) (j|j) : 2 <;> simp [diagonal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2081\u2082 : Matrix m n R\nM\u2082\u2081 : Matrix n m R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081 M\u2081\u2082 M\u2082\u2081 M\u2082\u2082).charmatrix = fromBlocks M\u2081\u2081.charmatrix (-M\u2081\u2082.map \u21d1C) (-M\u2082\u2081.map \u21d1C) M\u2082\u2082.charmatrix"}, {"line": "simp only [charmatrix]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2081\u2082 : Matrix m n R\nM\u2082\u2081 : Matrix n m R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (scalar (m \u2295 n)) X - C.mapMatrix (fromBlocks M\u2081\u2081 M\u2081\u2082 M\u2082\u2081 M\u2082\u2082) =\n    fromBlocks ((scalar m) X - C.mapMatrix M\u2081\u2081) (-M\u2081\u2082.map \u21d1C) (-M\u2082\u2081.map \u21d1C) ((scalar n) X - C.mapMatrix M\u2082\u2082)"}, {"line": "ext (i|i) (j|j) : 2 <;> simp [diagonal]", "tactic_state": "case a.inl.inl\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2081\u2082 : Matrix m n R\nM\u2082\u2081 : Matrix n m R\nM\u2082\u2082 : Matrix n n R\ni j : m\n\u22a2 (if Sum.inl i = Sum.inl j then X else 0) = if i = j then X else 0\n---\ncase a.inr.inr\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2081\u2082 : Matrix m n R\nM\u2082\u2081 : Matrix n m R\nM\u2082\u2082 : Matrix n n R\ni j : n\n\u22a2 (if Sum.inr i = Sum.inr j then X else 0) = if i = j then X else 0"}]}
{"declaration": "lemma charmatrix_blockTriangular_iff {\u03b1 : Type*} [Preorder \u03b1] {M : Matrix n n R} {b : n \u2192 \u03b1} :\n    M.charmatrix.BlockTriangular b \u2194 M.BlockTriangular b := by\n  rw [charmatrix]\n  rw [scalar_apply]\n  rw [RingHom.mapMatrix_apply]\n  rw [(blockTriangular_diagonal _).sub_iff_right]\n  simp [BlockTriangular]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 : Type u_5\ninst\u271d : Preorder \u03b1\nM : Matrix n n R\nb : n \u2192 \u03b1\n\u22a2 M.charmatrix.BlockTriangular b \u2194 M.BlockTriangular b"}, {"line": "rw [charmatrix]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 : Type u_5\ninst\u271d : Preorder \u03b1\nM : Matrix n n R\nb : n \u2192 \u03b1\n\u22a2 ((scalar n) X - C.mapMatrix M).BlockTriangular b \u2194 M.BlockTriangular b"}, {"line": "rw [scalar_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 : Type u_5\ninst\u271d : Preorder \u03b1\nM : Matrix n n R\nb : n \u2192 \u03b1\n\u22a2 ((diagonal fun x => X) - C.mapMatrix M).BlockTriangular b \u2194 M.BlockTriangular b"}, {"line": "rw [RingHom.mapMatrix_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 : Type u_5\ninst\u271d : Preorder \u03b1\nM : Matrix n n R\nb : n \u2192 \u03b1\n\u22a2 ((diagonal fun x => X) - M.map \u21d1C).BlockTriangular b \u2194 M.BlockTriangular b"}, {"line": "rw [(blockTriangular_diagonal _).sub_iff_right]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 : Type u_5\ninst\u271d : Preorder \u03b1\nM : Matrix n n R\nb : n \u2192 \u03b1\n\u22a2 (M.map \u21d1C).BlockTriangular b \u2194 M.BlockTriangular b"}, {"line": "simp [BlockTriangular]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem charpoly_reindex (e : n \u2243 m)\n    (M : Matrix n n R) : (reindex e e M).charpoly = M.charpoly := by\n  unfold Matrix.charpoly\n  rw [charmatrix_reindex]\n  rw [Matrix.det_reindex_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\ne : n \u2243 m\nM : Matrix n n R\n\u22a2 ((reindex e e) M).charpoly = M.charpoly"}, {"line": "unfold Matrix.charpoly", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\ne : n \u2243 m\nM : Matrix n n R\n\u22a2 ((reindex e e) M).charmatrix.det = M.charmatrix.det"}, {"line": "rw [charmatrix_reindex]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\ne : n \u2243 m\nM : Matrix n n R\n\u22a2 ((reindex e e) M.charmatrix).det = M.charmatrix.det\n---\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\ne : n \u2243 m\nM : Matrix n n R\n\u22a2 DecidableEq n\n---\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\ne : n \u2243 m\nM : Matrix n n R\n\u22a2 Fintype n"}, {"line": "rw [Matrix.det_reindex_self]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma charpoly_map (M : Matrix n n R) (f : R \u2192+* S) :\n    (M.map f).charpoly = M.charpoly.map f := by\n  rw [charpoly]\n  rw [charmatrix_map]\n  rw [\u2190 Polynomial.coe_mapRingHom]\n  rw [charpoly]\n  rw [RingHom.map_det]\n  rw [RingHom.mapMatrix_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nf : R \u2192+* S\n\u22a2 (M.map \u21d1f).charpoly = Polynomial.map f M.charpoly"}, {"line": "rw [charpoly]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nf : R \u2192+* S\n\u22a2 (M.map \u21d1f).charmatrix.det = Polynomial.map f M.charpoly"}, {"line": "rw [charmatrix_map]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nf : R \u2192+* S\n\u22a2 (M.charmatrix.map (Polynomial.map f)).det = Polynomial.map f M.charpoly"}, {"line": "rw [\u2190 Polynomial.coe_mapRingHom]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nf : R \u2192+* S\n\u22a2 (M.charmatrix.map \u21d1(mapRingHom f)).det = (mapRingHom f) M.charpoly"}, {"line": "rw [charpoly]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nf : R \u2192+* S\n\u22a2 (M.charmatrix.map \u21d1(mapRingHom f)).det = (mapRingHom f) M.charmatrix.det"}, {"line": "rw [RingHom.map_det]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\nn : Type u_4\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nf : R \u2192+* S\n\u22a2 (M.charmatrix.map \u21d1(mapRingHom f)).det = ((mapRingHom f).mapMatrix M.charmatrix).det"}, {"line": "rw [RingHom.mapMatrix_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma charpoly_fromBlocks_zero\u2081\u2082 :\n    (fromBlocks M\u2081\u2081 0 M\u2082\u2081 M\u2082\u2082).charpoly = (M\u2081\u2081.charpoly * M\u2082\u2082.charpoly) := by\n  simp only [charpoly]\n  simp only [charmatrix_fromBlocks]\n  simp only [Matrix.map_zero _ (Polynomial.C_0)]\n  simp only [neg_zero]\n  simp only [det_fromBlocks_zero\u2081\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2082\u2081 : Matrix n m R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081 0 M\u2082\u2081 M\u2082\u2082).charpoly = M\u2081\u2081.charpoly * M\u2082\u2082.charpoly"}, {"line": "simp only [charpoly]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2082\u2081 : Matrix n m R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081 0 M\u2082\u2081 M\u2082\u2082).charmatrix.det = M\u2081\u2081.charmatrix.det * M\u2082\u2082.charmatrix.det"}, {"line": "simp only [charmatrix_fromBlocks]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2082\u2081 : Matrix n m R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081.charmatrix (-Matrix.map 0 \u21d1C) (-M\u2082\u2081.map \u21d1C) M\u2082\u2082.charmatrix).det =\n    M\u2081\u2081.charmatrix.det * M\u2082\u2082.charmatrix.det"}, {"line": "simp only [Matrix.map_zero _ (Polynomial.C_0)]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2082\u2081 : Matrix n m R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081.charmatrix (-0) (-M\u2082\u2081.map \u21d1C) M\u2082\u2082.charmatrix).det = M\u2081\u2081.charmatrix.det * M\u2082\u2082.charmatrix.det"}, {"line": "simp only [neg_zero]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2082\u2081 : Matrix n m R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081.charmatrix 0 (-M\u2082\u2081.map \u21d1C) M\u2082\u2082.charmatrix).det = M\u2081\u2081.charmatrix.det * M\u2082\u2082.charmatrix.det"}, {"line": "simp only [det_fromBlocks_zero\u2081\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma charpoly_fromBlocks_zero\u2082\u2081 :\n    (fromBlocks M\u2081\u2081 M\u2081\u2082 0 M\u2082\u2082).charpoly = (M\u2081\u2081.charpoly * M\u2082\u2082.charpoly) := by\n  simp only [charpoly]\n  simp only [charmatrix_fromBlocks]\n  simp only [Matrix.map_zero _ (Polynomial.C_0)]\n  simp only [neg_zero]\n  simp only [det_fromBlocks_zero\u2082\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2081\u2082 : Matrix m n R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081 M\u2081\u2082 0 M\u2082\u2082).charpoly = M\u2081\u2081.charpoly * M\u2082\u2082.charpoly"}, {"line": "simp only [charpoly]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2081\u2082 : Matrix m n R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081 M\u2081\u2082 0 M\u2082\u2082).charmatrix.det = M\u2081\u2081.charmatrix.det * M\u2082\u2082.charmatrix.det"}, {"line": "simp only [charmatrix_fromBlocks]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2081\u2082 : Matrix m n R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081.charmatrix (-M\u2081\u2082.map \u21d1C) (-Matrix.map 0 \u21d1C) M\u2082\u2082.charmatrix).det =\n    M\u2081\u2081.charmatrix.det * M\u2082\u2082.charmatrix.det"}, {"line": "simp only [Matrix.map_zero _ (Polynomial.C_0)]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2081\u2082 : Matrix m n R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081.charmatrix (-M\u2081\u2082.map \u21d1C) (-0) M\u2082\u2082.charmatrix).det = M\u2081\u2081.charmatrix.det * M\u2082\u2082.charmatrix.det"}, {"line": "simp only [neg_zero]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nm : Type u_3\nn : Type u_4\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM\u2081\u2081 : Matrix m m R\nM\u2081\u2082 : Matrix m n R\nM\u2082\u2082 : Matrix n n R\n\u22a2 (fromBlocks M\u2081\u2081.charmatrix (-M\u2081\u2082.map \u21d1C) 0 M\u2082\u2082.charmatrix).det = M\u2081\u2081.charmatrix.det * M\u2082\u2082.charmatrix.det"}, {"line": "simp only [det_fromBlocks_zero\u2082\u2081]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma charmatrix_toSquareBlock {\u03b1 : Type*} [DecidableEq \u03b1] {b : n \u2192 \u03b1} {a : \u03b1} :\n    (M.toSquareBlock b a).charmatrix = M.charmatrix.toSquareBlock b a := by\n  ext i j : 1\n  simp [charmatrix_apply, toSquareBlock_def, diagonal_apply, Subtype.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix n n R\n\u03b1 : Type u_5\ninst\u271d : DecidableEq \u03b1\nb : n \u2192 \u03b1\na : \u03b1\n\u22a2 (M.toSquareBlock b a).charmatrix = M.charmatrix.toSquareBlock b a"}, {"line": "ext i j : 1", "tactic_state": "case a\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix n n R\n\u03b1 : Type u_5\ninst\u271d : DecidableEq \u03b1\nb : n \u2192 \u03b1\na : \u03b1\ni j : { a_1 // b a_1 = a }\n\u22a2 (M.toSquareBlock b a).charmatrix i j = M.charmatrix.toSquareBlock b a i j"}, {"line": "simp [charmatrix_apply, toSquareBlock_def, diagonal_apply, Subtype.ext_iff]", "tactic_state": "case a\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix n n R\n\u03b1 : Type u_5\ninst\u271d : DecidableEq \u03b1\nb : n \u2192 \u03b1\na : \u03b1\ni j : { a_1 // b a_1 = a }\n\u22a2 (if i = j then X else 0) = if \u2191i = \u2191j then X else 0"}]}
{"declaration": "lemma charpoly_of_upperTriangular [LinearOrder n] (M : Matrix n n R) (h : M.BlockTriangular id) :\n    M.charpoly = \u220f i : n, (X - C (M i i)) := by\n  simp [charpoly, det_of_upperTriangular h.charmatrix]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]", "{m n : Type*} [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n]", "(M\u2081\u2081 : Matrix m m R) (M\u2081\u2082 : Matrix m n R) (M\u2082\u2081 : Matrix n m R) (M\u2082\u2082 M : Matrix n n R)", "(i j : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : LinearOrder n\nM : Matrix n n R\nh : M.BlockTriangular id\n\u22a2 M.charpoly = \u220f i, (X - C (M i i))"}, {"line": "simp [charpoly, det_of_upperTriangular h.charmatrix]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nn : Type u_4\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : LinearOrder n\nM : Matrix n n R\nh : M.BlockTriangular id\n\u22a2 M.charmatrix.det = \u220f i, (X - C (M i i))"}]}
{"declaration": "theorem charmatrix_apply_natDegree [Nontrivial R] (i j : n) :\n    (charmatrix M i j).natDegree = ite (i = j) 1 0 := by\n  by_cases h : i = j <;> simp [h, \u2190 degree_eq_iff_natDegree_eq_of_pos (Nat.succ_pos 0)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R : Type u} [CommRing R]", "{n G : Type v} [DecidableEq n] [Fintype n]", "{\u03b1 \u03b2 : Type v} [DecidableEq \u03b1]", "{M : Matrix n n R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : CommRing R\nn : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix n n R\ninst\u271d : Nontrivial R\ni j : n\n\u22a2 (M.charmatrix i j).natDegree = if i = j then 1 else 0"}, {"line": "by_cases h : i = j <;> simp [h, \u2190 degree_eq_iff_natDegree_eq_of_pos (Nat.succ_pos 0)]", "tactic_state": "case pos\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix n n R\ninst\u271d : Nontrivial R\ni j : n\nh : i = j\n\u22a2 X.degree = 1"}]}
{"declaration": "theorem charmatrix_apply_natDegree_le (i j : n) :\n    (charmatrix M i j).natDegree \u2264 ite (i = j) 1 0 := by\n  split_ifs with h <;> simp [h, natDegree_X_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R : Type u} [CommRing R]", "{n G : Type v} [DecidableEq n] [Fintype n]", "{\u03b1 \u03b2 : Type v} [DecidableEq \u03b1]", "{M : Matrix n n R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\ni j : n\n\u22a2 (M.charmatrix i j).natDegree \u2264 if i = j then 1 else 0"}, {"line": "split_ifs with h <;> simp [h, natDegree_X_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem matPolyEquiv_eval_eq_map (M : Matrix n n R[X]) (r : R) :\n    (matPolyEquiv M).eval (scalar n r) = M.map (eval r) := by\n  simpa only [AlgEquiv.symm_apply_apply] using (matPolyEquiv_symm_map_eval (matPolyEquiv M) r).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R : Type u} [CommRing R]", "{n G : Type v} [DecidableEq n] [Fintype n]", "{\u03b1 \u03b2 : Type v} [DecidableEq \u03b1]", "{M : Matrix n n R}", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\n\u22a2 eval ((scalar n) r) (matPolyEquiv M) = M.map (eval r)"}, {"line": "simpa only [AlgEquiv.symm_apply_apply] using (matPolyEquiv_symm_map_eval (matPolyEquiv M) r).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem matPolyEquiv_eval (M : Matrix n n R[X]) (r : R) (i j : n) :\n    (matPolyEquiv M).eval (scalar n r) i j = (M i j).eval r := by\n  rw [matPolyEquiv_eval_eq_map]\n  rw [map_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R : Type u} [CommRing R]", "{n G : Type v} [DecidableEq n] [Fintype n]", "{\u03b1 \u03b2 : Type v} [DecidableEq \u03b1]", "{M : Matrix n n R}", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\ni j : n\n\u22a2 eval ((scalar n) r) (matPolyEquiv M) i j = eval r (M i j)"}, {"line": "rw [matPolyEquiv_eval_eq_map]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\ni j : n\n\u22a2 M.map (eval r) i j = eval r (M i j)"}, {"line": "rw [map_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_det (M : Matrix n n R[X]) (r : R) :\n    Polynomial.eval r M.det = (Polynomial.eval (scalar n r) (matPolyEquiv M)).det := by\n  rw [Polynomial.eval]\n  rw [\u2190 coe_eval\u2082RingHom]\n  rw [RingHom.map_det]\n  apply congr_arg det\n  ext\n  symm\n  exact matPolyEquiv_eval _ _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R : Type u} [CommRing R]", "{n G : Type v} [DecidableEq n] [Fintype n]", "{\u03b1 \u03b2 : Type v} [DecidableEq \u03b1]", "{M : Matrix n n R}", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\n\u22a2 eval r M.det = (eval ((scalar n) r) (matPolyEquiv M)).det"}, {"line": "rw [Polynomial.eval]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\n\u22a2 eval\u2082 (RingHom.id R) r M.det = (eval ((scalar n) r) (matPolyEquiv M)).det"}, {"line": "rw [\u2190 coe_eval\u2082RingHom]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\n\u22a2 (eval\u2082RingHom (RingHom.id R) r) M.det = (eval ((scalar n) r) (matPolyEquiv M)).det"}, {"line": "rw [RingHom.map_det]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\n\u22a2 ((eval\u2082RingHom (RingHom.id R) r).mapMatrix M).det = (eval ((scalar n) r) (matPolyEquiv M)).det"}, {"line": "apply congr_arg det", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\n\u22a2 (eval\u2082RingHom (RingHom.id R) r).mapMatrix M = eval ((scalar n) r) (matPolyEquiv M)"}, {"line": "ext", "tactic_state": "case a\nR : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\ni\u271d j\u271d : n\n\u22a2 (eval\u2082RingHom (RingHom.id R) r).mapMatrix M i\u271d j\u271d = eval ((scalar n) r) (matPolyEquiv M) i\u271d j\u271d"}, {"line": "symm", "tactic_state": "case a\nR : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\ni\u271d j\u271d : n\n\u22a2 eval ((scalar n) r) (matPolyEquiv M) i\u271d j\u271d = (eval\u2082RingHom (RingHom.id R) r).mapMatrix M i\u271d j\u271d"}, {"line": "exact matPolyEquiv_eval _ _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_eq_sign_charpoly_coeff (M : Matrix n n R) :\n    M.det = (-1) ^ Fintype.card n * M.charpoly.coeff 0 := by\n  rw [coeff_zero_eq_eval_zero]\n  rw [charpoly]\n  rw [eval_det]\n  rw [matPolyEquiv_charmatrix]\n  rw [\u2190 det_smul]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R : Type u} [CommRing R]", "{n G : Type v} [DecidableEq n] [Fintype n]", "{\u03b1 \u03b2 : Type v} [DecidableEq \u03b1]", "{M : Matrix n n R}", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\n\u22a2 M.det = (-1) ^ Fintype.card n * M.charpoly.coeff 0"}, {"line": "rw [coeff_zero_eq_eval_zero]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\n\u22a2 M.det = (-1) ^ Fintype.card n * eval 0 M.charpoly"}, {"line": "rw [charpoly]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\n\u22a2 M.det = (-1) ^ Fintype.card n * eval 0 M.charmatrix.det"}, {"line": "rw [eval_det]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\n\u22a2 M.det = (-1) ^ Fintype.card n * (eval ((scalar n) 0) (matPolyEquiv M.charmatrix)).det"}, {"line": "rw [matPolyEquiv_charmatrix]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\n\u22a2 M.det = (-1) ^ Fintype.card n * (eval ((scalar n) 0) (X - C M)).det"}, {"line": "rw [\u2190 det_smul]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\n\u22a2 M.det = (-1 \u2022 eval ((scalar n) 0) (X - C M)).det"}, {"line": "simp", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\n\u22a2 M.det = (-1 \u2022 eval 0 (X - C M)).det"}]}
{"declaration": "theorem pow_eq_aeval_mod_charpoly (M : Matrix n n R) (k : \u2115) :\n    M ^ k = aeval M (X ^ k %\u2098 M.charpoly) := by rw [\u2190 aeval_eq_aeval_mod_charpoly, map_pow, aeval_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "context": {"open": ["Finset Matrix Polynomial"], "variables": ["{R : Type u} [CommRing R]", "{n G : Type v} [DecidableEq n] [Fintype n]", "{\u03b1 \u03b2 : Type v} [DecidableEq \u03b1]", "{M : Matrix n n R}", "(M)", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nk : \u2115\n\u22a2 M ^ k = (aeval M) (X ^ k %\u2098 M.charpoly)"}, {"line": "rw [\u2190 aeval_eq_aeval_mod_charpoly, map_pow, aeval_X]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nk : \u2115\n\u22a2 MonoidHomClass (Polynomial R \u2192\u2090[R] Matrix n n R) (Polynomial R) (Matrix n n R)"}]}
{"declaration": "theorem Matrix.Represents.zero : (0 : Matrix \u03b9 \u03b9 R).Represents b 0 := by\n  delta Matrix.Represents\n  rw [map_zero]\n  rw [map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/LinearMap.lean", "context": {"open": ["Polynomial Matrix"], "variables": ["{\u03b9 : Type*} [Fintype \u03b9]", "{M : Type*} [AddCommGroup M] (R : Type*) [CommRing R] [Module R M] (I : Ideal R)", "(b : \u03b9 \u2192 M)", "{R} [DecidableEq \u03b9]", "{b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nb : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\n\u22a2 Represents b 0 0"}, {"line": "delta Matrix.Represents", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nb : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\n\u22a2 (PiToModule.fromMatrix R b) 0 = (PiToModule.fromEnd R b) 0"}, {"line": "rw [map_zero]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nb : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\n\u22a2 0 = (PiToModule.fromEnd R b) 0\n---\n\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nb : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\n\u22a2 ZeroHomClass (Matrix \u03b9 \u03b9 R \u2192\u2097[R] (\u03b9 \u2192 R) \u2192\u2097[R] M) (Matrix \u03b9 \u03b9 R) ((\u03b9 \u2192 R) \u2192\u2097[R] M)"}, {"line": "rw [map_zero]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nb : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\n\u22a2 ZeroHomClass (Matrix \u03b9 \u03b9 R \u2192\u2097[R] (\u03b9 \u2192 R) \u2192\u2097[R] M) (Matrix \u03b9 \u03b9 R) ((\u03b9 \u2192 R) \u2192\u2097[R] M)"}]}
{"declaration": "theorem Matrix.Represents.smul {A : Matrix \u03b9 \u03b9 R} {f : Module.End R M} (h : A.Represents b f)\n    (r : R) : (r \u2022 A).Represents b (r \u2022 f) := by\n  delta Matrix.Represents at h \u22a2\n  rw [map_smul]\n  rw [map_smul]\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/LinearMap.lean", "context": {"open": ["Polynomial Matrix"], "variables": ["{\u03b9 : Type*} [Fintype \u03b9]", "{M : Type*} [AddCommGroup M] (R : Type*) [CommRing R] [Module R M] (I : Ideal R)", "(b : \u03b9 \u2192 M)", "{R} [DecidableEq \u03b9]", "{b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nb : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\nA : Matrix \u03b9 \u03b9 R\nf : Module.End R M\nh : Represents b A f\nr : R\n\u22a2 Represents b (r \u2022 A) (r \u2022 f)"}, {"line": "delta Matrix.Represents at h \u22a2", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nb : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\nA : Matrix \u03b9 \u03b9 R\nf : Module.End R M\nh : (PiToModule.fromMatrix R b) A = (PiToModule.fromEnd R b) f\nr : R\n\u22a2 (PiToModule.fromMatrix R b) (r \u2022 A) = (PiToModule.fromEnd R b) (r \u2022 f)"}, {"line": "rw [map_smul]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nb : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\nA : Matrix \u03b9 \u03b9 R\nf : Module.End R M\nh : (PiToModule.fromMatrix R b) A = (PiToModule.fromEnd R b) f\nr : R\n\u22a2 r \u2022 (PiToModule.fromMatrix R b) A = (PiToModule.fromEnd R b) (r \u2022 f)"}, {"line": "rw [map_smul]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nb : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\nA : Matrix \u03b9 \u03b9 R\nf : Module.End R M\nh : (PiToModule.fromMatrix R b) A = (PiToModule.fromEnd R b) f\nr : R\n\u22a2 r \u2022 (PiToModule.fromMatrix R b) A = r \u2022 (PiToModule.fromEnd R b) f"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.Represents.algebraMap (r : R) :\n    (algebraMap _ (Matrix \u03b9 \u03b9 R) r).Represents b (algebraMap _ (Module.End R M) r) := by\n  simpa only [Algebra.algebraMap_eq_smul_one] using Matrix.Represents.one.smul r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Charpoly/LinearMap.lean", "context": {"open": ["Polynomial Matrix"], "variables": ["{\u03b9 : Type*} [Fintype \u03b9]", "{M : Type*} [AddCommGroup M] (R : Type*) [CommRing R] [Module R M] (I : Ideal R)", "(b : \u03b9 \u2192 M)", "{R} [DecidableEq \u03b9]", "{b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : CommRing R\nr : R\n\u22a2 sorry"}, {"line": "simpa only [Algebra.algebraMap_eq_smul_one] using Matrix.Represents.one.smul r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_apply' (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) i := by\n  simp [det_apply, Units.smul_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "context": {"open": ["Equiv Equiv.Perm Finset Function"], "variables": ["{m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]", "{R : Type v} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nR : Type v\ninst\u271d : CommRing R\nx\u271d : Sort u_3\n\u03b5 : x\u271d\nM : Matrix n n R\n\u22a2 M.det = \u2211 \u03c3, sorry * \u220f i, M (\u03c3 i) i"}, {"line": "simp [det_apply, Units.smul_def]", "tactic_state": "n : Type u_2\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nR : Type v\ninst\u271d : CommRing R\nx\u271d : Sort u_3\n\u03b5 : x\u271d\nM : Matrix n n R\n\u22a2 M.det = \u2211 x, sorry () * \u220f i, M (x i) i"}]}
{"declaration": "theorem det_isEmpty [IsEmpty n] {A : Matrix n n R} : det A = 1 := by simp [det_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "context": {"open": ["Equiv Equiv.Perm Finset Function"], "variables": ["{m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]", "{R : Type v} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_3\ndet : x\u271d\ninst\u271d : IsEmpty n\nA : Matrix n n R\n\u22a2 sorry = 1"}, {"line": "simp [det_apply]", "tactic_state": "n : Type u_2\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_3\ndet : x\u271d\ninst\u271d : IsEmpty n\nA : Matrix n n R\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem coe_det_isEmpty [IsEmpty n] : (det : Matrix n n R \u2192 R) = Function.const _ 1 := by\n  ext\n  exact det_isEmpty\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "context": {"open": ["Equiv Equiv.Perm Finset Function"], "variables": ["{m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]", "{R : Type v} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\ndet : Matrix n n R \u2192 R\ninst\u271d : IsEmpty n\n\u22a2 det = const (Matrix n n R) 1"}, {"line": "ext", "tactic_state": "case h\nn : Type u_2\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\ndet : Matrix n n R \u2192 R\ninst\u271d : IsEmpty n\nx\u271d : Matrix n n R\n\u22a2 det x\u271d = const (Matrix n n R) 1 x\u271d"}, {"line": "exact det_isEmpty", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_unique {n : Type*} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :\n    det A = A default default := by simp [det_apply, univ_unique]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "context": {"open": ["Equiv Equiv.Perm Finset Function"], "variables": ["{m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]", "{R : Type v} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type v\ninst\u271d\u00b3 : CommRing R\nx\u271d : Sort u_4\ndet : x\u271d\nn : Type u_3\ninst\u271d\u00b2 : Unique n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nA : Matrix n n R\n\u22a2 sorry = A default default"}, {"line": "simp [det_apply, univ_unique]", "tactic_state": "R : Type v\ninst\u271d\u00b3 : CommRing R\nx\u271d : Sort u_4\ndet : x\u271d\nn : Type u_3\ninst\u271d\u00b2 : Unique n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nA : Matrix n n R\n\u22a2 sorry () = A default default"}]}
{"declaration": "theorem det_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) :\n    det A = A k k := by\n  have := uniqueOfSubsingleton k\n  convert det_unique A\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "context": {"open": ["Equiv Equiv.Perm Finset Function"], "variables": ["{m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]", "{R : Type v} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_3\ndet : x\u271d\ninst\u271d : Subsingleton n\nA : Matrix n n R\nk : n\n\u22a2 sorry = A k k"}, {"line": "have := uniqueOfSubsingleton k", "tactic_state": "n : Type u_2\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_3\ndet : x\u271d\ninst\u271d : Subsingleton n\nA : Matrix n n R\nk : n\nthis : Unique n\n\u22a2 sorry = A k k"}, {"line": "convert det_unique A", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.RingHom.map_det (f : R \u2192+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) := by\n  simp [Matrix.det_apply', map_sum f, map_prod f]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "context": {"open": ["Equiv Equiv.Perm Finset Function"], "variables": ["{m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]", "{R : Type v} [CommRing R]", "{S : Type w} [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type w\ninst\u271d : CommRing S\nf : R \u2192+* S\nM : Matrix n n R\n\u22a2 f M.det = (f.mapMatrix M).det"}, {"line": "simp [Matrix.det_apply', map_sum f, map_prod f]", "tactic_state": "n : Type u_2\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type w\ninst\u271d : CommRing S\nf : R \u2192+* S\nM : Matrix n n R\n\u22a2 \u2211 x, f \u2191\u2191(sign x) * f (\u220f i, M (x i) i) = \u2211 x, \u2191\u2191(sign x) * \u220f x_1, f (M (x x_1) x_1)"}]}
{"declaration": "theorem det_eq_of_eq_mul_det_one {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)\n    (hA : A = B * C) : det A = det B :=\n  calc\n    det A = det (B * C) := congr_arg _ hA\n    _ = det B * det C := det_mul _ _\n    _ = det B := by rw [hC, mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "context": {"open": ["Equiv Equiv.Perm Finset Function"], "variables": ["{m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]", "{R : Type v} [CommRing R]", "{S : Type w} [CommRing S]", "{M : Matrix n n R} {i j : n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nR : Type v\ninst\u271d : CommRing R\nx\u271d : Sort u_3\ndet : x\u271d\nA B C : Matrix n n R\nhC : sorry = 1\nhA : A = B * C\n\u22a2 sorry * sorry = sorry"}, {"line": "rw [hC, mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_eq_of_eq_det_one_mul {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)\n    (hA : A = C * B) : det A = det B :=\n  calc\n    det A = det (C * B) := congr_arg _ hA\n    _ = det C * det B := det_mul _ _\n    _ = det B := by rw [hC, one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "context": {"open": ["Equiv Equiv.Perm Finset Function"], "variables": ["{m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]", "{R : Type v} [CommRing R]", "{S : Type w} [CommRing S]", "{M : Matrix n n R} {i j : n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_2\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nR : Type v\ninst\u271d : CommRing R\nx\u271d : Sort u_3\ndet : x\u271d\nA B C : Matrix n n R\nhC : sorry = 1\nhA : A = C * B\n\u22a2 sorry * sorry = sorry"}, {"line": "rw [hC, one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piFamily_single_left_apply [Fintype \u03b9] [\u2200 i, DecidableEq (\u03ba i)]\n    (p : \u03a0 i, \u03ba i) (f : MultilinearMap R (fun i \u21a6 M i (p i)) (N p)) (x : \u03a0 i j, M i j) :\n    piFamily (Pi.single p f) x = Pi.single p (f fun i => x i (p i)) := by\n  ext p'\n  obtain rfl | hp := eq_or_ne p p'\n  \u00b7 simp\n  \u00b7 simp [hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Multilinear/Pi.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u\u03b9} {\u03ba : \u03b9 \u2192 Type u\u03ba}", "{S : Type uS} {R : Type uR}", "{M : \u2200 i, \u03ba i \u2192 Type uM} {N : Type uN}", "[Semiring R]", "[\u2200 i k, AddCommMonoid (M i k)] [AddCommMonoid N]", "[\u2200 i k, Module R (M i k)] [Module R N]", "{M : \u2200 i, \u03ba i \u2192 Type uM} {N : (\u03a0 i, \u03ba i) \u2192 Type uN}", "[Semiring R]", "[\u2200 i k, AddCommMonoid (M i k)] [\u2200 p, AddCommMonoid (N p)]", "[\u2200 i k, Module R (M i k)] [\u2200 p, Module R (N p)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\u03b9\n\u03ba : \u03b9 \u2192 Type u\u03ba\nR : Type uR\ninst\u271d\u2077 : Semiring R\nM : (i : \u03b9) \u2192 \u03ba i \u2192 Type uM\nN : ((i : \u03b9) \u2192 \u03ba i) \u2192 Type uN\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 AddCommMonoid (M i k)\ninst\u271d\u2074 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 AddCommMonoid (N p)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 Module R (M i k)\ninst\u271d\u00b2 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 Module R (N p)\nx\u271d : Sort u_1\npiFamily : x\u271d\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03ba i)\np : (i : \u03b9) \u2192 \u03ba i\nf : MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : \u03b9) \u2192 (j : \u03ba i) \u2192 M i j\n\u22a2 sorry = Pi.single p (f fun i => x i (p i))"}, {"line": "ext p'", "tactic_state": "case h\n\u03b9 : Type u\u03b9\n\u03ba : \u03b9 \u2192 Type u\u03ba\nR : Type uR\ninst\u271d\u2077 : Semiring R\nM : (i : \u03b9) \u2192 \u03ba i \u2192 Type uM\nN : ((i : \u03b9) \u2192 \u03ba i) \u2192 Type uN\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 AddCommMonoid (M i k)\ninst\u271d\u2074 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 AddCommMonoid (N p)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 Module R (M i k)\ninst\u271d\u00b2 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 Module R (N p)\nx\u271d : Sort u_1\npiFamily : x\u271d\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03ba i)\np : (i : \u03b9) \u2192 \u03ba i\nf : MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : \u03b9) \u2192 (j : \u03ba i) \u2192 M i j\np' : (i : \u03b9) \u2192 \u03ba i\n\u22a2 sorry p' = Pi.single p (f fun i => x i (p i)) p'"}, {"line": "obtain rfl | hp := eq_or_ne p p'", "tactic_state": "case h.inl\n\u03b9 : Type u\u03b9\n\u03ba : \u03b9 \u2192 Type u\u03ba\nR : Type uR\ninst\u271d\u2077 : Semiring R\nM : (i : \u03b9) \u2192 \u03ba i \u2192 Type uM\nN : ((i : \u03b9) \u2192 \u03ba i) \u2192 Type uN\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 AddCommMonoid (M i k)\ninst\u271d\u2074 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 AddCommMonoid (N p)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 Module R (M i k)\ninst\u271d\u00b2 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 Module R (N p)\nx\u271d : Sort u_1\npiFamily : x\u271d\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03ba i)\np : (i : \u03b9) \u2192 \u03ba i\nf : MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : \u03b9) \u2192 (j : \u03ba i) \u2192 M i j\n\u22a2 sorry p = Pi.single p (f fun i => x i (p i)) p\n---\ncase h.inr\n\u03b9 : Type u\u03b9\n\u03ba : \u03b9 \u2192 Type u\u03ba\nR : Type uR\ninst\u271d\u2077 : Semiring R\nM : (i : \u03b9) \u2192 \u03ba i \u2192 Type uM\nN : ((i : \u03b9) \u2192 \u03ba i) \u2192 Type uN\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 AddCommMonoid (M i k)\ninst\u271d\u2074 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 AddCommMonoid (N p)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 Module R (M i k)\ninst\u271d\u00b2 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 Module R (N p)\nx\u271d : Sort u_1\npiFamily : x\u271d\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03ba i)\np : (i : \u03b9) \u2192 \u03ba i\nf : MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : \u03b9) \u2192 (j : \u03ba i) \u2192 M i j\np' : (i : \u03b9) \u2192 \u03ba i\nhp : p \u2260 p'\n\u22a2 sorry p' = Pi.single p (f fun i => x i (p i)) p'"}, {"line": "\u00b7 simp", "tactic_state": "case h.inr\n\u03b9 : Type u\u03b9\n\u03ba : \u03b9 \u2192 Type u\u03ba\nR : Type uR\ninst\u271d\u2077 : Semiring R\nM : (i : \u03b9) \u2192 \u03ba i \u2192 Type uM\nN : ((i : \u03b9) \u2192 \u03ba i) \u2192 Type uN\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 AddCommMonoid (M i k)\ninst\u271d\u2074 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 AddCommMonoid (N p)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 (k : \u03ba i) \u2192 Module R (M i k)\ninst\u271d\u00b2 : (p : (i : \u03b9) \u2192 \u03ba i) \u2192 Module R (N p)\nx\u271d : Sort u_1\npiFamily : x\u271d\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03ba i)\np : (i : \u03b9) \u2192 \u03ba i\nf : MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : \u03b9) \u2192 (j : \u03ba i) \u2192 M i j\np' : (i : \u03b9) \u2192 \u03ba i\nhp : p \u2260 p'\n\u22a2 sorry p' = Pi.single p (f fun i => x i (p i)) p'"}, {"line": "\u00b7 simp [hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem domCoprodDep'_apply (a : MultilinearMap R (fun i\u2081 \u21a6 N (.inl i\u2081)) N\u2081)\n    (b : MultilinearMap R (fun i\u2082 \u21a6 N (.inr i\u2082)) N\u2082) :\n    domCoprodDep' (a \u2297\u209c b) = domCoprodDep a b := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Multilinear/TensorProduct.lean", "context": {"open": ["TensorProduct"], "variables": ["{R \u03b9\u2081 \u03b9\u2082 \u03b9\u2083 \u03b9\u2084 : Type*}", "[CommSemiring R]", "{N\u2081 : Type*} [AddCommMonoid N\u2081] [Module R N\u2081]", "{N\u2082 : Type*} [AddCommMonoid N\u2082] [Module R N\u2082]", "{N : \u03b9\u2081 \u2295 \u03b9\u2082 \u2192 Type*} [\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b9\u2081 : Type u_2\n\u03b9\u2082 : Type u_3\ninst\u271d\u2076 : CommSemiring R\nN\u2081 : Type u_6\ninst\u271d\u2075 : AddCommMonoid N\u2081\ninst\u271d\u2074 : Module R N\u2081\nN\u2082 : Type u_7\ninst\u271d\u00b3 : AddCommMonoid N\u2082\ninst\u271d\u00b2 : Module R N\u2082\nN : \u03b9\u2081 \u2295 \u03b9\u2082 \u2192 Type u_8\ninst\u271d\u00b9 : (i : \u03b9\u2081 \u2295 \u03b9\u2082) \u2192 AddCommMonoid (N i)\ninst\u271d : (i : \u03b9\u2081 \u2295 \u03b9\u2082) \u2192 Module R (N i)\nx\u271d\u00b9 : Sort u_9\ndomCoprodDep' : x\u271d\u00b9\nx\u271d : Sort u_10\ndomCoprodDep : x\u271d\na : MultilinearMap R (fun i\u2081 => N (Sum.inl i\u2081)) N\u2081\nb : MultilinearMap R (fun i\u2082 => N (Sum.inr i\u2082)) N\u2082\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_zero [Nonempty \u03b9] : f 0 = 0 := by\n  obtain \u27e8i, _\u27e9 : \u2203 i : \u03b9, i \u2208 Set.univ := Set.exists_mem_of_nonempty \u03b9\n  exact map_coord_zero f i rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Multilinear/Basic.lean", "context": {"open": ["Fin Function Finset Set"], "variables": ["{R : Type uR} {S : Type uS} {\u03b9 : Type u\u03b9} {n : \u2115}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, AddCommMonoid (M\u2081 i)] [AddCommMonoid M\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : ?m.933\nM\u2081 : ?m.963\nM\u2082 : Type ?u.1033\nR : Type uR\nS : Type uS\n\u03b9\u271d : Type u\u03b9\nn : \u2115\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : ?m.1845 \u2192 AddCommMonoid sorry\ninst\u271d\u00b2 : ?m.1847 \u2192 AddCommMonoid sorry\ninst\u271d\u00b9 : AddCommMonoid M\u2082\n\u03b9 : Type u\u03b9\nx\u271d : Sort u_1\nf : x\u271d\ninst\u271d : Nonempty \u03b9\n\u22a2 sorry = 0"}, {"line": "obtain \u27e8i, _\u27e9 : \u2203 i : \u03b9, i \u2208 Set.univ := Set.exists_mem_of_nonempty \u03b9", "tactic_state": "case intro\nM : ?m.933\nM\u2081 : ?m.963\nM\u2082 : Type ?u.1033\nR : Type uR\nS : Type uS\n\u03b9\u271d : Type u\u03b9\nn : \u2115\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : ?m.1845 \u2192 AddCommMonoid sorry\ninst\u271d\u00b2 : ?m.1847 \u2192 AddCommMonoid sorry\ninst\u271d\u00b9 : AddCommMonoid M\u2082\n\u03b9 : Type u\u03b9\nx\u271d : Sort u_1\nf : x\u271d\ninst\u271d : Nonempty \u03b9\ni : \u03b9\nh\u271d : i \u2208 Set.univ\n\u22a2 sorry = 0"}, {"line": "exact map_coord_zero f i rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_update_sum {\u03b1 : Type*} [DecidableEq \u03b9] (t : Finset \u03b1) (i : \u03b9) (g : \u03b1 \u2192 M\u2081 i)\n    (m : \u2200 i, M\u2081 i) : f (update m i (\u2211 a \u2208 t, g a)) = \u2211 a \u2208 t, f (update m i (g a)) := by\n  classical\n    induction t using Finset.induction with\n    | empty => simp\n    | insert _ _ has ih => simp [Finset.sum_insert has, ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Multilinear/Basic.lean", "context": {"open": ["Fin Function Finset Set", "Fintype Finset"], "variables": ["{R : Type uR} {S : Type uS} {\u03b9 : Type u\u03b9} {n : \u2115}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, AddCommMonoid (M\u2081 i)] [AddCommMonoid M\u2082]", "[DistribSMul S M\u2082] [SMulCommClass R S M\u2082]", "(R M\u2082 M\u2083)", "(M\u2081) {M\u2082}", "{M\u2081' : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (M\u2081' i)] [\u2200 i, Module R (M\u2081' i)]", "{M\u2081'' : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (M\u2081'' i)] [\u2200 i, Module R (M\u2081'' i)]", "{\u03b1 : \u03b9 \u2192 Type*} (g : \u2200 i, \u03b1 i \u2192 M\u2081 i) (A : \u2200 i, Finset (\u03b1 i))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : ?m.9910\nM\u2081\u271d : ?m.9940\nM\u2082\u271d : Type ?u.10010\nR : Type uR\nS : Type uS\n\u03b9\u271d : Type u\u03b9\nn : \u2115\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : ?m.11361 R \u2192 AddCommMonoid sorry\ninst\u271d\u2076 : ?m.11363 R \u2192 AddCommMonoid sorry\ninst\u271d\u2075 : AddCommMonoid M\u2082\u271d\nM\u2082 : ?m.11367 R\nM\u2083 : ?m.11371 R\nM\u2081 : ?m.11375 R M\u2083\nM\u2081' : \u03b9\u271d \u2192 Type u_1\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081' i)\ninst\u271d\u00b3 : (i : \u03b9\u271d) \u2192 Module R (M\u2081' i)\nM\u2081'' : \u03b9\u271d \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'' i)\ninst\u271d\u00b9 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'' i)\n\u03b1\u271d : \u03b9\u271d \u2192 Type u_3\ng\u271d : (i : \u03b9\u271d) \u2192 \u03b1\u271d i \u2192 sorry\nA : (i : \u03b9\u271d) \u2192 Finset (\u03b1\u271d i)\n\u03b9 : Type u\u03b9\nx\u271d : Sort u_5\nf : x\u271d\n\u03b1 : Type u_4\ninst\u271d : DecidableEq \u03b9\nt : Finset \u03b1\ni : \u03b9\ng : \u03b1 \u2192 sorry\nm : ?m.15643 _fvar.11397 _fvar.11398 _fvar.11406 _fvar.11407 t i g \u2192 sorry\n\u22a2 sorry = \u2211 a \u2208 t, ?m.11490"}, {"line": "classical\n    induction t using Finset.induction with\n    | empty => simp\n    | insert _ _ has ih => simp [Finset.sum_insert has, ih]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma domDomRestrict_aux_right {\u03b9} [DecidableEq \u03b9] (P : \u03b9 \u2192 Prop) [DecidablePred P] {M\u2081 : \u03b9 \u2192 Type*}\n    [DecidableEq {a // \u00ac P a}]\n    (x : (i : {a // P a}) \u2192 M\u2081 i) (z : (i : {a // \u00ac P a}) \u2192 M\u2081 i) (i : {a : \u03b9 // \u00ac P a})\n    (c : M\u2081 i) : (fun j \u21a6 if h : P j then x \u27e8j, h\u27e9 else Function.update z i c \u27e8j, h\u27e9) =\n    Function.update (fun j => if h : P j then x \u27e8j, h\u27e9 else z \u27e8j, h\u27e9) i c := by\n  simpa only [dite_not] using domDomRestrict_aux _ z (fun j \u21a6 x \u27e8j.1, not_not.mp j.2\u27e9) i c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Multilinear/Basic.lean", "context": {"open": ["Fin Function Finset Set", "Fintype Finset"], "variables": ["{R : Type uR} {S : Type uS} {\u03b9 : Type u\u03b9} {n : \u2115}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, AddCommMonoid (M\u2081 i)] [AddCommMonoid M\u2082]", "[DistribSMul S M\u2082] [SMulCommClass R S M\u2082]", "(R M\u2082 M\u2083)", "(M\u2081) {M\u2082}", "{M\u2081' : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (M\u2081' i)] [\u2200 i, Module R (M\u2081' i)]", "{M\u2081'' : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (M\u2081'' i)] [\u2200 i, Module R (M\u2081'' i)]", "{\u03b1 : \u03b9 \u2192 Type*} (g : \u2200 i, \u03b1 i \u2192 M\u2081 i) (A : \u2200 i, Finset (\u03b1 i))", "(R)", "{A : Type*} [Semiring A] [SMul R A] [\u2200 i : \u03b9, Module A (M\u2081 i)] [Module A M\u2082]", "{\u03b9\u2081 \u03b9\u2082 \u03b9\u2083 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : ?m.18167\nM\u2081\u271d\u00b9 : ?m.18197\nM\u2082\u271d : Type ?u.18267\nR : Type uR\nS : Type uS\n\u03b9\u271d : Type u\u03b9\nn : \u2115\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : ?m.19627 R \u2192 AddCommMonoid sorry\ninst\u271d\u2078 : ?m.19629 R \u2192 AddCommMonoid sorry\ninst\u271d\u2077 : AddCommMonoid M\u2082\u271d\nM\u2082 : ?m.19633 R\nM\u2083 : ?m.19637 R\nM\u2081\u271d : ?m.19641 R M\u2083\nM\u2081' : \u03b9\u271d \u2192 Type u_1\ninst\u271d\u2076 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081' i)\ninst\u271d\u2075 : (i : \u03b9\u271d) \u2192 Module R (M\u2081' i)\nM\u2081'' : \u03b9\u271d \u2192 Type u_2\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'' i)\ninst\u271d\u00b3 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'' i)\n\u03b1 : \u03b9\u271d \u2192 Type u_3\ng : (i : \u03b9\u271d) \u2192 \u03b1 i \u2192 sorry\nA : (i : \u03b9\u271d) \u2192 Finset (\u03b1 i)\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\n\u03b9\u2083 : Type u_6\n\u03b9 : Sort u_8\ninst\u271d\u00b2 : DecidableEq \u03b9\nP : \u03b9 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred P\nM\u2081 : \u03b9 \u2192 Type u_7\ninst\u271d : DecidableEq { a // \u00acP a }\nx : (i : { a // P a }) \u2192 M\u2081 \u2191i\nz : (i : { a // \u00acP a }) \u2192 M\u2081 \u2191i\ni : { a // \u00acP a }\nc : M\u2081 \u2191i\n\u22a2 (fun j => if h : P j then x \u27e8j, h\u27e9 else update z i c \u27e8j, h\u27e9) =\n    update (fun j => if h : P j then x \u27e8j, h\u27e9 else z \u27e8j, h\u27e9) (\u2191i) c"}, {"line": "simpa only [dite_not] using domDomRestrict_aux _ z (fun j \u21a6 x \u27e8j.1, not_not.mp j.2\u27e9) i c", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iteratedFDeriv_aux {\u03b9} {M\u2081 : \u03b9 \u2192 Type*} {\u03b1 : Type*} [DecidableEq \u03b1]\n    (s : Set \u03b9) [DecidableEq { x // x \u2208 s }] (e : \u03b1 \u2243 s)\n    (m : \u03b1 \u2192 ((i : \u03b9) \u2192 M\u2081 i)) (a : \u03b1) (z : (i : \u03b9) \u2192 M\u2081 i) :\n    (fun i \u21a6 update m a z (e.symm i) i) =\n      (fun i \u21a6 update (fun j \u21a6 m (e.symm j) j) (e a) (z (e a)) i) := by\n  ext i\n  rcases eq_or_ne a (e.symm i) with rfl | hne\n  \u00b7 rw [Equiv.apply_symm_apply e i, update_self, update_self]\n  \u00b7 rw [update_of_ne hne.symm, update_of_ne fun h \u21a6 (Equiv.symm_apply_apply .. \u25b8 h \u25b8 hne) rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Multilinear/Basic.lean", "context": {"open": ["Fin Function Finset Set", "Fintype Finset"], "variables": ["{R : Type uR} {S : Type uS} {\u03b9 : Type u\u03b9} {n : \u2115}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, AddCommMonoid (M\u2081 i)] [AddCommMonoid M\u2082]", "[DistribSMul S M\u2082] [SMulCommClass R S M\u2082]", "(R M\u2082 M\u2083)", "(M\u2081) {M\u2082}", "{M\u2081' : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (M\u2081' i)] [\u2200 i, Module R (M\u2081' i)]", "{M\u2081'' : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (M\u2081'' i)] [\u2200 i, Module R (M\u2081'' i)]", "{\u03b1 : \u03b9 \u2192 Type*} (g : \u2200 i, \u03b1 i \u2192 M\u2081 i) (A : \u2200 i, Finset (\u03b1 i))", "(R)", "{A : Type*} [Semiring A] [SMul R A] [\u2200 i : \u03b9, Module A (M\u2081 i)] [Module A M\u2082]", "{\u03b9\u2081 \u03b9\u2082 \u03b9\u2083 : Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (M\u2081 i)] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "{\u03b9\u2081 \u03b9\u2082 : Type*}", "[Semiring R] [(i : \u03b9) \u2192 AddCommMonoid (M\u2081 i)] [(i : \u03b9) \u2192 Module R (M\u2081 i)]", "[Semiring S] [Module S M\u2082] [SMulCommClass R S M\u2082]", "[AddCommMonoid M\u2083] [Module S M\u2083] [Module R M\u2083] [SMulCommClass R S M\u2083]", "(S) in", "(R S M\u2081 M\u2082 M\u2083)", "[CommSemiring R] [\u2200 i, AddCommMonoid (M\u2081 i)] [\u2200 i, AddCommMonoid (M i)] [AddCommMonoid M\u2082]", "{M\u2081' : \u03b9 \u2192 Type*} [\u03a0 i, AddCommMonoid (M\u2081' i)] [\u03a0 i, Module R (M\u2081' i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : ?m.57185\nM\u2081\u271d\u00b9 : ?m.57215\nM\u2082\u271d : Type ?u.57285\nR : Type uR\nS : Type uS\n\u03b9\u271d : Type u\u03b9\nn : \u2115\ninst\u271d\u00b9\u2074 : Semiring R\ninst\u271d\u00b9\u00b3 : ?m.61763 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b2 : ?m.61765 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2082\u271d\nM\u2082 : ?m.61769 R\nM\u2083 : ?m.61773 R\nM\u2081\u271d : ?m.61777 R M\u2083\nM\u2081'\u271d : \u03b9\u271d \u2192 Type u_1\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'\u271d i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'\u271d i)\nM\u2081'' : \u03b9\u271d \u2192 Type u_2\ninst\u271d\u2078 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'' i)\ninst\u271d\u2077 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'' i)\n\u03b1\u271d : \u03b9\u271d \u2192 Type u_3\ng : (i : \u03b9\u271d) \u2192 \u03b1\u271d i \u2192 sorry\nA : (i : \u03b9\u271d) \u2192 Finset (\u03b1\u271d i)\n\u03b9\u2081\u271d : Type u_4\n\u03b9\u2082\u271d : Type u_5\n\u03b9\u2083 : Type u_6\n\u03b9\u2081 : Type u_7\n\u03b9\u2082 : Type u_8\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : \u03b9\u271d \u2192 AddCommMonoid sorry\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 Module R sorry\nM\u2081' : \u03b9\u271d \u2192 Type u_9\ninst\u271d\u00b3 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081' i)\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 Module R (M\u2081' i)\n\u03b9 : Type u_12\nM\u2081 : \u03b9 \u2192 Type u_10\n\u03b1 : Type u_11\ninst\u271d\u00b9 : DecidableEq \u03b1\ns : Set \u03b9\ninst\u271d : DecidableEq { x // x \u2208 s }\ne : \u03b1 \u2243 \u2191s\nm : \u03b1 \u2192 (i : \u03b9) \u2192 M\u2081 i\na : \u03b1\nz : (i : \u03b9) \u2192 M\u2081 i\n\u22a2 (fun i => update m a z (e.symm i) \u2191i) = fun i => update (fun j => m (e.symm j) \u2191j) (e a) (z \u2191(e a)) i"}, {"line": "ext i", "tactic_state": "case h\nM : ?m.57185\nM\u2081\u271d\u00b9 : ?m.57215\nM\u2082\u271d : Type ?u.57285\nR : Type uR\nS : Type uS\n\u03b9\u271d : Type u\u03b9\nn : \u2115\ninst\u271d\u00b9\u2074 : Semiring R\ninst\u271d\u00b9\u00b3 : ?m.61763 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b2 : ?m.61765 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2082\u271d\nM\u2082 : ?m.61769 R\nM\u2083 : ?m.61773 R\nM\u2081\u271d : ?m.61777 R M\u2083\nM\u2081'\u271d : \u03b9\u271d \u2192 Type u_1\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'\u271d i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'\u271d i)\nM\u2081'' : \u03b9\u271d \u2192 Type u_2\ninst\u271d\u2078 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'' i)\ninst\u271d\u2077 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'' i)\n\u03b1\u271d : \u03b9\u271d \u2192 Type u_3\ng : (i : \u03b9\u271d) \u2192 \u03b1\u271d i \u2192 sorry\nA : (i : \u03b9\u271d) \u2192 Finset (\u03b1\u271d i)\n\u03b9\u2081\u271d : Type u_4\n\u03b9\u2082\u271d : Type u_5\n\u03b9\u2083 : Type u_6\n\u03b9\u2081 : Type u_7\n\u03b9\u2082 : Type u_8\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : \u03b9\u271d \u2192 AddCommMonoid sorry\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 Module R sorry\nM\u2081' : \u03b9\u271d \u2192 Type u_9\ninst\u271d\u00b3 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081' i)\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 Module R (M\u2081' i)\n\u03b9 : Type u_12\nM\u2081 : \u03b9 \u2192 Type u_10\n\u03b1 : Type u_11\ninst\u271d\u00b9 : DecidableEq \u03b1\ns : Set \u03b9\ninst\u271d : DecidableEq { x // x \u2208 s }\ne : \u03b1 \u2243 \u2191s\nm : \u03b1 \u2192 (i : \u03b9) \u2192 M\u2081 i\na : \u03b1\nz : (i : \u03b9) \u2192 M\u2081 i\ni : \u2191s\n\u22a2 update m a z (e.symm i) \u2191i = update (fun j => m (e.symm j) \u2191j) (e a) (z \u2191(e a)) i"}, {"line": "rcases eq_or_ne a (e.symm i) with rfl | hne", "tactic_state": "case h.inl\nM : ?m.57185\nM\u2081\u271d\u00b9 : ?m.57215\nM\u2082\u271d : Type ?u.57285\nR : Type uR\nS : Type uS\n\u03b9\u271d : Type u\u03b9\nn : \u2115\ninst\u271d\u00b9\u2074 : Semiring R\ninst\u271d\u00b9\u00b3 : ?m.61763 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b2 : ?m.61765 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2082\u271d\nM\u2082 : ?m.61769 R\nM\u2083 : ?m.61773 R\nM\u2081\u271d : ?m.61777 R M\u2083\nM\u2081'\u271d : \u03b9\u271d \u2192 Type u_1\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'\u271d i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'\u271d i)\nM\u2081'' : \u03b9\u271d \u2192 Type u_2\ninst\u271d\u2078 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'' i)\ninst\u271d\u2077 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'' i)\n\u03b1\u271d : \u03b9\u271d \u2192 Type u_3\ng : (i : \u03b9\u271d) \u2192 \u03b1\u271d i \u2192 sorry\nA : (i : \u03b9\u271d) \u2192 Finset (\u03b1\u271d i)\n\u03b9\u2081\u271d : Type u_4\n\u03b9\u2082\u271d : Type u_5\n\u03b9\u2083 : Type u_6\n\u03b9\u2081 : Type u_7\n\u03b9\u2082 : Type u_8\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : \u03b9\u271d \u2192 AddCommMonoid sorry\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 Module R sorry\nM\u2081' : \u03b9\u271d \u2192 Type u_9\ninst\u271d\u00b3 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081' i)\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 Module R (M\u2081' i)\n\u03b9 : Type u_12\nM\u2081 : \u03b9 \u2192 Type u_10\n\u03b1 : Type u_11\ninst\u271d\u00b9 : DecidableEq \u03b1\ns : Set \u03b9\ninst\u271d : DecidableEq { x // x \u2208 s }\ne : \u03b1 \u2243 \u2191s\nm : \u03b1 \u2192 (i : \u03b9) \u2192 M\u2081 i\nz : (i : \u03b9) \u2192 M\u2081 i\ni : \u2191s\n\u22a2 update m (e.symm i) z (e.symm i) \u2191i = update (fun j => m (e.symm j) \u2191j) (e (e.symm i)) (z \u2191(e (e.symm i))) i\n---\ncase h.inr\nM : ?m.57185\nM\u2081\u271d\u00b9 : ?m.57215\nM\u2082\u271d : Type ?u.57285\nR : Type uR\nS : Type uS\n\u03b9\u271d : Type u\u03b9\nn : \u2115\ninst\u271d\u00b9\u2074 : Semiring R\ninst\u271d\u00b9\u00b3 : ?m.61763 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b2 : ?m.61765 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2082\u271d\nM\u2082 : ?m.61769 R\nM\u2083 : ?m.61773 R\nM\u2081\u271d : ?m.61777 R M\u2083\nM\u2081'\u271d : \u03b9\u271d \u2192 Type u_1\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'\u271d i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'\u271d i)\nM\u2081'' : \u03b9\u271d \u2192 Type u_2\ninst\u271d\u2078 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'' i)\ninst\u271d\u2077 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'' i)\n\u03b1\u271d : \u03b9\u271d \u2192 Type u_3\ng : (i : \u03b9\u271d) \u2192 \u03b1\u271d i \u2192 sorry\nA : (i : \u03b9\u271d) \u2192 Finset (\u03b1\u271d i)\n\u03b9\u2081\u271d : Type u_4\n\u03b9\u2082\u271d : Type u_5\n\u03b9\u2083 : Type u_6\n\u03b9\u2081 : Type u_7\n\u03b9\u2082 : Type u_8\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : \u03b9\u271d \u2192 AddCommMonoid sorry\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 Module R sorry\nM\u2081' : \u03b9\u271d \u2192 Type u_9\ninst\u271d\u00b3 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081' i)\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 Module R (M\u2081' i)\n\u03b9 : Type u_12\nM\u2081 : \u03b9 \u2192 Type u_10\n\u03b1 : Type u_11\ninst\u271d\u00b9 : DecidableEq \u03b1\ns : Set \u03b9\ninst\u271d : DecidableEq { x // x \u2208 s }\ne : \u03b1 \u2243 \u2191s\nm : \u03b1 \u2192 (i : \u03b9) \u2192 M\u2081 i\na : \u03b1\nz : (i : \u03b9) \u2192 M\u2081 i\ni : \u2191s\nhne : a \u2260 e.symm i\n\u22a2 update m a z (e.symm i) \u2191i = update (fun j => m (e.symm j) \u2191j) (e a) (z \u2191(e a)) i"}, {"line": "\u00b7 rw [Equiv.apply_symm_apply e i, update_self, update_self]", "tactic_state": "case h.inr\nM : ?m.57185\nM\u2081\u271d\u00b9 : ?m.57215\nM\u2082\u271d : Type ?u.57285\nR : Type uR\nS : Type uS\n\u03b9\u271d : Type u\u03b9\nn : \u2115\ninst\u271d\u00b9\u2074 : Semiring R\ninst\u271d\u00b9\u00b3 : ?m.61763 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b2 : ?m.61765 R \u2192 AddCommMonoid sorry\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2082\u271d\nM\u2082 : ?m.61769 R\nM\u2083 : ?m.61773 R\nM\u2081\u271d : ?m.61777 R M\u2083\nM\u2081'\u271d : \u03b9\u271d \u2192 Type u_1\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'\u271d i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'\u271d i)\nM\u2081'' : \u03b9\u271d \u2192 Type u_2\ninst\u271d\u2078 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081'' i)\ninst\u271d\u2077 : (i : \u03b9\u271d) \u2192 Module R (M\u2081'' i)\n\u03b1\u271d : \u03b9\u271d \u2192 Type u_3\ng : (i : \u03b9\u271d) \u2192 \u03b1\u271d i \u2192 sorry\nA : (i : \u03b9\u271d) \u2192 Finset (\u03b1\u271d i)\n\u03b9\u2081\u271d : Type u_4\n\u03b9\u2082\u271d : Type u_5\n\u03b9\u2083 : Type u_6\n\u03b9\u2081 : Type u_7\n\u03b9\u2082 : Type u_8\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : \u03b9\u271d \u2192 AddCommMonoid sorry\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 Module R sorry\nM\u2081' : \u03b9\u271d \u2192 Type u_9\ninst\u271d\u00b3 : (i : \u03b9\u271d) \u2192 AddCommMonoid (M\u2081' i)\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 Module R (M\u2081' i)\n\u03b9 : Type u_12\nM\u2081 : \u03b9 \u2192 Type u_10\n\u03b1 : Type u_11\ninst\u271d\u00b9 : DecidableEq \u03b1\ns : Set \u03b9\ninst\u271d : DecidableEq { x // x \u2208 s }\ne : \u03b1 \u2243 \u2191s\nm : \u03b1 \u2192 (i : \u03b9) \u2192 M\u2081 i\na : \u03b1\nz : (i : \u03b9) \u2192 M\u2081 i\ni : \u2191s\nhne : a \u2260 e.symm i\n\u22a2 update m a z (e.symm i) \u2191i = update (fun j => m (e.symm j) \u2191j) (e a) (z \u2191(e a)) i"}, {"line": "\u00b7 rw [update_of_ne hne.symm, update_of_ne fun h \u21a6 (Equiv.symm_apply_apply .. \u25b8 h \u25b8 hne) rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem associated_tmul [Invertible (2 : A)]\n    (Q\u2081 : QuadraticMap A M\u2081 N\u2081) (Q\u2082 : QuadraticMap R M\u2082 N\u2082) :\n    (Q\u2081.tmul Q\u2082).associated = Q\u2081.associated.tmul Q\u2082.associated := by\n  letI : Invertible (2 : A) := (Invertible.map (algebraMap R A) 2).copy 2 (map_ofNat _ _).symm\n  rw [QuadraticMap.tmul]\n  rw [BilinMap.tmul]\n  have : Subsingleton (Invertible (2 : A)) := inferInstance\n  convert associated_left_inverse A (LinearMap.BilinMap.tmul_isSymm\n    (QuadraticMap.associated_isSymm A Q\u2081) (QuadraticMap.associated_isSymm R Q\u2082))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/QuadraticForm/TensorProduct.lean", "context": {"open": ["LinearMap (BilinMap BilinForm)", "TensorProduct QuadraticMap"], "variables": ["{R : Type uR} {A : Type uA} {M\u2081 : Type uM\u2081} {M\u2082 : Type uM\u2082} {N\u2081 : Type uN\u2081} {N\u2082 : Type uN\u2082}", "[CommRing R] [CommRing A]", "[AddCommGroup M\u2081] [AddCommGroup M\u2082] [AddCommGroup N\u2081] [AddCommGroup N\u2082]", "[Algebra R A] [Module R M\u2081] [Module A M\u2081] [Module R N\u2081] [Module A N\u2081]", "[SMulCommClass R A M\u2081] [IsScalarTower R A M\u2081] [IsScalarTower R A N\u2081]", "[Module R M\u2082] [Module R N\u2082]", "[Invertible (2 : R)]", "(R A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\nA : Type uA\nM\u2081 : Type uM\u2081\nM\u2082 : Type uM\u2082\nN\u2081 : Type uN\u2081\nN\u2082 : Type uN\u2082\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : AddCommGroup M\u2081\ninst\u271d\u00b9\u2074 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b3 : AddCommGroup N\u2081\ninst\u271d\u00b9\u00b2 : AddCommGroup N\u2082\ninst\u271d\u00b9\u00b9 : Algebra R A\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : Module A M\u2081\ninst\u271d\u2078 : Module R N\u2081\ninst\u271d\u2077 : Module A N\u2081\ninst\u271d\u2076 : SMulCommClass R A M\u2081\ninst\u271d\u2075 : IsScalarTower R A M\u2081\ninst\u271d\u2074 : IsScalarTower R A N\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module R N\u2082\ninst\u271d\u00b9 : Invertible 2\ninst\u271d : Invertible 2\nQ\u2081 : QuadraticMap A M\u2081 N\u2081\nQ\u2082 : QuadraticMap R M\u2082 N\u2082\n\u22a2 associated (Q\u2081.tmul Q\u2082) = (associated Q\u2081).tmul (associated Q\u2082)"}, {"line": "letI : Invertible (2 : A) := (Invertible.map (algebraMap R A) 2).copy 2 (map_ofNat _ _).symm", "tactic_state": "R : Type uR\nA : Type uA\nM\u2081 : Type uM\u2081\nM\u2082 : Type uM\u2082\nN\u2081 : Type uN\u2081\nN\u2082 : Type uN\u2082\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : AddCommGroup M\u2081\ninst\u271d\u00b9\u2074 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b3 : AddCommGroup N\u2081\ninst\u271d\u00b9\u00b2 : AddCommGroup N\u2082\ninst\u271d\u00b9\u00b9 : Algebra R A\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : Module A M\u2081\ninst\u271d\u2078 : Module R N\u2081\ninst\u271d\u2077 : Module A N\u2081\ninst\u271d\u2076 : SMulCommClass R A M\u2081\ninst\u271d\u2075 : IsScalarTower R A M\u2081\ninst\u271d\u2074 : IsScalarTower R A N\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module R N\u2082\ninst\u271d\u00b9 : Invertible 2\ninst\u271d : Invertible 2\nQ\u2081 : QuadraticMap A M\u2081 N\u2081\nQ\u2082 : QuadraticMap R M\u2082 N\u2082\nthis : sorry := sorry\n\u22a2 associated (Q\u2081.tmul Q\u2082) = (associated Q\u2081).tmul (associated Q\u2082)"}, {"line": "rw [QuadraticMap.tmul]", "tactic_state": "R : Type uR\nA : Type uA\nM\u2081 : Type uM\u2081\nM\u2082 : Type uM\u2082\nN\u2081 : Type uN\u2081\nN\u2082 : Type uN\u2082\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : AddCommGroup M\u2081\ninst\u271d\u00b9\u2074 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b3 : AddCommGroup N\u2081\ninst\u271d\u00b9\u00b2 : AddCommGroup N\u2082\ninst\u271d\u00b9\u00b9 : Algebra R A\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : Module A M\u2081\ninst\u271d\u2078 : Module R N\u2081\ninst\u271d\u2077 : Module A N\u2081\ninst\u271d\u2076 : SMulCommClass R A M\u2081\ninst\u271d\u2075 : IsScalarTower R A M\u2081\ninst\u271d\u2074 : IsScalarTower R A N\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module R N\u2082\ninst\u271d\u00b9 : Invertible 2\ninst\u271d : Invertible 2\nQ\u2081 : QuadraticMap A M\u2081 N\u2081\nQ\u2082 : QuadraticMap R M\u2082 N\u2082\nthis : sorry := sorry\n\u22a2 associated ((tensorDistrib R A) (Q\u2081 \u2297\u209c[R] Q\u2082)) = (associated Q\u2081).tmul (associated Q\u2082)"}, {"line": "rw [BilinMap.tmul]", "tactic_state": "R : Type uR\nA : Type uA\nM\u2081 : Type uM\u2081\nM\u2082 : Type uM\u2082\nN\u2081 : Type uN\u2081\nN\u2082 : Type uN\u2082\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : AddCommGroup M\u2081\ninst\u271d\u00b9\u2074 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b3 : AddCommGroup N\u2081\ninst\u271d\u00b9\u00b2 : AddCommGroup N\u2082\ninst\u271d\u00b9\u00b9 : Algebra R A\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : Module A M\u2081\ninst\u271d\u2078 : Module R N\u2081\ninst\u271d\u2077 : Module A N\u2081\ninst\u271d\u2076 : SMulCommClass R A M\u2081\ninst\u271d\u2075 : IsScalarTower R A M\u2081\ninst\u271d\u2074 : IsScalarTower R A N\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module R N\u2082\ninst\u271d\u00b9 : Invertible 2\ninst\u271d : Invertible 2\nQ\u2081 : QuadraticMap A M\u2081 N\u2081\nQ\u2082 : QuadraticMap R M\u2082 N\u2082\nthis : sorry := sorry\n\u22a2 associated ((tensorDistrib R A) (Q\u2081 \u2297\u209c[R] Q\u2082)) = (BilinMap.tensorDistrib R A) (associated Q\u2081 \u2297\u209c[R] associated Q\u2082)"}, {"line": "have : Subsingleton (Invertible (2 : A)) := inferInstance", "tactic_state": "R : Type uR\nA : Type uA\nM\u2081 : Type uM\u2081\nM\u2082 : Type uM\u2082\nN\u2081 : Type uN\u2081\nN\u2082 : Type uN\u2082\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : AddCommGroup M\u2081\ninst\u271d\u00b9\u2074 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b3 : AddCommGroup N\u2081\ninst\u271d\u00b9\u00b2 : AddCommGroup N\u2082\ninst\u271d\u00b9\u00b9 : Algebra R A\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : Module A M\u2081\ninst\u271d\u2078 : Module R N\u2081\ninst\u271d\u2077 : Module A N\u2081\ninst\u271d\u2076 : SMulCommClass R A M\u2081\ninst\u271d\u2075 : IsScalarTower R A M\u2081\ninst\u271d\u2074 : IsScalarTower R A N\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module R N\u2082\ninst\u271d\u00b9 : Invertible 2\ninst\u271d : Invertible 2\nQ\u2081 : QuadraticMap A M\u2081 N\u2081\nQ\u2082 : QuadraticMap R M\u2082 N\u2082\nthis\u271d : sorry := sorry\nthis : Subsingleton sorry\n\u22a2 associated ((tensorDistrib R A) (Q\u2081 \u2297\u209c[R] Q\u2082)) = (BilinMap.tensorDistrib R A) (associated Q\u2081 \u2297\u209c[R] associated Q\u2082)"}, {"line": "convert associated_left_inverse A (LinearMap.BilinMap.tmul_isSymm\n    (QuadraticMap.associated_isSymm A Q\u2081) (QuadraticMap.associated_isSymm R Q\u2082))", "tactic_state": "case h.e'_3.h.e'_6.h.e'_9.h.e'_5.h.e'_1.h.e'_6\nR : Type uR\nA : Type uA\nM\u2081 : Type uM\u2081\nM\u2082 : Type uM\u2082\nN\u2081 : Type uN\u2081\nN\u2082 : Type uN\u2082\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : AddCommGroup M\u2081\ninst\u271d\u00b9\u2074 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b3 : AddCommGroup N\u2081\ninst\u271d\u00b9\u00b2 : AddCommGroup N\u2082\ninst\u271d\u00b9\u00b9 : Algebra R A\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : Module A M\u2081\ninst\u271d\u2078 : Module R N\u2081\ninst\u271d\u2077 : Module A N\u2081\ninst\u271d\u2076 : SMulCommClass R A M\u2081\ninst\u271d\u2075 : IsScalarTower R A M\u2081\ninst\u271d\u2074 : IsScalarTower R A N\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module R N\u2082\ninst\u271d\u00b9 : Invertible 2\ninst\u271d : Invertible 2\nQ\u2081 : QuadraticMap A M\u2081 N\u2081\nQ\u2082 : QuadraticMap R M\u2082 N\u2082\nthis\u271d : sorry := sorry\nthis : Subsingleton sorry\n\u22a2 inst\u271d = (Invertible.map (algebraMap R A) 2).copy 2 \u22ef"}]}
{"declaration": "theorem _root_.LinearMap.compQuadraticMap_polar [CommSemiring S] [Algebra S R] [Module S N]\n    [Module S N'] [IsScalarTower S R N] [Module S M] [IsScalarTower S R M] (f : N \u2192\u2097[S] N')\n    (Q : QuadraticMap R M N) (x y : M) : polar (f.compQuadraticMap' Q) x y = f (polar Q x y) := by\n  simp [polar]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/QuadraticForm/Basic.lean", "context": {"open": ["LinearMap (BilinMap BilinForm)", "QuadraticMap", "LinearMap (BilinMap)"], "variables": ["{S T : Type*}", "{R : Type*} {M N P A : Type*}", "[CommRing R] [AddCommGroup M] [AddCommGroup N]", "(R : Type u) (M : Type v) [CommSemiring R] [AddCommMonoid M] [Module R M]", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "{Q Q' : QuadraticMap R M N}", "(Q)", "{Q}", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "(Q : QuadraticMap R M N)", "[CommRing R] [AddCommGroup M] [AddCommGroup N]", "[Module R M] [Module R N] (Q : QuadraticMap R M N)", "[CommSemiring S] [Algebra S R] [Module S M] [IsScalarTower S R M] [Module S N]", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "[Monoid S] [Monoid T] [DistribMulAction S N] [DistribMulAction T N]", "[SMulCommClass S R N] [SMulCommClass T R N]", "[CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "[CommSemiring R] [CommSemiring S] [AddCommMonoid M] [Module R M] [AddCommMonoid N]", "[IsScalarTower S R M] [IsScalarTower S R N]", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "[AddCommMonoid P] [Module R P]", "[CommSemiring R] [NonUnitalNonAssocSemiring A] [AddCommMonoid M] [Module R M]", "[Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "{N' : Type*} [AddCommMonoid N'] [Module R N']", "{n : Type*}", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "{N' : Type*} [AddCommMonoid N'] [Module R N']", "(R M)", "(S R M)", "[CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "{B : BilinMap R M N}", "{N' : Type*} [AddCommGroup N'] [Module R N']", "{N' : Type*} [AddCommGroup N']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\nN : Type u_5\ninst\u271d\u2076\u2079 : AddCommGroup N\nR : Type u\nM : Type v\ninst\u271d\u2076\u2078 : CommSemiring R\ninst\u271d\u2076\u2077 : AddCommMonoid M\ninst\u271d\u2076\u2076 : Module R M\ninst\u271d\u2076\u2075 : CommSemiring R\ninst\u271d\u2076\u2074 : AddCommMonoid M\ninst\u271d\u2076\u00b3 : Module R M\ninst\u271d\u2076\u00b2 : AddCommMonoid N\ninst\u271d\u2076\u00b9 : Module R N\ninst\u271d\u2076\u2070 : CommSemiring R\ninst\u271d\u2075\u2079 : AddCommMonoid M\ninst\u271d\u2075\u2078 : Module R M\ninst\u271d\u2075\u2077 : AddCommMonoid N\ninst\u271d\u2075\u2076 : Module R N\ninst\u271d\u2075\u2075 : CommRing R\ninst\u271d\u2075\u2074 : AddCommGroup M\ninst\u271d\u2075\u00b3 : AddCommGroup N\ninst\u271d\u2075\u00b2 : Module R M\ninst\u271d\u2075\u00b9 : Module R N\ninst\u271d\u2075\u2070 : CommSemiring S\ninst\u271d\u2074\u2079 : Algebra S R\ninst\u271d\u2074\u2078 : Module S M\ninst\u271d\u2074\u2077 : IsScalarTower S R M\ninst\u271d\u2074\u2076 : Module S N\ninst\u271d\u2074\u2075 : CommSemiring R\ninst\u271d\u2074\u2074 : AddCommMonoid M\ninst\u271d\u2074\u00b3 : Module R M\ninst\u271d\u2074\u00b2 : AddCommMonoid N\ninst\u271d\u2074\u00b9 : Module R N\ninst\u271d\u2074\u2070 : Monoid S\ninst\u271d\u00b3\u2079 : DistribMulAction S N\ninst\u271d\u00b3\u2078 : SMulCommClass S R N\ninst\u271d\u00b3\u2077 : CommRing R\ninst\u271d\u00b3\u2076 : AddCommGroup M\ninst\u271d\u00b3\u2075 : Module R M\ninst\u271d\u00b3\u2074 : AddCommGroup N\ninst\u271d\u00b3\u00b3 : Module R N\ninst\u271d\u00b3\u00b2 : CommSemiring R\ninst\u271d\u00b3\u00b9 : CommSemiring S\ninst\u271d\u00b3\u2070 : AddCommMonoid M\ninst\u271d\u00b2\u2079 : Module R M\ninst\u271d\u00b2\u2078 : AddCommMonoid N\ninst\u271d\u00b2\u2077 : IsScalarTower S R M\ninst\u271d\u00b2\u2076 : IsScalarTower S R N\ninst\u271d\u00b2\u2075 : CommSemiring R\ninst\u271d\u00b2\u2074 : AddCommMonoid M\ninst\u271d\u00b2\u00b3 : Module R M\ninst\u271d\u00b2\u00b2 : AddCommMonoid N\ninst\u271d\u00b2\u00b9 : Module R N\ninst\u271d\u00b2\u2070 : CommSemiring R\ninst\u271d\u00b9\u2079 : AddCommMonoid M\ninst\u271d\u00b9\u2078 : Module R M\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : Module R M\ninst\u271d\u00b9\u2074 : AddCommMonoid N\ninst\u271d\u00b9\u00b3 : Module R N\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : AddCommGroup M\ninst\u271d\u00b9\u2070 : AddCommGroup N\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R N\nN' : Type u_12\ninst\u271d\u2077 : AddCommGroup N'\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra S R\ninst\u271d\u2074 : Module S N\ninst\u271d\u00b3 : Module S N'\ninst\u271d\u00b2 : IsScalarTower S R N\ninst\u271d\u00b9 : Module S M\ninst\u271d : IsScalarTower S R M\nf : N \u2192\u2097[S] N'\nQ : QuadraticMap R M N\nx y : M\n\u22a2 polar (\u21d1(f.compQuadraticMap' Q)) x y = f (polar (\u21d1Q) x y)"}, {"line": "simp [polar]", "tactic_state": "S : Type u_1\nN : Type u_5\ninst\u271d\u2076\u2079 : AddCommGroup N\nR : Type u\nM : Type v\ninst\u271d\u2076\u2078 : CommSemiring R\ninst\u271d\u2076\u2077 : AddCommMonoid M\ninst\u271d\u2076\u2076 : Module R M\ninst\u271d\u2076\u2075 : CommSemiring R\ninst\u271d\u2076\u2074 : AddCommMonoid M\ninst\u271d\u2076\u00b3 : Module R M\ninst\u271d\u2076\u00b2 : AddCommMonoid N\ninst\u271d\u2076\u00b9 : Module R N\ninst\u271d\u2076\u2070 : CommSemiring R\ninst\u271d\u2075\u2079 : AddCommMonoid M\ninst\u271d\u2075\u2078 : Module R M\ninst\u271d\u2075\u2077 : AddCommMonoid N\ninst\u271d\u2075\u2076 : Module R N\ninst\u271d\u2075\u2075 : CommRing R\ninst\u271d\u2075\u2074 : AddCommGroup M\ninst\u271d\u2075\u00b3 : AddCommGroup N\ninst\u271d\u2075\u00b2 : Module R M\ninst\u271d\u2075\u00b9 : Module R N\ninst\u271d\u2075\u2070 : CommSemiring S\ninst\u271d\u2074\u2079 : Algebra S R\ninst\u271d\u2074\u2078 : Module S M\ninst\u271d\u2074\u2077 : IsScalarTower S R M\ninst\u271d\u2074\u2076 : Module S N\ninst\u271d\u2074\u2075 : CommSemiring R\ninst\u271d\u2074\u2074 : AddCommMonoid M\ninst\u271d\u2074\u00b3 : Module R M\ninst\u271d\u2074\u00b2 : AddCommMonoid N\ninst\u271d\u2074\u00b9 : Module R N\ninst\u271d\u2074\u2070 : Monoid S\ninst\u271d\u00b3\u2079 : DistribMulAction S N\ninst\u271d\u00b3\u2078 : SMulCommClass S R N\ninst\u271d\u00b3\u2077 : CommRing R\ninst\u271d\u00b3\u2076 : AddCommGroup M\ninst\u271d\u00b3\u2075 : Module R M\ninst\u271d\u00b3\u2074 : AddCommGroup N\ninst\u271d\u00b3\u00b3 : Module R N\ninst\u271d\u00b3\u00b2 : CommSemiring R\ninst\u271d\u00b3\u00b9 : CommSemiring S\ninst\u271d\u00b3\u2070 : AddCommMonoid M\ninst\u271d\u00b2\u2079 : Module R M\ninst\u271d\u00b2\u2078 : AddCommMonoid N\ninst\u271d\u00b2\u2077 : IsScalarTower S R M\ninst\u271d\u00b2\u2076 : IsScalarTower S R N\ninst\u271d\u00b2\u2075 : CommSemiring R\ninst\u271d\u00b2\u2074 : AddCommMonoid M\ninst\u271d\u00b2\u00b3 : Module R M\ninst\u271d\u00b2\u00b2 : AddCommMonoid N\ninst\u271d\u00b2\u00b9 : Module R N\ninst\u271d\u00b2\u2070 : CommSemiring R\ninst\u271d\u00b9\u2079 : AddCommMonoid M\ninst\u271d\u00b9\u2078 : Module R M\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : Module R M\ninst\u271d\u00b9\u2074 : AddCommMonoid N\ninst\u271d\u00b9\u00b3 : Module R N\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : AddCommGroup M\ninst\u271d\u00b9\u2070 : AddCommGroup N\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R N\nN' : Type u_12\ninst\u271d\u2077 : AddCommGroup N'\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra S R\ninst\u271d\u2074 : Module S N\ninst\u271d\u00b3 : Module S N'\ninst\u271d\u00b2 : IsScalarTower S R N\ninst\u271d\u00b9 : Module S M\ninst\u271d : IsScalarTower S R M\nf : N \u2192\u2097[S] N'\nQ : QuadraticMap R M N\nx y : M\n\u22a2 f (Q (x + y)) - f (Q x) - f (Q y) = f (Q (x + y) - Q x - Q y)"}]}
{"declaration": "theorem toBilin_apply (Q : QuadraticMap R M N) (bm : Basis \u03b9 R M) (i j : \u03b9) :\n    Q.toBilin bm (bm i) (bm j) =\n      if i = j then Q (bm i) else if i < j then polar Q (bm i) (bm j) else 0 := by\n  simp [toBilin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/QuadraticForm/Basis.lean", "context": {"open": ["LinearMap (BilinMap)", "Finsupp"], "variables": ["{\u03b9 R M N : Type*}", "[CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "[DecidableEq \u03b9]", "[LinearOrder \u03b9]", "[CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup N\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Module R N\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : LinearOrder \u03b9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx\u271d : Sort u_5\npolar : x\u271d\nQ : QuadraticMap R M N\nbm : Basis \u03b9 R M\ni j : \u03b9\n\u22a2 ((Q.toBilin bm) (bm i)) (bm j) = if i = j then Q (bm i) else if i < j then sorry else 0"}, {"line": "simp [toBilin]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup N\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Module R N\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : LinearOrder \u03b9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx\u271d : Sort u_5\npolar : x\u271d\nQ : QuadraticMap R M N\nbm : Basis \u03b9 R M\ni j : \u03b9\n\u22a2 ((Q.toBilin bm) (bm i)) (bm j) = if i = j then Q (bm i) else if i < j then sorry () else 0"}]}
{"declaration": "theorem card_eq_card_quotient_mul_card (S : Submodule R M) :\n    Nat.card M = Nat.card S * Nat.card (M \u29f8 S) := by\n  rw [mul_comm]\n  rw [\u2190 Nat.card_prod]\n  exact Nat.card_congr AddSubgroup.addGroupEquivQuotientProdAddSubgroup\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Quotient/Basic.lean", "context": {"open": ["LinearMap QuotientAddGroup"], "variables": ["{R M : Type*} {r : R} {x y : M} [Ring R] [AddCommGroup M] [Module R M]", "(p p' p'' : Submodule R M)", "(S : Type*)", "{p}", "(p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nS : Submodule R M\n\u22a2 Nat.card M = Nat.card \u21a5S * Nat.card (M \u29f8 S)"}, {"line": "rw [mul_comm]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nS : Submodule R M\n\u22a2 Nat.card M = Nat.card (M \u29f8 S) * Nat.card \u21a5S"}, {"line": "rw [\u2190 Nat.card_prod]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nS : Submodule R M\n\u22a2 Nat.card M = Nat.card ((M \u29f8 S) \u00d7 \u21a5S)"}, {"line": "exact Nat.card_congr AddSubgroup.addGroupEquivQuotientProdAddSubgroup", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_map_mkQ : comap p.mkQ (map p.mkQ p') = p \u2294 p' := by simp [comap_map_eq, sup_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Quotient/Basic.lean", "context": {"open": ["LinearMap QuotientAddGroup"], "variables": ["{R M : Type*} {r : R} {x y : M} [Ring R] [AddCommGroup M] [Module R M]", "(p p' p'' : Submodule R M)", "(S : Type*)", "{p}", "(p)", "{M\u2082 : Type*} [AddCommGroup M\u2082] [Module R M\u2082]", "{R\u2082 M\u2082 : Type*} [Ring R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np p' : Submodule R M\nx\u271d : Sort u_7\ncomap : x\u271d\n\u22a2 sorry = p \u2294 p'"}, {"line": "simp [comap_map_eq, sup_comm]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np p' : Submodule R M\nx\u271d : Sort u_7\ncomap : x\u271d\n\u22a2 sorry () = p \u2294 p'"}]}
{"declaration": "theorem range_liftQ [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h) :\n    range (p.liftQ f h) = range f := by simpa only [range_eq_map] using map_liftQ _ _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Quotient/Basic.lean", "context": {"open": ["LinearMap QuotientAddGroup"], "variables": ["{R M : Type*} {r : R} {x y : M} [Ring R] [AddCommGroup M] [Module R M]", "(p p' p'' : Submodule R M)", "(S : Type*)", "{p}", "(p)", "{M\u2082 : Type*} [AddCommGroup M\u2082] [Module R M\u2082]", "{R\u2082 M\u2082 : Type*} [Ring R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "(q : Submodule R\u2082 M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\np : Submodule R M\nR\u2082 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : Ring R\u2082\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d : RingHomSurjective \u03c4\u2081\u2082\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nh : p \u2264 ker f\n\u22a2 range (p.liftQ f h) = range f"}, {"line": "simpa only [range_eq_map] using map_liftQ _ _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ker_le_range_iff {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083} :\n    ker g \u2264 range f \u2194 (range f).mkQ.comp (ker g).subtype = 0 := by\n  rw [\u2190 range_le_ker_iff]\n  rw [Submodule.ker_mkQ]\n  rw [Submodule.range_subtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Quotient/Basic.lean", "context": {"open": ["LinearMap QuotientAddGroup", "Submodule"], "variables": ["{R M : Type*} {r : R} {x y : M} [Ring R] [AddCommGroup M] [Module R M]", "(p p' p'' : Submodule R M)", "(S : Type*)", "{p}", "(p)", "{M\u2082 : Type*} [AddCommGroup M\u2082] [Module R M\u2082]", "{R\u2082 M\u2082 : Type*} [Ring R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "(q : Submodule R\u2082 M\u2082)", "{p p' p''}", "{R M R\u2082 M\u2082 R\u2083 M\u2083 : Type*}", "[Ring R] [Ring R\u2082] [Ring R\u2083]", "[AddCommMonoid M] [AddCommGroup M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083] [RingHomSurjective \u03c4\u2081\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\nM : Type u_8\nR\u2082 : Type u_9\nM\u2082 : Type u_10\nR\u2083 : Type u_11\nM\u2083 : Type u_12\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : Ring R\u2082\ninst\u271d\u2077 : Ring R\u2083\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\u2082\ninst\u271d\u2074 : AddCommMonoid M\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\ninst\u271d\u00b9 : Module R\u2083 M\u2083\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083\ninst\u271d : RingHomSurjective \u03c4\u2081\u2082\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083\n\u22a2 ker g \u2264 range f \u2194 (range f).mkQ \u2218\u2097 (ker g).subtype = 0"}, {"line": "rw [\u2190 range_le_ker_iff]", "tactic_state": "R : Type u_7\nM : Type u_8\nR\u2082 : Type u_9\nM\u2082 : Type u_10\nR\u2083 : Type u_11\nM\u2083 : Type u_12\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : Ring R\u2082\ninst\u271d\u2077 : Ring R\u2083\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\u2082\ninst\u271d\u2074 : AddCommMonoid M\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\ninst\u271d\u00b9 : Module R\u2083 M\u2083\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083\ninst\u271d : RingHomSurjective \u03c4\u2081\u2082\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083\n\u22a2 ker g \u2264 range f \u2194 range (ker g).subtype \u2264 ker (range f).mkQ"}, {"line": "rw [Submodule.ker_mkQ]", "tactic_state": "R : Type u_7\nM : Type u_8\nR\u2082 : Type u_9\nM\u2082 : Type u_10\nR\u2083 : Type u_11\nM\u2083 : Type u_12\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : Ring R\u2082\ninst\u271d\u2077 : Ring R\u2083\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\u2082\ninst\u271d\u2074 : AddCommMonoid M\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\ninst\u271d\u00b9 : Module R\u2083 M\u2083\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083\ninst\u271d : RingHomSurjective \u03c4\u2081\u2082\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083\n\u22a2 ker g \u2264 range f \u2194 range (ker g).subtype \u2264 range f"}, {"line": "rw [Submodule.range_subtype]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_eq_zero : (mk x : M \u29f8 p) = 0 \u2194 x \u2208 p := by simpa using (Quotient.eq' p : mk x = 0 \u2194 _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Quotient/Defs.lean", "context": {"open": ["QuotientAddGroup"], "variables": ["{R M : Type*} {r : R} {x y : M} [Ring R] [AddCommGroup M] [Module R M]", "(p p' : Submodule R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\nx : M\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : Submodule R M\n\u22a2 \u2191x = 0 \u2194 x \u2208 p"}, {"line": "simpa using (Quotient.eq' p : mk x = 0 \u2194 _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subsingleton_iff : Subsingleton (M \u29f8 p) \u2194 \u2200 x : M, x \u2208 p := by\n  rw [subsingleton_iff_forall_eq 0]\n  rw [Submodule.Quotient.forall]\n  simp_rw [Submodule.Quotient.mk_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Quotient/Defs.lean", "context": {"open": ["QuotientAddGroup"], "variables": ["{R M : Type*} {r : R} {x y : M} [Ring R] [AddCommGroup M] [Module R M]", "(p p' : Submodule R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : Submodule R M\n\u22a2 Subsingleton (M \u29f8 p) \u2194 \u2200 (x : M), x \u2208 p"}, {"line": "rw [subsingleton_iff_forall_eq 0]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : Submodule R M\n\u22a2 (\u2200 (y : M \u29f8 p), y = 0) \u2194 \u2200 (x : M), x \u2208 p"}, {"line": "rw [Submodule.Quotient.forall]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : Submodule R M\n\u22a2 (\u2200 (a : M), Submodule.Quotient.mk a = 0) \u2194 \u2200 (x : M), x \u2208 p"}, {"line": "simp_rw [Submodule.Quotient.mk_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma span_int_root_support :\n    span \u2124 (P.root '' b.support) = span \u2124 (range P.root) := by\n  refine le_antisymm (span_mono <| image_subset_range _ _) (span_le.mpr ?_)\n  rintro - \u27e8i, rfl\u27e9\n  exact b.root_mem_span_int i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/RootSystem/Base.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 R M N : Type*} [CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "{P : RootPairing \u03b9 R M N} (b : P.Base)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nP : RootPairing \u03b9 R M N\nb : P.Base\n\u22a2 span \u2124 (\u21d1P.root '' b.support) = span \u2124 (range \u21d1P.root)"}, {"line": "refine le_antisymm (span_mono <| image_subset_range _ _) (span_le.mpr ?_)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nP : RootPairing \u03b9 R M N\nb : P.Base\n\u22a2 range \u21d1P.root \u2286 \u2191(span \u2124 (\u21d1P.root '' b.support))"}, {"line": "rintro - \u27e8i, rfl\u27e9", "tactic_state": "case intro\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nP : RootPairing \u03b9 R M N\nb : P.Base\ni : \u03b9\n\u22a2 P.root i \u2208 \u2191(span \u2124 (\u21d1P.root '' b.support))"}, {"line": "exact b.root_mem_span_int i", "tactic_state": "No Goals!"}]}
{"declaration": "lemma root_add_zsmul_mem_range_iff {z : \u2124} :\n    P.root j + z \u2022 P.root i \u2208 range P.root \u2194\n      z \u2208 Icc (- P.chainBotCoeff i j : \u2124) (P.chainTopCoeff i j) := by\n  rcases z.eq_nat_or_neg with \u27e8n, rfl | rfl\u27e9\n  \u00b7 simp [P.root_add_nsmul_mem_range_iff_le_chainTopCoeff h]\n  \u00b7 simp [P.root_sub_nsmul_mem_range_iff_le_chainBotCoeff h, \u2190 sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/RootSystem/Chain.lean", "context": {"open": ["FaithfulSMul Function Set Submodule", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 R M N : Type*} [Finite \u03b9] [CommRing R] [CharZero R] [IsDomain R]", "{P : RootPairing \u03b9 R M N} [P.IsCrystallographic] {i j : \u03b9}", "(i j)", "{i j}", "(h : LinearIndependent R ![P.root i, P.root j])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\n\u22a2 sorry + z \u2022 sorry \u2208 range sorry \u2194 z \u2208 Icc (-sorry) sorry"}, {"line": "rcases z.eq_nat_or_neg with \u27e8n, rfl | rfl\u27e9", "tactic_state": "case intro.inl\nn : \u2115\n\u22a2 sorry + \u2191n \u2022 sorry \u2208 range sorry \u2194 \u2191n \u2208 Icc (-sorry) sorry\n---\ncase intro.inr\nn : \u2115\n\u22a2 sorry + -\u2191n \u2022 sorry \u2208 range sorry \u2194 -\u2191n \u2208 Icc (-sorry) sorry"}, {"line": "\u00b7 simp [P.root_add_nsmul_mem_range_iff_le_chainTopCoeff h]", "tactic_state": "case intro.inr\nn : \u2115\n\u22a2 sorry + -\u2191n \u2022 sorry \u2208 range sorry \u2194 -\u2191n \u2208 Icc (-sorry) sorry"}, {"line": "\u00b7 simp [P.root_sub_nsmul_mem_range_iff_le_chainBotCoeff h, \u2190 sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coroot_root_eq_pairing : P.toLinearMap.flip (P.coroot i) (P.root j) = P.pairing j i := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/RootSystem/Defs.lean", "context": {"open": ["Set Function", "Module hiding reflection", "Submodule (span)", "AddSubgroup (zmultiples)"], "variables": ["(\u03b9 R M N : Type*)", "{\u03b9 R M N}", "(P : RootPairing \u03b9 R M N) (i j : \u03b9)", "(\u03b9 R M N) in", "(\u03b9 R M N) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma coroot_root_two :\n    P.toLinearMap.flip (P.coroot i) (P.root i) = 2 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/RootSystem/Defs.lean", "context": {"open": ["Set Function", "Module hiding reflection", "Submodule (span)", "AddSubgroup (zmultiples)"], "variables": ["(\u03b9 R M N : Type*)", "{\u03b9 R M N}", "(P : RootPairing \u03b9 R M N) (i j : \u03b9)", "(\u03b9 R M N) in", "(\u03b9 R M N) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 2"}, {"line": "simp", "tactic_state": "\u22a2 sorry () = 2"}]}
{"declaration": "lemma IsOrthogonal.reflection_apply_left (h : IsOrthogonal P i j) :\n    P.reflection j (P.root i) = P.root i := by\n  simp [reflection_apply, h.1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/RootSystem/Defs.lean", "context": {"open": ["Set Function", "Module hiding reflection", "Submodule (span)", "AddSubgroup (zmultiples)"], "variables": ["(\u03b9 R M N : Type*)", "{\u03b9 R M N}", "(P : RootPairing \u03b9 R M N) (i j : \u03b9)", "(\u03b9 R M N) in", "(\u03b9 R M N) in", "{i j} in", "{i j} in", "{P} in", "{P} in", "{P i j}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_5\nIsOrthogonal : x\u271d\nh : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [reflection_apply, h.1]", "tactic_state": "x\u271d : Sort u_5\nIsOrthogonal : x\u271d\nh : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma pairing_neg_two_neg_two_iff :\n    P.pairing i j = -2 \u2227 P.pairing j i = -2 \u2194 P.root i = -P.root j := by\n  simp only [\u2190 neg_eq_iff_eq_neg]\n  simpa [eq_comm (a := -P.root i), eq_comm (b := j)] using\n    P.pairing_two_two_iff (P.reflection_perm i i) j\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/RootSystem/Reduced.lean", "context": {"open": ["Module Set Function"], "variables": ["{\u03b9 R M N : Type*} [CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "[Finite \u03b9]", "[CharZero R] [NoZeroSMulDivisors R M]", "(i j)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = -2 \u2227 sorry = -2 \u2194 sorry = -sorry"}, {"line": "simp only [\u2190 neg_eq_iff_eq_neg]", "tactic_state": "\u22a2 -sorry = 2 \u2227 -sorry = 2 \u2194 -sorry = sorry"}, {"line": "simpa [eq_comm (a := -P.root i), eq_comm (b := j)] using\n    P.pairing_two_two_iff (P.reflection_perm i i) j", "tactic_state": "No Goals!"}]}
{"declaration": "lemma form_apply_root_ne_zero (i : \u03b9) :\n    B.form (P.root i) (P.root i) \u2260 0 := by\n  obtain \u27e8s, hs, hs'\u27e9 := B.exists_pos_eq i\n  simpa [\u2190 hs'] using hs.ne'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/RootSystem/RootPositive.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 R S M N : Type*} [CommRing S] [LinearOrder S] [IsStrictOrderedRing S]", "{P : RootPairing \u03b9 R M N} (B : P.InvariantForm) (i j : \u03b9)", "(S) in", "{P : RootPairing \u03b9 R M N} [P.IsValuedIn S] (B : P.RootPositiveForm S) (i j : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ni : \u03b9\n\u22a2 sorry \u2260 0"}, {"line": "obtain \u27e8s, hs, hs'\u27e9 := B.exists_pos_eq i", "tactic_state": "case zero\n\u03b9 : Type u_1\ni : \u03b9\n\u22a2 0 \u2260 0\n---\ncase succ\n\u03b9 : Type u_1\ni : \u03b9\nn\u271d : \u2115\n\u22a2 n\u271d + 1 \u2260 0"}, {"line": "simpa [\u2190 hs'] using hs.ne'", "tactic_state": "case succ\n\u03b9 : Type u_1\ni : \u03b9\nn\u271d : \u2115\n\u22a2 n\u271d + 1 \u2260 0"}]}
{"declaration": "lemma algebraMap_apply_eq_form_iff {x y : span S (range P.root)} {s : S} :\n    algebraMap S R s = B.form x y \u2194 s = B.posForm x y := by\n  simp [RootPositiveForm.posForm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/RootSystem/RootPositive.lean", "context": {"open": ["Function Set Submodule"], "variables": ["{\u03b9 R S M N : Type*} [CommRing S] [LinearOrder S] [IsStrictOrderedRing S]", "{P : RootPairing \u03b9 R M N} (B : P.InvariantForm) (i j : \u03b9)", "(S) in", "{P : RootPairing \u03b9 R M N} [P.IsValuedIn S] (B : P.RootPositiveForm S) (i j : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_3\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : LinearOrder S\ninst\u271d : IsStrictOrderedRing S\nx : \u21a5(span S (range sorry))\ny : \u21a5(span S (range sorry))\ns : S\n\u22a2 sorry = sorry \u2194 s = sorry"}, {"line": "simp [RootPositiveForm.posForm]", "tactic_state": "S : Type u_3\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : LinearOrder S\ninst\u271d : IsStrictOrderedRing S\nx : \u21a5(span S (range sorry))\ny : \u21a5(span S (range sorry))\ns : S\n\u22a2 sorry () = sorry () \u2194 s = sorry ()"}]}
